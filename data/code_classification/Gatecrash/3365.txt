public class ExecutionersSwing extends CardImpl {°Ïpublic ExecutionersSwing(UUID ownerId) {°Ïsuper(ownerId, 161, "Executioner's Swing", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{W}{B}");°Ïthis.expansionSetCode = "GTC";°Ïthis.getSpellAbility().addEffect(new BoostTargetEffect(-5,-5, Duration.EndOfTurn));°Ïthis.getSpellAbility().addTarget(new TargetCreaturePermanentThatDealtDamageThisTurn());°Ïthis.getSpellAbility().addWatcher(new SourceDidDamageWatcher());°Ï}°Ïpublic ExecutionersSwing(final ExecutionersSwing card) {°Ïsuper(card);°Ï}°Ï@Override°Ïpublic ExecutionersSwing copy() {°Ïreturn new ExecutionersSwing(this);°Ï}°Ï}°Ïclass TargetCreaturePermanentThatDealtDamageThisTurn extends TargetPermanent {°Ïpublic TargetCreaturePermanentThatDealtDamageThisTurn() {°Ïsuper(1, 1, new FilterCreaturePermanent(), false);°ÏtargetName = "creature that dealt damage this turn";°Ï}°Ïpublic TargetCreaturePermanentThatDealtDamageThisTurn(final TargetCreaturePermanentThatDealtDamageThisTurn target) {°Ïsuper(target);°Ï}°Ï@Override°Ïpublic boolean canTarget(UUID id, Ability source, Game game) {°ÏSourceDidDamageWatcher watcher = (SourceDidDamageWatcher) game.getState().getWatchers().get("SourceDidDamageWatcher");°Ïif (watcher != null) {°Ïif (watcher.damageSources.contains(id)) {°Ïreturn super.canTarget(id, source, game);°Ï}°Ï}°Ïreturn false;°Ï}°Ï@Override°Ïpublic boolean canChoose(UUID sourceId, UUID sourceControllerId, Game game) {°Ïint remainingTargets = this.minNumberOfTargets - targets.size();°Ïif (remainingTargets <= 0) {°Ïreturn true;°Ï}°Ïint count = 0;°ÏMageObject targetSource = game.getObject(sourceId);°ÏSourceDidDamageWatcher watcher = (SourceDidDamageWatcher) game.getState().getWatchers().get("SourceDidDamageWatcher");°Ïif (watcher != null) {°Ïfor (Permanent permanent: game.getBattlefield().getActivePermanents(filter, sourceControllerId, sourceId, game)) {°Ïif (!targets.containsKey(permanent.getId()) && watcher.damageSources.contains(permanent.getId())) {°Ïif (!notTarget || permanent.canBeTargetedBy(targetSource, sourceControllerId, game)) {°Ïcount++;°Ïif (count >= remainingTargets) {°Ïreturn true;°Ï}°Ï}°Ï}°Ï}°Ï}°Ïreturn false;°Ï}°Ï@Override°Ïpublic Set<UUID> possibleTargets(UUID sourceId, UUID sourceControllerId, Game game) {°ÏSet<UUID> availablePossibleTargets = super.possibleTargets(sourceId, sourceControllerId, game);°ÏSet<UUID> possibleTargets = new HashSet<UUID>();°ÏSourceDidDamageWatcher watcher = (SourceDidDamageWatcher) game.getState().getWatchers().get("SourceDidDamageWatcher");°Ïif (watcher != null) {°Ïfor (UUID targetId : availablePossibleTargets) {°ÏPermanent permanent = game.getPermanent(targetId);°Ïif (permanent != null && !targets.containsKey(permanent.getId()) && watcher.damageSources.contains(targetId)) {°ÏpossibleTargets.add(targetId);°Ï}°Ï}°Ï}°Ïreturn possibleTargets;°Ï}°Ï@Override°Ïpublic TargetCreaturePermanentThatDealtDamageThisTurn copy() {°Ïreturn new TargetCreaturePermanentThatDealtDamageThisTurn(this);°Ï}°Ï}°Ï
