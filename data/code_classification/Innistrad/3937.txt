public class ManorGargoyle extends CardImpl {°Ïprivate static final String rule = "{this} is indestructible as long as it has defender.";°Ïpublic ManorGargoyle(UUID ownerId) {°Ïsuper(ownerId, 228, "Manor Gargoyle", Rarity.RARE, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{5}");°Ïthis.expansionSetCode = "ISD";°Ïthis.subtype.add("Gargoyle");°Ïthis.power = new MageInt(4);°Ïthis.toughness = new MageInt(4);°Ïthis.addAbility(DefenderAbility.getInstance());°Ï/*°ÏTODO: Implement the dependency rule°Ï613.7. Within a layer or sublayer, determining which order effects are applied in is sometimes done using a dependency system.°ÏIf a dependency exists, it will override the timestamp system.°Ï613.7a An effect is said to °∞depend on°± another if°Ï(a) it°Øs applied in the same layer (and, if applicable, sublayer) as the other effect (see rules 613.1 and 613.3);°Ï(b) applying the other would change the text or the existence of the first effect, what it applies to, or what°Ïit does to any of the things it applies to; and°Ï(c) neither effect is from a characteristic-defining ability or both effects are from characteristic-defining°Ïabilities. Otherwise, the effect is considered to be independent of the other effect.°Ï613.7b An effect dependent on one or more other effects waits to apply until just after all of those effects have been applied.°ÏIf multiple dependent effects would apply simultaneously in this way, they°Øre applied in timestamp order relative to each°Ïother. If several dependent effects form a dependency loop, then this rule is ignored and the effects in the dependency°Ïloop are applied in timestamp order.°Ï613.7c After each effect is applied, the order of remaining effects is reevaluated and may change if an effect that has not yet°Ïbeen applied becomes dependent on or independent of one or more other effects that have not yet been applied.°Ï*/°ÏConditionalContinuousEffect effect = new ConditionalContinuousEffect(new GainAbilitySourceEffect(IndestructibleAbility.getInstance()), HasDefenderCondition.getInstance(), rule);°Ïthis.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, effect));°ÏEffect effect2 = new LoseAbilitySourceEffect(DefenderAbility.getInstance(), Duration.EndOfTurn);°Ïeffect2.setText("Until end of turn, {this} loses defender");°ÏAbility ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect2, new ManaCostsImpl("{1}"));°Ïeffect2 = new GainAbilitySourceEffect(FlyingAbility.getInstance(), Duration.EndOfTurn);°Ïeffect2.setText("and gains flying");°Ïability.addEffect(effect2);°Ïthis.addAbility(ability);°Ï}°Ïpublic ManorGargoyle(final ManorGargoyle card) {°Ïsuper(card);°Ï}°Ï@Override°Ïpublic ManorGargoyle copy() {°Ïreturn new ManorGargoyle(this);°Ï}°Ï}°Ïclass HasDefenderCondition implements Condition {°Ïprivate static HasDefenderCondition INSTANCE;°Ïprivate HasDefenderCondition() {°Ï}°Ïpublic static HasDefenderCondition getInstance() {°Ïif (INSTANCE == null) {°ÏINSTANCE = new HasDefenderCondition();°Ï}°Ïreturn INSTANCE;°Ï}°Ï@Override°Ïpublic boolean apply(Game game, Ability source) {°ÏPermanent permanent = game.getPermanent(source.getSourceId());°Ïif (permanent != null) {°ÏAbilities<Ability> abilities = permanent.getAbilities();°Ïfor (Ability ability : abilities) {°Ïif (ability.getClass().equals(DefenderAbility.getInstance().getClass())) {°Ïreturn true;°Ï}°Ï}°Ï}°Ïreturn false;°Ï}°Ï}°Ï
