{"code": "protected void tearDown(){\n}\n", "nl": "Tears down the fixture, for example, close a network connection. This method is called after a test is executed."}
{"code": "@KnownFailure(\"Fixed on DonutBurger, Wrong Exception thrown\") public void test_unwrap_ByteBuffer_ByteBuffer_02(){\n  String host=\"new host\";\n  int port=8080;\n  ByteBuffer bbs=ByteBuffer.allocate(10);\n  ByteBuffer bbR=ByteBuffer.allocate(100).asReadOnlyBuffer();\n  ByteBuffer[] bbA={bbR,ByteBuffer.allocate(10),ByteBuffer.allocate(100)};\n  SSLEngine sse=getEngine(host,port);\n  sse.setUseClientMode(true);\n  try {\n    sse.unwrap(bbs,bbA);\n    fail(\"ReadOnlyBufferException wasn't thrown\");\n  }\n catch (  ReadOnlyBufferException iobe) {\n  }\ncatch (  Exception e) {\n    fail(e + \" was thrown instead of ReadOnlyBufferException\");\n  }\n}\n", "nl": "javax.net.ssl.SSLEngine#unwrap(ByteBuffer src, ByteBuffer[] dsts) ReadOnlyBufferException should be thrown."}
{"code": "public static CstFloat make(int bits){\n  return new CstFloat(bits);\n}\n", "nl": "Makes an instance for the given value. This may (but does not necessarily) return an already-allocated instance."}
{"code": "public long size(){\n  long size=0;\n  if (parsedGeneExpressions == null)   parseGenes();\n  for (int i=0; i < parsedGeneExpressions.length; i++)   size+=parsedGeneExpressions[i].numberOfNodes();\n  return size;\n}\n", "nl": "Returns the \"size\" of the chromosome, namely, the number of nodes in all of its parsed genes -- does not include the linking functions. "}
{"code": "public void increment(View view){\n  if (quantity == 100) {\n    return;\n  }\n  quantity=quantity + 1;\n  displayQuantity(quantity);\n}\n", "nl": "This method is called when the plus button is clicked."}
{"code": "public void trimToSize(){\n  ++modCount;\n  if (size < elementData.length) {\n    elementData=Arrays.copyOf(elementData,size);\n  }\n}\n", "nl": "Trims the capacity of this <tt>ArrayHashList</tt> instance to be the list's current size. An application can use this operation to minimize the storage of an <tt>ArrayHashList</tt> instance."}
{"code": "public SyncValueResponseMessage(SyncValueResponseMessage other){\n  __isset_bitfield=other.__isset_bitfield;\n  if (other.isSetHeader()) {\n    this.header=new AsyncMessageHeader(other.header);\n  }\n  this.count=other.count;\n}\n", "nl": "Performs a deep copy on <i>other</i>."}
{"code": "public void clearParsers(){\n  if (parserManager != null) {\n    parserManager.clearParsers();\n  }\n}\n", "nl": "Removes all parsers from this text area."}
{"code": "@Override public void run(){\n  while (doWork) {\n    deliverLock();\n    while (tomLayer.isRetrievingState()) {\n      System.out.println(\"-- Retrieving State\");\n      canDeliver.awaitUninterruptibly();\n      if (tomLayer.getLastExec() == -1)       System.out.println(\"-- Ready to process operations\");\n    }\n    try {\n      ArrayList<Decision> decisions=new ArrayList<Decision>();\n      decidedLock.lock();\n      if (decided.isEmpty()) {\n        notEmptyQueue.await();\n      }\n      decided.drainTo(decisions);\n      decidedLock.unlock();\n      if (!doWork)       break;\n      if (decisions.size() > 0) {\n        TOMMessage[][] requests=new TOMMessage[decisions.size()][];\n        int[] consensusIds=new int[requests.length];\n        int[] leadersIds=new int[requests.length];\n        int[] regenciesIds=new int[requests.length];\n        CertifiedDecision[] cDecs;\n        cDecs=new CertifiedDecision[requests.length];\n        int count=0;\n        for (        Decision d : decisions) {\n          requests[count]=extractMessagesFromDecision(d);\n          consensusIds[count]=d.getConsensusId();\n          leadersIds[count]=d.getLeader();\n          regenciesIds[count]=d.getRegency();\n          CertifiedDecision cDec=new CertifiedDecision(this.controller.getStaticConf().getProcessId(),d.getConsensusId(),d.getValue(),d.getDecisionEpoch().proof);\n          cDecs[count]=cDec;\n          if (requests[count][0].equals(d.firstMessageProposed)) {\n            long time=requests[count][0].timestamp;\n            long seed=requests[count][0].seed;\n            int numOfNonces=requests[count][0].numOfNonces;\n            requests[count][0]=d.firstMessageProposed;\n            requests[count][0].timestamp=time;\n            requests[count][0].seed=seed;\n            requests[count][0].numOfNonces=numOfNonces;\n          }\n          count++;\n        }\n        Decision lastDecision=decisions.get(decisions.size() - 1);\n        if (requests != null && requests.length > 0) {\n          deliverMessages(consensusIds,regenciesIds,leadersIds,cDecs,requests);\n          if (controller.hasUpdates()) {\n            processReconfigMessages(lastDecision.getConsensusId());\n            tomLayer.setLastExec(lastDecision.getConsensusId());\n            tomLayer.setInExec(-1);\n          }\n        }\n        int cid=lastDecision.getConsensusId();\n        if (cid > 2) {\n          int stableConsensus=cid - 3;\n          tomLayer.execManager.removeConsensus(stableConsensus);\n        }\n      }\n    }\n catch (    Exception e) {\n      e.printStackTrace(System.err);\n    }\n    deliverUnlock();\n  }\n  java.util.logging.Logger.getLogger(DeliveryThread.class.getName()).log(Level.INFO,\"DeliveryThread stopped.\");\n}\n", "nl": "This is the code for the thread. It delivers decisions to the TOM request receiver object (which is the application)"}
{"code": "private byte[] calculateUValue(byte[] generalKey,byte[] firstDocIdValue,int revision) throws GeneralSecurityException, EncryptionUnsupportedByProductException {\n  if (revision == 2) {\n    Cipher rc4=createRC4Cipher();\n    SecretKey key=createRC4Key(generalKey);\n    initEncryption(rc4,key);\n    return crypt(rc4,PW_PADDING);\n  }\n else   if (revision >= 3) {\n    MessageDigest md5=createMD5Digest();\n    md5.update(PW_PADDING);\n    if (firstDocIdValue != null) {\n      md5.update(firstDocIdValue);\n    }\n    final byte[] hash=md5.digest();\n    Cipher rc4=createRC4Cipher();\n    SecretKey key=createRC4Key(generalKey);\n    initEncryption(rc4,key);\n    final byte[] v=crypt(rc4,hash);\n    rc4shuffle(v,generalKey,rc4);\n    assert v.length == 16;\n    final byte[] entryValue=new byte[32];\n    System.arraycopy(v,0,entryValue,0,v.length);\n    System.arraycopy(v,0,entryValue,16,v.length);\n    return entryValue;\n  }\n else {\n    throw new EncryptionUnsupportedByProductException(\"Unsupported standard security handler revision \" + revision);\n  }\n}\n", "nl": "Calculate what the U value should consist of given a particular key and document configuration. Correponds to Algorithms 3.4 and 3.5 of the PDF Reference version 1.7"}
{"code": "private void assign(HashMap<String,DBIDs> labelMap,String label,DBIDRef id){\n  if (labelMap.containsKey(label)) {\n    DBIDs exist=labelMap.get(label);\n    if (exist instanceof DBID) {\n      ModifiableDBIDs n=DBIDUtil.newHashSet();\n      n.add((DBID)exist);\n      n.add(id);\n      labelMap.put(label,n);\n    }\n else {\n      assert (exist instanceof HashSetModifiableDBIDs);\n      assert (exist.size() > 1);\n      ((ModifiableDBIDs)exist).add(id);\n    }\n  }\n else {\n    labelMap.put(label,DBIDUtil.deref(id));\n  }\n}\n", "nl": "Assigns the specified id to the labelMap according to its label"}
{"code": "private void showFeedback(String message){\n  if (myHost != null) {\n    myHost.showFeedback(message);\n  }\n else {\n    System.out.println(message);\n  }\n}\n", "nl": "Used to communicate feedback pop-up messages between a plugin tool and the main Whitebox user-interface."}
{"code": "public CDeleteAction(final BackEndDebuggerProvider debuggerProvider,final int[] rows){\n  super(rows.length == 1 ? \"Remove Breakpoint\" : \"Remove Breakpoints\");\n  m_debuggerProvider=Preconditions.checkNotNull(debuggerProvider,\"IE01344: Debugger provider argument can not be null\");\n  m_rows=rows.clone();\n}\n", "nl": "Creates a new action object."}
{"code": "public Yaml(BaseConstructor constructor,Representer representer,DumperOptions dumperOptions,Resolver resolver){\n  if (!constructor.isExplicitPropertyUtils()) {\n    constructor.setPropertyUtils(representer.getPropertyUtils());\n  }\n else   if (!representer.isExplicitPropertyUtils()) {\n    representer.setPropertyUtils(constructor.getPropertyUtils());\n  }\n  this.constructor=constructor;\n  representer.setDefaultFlowStyle(dumperOptions.getDefaultFlowStyle());\n  representer.setDefaultScalarStyle(dumperOptions.getDefaultScalarStyle());\n  representer.getPropertyUtils().setAllowReadOnlyProperties(dumperOptions.isAllowReadOnlyProperties());\n  representer.setTimeZone(dumperOptions.getTimeZone());\n  this.representer=representer;\n  this.dumperOptions=dumperOptions;\n  this.resolver=resolver;\n  this.name=\"Yaml:\" + System.identityHashCode(this);\n}\n", "nl": "Create Yaml instance. It is safe to create a few instances and use them in different Threads."}
{"code": "public void testHitEndAfterFind(){\n  hitEndTest(true,\"#01.0\",\"r((ege)|(geg))x\",\"regexx\",false);\n  hitEndTest(true,\"#01.1\",\"r((ege)|(geg))x\",\"regex\",false);\n  hitEndTest(true,\"#01.2\",\"r((ege)|(geg))x\",\"rege\",true);\n  hitEndTest(true,\"#01.2\",\"r((ege)|(geg))x\",\"xregexx\",false);\n  hitEndTest(true,\"#02.0\",\"regex\",\"rexreger\",true);\n  hitEndTest(true,\"#02.1\",\"regex\",\"raxregexr\",false);\n  String floatRegex=getHexFloatRegex();\n  hitEndTest(true,\"#03.0\",floatRegex,Double.toHexString(-1.234d),true);\n  hitEndTest(true,\"#03.1\",floatRegex,\"1 ABC\" + Double.toHexString(Double.NaN) + \"buhuhu\",false);\n  hitEndTest(true,\"#03.2\",floatRegex,Double.toHexString(-0.0) + \"--\",false);\n  hitEndTest(true,\"#03.3\",floatRegex,\"--\" + Double.toHexString(Double.MIN_VALUE) + \"--\",false);\n  hitEndTest(true,\"#04.0\",\"(\\\\d+) fish (\\\\d+) fish (\\\\w+) fish (\\\\d+)\",\"1 fish 2 fish red fish 5\",true);\n  hitEndTest(true,\"#04.1\",\"(\\\\d+) fish (\\\\d+) fish (\\\\w+) fish (\\\\d+)\",\"----1 fish 2 fish red fish 5----\",false);\n}\n", "nl": "Regression test for HARMONY-4396"}
{"code": "public void add(Individual individual){\n  individuals.add(individual);\n}\n", "nl": "Adds a single individual."}
{"code": "public boolean removeSession(IgniteUuid sesId){\n  GridTaskSessionImpl ses=sesMap.get(sesId);\n  assert ses == null || ses.isFullSupport();\n  if (ses != null && ses.release()) {\n    sesMap.remove(sesId,ses);\n    return true;\n  }\n  return false;\n}\n", "nl": "Removes session for a given session ID."}
{"code": "public static Bitmap loadBitmapOptimized(Uri uri,Context context,int limit) throws ImageLoadException {\n  return loadBitmapOptimized(new UriSource(uri,context){\n  }\n,limit);\n}\n", "nl": "Loading bitmap with optimized loaded size less than specific pixels count"}
{"code": "protected BasePeriod(long duration){\n  super();\n  iType=PeriodType.standard();\n  int[] values=ISOChronology.getInstanceUTC().get(DUMMY_PERIOD,duration);\n  iValues=new int[8];\n  System.arraycopy(values,0,iValues,4,4);\n}\n", "nl": "Creates a period from the given millisecond duration with the standard period type and ISO rules, ensuring that the calculation is performed with the time-only period type. <p> The calculation uses the hour, minute, second and millisecond fields."}
{"code": "public FlatBufferBuilder(){\n  this(1024);\n}\n", "nl": "Start with a buffer of 1KiB, then grow as required."}
{"code": "public PbrpcConnectionException(String arg0,Throwable arg1){\n  super(arg0,arg1);\n}\n", "nl": "Creates a new instance of PbrpcConnectionException."}
{"code": "public void uninstallUI(JComponent a){\n  for (int i=0; i < uis.size(); i++) {\n    ((ComponentUI)(uis.elementAt(i))).uninstallUI(a);\n  }\n}\n", "nl": "Invokes the <code>uninstallUI</code> method on each UI handled by this object."}
{"code": "public static void shutdown(){\n  if (instance != null) {\n    instance.save();\n  }\n}\n", "nl": "Saves the configuration file."}
{"code": "public boolean GE(Word w2){\n  return value.GE(w2.value);\n}\n", "nl": "Greater-than or equal comparison"}
{"code": "public static UnionCoder of(List<Coder<?>> elementCoders){\n  return new UnionCoder(elementCoders);\n}\n", "nl": "Builds a union coder with the given list of element coders.  This list corresponds to a mapping of union tag to Coder.  Union tags start at 0."}
{"code": "public void testFileDeletion() throws Exception {\n  File testDir=createTestDir(\"testFileDeletion\");\n  String prefix1=\"testFileDeletion1\";\n  File[] files1=createFiles(testDir,prefix1,5);\n  String prefix2=\"testFileDeletion2\";\n  File[] files2=createFiles(testDir,prefix2,5);\n  FileCommands.deleteFiles(files1,true);\n  assertNotExists(files1);\n  FileCommands.deleteFiles(files2,false);\n  Thread.sleep(1000);\n  assertNotExists(files2);\n}\n", "nl": "Verify ability to delete a list of files."}
{"code": "public boolean isOnClasspath(String classpath){\n  return this.classpath.equals(classpath);\n}\n", "nl": "Evaluates if the Dependency is targeted for a classpath type."}
{"code": "protected void source(String ceylon){\n  String providerPreSrc=\"provider/\" + ceylon + \"_pre.ceylon\";\n  String providerPostSrc=\"provider/\" + ceylon + \"_post.ceylon\";\n  String clientSrc=\"client/\" + ceylon + \"_client.ceylon\";\n  compile(providerPreSrc,providerModuleSrc,providerPackageSrc);\n  compile(clientSrc,clientModuleSrc);\n  compile(providerPostSrc,providerModuleSrc,providerPackageSrc);\n  compile(clientSrc,clientModuleSrc);\n}\n", "nl": "Checks that we can still compile a client after a change"}
{"code": "public PerformanceMonitor(){\n  initComponents();\n  if (Display.getInstance().getCurrent() != null) {\n    refreshFrameActionPerformed(null);\n  }\n  resultData.setModel(new Model());\n  performanceLog.setLineWrap(true);\n  resultData.setRowSorter(new TableRowSorter<Model>((Model)resultData.getModel()));\n}\n", "nl": "Creates new form PerformanceMonitor"}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2014-09-03 15:01:15.190 -0400\",hash_original_method=\"F262A3A18BABECF7EC492736953EAF6E\",hash_generated_method=\"94A4545C167C029CC38AACEACF2087E9\") private void unparkSuccessor(Node node){\n  int ws=node.waitStatus;\n  if (ws < 0)   compareAndSetWaitStatus(node,ws,0);\n  Node s=node.next;\n  if (s == null || s.waitStatus > 0) {\n    s=null;\n    for (Node t=tail; t != null && t != node; t=t.prev)     if (t.waitStatus <= 0)     s=t;\n  }\n  if (s != null)   LockSupport.unpark(s.thread);\n}\n", "nl": "Wakes up node's successor, if one exists."}
{"code": "@DSComment(\"From safe class list\") @DSSafe(DSCat.SAFE_LIST) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 13:02:44.364 -0500\",hash_original_method=\"EA3734ADDEB20313C9CAB09B48812C54\",hash_generated_method=\"4858AFE909DDE63867ACB561D5449C13\") static public void assertFalse(String message,boolean condition){\n  assertTrue(message,!condition);\n}\n", "nl": "Asserts that a condition is false. If it isn't it throws an AssertionFailedError with the given message."}
{"code": "@Override protected void initData(){\n  Intent intent=new Intent(this,PushMessageService.class);\n  this.startService(intent);\n  this.bindService(intent,this.connection,Context.BIND_AUTO_CREATE);\n}\n", "nl": "Initialize the Activity data"}
{"code": "public static Date parseDateDay(String dateString) throws ParseException {\n  return getSimplDateFormat(DF_DEF).parse(dateString);\n}\n", "nl": "Returns date parsed from string in format: yyyy.MM.dd."}
{"code": "private boolean doesStoragePortExistsInVArray(StoragePort umfsStoragePort,VirtualArray virtualArray){\n  List<URI> virtualArrayPorts=returnAllPortsInVArray(virtualArray.getId());\n  if (virtualArrayPorts.contains(umfsStoragePort.getId())) {\n    return true;\n  }\n  return false;\n}\n", "nl": "Checks if the given storage port is part of VArray"}
{"code": "public SpringVaadinServletService(VaadinServlet servlet,DeploymentConfiguration deploymentConfiguration,String serviceUrl) throws ServiceException {\n  super(servlet,deploymentConfiguration);\n  this.serviceUrl=serviceUrl;\n}\n", "nl": "Create a servlet service instance that allows the use of a custom service URL."}
{"code": "private static List<TranslationResult> translateChildrenOfNode(final ITranslationEnvironment environment,final IOperandTreeNode expression,OperandSize size,final boolean loadOperand,Long baseOffset) throws InternalTranslationException {\n  final List<TranslationResult> partialResults=new ArrayList<>();\n  final List<? extends IOperandTreeNode> children=expression.getChildren();\n  Collections.sort(children,comparator);\n  for (  final IOperandTreeNode child : children) {\n    final TranslationResult nextResult=loadOperand(environment,baseOffset,child,isSegmentExpression(expression.getValue()) ? expression : null,size,loadOperand);\n    partialResults.add(nextResult);\n    baseOffset+=nextResult.getInstructions().size();\n  }\n  return partialResults;\n}\n", "nl": "Iterates over the children of a node in the operand tree and generates translations for them."}
{"code": "public void removeShutdownLatch(final CountDownLatch latch){\n  removeShutdownLatch(latch,false);\n}\n", "nl": "Releases the latch and removes it from the latches being handled by this handler."}
{"code": "public Version(){\n  this(CommonReflection.getVersionTag());\n}\n", "nl": "Constructs a new Version from the current server version running"}
{"code": "public static void startActivity(Context context,String chatId){\n  Intent intent=new Intent(context,SendGroupFile.class);\n  intent.putExtra(EXTRA_CHAT_ID,chatId);\n  context.startActivity(intent);\n}\n", "nl": "Start SendGroupFile activity"}
{"code": "public Index excludedDataCenters(String excludedDataCenters){\n  this.excludedDataCenters=excludedDataCenters;\n  return this;\n}\n", "nl": "Sets the list of excluded data centers."}
{"code": "public final int read() throws IOException {\n  int result=src.read();\n  if (result != -1) {\n    ++pointer;\n  }\n  return result;\n}\n", "nl": "Forwards the request to the real <code>InputStream</code>."}
{"code": "public static boolean compareAndSwapInt(Object obj,long off,int exp,int upd){\n  return UNSAFE.compareAndSwapInt(obj,off,exp,upd);\n}\n", "nl": "Integer CAS."}
{"code": "public static String dec2Bin(int value){\n  String result=\"\";\n  return dec2Bin(value,result);\n}\n", "nl": "Methods converts a decimal number into a binary number as a string"}
{"code": "public void apply(RecyclerView recyclerView,Iterable<Item> items){\n  if (items != null) {\n    HashMap<Integer,Stack<RecyclerView.ViewHolder>> cache=new HashMap<>();\n    for (    Item d : items) {\n      if (!cache.containsKey(d.getType())) {\n        cache.put(d.getType(),new Stack<RecyclerView.ViewHolder>());\n      }\n      if (mCacheSize == -1 || cache.get(d.getType()).size() <= mCacheSize) {\n        cache.get(d.getType()).push(d.getViewHolder(recyclerView));\n      }\n      RecyclerView.RecycledViewPool recyclerViewPool=new RecyclerView.RecycledViewPool();\n      for (      Map.Entry<Integer,Stack<RecyclerView.ViewHolder>> entry : cache.entrySet()) {\n        recyclerViewPool.setMaxRecycledViews(entry.getKey(),mCacheSize);\n        for (        RecyclerView.ViewHolder holder : entry.getValue()) {\n          recyclerViewPool.putRecycledView(holder);\n        }\n        entry.getValue().clear();\n      }\n      cache.clear();\n      recyclerView.setRecycledViewPool(recyclerViewPool);\n    }\n  }\n}\n", "nl": "init the cache on your own."}
{"code": "public void incNumOverflowOnDisk(long delta){\n  this.stats.incLong(numOverflowOnDiskId,delta);\n}\n", "nl": "Increments the current number of entries whose value has been overflowed to disk by a given amount."}
{"code": "public void paint(Graphics a,JComponent b){\n  for (int i=0; i < uis.size(); i++) {\n    ((ComponentUI)(uis.elementAt(i))).paint(a,b);\n  }\n}\n", "nl": "Invokes the <code>paint</code> method on each UI handled by this object."}
{"code": "public void updateUI(){\n  setUI((TableHeaderUI)UIManager.getUI(this));\n  TableCellRenderer renderer=getDefaultRenderer();\n  if (renderer instanceof Component) {\n    SwingUtilities.updateComponentTreeUI((Component)renderer);\n  }\n}\n", "nl": "Notification from the <code>UIManager</code> that the look and feel (L&amp;F) has changed. Replaces the current UI object with the latest version from the <code>UIManager</code>."}
{"code": "public static RefactoringStatus create(IStatus status){\n  if (status.isOK())   return new RefactoringStatus();\n  if (!status.isMultiStatus()) {\nswitch (status.getSeverity()) {\ncase IStatus.OK:\n      return new RefactoringStatus();\ncase IStatus.INFO:\n    return RefactoringStatus.createWarningStatus(status.getMessage());\ncase IStatus.WARNING:\n  return RefactoringStatus.createErrorStatus(status.getMessage());\ncase IStatus.ERROR:\nreturn RefactoringStatus.createFatalErrorStatus(status.getMessage());\ncase IStatus.CANCEL:\nreturn RefactoringStatus.createFatalErrorStatus(status.getMessage());\ndefault :\nreturn RefactoringStatus.createFatalErrorStatus(status.getMessage());\n}\n}\n else {\nIStatus[] children=status.getChildren();\nRefactoringStatus result=new RefactoringStatus();\nfor (int i=0; i < children.length; i++) {\nresult.merge(RefactoringStatus.create(children[i]));\n}\nreturn result;\n}\n}\n", "nl": "Creates a new <code>RefactoringStatus</code> from the given <code>IStatus</code>. An OK status is mapped to an OK refactoring status, an information status is mapped to a warning refactoring status, a warning status is mapped to an error refactoring status and an error or cancel status is mapped to a fatal refactoring status. An unknown status is converted into a fatal error status as well. If the status is a <code>MultiStatus </code> then the first level of children of the status will be added as refactoring status entries to the created refactoring status."}
{"code": "public void debug(String msg){\n  debugLogger.debug(msg);\n}\n", "nl": "Log a Setup and/or administrative log message for log4jdbc."}
{"code": "public int size(){\n  return codon.length;\n}\n", "nl": "Returns the length of the integer codon representation of this grammar."}
{"code": "public Diff decode() throws UnsupportedEncodingException, DecodingException {\n  int header=r.read(3);\n  if (DiffAction.parse(header) != DiffAction.DECODER_DATA) {\n    throw new DecodingException(\"Invalid codecData code: \" + header);\n  }\n  int blockSize_C=3;\n  int blockSize_S=r.read(5);\n  int blockSize_E=r.read(5);\n  int blockSize_B=r.read(5);\n  int blockSize_L=r.read(5);\n  r.read(1);\n  if (blockSize_S < 0 || blockSize_S > 31) {\n    throw new DecodingException(\"blockSize_S out of range: \" + blockSize_S);\n  }\n  if (blockSize_E < 0 || blockSize_E > 31) {\n    throw new DecodingException(\"blockSize_E out of range: \" + blockSize_E);\n  }\n  if (blockSize_B < 0 || blockSize_B > 31) {\n    throw new DecodingException(\"blockSize_B out of range: \" + blockSize_B);\n  }\n  if (blockSize_L < 0 || blockSize_L > 31) {\n    throw new DecodingException(\"blockSize_L out of range: \" + blockSize_L);\n  }\n  return decode(blockSize_C,blockSize_S,blockSize_E,blockSize_B,blockSize_L);\n}\n", "nl": "Decodes the information and returns the Diff."}
{"code": "public FontSizeLocator(){\n}\n", "nl": "Creates a new instance."}
{"code": "@SuppressWarnings({\"unchecked\",\"rawtypes\"}) static <E extends Comparable<E>>AutoSortedCollection<E> createAutoSortedCollection(Collection<? extends E> values){\n  return createAutoSortedCollection(null,values);\n}\n", "nl": "Construct new auto sorted collection using natural order."}
{"code": "@Override public String toString(){\n  return super.toString();\n}\n", "nl": "Returns the super class implementation of toString()."}
{"code": "public boolean useLayoutEditor(SignalMast destination){\n  if (!destList.containsKey(destination)) {\n    return false;\n  }\n  return destList.get(destination).useLayoutEditor();\n}\n", "nl": "Query if we are using the layout editor panels to build the signal mast logic, blocks, turnouts ."}
{"code": "private static String unescapePathComponent(String name){\n  return name.replaceAll(\"\\\\\\\\(.)\",\" 1\");\n}\n", "nl": "Convert a path component that contains backslash escape sequences to a literal string. This is necessary when you want to explicitly refer to a path that contains globber metacharacters."}
{"code": "public AbstractExampleTable(List<Attribute> attributes){\n  addAttributes(attributes);\n}\n", "nl": "Creates a new ExampleTable."}
{"code": "public void zoomOut(){\n  Matrix save=mViewPortHandler.zoomOut(getWidth() / 2f,-(getHeight() / 2f));\n  mViewPortHandler.refresh(save,this,true);\n}\n", "nl": "Zooms out by 0.7f, from the charts center. center."}
{"code": "public Media createBackgroundMedia(String uri) throws IOException {\n  return impl.createBackgroundMedia(uri);\n}\n", "nl": "Creates an audio media that can be played in the background."}
{"code": "private boolean hasNextTlsMode(){\n  return nextTlsMode != TLS_MODE_NULL;\n}\n", "nl": "Returns true if there's another TLS mode to try."}
{"code": "protected void copyToOpsw(){\n  opsw[1]=fullmode.isSelected();\n  opsw[2]=twoaspects.isSelected();\n  opsw[11]=semaphore.isSelected();\n  opsw[12]=pulsed.isSelected();\n  opsw[13]=disableDS.isSelected();\n  opsw[14]=fromloconet.isSelected();\n  opsw[15]=disablelocal.isSelected();\n  opsw[17]=sigaddress.isSelected();\n  opsw[18]=bcastaddress.isSelected();\n  opsw[19]=semaddress.isSelected();\n  opsw[20]=setdefault.isSelected();\n  opsw[21]=exercise.isSelected();\n  int value=section1to4mode.getSelectedIndex();\n  if ((value & 0x01) != 0) {\n    opsw[5]=true;\n  }\n else {\n    opsw[5]=false;\n  }\n  if ((value & 0x02) != 0) {\n    opsw[4]=true;\n  }\n else {\n    opsw[4]=false;\n  }\n  if ((value & 0x04) != 0) {\n    opsw[3]=true;\n  }\n else {\n    opsw[3]=false;\n  }\n  value=section5to8mode.getSelectedIndex();\n  if ((value & 0x01) != 0) {\n    opsw[8]=true;\n  }\n else {\n    opsw[8]=false;\n  }\n  if ((value & 0x02) != 0) {\n    opsw[7]=true;\n  }\n else {\n    opsw[7]=false;\n  }\n  if ((value & 0x04) != 0) {\n    opsw[6]=true;\n  }\n else {\n    opsw[6]=false;\n  }\n  value=fourthAspect.getSelectedIndex();\n  if ((value & 0x01) != 0) {\n    opsw[10]=true;\n  }\n else {\n    opsw[10]=false;\n  }\n  if ((value & 0x02) != 0) {\n    opsw[9]=true;\n  }\n else {\n    opsw[9]=false;\n  }\n}\n", "nl": "Copy from the GUI to the opsw array. <p> Used before write operations start"}
{"code": "@Override public void onRequestPermissionsResult(int requestCode,@NonNull String[] permissions,@NonNull int[] grantResults){\n  if (requestCode == ALLOW_PERMISSIONS && grantResults.length > 0) {\n    List<String> permissionsNotAllowed=new ArrayList<>();\n    for (int i=0; i < permissions.length; i++) {\n      if (grantResults[i] == PackageManager.PERMISSION_DENIED) {\n        permissionsNotAllowed.add(permissions[i]);\n      }\n    }\n    if (permissionsNotAllowed.isEmpty()) {\n      initEvent();\n    }\n else {\n      permissionNotEnabled();\n    }\n  }\n else {\n    permissionNotEnabled();\n  }\n}\n", "nl": "This method is a callback. Check the user's answer after requesting permission."}
{"code": "public String rowGet(String key){\n  String resolvedKey=resolveRowKey(key);\n  String cachedValue=rowMapCache.get(resolvedKey);\n  if (cachedValue != null) {\n    return cachedValue;\n  }\n  String value=rowMap.get(resolvedKey);\n  if (value == null && parent != null) {\n    value=parent.rowGet(resolvedKey);\n  }\n  if (value == null) {\n    return null;\n  }\n  String expandedString=expand(value,false);\n  rowMapCache.put(resolvedKey,expandedString);\n  return expandedString;\n}\n", "nl": "Looks up and returns the RowSpec associated with the given key. First looks for an association in this LayoutMap. If there's no association, the lookup continues with the parent map - if any."}
{"code": "public void postEvaluationStatistics(final EvolutionState state){\n  super.postEvaluationStatistics(state);\n  state.output.println(\"\\nGeneration: \" + state.generation,Output.V_NO_GENERAL,statisticslog);\n  for (int x=0; x < state.population.subpops.length; x++)   for (int y=1; y < state.population.subpops[x].individuals.length; y++)   state.population.subpops[x].individuals[y].printIndividualForHumans(state,statisticslog,Output.V_NO_GENERAL);\n}\n", "nl": "Logs the best individual of the generation."}
{"code": "private void checkUserExists(String entidad) throws Exception {\n  int count;\n  UsersTable table=new UsersTable();\n  DbConnection dbConn=new DbConnection();\n  try {\n    dbConn.open(DBSessionManager.getSession());\n    if (_id == ISicresAdminDefsKeys.NULL_ID)     count=DbSelectFns.selectCount(dbConn,table.getBaseTableName(),table.getCountNameQual(_name));\n else     count=DbSelectFns.selectCount(dbConn,table.getBaseTableName(),table.getCountNameIdQual(_id,_name));\n    if (count > 0)     ISicresAdminBasicException.throwException(ISicresAdminUserKeys.EC_USER_EXISTS_NAME);\n  }\n catch (  Exception e) {\n    _logger.error(e);\n    throw e;\n  }\n finally {\n    dbConn.close();\n  }\n}\n", "nl": "Comprueba que el usuario tiene distinto nombre a los que ya existen."}
{"code": "@Transactional public Role createRoleWithPermissions(Role role,Set<Long> permissionIds){\n  Role current=findRoleByRoleName(role.getRoleName());\n  Preconditions.checkState(current == null,\"Role %s already exists!\",role.getRoleName());\n  Role createdRole=roleRepository.save(role);\n  if (!CollectionUtils.isEmpty(permissionIds)) {\n    Iterable<RolePermission> rolePermissions=FluentIterable.from(permissionIds).transform(null);\n    rolePermissionRepository.save(rolePermissions);\n  }\n  return createdRole;\n}\n", "nl": "Create role with permissions, note that role name should be unique"}
{"code": "protected void generateNewCursorBox(){\n  if ((old_m_x2 != -1) || (old_m_y2 != -1) || (Math.abs(commonValues.m_x2 - old_m_x2) > 5)|| (Math.abs(commonValues.m_y2 - old_m_y2) > 5)) {\n    int top_x=commonValues.m_x1;\n    if (commonValues.m_x1 > commonValues.m_x2) {\n      top_x=commonValues.m_x2;\n    }\n    int top_y=commonValues.m_y1;\n    if (commonValues.m_y1 > commonValues.m_y2) {\n      top_y=commonValues.m_y2;\n    }\n    final int w=Math.abs(commonValues.m_x2 - commonValues.m_x1);\n    final int h=Math.abs(commonValues.m_y2 - commonValues.m_y1);\n    final int[] currentRectangle={top_x,top_y,w,h};\n    decode_pdf.updateCursorBoxOnScreen(currentRectangle,DecoderOptions.highlightColor.getRGB());\n    if (!currentCommands.extractingAsImage) {\n      final int[] r={commonValues.m_x1,commonValues.m_y1,commonValues.m_x2 - commonValues.m_x1,commonValues.m_y2 - commonValues.m_y1};\n      decode_pdf.getTextLines().addHighlights(new int[][]{r},false,commonValues.getCurrentPage());\n    }\n    old_m_x2=commonValues.m_x2;\n    old_m_y2=commonValues.m_y2;\n  }\n  decode_pdf.repaintPane(commonValues.getCurrentPage());\n}\n", "nl": "generate new  cursorBox and highlight extractable text, if hardware acceleration off and extraction on<br> and update current cursor box displayed on screen"}
{"code": "public OMGraphicList(int initialCapacity){\n  graphics=Collections.synchronizedList(new ArrayList<OMGraphic>(initialCapacity));\n}\n", "nl": "Construct an OMGraphicList with an initial capacity."}
{"code": "private void saveToSettings(){\n  List<String> dataToSave=new LinkedList<>();\n  for (  UsercolorItem item : data) {\n    dataToSave.add(item.getId() + \",\" + HtmlColors.getColorString(item.getColor()));\n  }\n  settings.putList(\"usercolors\",dataToSave);\n}\n", "nl": "Copy the current data to the settings."}
{"code": "public static boolean isArrayForName(String value){\n  return ARRAY_FOR_NAME_PATTERN.matcher(value).matches();\n}\n", "nl": "Returns true if the given string looks like a Java array name."}
{"code": "public double length(){\n  return Math.sqrt(this.x * this.x + this.y * this.y);\n}\n", "nl": "Calculates the length of the vector."}
{"code": "public String toString(){\n  return schema;\n}\n", "nl": "Returns this' media-type (a MIME content-type category) (previously returned a description key)"}
{"code": "public void restoreStarting(int numPackages){\n}\n", "nl": "The restore operation has begun."}
{"code": "private boolean resourceIsGwtXmlAndInGwt(IResource resource) throws CoreException {\n  return GWTNature.isGWTProject(resource.getProject()) && resource.getName().endsWith(\".gwt.xml\");\n}\n", "nl": "If the resource is a .gwt.xml file and we're in a gwt-enabled project, return true."}
{"code": "public GlowCreature(Location location,EntityType type,double maxHealth){\n  super(location,maxHealth);\n  this.type=type;\n}\n", "nl": "Creates a new monster."}
{"code": "public CacheLayer(){\n}\n", "nl": "Construct a default CacheLayer."}
{"code": "protected Address buildAndroidAddress(JSONObject jResult) throws JSONException {\n  Address gAddress=new Address(mLocale);\n  gAddress.setLatitude(jResult.getDouble(\"lat\"));\n  gAddress.setLongitude(jResult.getDouble(\"lng\"));\n  int addressIndex=0;\n  if (jResult.has(\"streetName\")) {\n    gAddress.setAddressLine(addressIndex++,jResult.getString(\"streetName\"));\n    gAddress.setThoroughfare(jResult.getString(\"streetName\"));\n  }\n  if (jResult.has(\"zipCode\")) {\n    gAddress.setAddressLine(addressIndex++,jResult.getString(\"zipCode\"));\n    gAddress.setPostalCode(jResult.getString(\"zipCode\"));\n  }\n  if (jResult.has(\"city\")) {\n    gAddress.setAddressLine(addressIndex++,jResult.getString(\"city\"));\n    gAddress.setLocality(jResult.getString(\"city\"));\n  }\n  if (jResult.has(\"state\")) {\n    gAddress.setAdminArea(jResult.getString(\"state\"));\n  }\n  if (jResult.has(\"country\")) {\n    gAddress.setAddressLine(addressIndex++,jResult.getString(\"country\"));\n    gAddress.setCountryName(jResult.getString(\"country\"));\n  }\n  if (jResult.has(\"countrycode\"))   gAddress.setCountryCode(jResult.getString(\"countrycode\"));\n  return gAddress;\n}\n", "nl": "Build an Android Address object from the Gisgraphy address in JSON format."}
{"code": "public JDBCCategoryDataset(Connection connection,String query) throws SQLException {\n  this(connection);\n  executeQuery(query);\n}\n", "nl": "Creates a new dataset with the given database connection, and executes the supplied query to populate the dataset."}
{"code": "public static Map<String,Object> generateReqsFromCancelledPOItems(DispatchContext dctx,Map<String,? extends Object> context){\n  Delegator delegator=dctx.getDelegator();\n  LocalDispatcher dispatcher=dctx.getDispatcher();\n  GenericValue userLogin=(GenericValue)context.get(\"userLogin\");\n  Locale locale=(Locale)context.get(\"locale\");\n  String orderId=(String)context.get(\"orderId\");\n  String facilityId=(String)context.get(\"facilityId\");\n  try {\n    GenericValue orderHeader=EntityQuery.use(delegator).from(\"OrderHeader\").where(\"orderId\",orderId).queryOne();\n    if (UtilValidate.isEmpty(orderHeader)) {\n      String errorMessage=UtilProperties.getMessage(resource_error,\"OrderErrorOrderIdNotFound\",UtilMisc.toMap(\"orderId\",orderId),locale);\n      Debug.logError(errorMessage,module);\n      return ServiceUtil.returnError(errorMessage);\n    }\n    if (!\"PURCHASE_ORDER\".equals(orderHeader.getString(\"orderTypeId\"))) {\n      String errorMessage=UtilProperties.getMessage(resource_error,\"ProductErrorOrderNotPurchaseOrder\",UtilMisc.toMap(\"orderId\",orderId),locale);\n      Debug.logError(errorMessage,module);\n      return ServiceUtil.returnError(errorMessage);\n    }\n    Map<String,Object> productRequirementQuantities=new HashMap<String,Object>();\n    List<GenericValue> orderItems=orderHeader.getRelated(\"OrderItem\",null,null,false);\n    for (    GenericValue orderItem : orderItems) {\n      if (!\"PRODUCT_ORDER_ITEM\".equals(orderItem.getString(\"orderItemTypeId\")))       continue;\n      BigDecimal orderItemCancelQuantity=BigDecimal.ZERO;\n      if (!UtilValidate.isEmpty(orderItem.get(\"cancelQuantity\"))) {\n        orderItemCancelQuantity=orderItem.getBigDecimal(\"cancelQuantity\");\n      }\n      if (orderItemCancelQuantity.compareTo(BigDecimal.ZERO) <= 0)       continue;\n      String productId=orderItem.getString(\"productId\");\n      if (productRequirementQuantities.containsKey(productId)) {\n        orderItemCancelQuantity=orderItemCancelQuantity.add((BigDecimal)productRequirementQuantities.get(productId));\n      }\n      productRequirementQuantities.put(productId,orderItemCancelQuantity);\n    }\n    for (    String productId : productRequirementQuantities.keySet()) {\n      BigDecimal requiredQuantity=(BigDecimal)productRequirementQuantities.get(productId);\n      Map<String,Object> createRequirementResult=dispatcher.runSync(\"createRequirement\",UtilMisc.<String,Object>toMap(\"requirementTypeId\",\"PRODUCT_REQUIREMENT\",\"facilityId\",facilityId,\"productId\",productId,\"quantity\",requiredQuantity,\"userLogin\",userLogin));\n      if (ServiceUtil.isError(createRequirementResult))       return createRequirementResult;\n    }\n  }\n catch (  GenericEntityException e) {\n    Debug.logError(e,module);\n    return ServiceUtil.returnError(e.getMessage());\n  }\ncatch (  GenericServiceException se) {\n    Debug.logError(se,module);\n    return ServiceUtil.returnError(se.getMessage());\n  }\n  return ServiceUtil.returnSuccess();\n}\n", "nl": "Generates a product requirement for the total cancelled quantity over all order items for each product"}
{"code": "private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {\n  s.defaultReadObject();\n  if (bayesIm == null) {\n    throw new NullPointerException();\n  }\n  if (variables == null) {\n    throw new NullPointerException();\n  }\n}\n", "nl": "Adds semantic checks to the default deserialization method. This method must have the standard signature for a readObject method, and the body of the method must begin with \"s.defaultReadObject();\". Other than that, any semantic checks can be specified and do not need to stay the same from version to version. A readObject method of this form may be added to any class, even if Tetrad sessions were previously saved out using a version of the class that didn't include it. (That's what the \"s.defaultReadObject();\" is for. See J. Bloch, Effective Java, for help."}
{"code": "boolean contains(ProtocolVersion protocolVersion){\n  if (protocolVersion == ProtocolVersion.SSL20Hello) {\n    return false;\n  }\n  return protocols.contains(protocolVersion);\n}\n", "nl": "Return whether this list contains the specified protocol version. SSLv2Hello is not a real protocol version we support, we always return false for it."}
{"code": "@Override protected EClass eStaticClass(){\n  return DatatypePackage.Literals.OBJECT_PROPERTY_TYPE;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:34:35.806 -0500\",hash_original_method=\"E14DF72F5869874CC38AD67447F5264E\",hash_generated_method=\"127365361841BB38033FE96228DFD635\") public final Iterator<String> typesIterator(){\n  return mDataTypes != null ? mDataTypes.iterator() : null;\n}\n", "nl": "Return an iterator over the filter's data types."}
{"code": "public void registerGUI(final ConfigGUI gui){\n  this.gui=gui;\n}\n", "nl": "Sets the reference of the GUI."}
{"code": "public IntersectionMatrix(IntersectionMatrix other){\n  this();\n  matrix[Location.INTERIOR][Location.INTERIOR]=other.matrix[Location.INTERIOR][Location.INTERIOR];\n  matrix[Location.INTERIOR][Location.BOUNDARY]=other.matrix[Location.INTERIOR][Location.BOUNDARY];\n  matrix[Location.INTERIOR][Location.EXTERIOR]=other.matrix[Location.INTERIOR][Location.EXTERIOR];\n  matrix[Location.BOUNDARY][Location.INTERIOR]=other.matrix[Location.BOUNDARY][Location.INTERIOR];\n  matrix[Location.BOUNDARY][Location.BOUNDARY]=other.matrix[Location.BOUNDARY][Location.BOUNDARY];\n  matrix[Location.BOUNDARY][Location.EXTERIOR]=other.matrix[Location.BOUNDARY][Location.EXTERIOR];\n  matrix[Location.EXTERIOR][Location.INTERIOR]=other.matrix[Location.EXTERIOR][Location.INTERIOR];\n  matrix[Location.EXTERIOR][Location.BOUNDARY]=other.matrix[Location.EXTERIOR][Location.BOUNDARY];\n  matrix[Location.EXTERIOR][Location.EXTERIOR]=other.matrix[Location.EXTERIOR][Location.EXTERIOR];\n}\n", "nl": "Creates an <code>IntersectionMatrix</code> with the same elements as <code>other</code>."}
{"code": "public long readUnsignedInt(){\n  long result=shiftIntoLong(data,position,4);\n  position+=4;\n  return result;\n}\n", "nl": "Reads the next four bytes as an unsigned value."}
{"code": "public void emit(final SpannableStringBuilder out,final Block root){\n  root.removeSurroundingEmptyLines();\nswitch (root.type) {\ncase NONE:\n    break;\ncase PARAGRAPH:\n  this.config.decorator.openParagraph(out);\nbreak;\ncase BLOCKQUOTE:\nthis.config.decorator.openBlockquote(out);\nbreak;\ncase UNORDERED_LIST:\nthis.config.decorator.openUnorderedList(out);\nbreak;\ncase ORDERED_LIST:\nthis.config.decorator.openOrderedList(out);\nbreak;\ncase UNORDERED_LIST_ITEM:\nthis.config.decorator.openUnOrderedListItem(out);\nbreak;\ncase ORDERED_LIST_ITEM:\nthis.config.decorator.openOrderedListItem(out);\nbreak;\n}\nif (root.hasLines()) {\nthis.emitLines(out,root);\n}\n else {\nBlock block=root.blocks;\nwhile (block != null) {\nthis.emit(out,block);\nblock=block.next;\n}\n}\nswitch (root.type) {\ncase NONE:\nbreak;\ncase PARAGRAPH:\nthis.config.decorator.closeParagraph(out);\nbreak;\ncase BLOCKQUOTE:\nthis.config.decorator.closeBlockquote(out);\nbreak;\ncase UNORDERED_LIST:\nthis.config.decorator.closeUnorderedList(out);\nbreak;\ncase ORDERED_LIST:\nthis.config.decorator.closeOrderedList(out);\nbreak;\ncase UNORDERED_LIST_ITEM:\nthis.config.decorator.closeUnOrderedListItem(out);\nbreak;\ncase ORDERED_LIST_ITEM:\nthis.config.decorator.closeOrderedListItem(out);\nbreak;\n}\n}\n", "nl": "Transforms the given block recursively into HTML."}
{"code": "public boolean isInternable(){\n  return (classAnnotations != null) && (fieldAnnotations == null) && (methodAnnotations == null)&& (parameterAnnotations == null);\n}\n", "nl": "Returns whether this item is a candidate for interning. The only interning candidates are ones that <i>only</i> have a non-null set of class annotations, with no other lists."}
{"code": "public URI(final String scheme,final String userinfo,final String host,final int port,final String path,final String query,final String fragment) throws URIException {\n  this(scheme,(host == null) ? null : ((userinfo != null) ? userinfo + '@' : \"\") + host + ((port != -1) ? \":\" + port : \"\"),path,query,fragment);\n}\n", "nl": "Construct a general URI from the given components."}
{"code": "public void addUser(User user){\n  users.addElement(user);\n}\n", "nl": "Add a user"}
{"code": "protected void engineUpdate(byte b) throws SignatureException {\n  msgDigest.update(b);\n}\n", "nl": "Updates data to sign or to verify."}
{"code": "public RqMtFake(final Request req,final Request... dispositions) throws IOException {\n  this.fake=new RqMtBase(new RqMtFake.FakeMultipartRequest(req,dispositions));\n}\n", "nl": "Fake ctor."}
{"code": "public static Video randomVideo(){\n  String id=UUID.randomUUID().toString();\n  String title=\"Video-\" + id;\n  String url=\"http://coursera.org/some/video-\" + id;\n  long duration=60 * (int)Math.rint(Math.random() * 60) * 1000;\n  return new Video(title,url,duration);\n}\n", "nl": "Construct and return a Video object with a rnadom name, url, and duration."}
{"code": "public void addHeader(String header,String value){\n  clientHeaderMap.put(header,value);\n}\n", "nl": "Sets headers that will be added to all requests this client makes (before sending)."}
{"code": "public void addPostalAddress(PostalAddress postalAddress){\n  getPostalAddresses().add(postalAddress);\n}\n", "nl": "Adds a new contact postal address."}
{"code": "public CaughtExceptionRef newCaughtExceptionRef(){\n  return new JCaughtExceptionRef();\n}\n", "nl": "Constructs a CaughtExceptionRef() grammar chunk."}
{"code": "public void actionPerformed(ActionEvent e){\n  if (e.getSource() instanceof PerformanceIndicator) {\n    PerformanceIndicator pi=(PerformanceIndicator)e.getSource();\n    log.info(pi.getName());\n    MGoal goal=pi.getGoal();\n    if (goal.getMeasure() != null)     new PerformanceDetail(goal);\n  }\n}\n", "nl": "Action Listener for Drill Down"}
{"code": "public Iterator<AbstractNode> childIterator(final boolean dirtyNodesOnly){\n  if (dirtyNodesOnly) {\n    return new DirtyChildIterator(this);\n  }\n else {\n    return new ChildIterator(this);\n  }\n}\n", "nl": "Iterator visits the direct child nodes in the external key ordering."}
{"code": "public static int maxIndex(double[] doubles){\n  double maximum=0;\n  int maxIndex=0;\n  for (int i=0; i < doubles.length; i++) {\n    if ((i == 0) || (doubles[i] > maximum)) {\n      maxIndex=i;\n      maximum=doubles[i];\n    }\n  }\n  return maxIndex;\n}\n", "nl": "Returns index of maximum element in a given array of doubles. First maximum is returned."}
{"code": "private List<PreferenceIndex> crawlSingleIndexableResource(IndexableFragment indexableFragment){\n  List<PreferenceIndex> indexablePreferences=new ArrayList<>();\n  XmlPullParser parser=mContext.getResources().getXml(indexableFragment.xmlRes);\n  int type;\n  try {\n    while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && type != XmlPullParser.START_TAG) {\n    }\n    String nodeName=parser.getName();\n    if (!NODE_NAME_PREFERENCE_SCREEN.equals(nodeName)) {\n      throw new RuntimeException(\"XML document must start with <PreferenceScreen> tag; found\" + nodeName + \" at \"+ parser.getPositionDescription());\n    }\n    final int outerDepth=parser.getDepth();\n    final AttributeSet attrs=Xml.asAttributeSet(parser);\n    while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {\n      if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {\n        continue;\n      }\n      nodeName=parser.getName();\n      String key=PreferenceXmlUtil.getDataKey(mContext,attrs);\n      String title=PreferenceXmlUtil.getDataTitle(mContext,attrs);\n      if (NODE_NAME_PREFERENCE_CATEGORY.equals(nodeName) || TextUtils.isEmpty(key) || TextUtils.isEmpty(title)) {\n        continue;\n      }\n      PreferenceIndex indexablePreference=new PreferenceIndex(key,title,indexableFragment.fragmentName);\n      indexablePreferences.add(indexablePreference);\n    }\n  }\n catch (  XmlPullParserException|IOException|ReflectiveOperationException ex) {\n    Log.e(TAG,\"Error in parsing a preference xml file, skip it\",ex);\n  }\n  return indexablePreferences;\n}\n", "nl": "Skim through the xml preference file."}
{"code": "@Inline private static void genNullCheck(Assembler asm,GPR objRefReg){\n  asm.emitTEST_Reg_Reg(objRefReg,objRefReg);\n  asm.emitBranchLikelyNextInstruction();\n  ForwardReference fr=asm.forwardJcc(NE);\n  asm.emitINT_Imm(RuntimeEntrypoints.TRAP_NULL_POINTER + RVM_TRAP_BASE);\n  fr.resolve(asm);\n}\n", "nl": "Generate an explicit null check (compare to zero)."}
{"code": "public Location(String provider){\n  mProvider=provider;\n}\n", "nl": "Construct a new Location with a named provider. <p>By default time, latitude and longitude are 0, and the location has no bearing, altitude, speed, accuracy or extras."}
{"code": "@Override public void run(){\n  amIActive=true;\n  String demHeader=null;\n  String creekHeader=null;\n  String ttControlHeader=null;\n  String eacOutputHeader=null;\n  String dfcOutputHeader=null;\n  String gtcOutputHeader=null;\n  String ttpOutputHeader=null;\n  WhiteboxRaster dem;\n  WhiteboxRaster creek;\n  WhiteboxRaster ttControl=null;\n  WhiteboxRaster eacOutput;\n  WhiteboxRaster dfcOutput;\n  WhiteboxRaster gtcOutput;\n  WhiteboxRaster ttpOutput;\n  int numCols, numRows;\n  double gridRes;\n  boolean blnTTControl=true;\n  int flowIndex;\n  List<FlowCell> flowPath=new ArrayList<>();\n  int c;\n  int x, y;\n  int xn, yn;\n  double p;\n  int maxDirection;\n  double grad, maxGrad;\n  double deltaElev;\n  double deltaXY;\n  int radius;\n  float maxRadius=200;\n  int maxX=0, maxY=0;\n  double ttControlMean;\n  int[] xd=new int[]{0,-1,-1,-1,0,1,1,1};\n  int[] yd=new int[]{-1,-1,0,1,1,1,0,-1};\n  double[] dd=new double[]{1,Math.sqrt(2),1,Math.sqrt(2),1,Math.sqrt(2),1,Math.sqrt(2)};\n  double noData;\n  float progress=0;\n  if (args.length <= 0) {\n    showFeedback(\"Plugin parameters have not been set.\");\n    return;\n  }\n  for (int i=0; i < args.length; i++) {\n    if (i == 0) {\n      demHeader=args[i];\n    }\n else     if (i == 1) {\n      creekHeader=args[i];\n    }\n else     if (i == 2) {\n      ttControlHeader=args[i];\n      if (ttControlHeader.toLowerCase().contains(\"not specified\")) {\n        blnTTControl=false;\n      }\n    }\n else     if (i == 3) {\n      eacOutputHeader=args[i];\n    }\n else     if (i == 4) {\n      dfcOutputHeader=args[i];\n    }\n else     if (i == 5) {\n      gtcOutputHeader=args[i];\n    }\n else     if (i == 6) {\n      ttpOutputHeader=args[i];\n    }\n  }\n  if ((demHeader == null) || (creekHeader == null) || (eacOutputHeader == null)|| (dfcOutputHeader == null)|| (gtcOutputHeader == null)|| (ttpOutputHeader == null)) {\n    showFeedback(\"One or more of the input parameters have not been set properly.\");\n    return;\n  }\n  try {\n    dem=new WhiteboxRaster(demHeader,\"r\");\n    creek=new WhiteboxRaster(creekHeader,\"r\");\n    if (blnTTControl == true) {\n      ttControl=new WhiteboxRaster(ttControlHeader,\"r\");\n    }\n    numRows=dem.getNumberRows();\n    numCols=dem.getNumberColumns();\n    noData=dem.getNoDataValue();\n    gridRes=dem.getCellSizeX();\n    eacOutput=new WhiteboxRaster(eacOutputHeader,\"rw\",demHeader,WhiteboxRaster.DataType.FLOAT,0);\n    eacOutput.setPreferredPalette(\"blueyellow.pal\");\n    eacOutput.setDataScale(WhiteboxRasterBase.DataScale.CONTINUOUS);\n    eacOutput.setZUnits(\"dimensionless\");\n    dfcOutput=new WhiteboxRaster(dfcOutputHeader,\"rw\",demHeader,WhiteboxRaster.DataType.FLOAT,0);\n    dfcOutput.setPreferredPalette(\"blueyellow.pal\");\n    dfcOutput.setDataScale(WhiteboxRasterBase.DataScale.CONTINUOUS);\n    dfcOutput.setZUnits(\"dimensionless\");\n    gtcOutput=new WhiteboxRaster(gtcOutputHeader,\"rw\",demHeader,WhiteboxRaster.DataType.FLOAT,0);\n    gtcOutput.setPreferredPalette(\"blueyellow.pal\");\n    gtcOutput.setDataScale(WhiteboxRasterBase.DataScale.CONTINUOUS);\n    gtcOutput.setZUnits(\"dimensionless\");\n    ttpOutput=new WhiteboxRaster(ttpOutputHeader,\"rw\",demHeader,WhiteboxRaster.DataType.FLOAT,0);\n    ttpOutput.setPreferredPalette(\"blueyellow.pal\");\n    ttpOutput.setDataScale(WhiteboxRasterBase.DataScale.CONTINUOUS);\n    ttpOutput.setZUnits(\"dimensionless\");\n    updateProgress(\"Loop 1 of 2:\",0);\n    for (int row=0; row < numRows; row++) {\n      for (int col=0; col < numCols; col++) {\n        if (dem.getValue(row,col) != noData) {\n          if (creek.getValue(row,col) <= 0) {\n            eacOutput.setValue(row,col,-1048);\n          }\n        }\n else {\n          eacOutput.setValue(row,col,noData);\n          dfcOutput.setValue(row,col,noData);\n          gtcOutput.setValue(row,col,noData);\n          ttpOutput.setValue(row,col,noData);\n        }\n      }\n      progress=(float)(100f * row / (numRows - 1));\n      updateProgress(\"Loop 1 of 2:\",(int)progress);\n    }\n    updateProgress(\"Loop 2 of 2:\",0);\n    for (int row=0; row < numRows; row++) {\n      for (int col=0; col < numCols; col++) {\n        if (eacOutput.getValue(row,col) == -1048) {\n          flowIndex=-1;\n          flowPath=new ArrayList<>();\n          x=col;\n          y=row;\n          while (eacOutput.getValue(y,x) == -1048) {\n            flowIndex=flowIndex + 1;\n            flowPath.add(new FlowCell(y,x));\n            p=dem.getValue(y,x);\n            maxDirection=-1;\n            maxGrad=0;\n            for (c=0; c < 8; c++) {\n              xn=x + xd[c];\n              yn=y + yd[c];\n              if (dem.getValue(yn,xn) != noData) {\n                grad=(p - dem.getValue(yn,xn)) / (dd[c] * gridRes);\n                if (grad > maxGrad) {\n                  maxGrad=grad;\n                  maxDirection=c;\n                }\n              }\n            }\n            if (maxDirection > -1) {\n              x=x + xd[maxDirection];\n              y=y + yd[maxDirection];\n            }\n else {\n              radius=1;\n              do {\n                for (int i=-radius; i <= radius; i++) {\n                  for (int j=-radius; j <= radius; j++) {\n                    if (Math.abs(i) > radius - 1 || Math.abs(j) > radius - 1) {\n                      xn=x + i;\n                      yn=y + j;\n                      if (dem.getValue(yn,xn) != noData && dem.getValue(yn,xn) < p) {\n                        grad=(p - dem.getValue(yn,xn)) / (Math.sqrt(i * i + j * j) * gridRes);\n                        if (grad > maxGrad) {\n                          maxGrad=grad;\n                          maxX=xn;\n                          maxY=yn;\n                        }\n                      }\n                    }\n                  }\n                }\n                radius=radius + 1;\n              }\n while (maxGrad == 0 & radius <= maxRadius);\n              if (maxGrad > 0) {\n                x=maxX;\n                y=maxY;\n              }\n else {\n                eacOutput.setValue(y,x,noData);\n                dfcOutput.setValue(y,x,noData);\n                gtcOutput.setValue(y,x,noData);\n                ttpOutput.setValue(y,x,noData);\n              }\n            }\n          }\n          if (eacOutput.getValue(y,x) == noData) {\n            eacOutput.setValue(flowPath.get(flowIndex).rowIndex,flowPath.get(flowIndex).columnIndex,noData);\n            dfcOutput.setValue(flowPath.get(flowIndex).rowIndex,flowPath.get(flowIndex).columnIndex,noData);\n            gtcOutput.setValue(flowPath.get(flowIndex).rowIndex,flowPath.get(flowIndex).columnIndex,noData);\n            ttpOutput.setValue(flowPath.get(flowIndex).rowIndex,flowPath.get(flowIndex).columnIndex,noData);\n          }\n else {\n            deltaElev=dem.getValue(flowPath.get(flowIndex).rowIndex,flowPath.get(flowIndex).columnIndex) - dem.getValue(y,x);\n            deltaXY=Math.sqrt(Math.pow(flowPath.get(flowIndex).rowIndex - y,2) + Math.pow(flowPath.get(flowIndex).columnIndex - x,2)) * gridRes;\n            eacOutput.setValue(flowPath.get(flowIndex).rowIndex,flowPath.get(flowIndex).columnIndex,eacOutput.getValue(y,x) + deltaElev);\n            dfcOutput.setValue(flowPath.get(flowIndex).rowIndex,flowPath.get(flowIndex).columnIndex,dfcOutput.getValue(y,x) + deltaXY);\n            gtcOutput.setValue(flowPath.get(flowIndex).rowIndex,flowPath.get(flowIndex).columnIndex,(gtcOutput.getValue(y,x) * dfcOutput.getValue(y,x) + deltaElev) / dfcOutput.getValue(flowPath.get(flowIndex).rowIndex,flowPath.get(flowIndex).columnIndex));\n            if (blnTTControl == false) {\n              ttpOutput.setValue(flowPath.get(flowIndex).rowIndex,flowPath.get(flowIndex).columnIndex,ttpOutput.getValue(y,x) + Math.pow(deltaXY,2) / deltaElev);\n            }\n else {\n              ttControlMean=(ttControl.getValue(y,x) + ttControl.getValue(flowPath.get(flowIndex).rowIndex,flowPath.get(flowIndex).columnIndex)) / 2;\n              ttpOutput.setValue(flowPath.get(flowIndex).rowIndex,flowPath.get(flowIndex).columnIndex,ttpOutput.getValue(y,x) + Math.pow(deltaXY,2) / (deltaElev * ttControlMean));\n            }\n          }\n          for (int i=flowIndex - 1; i >= 0; i--) {\n            if (eacOutput.getValue(flowPath.get(i + 1).rowIndex,flowPath.get(i + 1).columnIndex) == noData) {\n              eacOutput.setValue(flowPath.get(i).rowIndex,flowPath.get(i).columnIndex,noData);\n              dfcOutput.setValue(flowPath.get(i).rowIndex,flowPath.get(i).columnIndex,noData);\n              gtcOutput.setValue(flowPath.get(i).rowIndex,flowPath.get(i).columnIndex,noData);\n              ttpOutput.setValue(flowPath.get(i).rowIndex,flowPath.get(i).columnIndex,noData);\n            }\n else {\n              deltaElev=dem.getValue(flowPath.get(i).rowIndex,flowPath.get(i).columnIndex) - dem.getValue(flowPath.get(i + 1).rowIndex,flowPath.get(i + 1).columnIndex);\n              deltaXY=Math.sqrt(Math.pow(flowPath.get(i).rowIndex - flowPath.get(i + 1).rowIndex,2) + Math.pow(flowPath.get(i).columnIndex - flowPath.get(i + 1).columnIndex,2)) * gridRes;\n              eacOutput.setValue(flowPath.get(i).rowIndex,flowPath.get(i).columnIndex,eacOutput.getValue(flowPath.get(i + 1).rowIndex,flowPath.get(i + 1).columnIndex) + deltaElev);\n              dfcOutput.setValue(flowPath.get(i).rowIndex,flowPath.get(i).columnIndex,dfcOutput.getValue(flowPath.get(i + 1).rowIndex,flowPath.get(i + 1).columnIndex) + deltaXY);\n              gtcOutput.setValue(flowPath.get(i).rowIndex,flowPath.get(i).columnIndex,(gtcOutput.getValue(flowPath.get(i + 1).rowIndex,flowPath.get(i + 1).columnIndex) * dfcOutput.getValue(flowPath.get(i + 1).rowIndex,flowPath.get(i + 1).columnIndex) + deltaElev) / dfcOutput.getValue(flowPath.get(i).rowIndex,flowPath.get(i).columnIndex));\n              if (blnTTControl == false) {\n                ttpOutput.setValue(flowPath.get(i).rowIndex,flowPath.get(i).columnIndex,ttpOutput.getValue(flowPath.get(i + 1).rowIndex,flowPath.get(i + 1).columnIndex) + Math.pow(deltaXY,2) / deltaElev);\n              }\n else {\n                ttControlMean=(ttControl.getValue(flowPath.get(i).rowIndex,flowPath.get(i).columnIndex) + ttControl.getValue(flowPath.get(i + 1).rowIndex,flowPath.get(i + 1).columnIndex)) / 2;\n                ttpOutput.setValue(flowPath.get(i).rowIndex,flowPath.get(i).columnIndex,ttpOutput.getValue(flowPath.get(i + 1).rowIndex,flowPath.get(i + 1).columnIndex) + Math.pow(deltaXY,2) / (deltaElev * ttControlMean));\n              }\n            }\n          }\n        }\n      }\n      if (cancelOp) {\n        cancelOperation();\n        return;\n      }\n      progress=(float)(100f * row / (numRows - 1));\n      updateProgress(\"Loop 2 of 2:\",(int)progress);\n    }\n    eacOutput.addMetadataEntry(\"Created by the \" + getDescriptiveName() + \" tool.\");\n    eacOutput.addMetadataEntry(\"Created on \" + new Date());\n    dfcOutput.addMetadataEntry(\"Created by the \" + getDescriptiveName() + \" tool.\");\n    dfcOutput.addMetadataEntry(\"Created on \" + new Date());\n    gtcOutput.addMetadataEntry(\"Created by the \" + getDescriptiveName() + \" tool.\");\n    gtcOutput.addMetadataEntry(\"Created on \" + new Date());\n    ttpOutput.addMetadataEntry(\"Created by the \" + getDescriptiveName() + \" tool.\");\n    ttpOutput.addMetadataEntry(\"Created on \" + new Date());\n    dem.close();\n    creek.close();\n    if (blnTTControl == true) {\n      ttControl.close();\n    }\n    eacOutput.close();\n    dfcOutput.close();\n    gtcOutput.close();\n    ttpOutput.close();\n    returnData(eacOutputHeader);\n  }\n catch (  Exception e) {\n    showFeedback(e.getMessage());\n  }\n finally {\n    updateProgress(\"Progress: \",0);\n    amIActive=false;\n    myHost.pluginComplete();\n  }\n}\n", "nl": "Used to execute this plugin tool."}
{"code": "public NodesInfoRequest(String... nodesIds){\n  super(nodesIds);\n}\n", "nl": "Get information from nodes based on the nodes ids specified. If none are passed, information for all nodes will be returned."}
{"code": "public static double norm(double[] a){\n  double squaredSum=0;\n  for (int i=0; i < a.length; i++) {\n    squaredSum+=a[i] * a[i];\n  }\n  return Math.sqrt(squaredSum);\n}\n", "nl": "Computes 2-norm of vector"}
{"code": "private static double[] toDoubleAray(Integer[] intArray,HashSet<Integer> skipIndex){\n  double[] res=new double[intArray.length - skipIndex.size()];\n  int skip=0;\n  for (int i=0; i < intArray.length; i++) {\n    if (skipIndex.contains(i)) {\n      skip++;\n      continue;\n    }\n    res[i - skip]=intArray[i].doubleValue();\n  }\n  return res;\n}\n", "nl": "Converts an array into array of doubles skipping specified indeces."}
{"code": "private void updateProgress(String progressLabel,int progress){\n  if (myHost != null && ((progress != previousProgress) || (!progressLabel.equals(previousProgressLabel)))) {\n    myHost.updateProgress(progressLabel,progress);\n  }\n  previousProgress=progress;\n  previousProgressLabel=progressLabel;\n}\n", "nl": "Used to communicate a progress update between a plugin tool and the main Whitebox user interface."}
{"code": "public CompositeValidationIssueProcessor(final IValidationIssueProcessor first,final IValidationIssueProcessor... others){\n  processors=Lists.asList(first,others);\n}\n", "nl": "Creates a new composite issue processor with the given sub processor arguments."}
{"code": "public OptionSet removeMaxAge(){\n  max_age=null;\n  return this;\n}\n", "nl": "Removes the Max-Age option. Returns the current OptionSet object for a fluent API."}
{"code": "public Request(){\n  locality=\"\";\n  state=\"\";\n  organization=\"\";\n  orgunit=\"\";\n  dnsname=\"\";\n  uri=\"\";\n  email=\"\";\n  ipaddress=\"\";\n  keyusage=0;\n}\n", "nl": "Ctor for the Request Object"}
{"code": "@Override protected Position determineMainLabelPosition(DrawContext dc){\n  return this.getReferencePosition();\n}\n", "nl": "Compute the position for the area's main label. This position indicates the position of the first line of the label. If there are more lines, they will be arranged South of the first line."}
{"code": "@Override Map<String,Object> extractFields(String line){\n  if (!initialized) {\n    init();\n    initialized=true;\n  }\n  String[] values=fixedWidthParser.parseLine(line);\n  if (hasHeader && Arrays.deepEquals(values,header)) {\n    return null;\n  }\n  Map<String,Object> map=Maps.newHashMap();\n  int i=0;\n  for (  FixedWidthField field : fields) {\n    map.put(field.getName(),getValue(field,values[i++]));\n  }\n  return map;\n}\n", "nl": "Extracts the fields from a fixed width record and returns a map containing field names and values"}
{"code": "@Override public boolean contains(Value subvalue){\n  return toString().contains(subvalue.toString());\n}\n", "nl": "Returns true if the value is contained in the relation structure. (this is done"}
{"code": "private void applyTo(ClassVisitor v,Field f){\n  if (Log.isLoggingOn()) {\n    Log.logLine(String.format(\"Visiting field %s\",f.toGenericString()));\n  }\n  v.visit(f);\n}\n", "nl": "Apply a visitor to a field."}
{"code": "@Override protected EClass eStaticClass(){\n  return ExpressionsPackage.Literals.BITWISE_AND_EXPRESSION;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "@Override public final void closePath(){\n  shape_primitives.addElement(H);\n  shape_primitive_x.addElement(0);\n  shape_primitive_y.addElement(0);\n  shape_primitive_x2.addElement(0);\n  shape_primitive_y2.addElement(0);\n  shape_primitive_x3.addElement(0);\n  shape_primitive_y3.addElement(0);\n}\n", "nl": "end a shape, storing info for later"}
{"code": "public DefaultBoundValueOperations(K key,RedisOperations<K,V> operations){\n  super(key,operations);\n  this.ops=operations.opsForValue();\n}\n", "nl": "Constructs a new <code>DefaultBoundValueOperations</code> instance."}
{"code": "@Override public void writeBatch() throws IOException {\n  if (getInstances() == null) {\n    throw new IOException(\"No instances to save\");\n  }\n  if (getRetrieval() == INCREMENTAL) {\n    throw new IOException(\"Batch and incremental saving cannot be mixed.\");\n  }\n  setRetrieval(BATCH);\n  setWriteMode(WRITE);\n  if ((retrieveFile() == null) && (getWriter() == null)) {\n    for (int i=0; i < getInstances().numInstances(); i++) {\n      System.out.println(instanceToLibsvm(getInstances().instance(i)));\n    }\n    setWriteMode(WAIT);\n  }\n else {\n    PrintWriter outW=new PrintWriter(getWriter());\n    for (int i=0; i < getInstances().numInstances(); i++) {\n      outW.println(instanceToLibsvm(getInstances().instance(i)));\n    }\n    outW.flush();\n    outW.close();\n    setWriteMode(WAIT);\n    outW=null;\n    resetWriter();\n    setWriteMode(CANCEL);\n  }\n}\n", "nl": "Writes a Batch of instances"}
{"code": "public FloatMatrix truthi(){\n  for (int i=0; i < length; i++) {\n    put(i,get(i) == 0.0f ? 0.0f : 1.0f);\n  }\n  return this;\n}\n", "nl": "Maps zero to 0.0 and all non-zero values to 1.0 (in-place)."}
{"code": "public void testCallProcEscapeSequenceWithWhitespaces() throws Exception {\n  check(\"CALL func1()\",\"{ call func1()}\");\n  check(\"CALL func1()\",\"{    call  func1()}\");\n  check(\"CALL func1()\",\"{ \\n call\\nfunc1()}\");\n  checkFail(\"{ \\n func1()}\");\n}\n", "nl": "Test escape sequences with additional whitespace characters"}
{"code": "public EnumRowStatus(Long valueIndex) throws IllegalArgumentException {\n  this(valueIndex.longValue());\n}\n", "nl": "Build an <code>EnumRowStatus</code> from a <code>Long</code>."}
{"code": "private void generateOps708(char[][] screenData,long[][] screenCellData,java.awt.geom.Rectangle2D.Float clipRect,float alphaFactor,float xoff,float yoff,float rowHeight,float currY,float charWidth,float currX){\n  if (reality.isIntegerPixels())   currY=(float)Math.floor(currY);\n  StringBuffer sb=new StringBuffer();\n  printCCBuffer(\"708 CCData to render\",screenData,sb,screenCellData,new StringBuffer());\n  sb.setLength(0);\n  for (int row=0; row < sage.media.sub.CCSubtitleHandler.CC_ROWS && screenData != null; row++) {\n    long lastCellFormat=screenCellData[row][0];\n    if (CellFormat.getBackgroundOpacity(lastCellFormat) == DTVCCOpacity.TRANSPARENT && screenData[row][0] == 0) {\n      lastCellFormat=CellFormat.setForeground(lastCellFormat,(byte)CellFormat.getForeground(lastCellFormat),DTVCCOpacity.TRANSPARENT);\n    }\n    rowOffsets[row]=-1;\n    float rowStartY=rowHeight * row;\n    float textOffset=charWidth;\n    int maxCols=screenCellData[row].length - 1;\n    int lastRenderedCol=-1;\n    for (int col=0; col < maxCols; col++) {\n      if (lastCellFormat != screenCellData[row][col]) {\n        int windowID=CellFormat.getWindowID(lastCellFormat);\n        if ((CellFormat.getForegroundOpacity(lastCellFormat) != DTVCCOpacity.TRANSPARENT || CellFormat.getBackgroundOpacity(lastCellFormat) != DTVCCOpacity.TRANSPARENT)) {\n          textOffset+=render708ops(screenData,screenCellData,clipRect,alphaFactor,xoff,yoff,rowHeight,currY,charWidth,currX,sb,lastCellFormat,rowStartY,textOffset,lastRenderedCol,row,col);\n          lastRenderedCol=col - 1;\n        }\n else {\n          addTo708WindowRect(windowID,xoff + currX + textOffset,yoff + rowStartY,sb.length() * charWidth,rowHeight);\n          textOffset+=sb.length() * charWidth;\n        }\n        sb.setLength(0);\n      }\n      lastCellFormat=screenCellData[row][col];\n      if (CellFormat.getBackgroundOpacity(lastCellFormat) == DTVCCOpacity.TRANSPARENT && screenData[row][col] == 0) {\n        lastCellFormat=CellFormat.setForeground(lastCellFormat,(byte)CellFormat.getForeground(lastCellFormat),DTVCCOpacity.TRANSPARENT);\n      }\n      if (CellFormat.getBackgroundOpacity(lastCellFormat) == DTVCCOpacity.TRANSPARENT && (CellFormat.getForegroundOpacity(lastCellFormat) == DTVCCOpacity.TRANSPARENT || screenData[row][col] == 0)) {\n        textOffset+=charWidth;\n      }\n else       if (screenData[row][col] != 0) {\n        if (rowOffsets[row] == -1) {\n          rowOffsets[row]=col;\n        }\n        sb.append(screenData[row][col]);\n      }\n else {\n        sb.append(' ');\n      }\n    }\n    if (sb.length() > 0) {\n      if (CellFormat.getForegroundOpacity(lastCellFormat) != DTVCCOpacity.TRANSPARENT || CellFormat.getBackgroundOpacity(lastCellFormat) != DTVCCOpacity.TRANSPARENT) {\n        render708ops(screenData,screenCellData,clipRect,alphaFactor,xoff,yoff,rowHeight,currY,charWidth,currX,sb,lastCellFormat,rowStartY,textOffset,lastRenderedCol,row,maxCols);\n      }\n    }\n    sb.setLength(0);\n  }\n  for (  List<RenderingOp> ops : cached708WindowOps) {\n    cachedRenderOps.addAll(ops);\n  }\n}\n", "nl": "Render the 708 caption text to the screen. BIG NOTE(codefu): This wont draw perfectly square boxes with text on it. e.g.: back-filled with black, 2 rows, 32 columns.  Text on second row \"testing\" will produce and image that is stepped.  If we want to draw squares, we need to track the widest character from any font/size that is used."}
{"code": "public static void putbytes2Uint8s(char[] destUint8s,byte[] srcBytes,int destOffset,int srcOffset,int count){\n  for (int i=0; i < count; i++) {\n    destUint8s[destOffset + i]=convertByte2Uint8(srcBytes[srcOffset + i]);\n  }\n}\n", "nl": "Put byte[] into char[]( we treat char[] as uint8[])"}
{"code": "public static void superposeWithAngle(ComplexVector vec1,ComplexVector vec2,float weight,int[] permutation){\n  int positionToAdd;\n  int dim=vec1.getDimension();\n  short c[]=vec2.getPhaseAngles();\n  float[] coordinates=vec1.getCoordinates();\n  if (permutation != null) {\n    for (int i=0; i < dim; i++) {\n      positionToAdd=permutation[i] << 1;\n      coordinates[positionToAdd]+=CircleLookupTable.getRealEntry(c[i]) * weight;\n      coordinates[positionToAdd + 1]+=CircleLookupTable.getImagEntry(c[i]) * weight;\n    }\n  }\n else {\n    for (int i=0; i < dim; i++) {\n      positionToAdd=i << 1;\n      coordinates[positionToAdd]+=CircleLookupTable.getRealEntry(c[i]) * weight;\n      coordinates[positionToAdd + 1]+=CircleLookupTable.getImagEntry(c[i]) * weight;\n    }\n  }\n}\n", "nl": "Superposes vec2 with vec1 with weight and permutation. vec1 is in CARTESIAN mode. vec2 is in POLAR mode."}
{"code": "protected void _addFieldMixIns(Class<?> targetClass,Class<?> mixInCls,Map<String,AnnotatedField> fields){\n  List<Class<?>> parents=new ArrayList<Class<?>>();\n  parents.add(mixInCls);\n  ClassUtil.findSuperTypes(mixInCls,targetClass,parents);\n  for (  Class<?> mixin : parents) {\n    for (    Field mixinField : mixin.getDeclaredFields()) {\n      if (!_isIncludableField(mixinField)) {\n        continue;\n      }\n      String name=mixinField.getName();\n      AnnotatedField maskedField=fields.get(name);\n      if (maskedField != null) {\n        for (        Annotation a : mixinField.getDeclaredAnnotations()) {\n          if (_annotationIntrospector.isHandled(a)) {\n            maskedField.addOrOverride(a);\n          }\n        }\n      }\n    }\n  }\n}\n", "nl": "Method called to add field mix-ins from given mix-in class (and its fields) into already collected actual fields (from introspected classes and their super-classes)"}
{"code": "@Override public boolean input(Instance instance) throws Exception {\n  if (getInputFormat() == null) {\n    throw new IllegalStateException(\"No input instance format defined\");\n  }\n  if (m_NewBatch) {\n    resetQueue();\n    m_NewBatch=false;\n  }\n  double[] vals=new double[instance.numAttributes() + 1];\n  for (int i=0; i < instance.numAttributes(); i++) {\n    if (instance.isMissing(i)) {\n      vals[i]=Utils.missingValue();\n    }\n else {\n      vals[i]=instance.value(i);\n    }\n  }\n  m_attributeExpression.evaluateExpression(vals);\n  Instance inst=null;\n  if (instance instanceof SparseInstance) {\n    inst=new SparseInstance(instance.weight(),vals);\n  }\n else {\n    inst=new DenseInstance(instance.weight(),vals);\n  }\n  inst.setDataset(getOutputFormat());\n  copyValues(inst,false,instance.dataset(),getOutputFormat());\n  inst.setDataset(getOutputFormat());\n  push(inst);\n  return true;\n}\n", "nl": "Input an instance for filtering. Ordinarily the instance is processed and made available for output immediately. Some filters require all instances be read before producing output."}
{"code": "public String lookup(String data){\n  Iterator<String> it=map.getPrefixedBy(data);\n  if (!it.hasNext())   return null;\n  return it.next();\n}\n", "nl": "Return the last String in the set that can be prefixed by this String (Trie's are stored in alphabetical order). Return null if no such String exist in the current set."}
{"code": "public boolean attempt(LiveAnalysis live,Register r1,Register r2){\n  if (isLiveAtDef(r2,r1,live))   return false;\n  if (isLiveAtDef(r1,r2,live))   return false;\n  if (split(r1,r2))   return false;\n  if (r1 == r2)   return false;\n  live.merge(r1,r2);\n  for (Enumeration<RegisterOperand> e=DefUse.defs(r2); e.hasMoreElements(); ) {\n    RegisterOperand def=e.nextElement();\n    DefUse.removeDef(def);\n    def.setRegister(r1);\n    DefUse.recordDef(def);\n  }\n  for (Enumeration<RegisterOperand> e=DefUse.uses(r2); e.hasMoreElements(); ) {\n    RegisterOperand use=e.nextElement();\n    DefUse.removeUse(use);\n    use.setRegister(r1);\n    DefUse.recordUse(use);\n  }\n  return true;\n}\n", "nl": "Attempt to coalesce register r2 into register r1.  If this is legal, <ul> <li> rewrite all defs and uses of r2 as defs and uses of r1 <li> update the liveness information <li> update the def-use chains </ul> <strong>PRECONDITION </strong> def-use chains must be computed and valid."}
{"code": "private void registerTarget(final Message message,final String virtualHost){\n  final String thingId=getStringHeaderKey(message,MessageHeaderKey.THING_ID,\"ThingId is null\");\n  final String replyTo=message.getMessageProperties().getReplyTo();\n  if (StringUtils.isEmpty(replyTo)) {\n    logAndThrowMessageError(message,\"No ReplyTo was set for the createThing Event.\");\n  }\n  final URI amqpUri=IpUtil.createAmqpUri(virtualHost,replyTo);\n  final Target target=controllerManagement.findOrRegisterTargetIfItDoesNotexist(thingId,amqpUri);\n  LOG.debug(\"Target {} reported online state.\",thingId);\n  lookIfUpdateAvailable(target);\n}\n", "nl": "Method to create a new target or to find the target if it already exists."}
{"code": "private void returnData(Object ret){\n  if (myHost != null) {\n    myHost.returnData(ret);\n  }\n}\n", "nl": "Used to communicate a return object from a plugin tool to the main Whitebox user-interface."}
{"code": "public long term(){\n  return term;\n}\n", "nl": "Returns the responding node's current term."}
{"code": "public void purgePlayer(Player player){\n  zombies.remove(player.getUniqueId());\n  humans.remove(player.getUniqueId());\n}\n", "nl": "Removes the player from the current ADTs."}
{"code": "public RestClient(String target,String username,String password,CloseableHttpAsyncClient asyncClient){\n  checkNotNull(target,\"target cannot be null\");\n  checkNotNull(username,\"username cannot be null\");\n  checkNotNull(password,\"password cannot be null\");\n  this.target=target;\n  this.clientContext=getHttpClientContext(target,username,password);\n  this.asyncClient=asyncClient == null ? getHttpClient() : asyncClient;\n}\n", "nl": "Constructs a RestClient."}
{"code": "private String createPatternHash(int baseColorIndex){\n  String hashSource=\"\" + baseColorIndex + \"\";\n  int count=0;\nsynchronized (PatternList) {\n    for (    BannerPattern bp : PatternList) {\n      if (count++ != 0) {\n        hashSource+=\"-\";\n      }\n      hashSource+=bp.toString();\n    }\n  }\n  return hashSource;\n}\n", "nl": "Creates a uniq string for combination of patterns"}
{"code": "public void close() throws IOException {\n  super.close();\n  disposerRecord.dispose();\n  stream=null;\n  cache=null;\n  cacheFile=null;\n  StreamCloser.removeFromQueue(closeAction);\n}\n", "nl": "Closes this <code>FileCacheImageInputStream</code>, closing and removing the cache file.  The source <code>InputStream</code> is not closed."}
{"code": "public static Uri importContent(String sessionId,String sourcePath) throws IOException {\n  File sourceFile=new File(sourcePath);\n  String targetPath=\"/\" + sessionId + \"/upload/\"+ sourceFile.getName();\n  targetPath=createUniqueFilename(targetPath);\n  copyToVfs(sourcePath,targetPath);\n  return vfsUri(targetPath);\n}\n", "nl": "Copy device content into vfs. All imported content is stored under /SESSION_NAME/ The original full path is retained to facilitate browsing The session content can be deleted when the session is over"}
{"code": "public static ProjectActionEvent createProjectClosedEvent(ProjectDescriptor project,boolean closingBeforeOpening){\n  return new ProjectActionEvent(project,ProjectAction.CLOSED,closingBeforeOpening);\n}\n", "nl": "Creates a Project Closed Event."}
{"code": "public static void initiateItemEvent(EntityPlayer player,ItemStack itemStack,int event,boolean limitRange){\n  try {\n    if (NetworkManager_initiateItemEvent == null)     NetworkManager_initiateItemEvent=Class.forName(getPackage() + \".core.network.NetworkManager\").getMethod(\"initiateItemEvent\",EntityPlayer.class,ItemStack.class,Integer.TYPE,Boolean.TYPE);\n    if (instance == null)     instance=getInstance();\n    NetworkManager_initiateItemEvent.invoke(instance,player,itemStack,event,limitRange);\n  }\n catch (  Exception e) {\n    throw new RuntimeException(e);\n  }\n}\n", "nl": "Immediately send an event for the specified Item to the clients in range. The item should implement INetworkItemEventListener to receive the event. If this method is being executed on the client (i.e. Singleplayer), it'll just call INetworkItemEventListener.onNetworkEvent (if implemented by the item)."}
{"code": "public Enumeration<V> elements(){\n  return new ValueIterator();\n}\n", "nl": "Returns an enumeration of the values in this table."}
{"code": "private boolean trackerAt(StendhalRPZone zone,int x,int y){\n  final List<Entity> list=zone.getEntitiesAt(x,y);\n  for (  Entity entity : list) {\n    if (entity instanceof ExpirationTracker) {\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "Checks to see if an ExpirationTracker is already at a given coordinate to prevent multiple one from accumulating in the database"}
{"code": "public Segment segment(long index){\n  assertOpen();\n  if (currentSegment != null && currentSegment.validIndex(index))   return currentSegment;\n  Map.Entry<Long,Segment> segment=segments.floorEntry(index);\n  return segment != null ? segment.getValue() : null;\n}\n", "nl": "Returns the segment for the given index."}
{"code": "@DSSafe(DSCat.SAFE_LIST) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2014-09-03 15:01:20.138 -0400\",hash_original_method=\"5CC57CD7C5B9408E54C315A9BE16050C\",hash_generated_method=\"E0C143C4A578FB33A41B66D46278449D\") public int nextInt(int least,int bound){\n  if (least >= bound)   throw new IllegalArgumentException();\n  return nextInt(bound - least) + least;\n}\n", "nl": "Returns a pseudorandom, uniformly distributed value between the given least value (inclusive) and bound (exclusive)."}
{"code": "protected ECPoint multiplyPositive(ECPoint p,BigInteger k){\n  ECPoint[] R=new ECPoint[]{p.getCurve().getInfinity(),p};\n  int n=k.bitLength();\n  for (int i=0; i < n; ++i) {\n    int b=k.testBit(i) ? 1 : 0;\n    int bp=1 - b;\n    R[bp]=R[bp].twicePlus(R[b]);\n  }\n  return R[0];\n}\n", "nl": "Joye's double-add algorithm."}
{"code": "void listItemsSortedSecure() throws Exception {\n  System.out.println(\"Secure Systems Inc. - list items\");\n  String order=input(\"order (id, name)?\");\n  if (!order.matches(\"[a-zA-Z0-9_]*\")) {\n    order=\"id\";\n  }\n  try {\n    ResultSet rs=stat.executeQuery(\"SELECT ID, NAME FROM ITEMS ORDER BY \" + order);\n    while (rs.next()) {\n      System.out.println(rs.getString(1) + \": \" + rs.getString(2));\n    }\n  }\n catch (  SQLException e) {\n    System.out.println(e);\n  }\n}\n", "nl": "List items using a specified sort order. The method is secure as the user input is validated before use. However the database has no chance to verify this."}
{"code": "private int readInt(InputStream is) throws IOException {\n  return ((is.read() << 24) | (is.read() << 16) | (is.read() << 8)| (is.read()));\n}\n", "nl": "Parses a 32-bit int."}
{"code": "void enableConfirmButtons(){\n  confirmChangesButton.setToolTipText(SymbolicProgBundle.getMessage(\"TipConfirmChangesSheet\"));\n  confirmAllButton.setToolTipText(SymbolicProgBundle.getMessage(\"TipConfirmAllSheet\"));\n  if (_cvModel.getProgrammer() != null && !_cvModel.getProgrammer().getCanRead()) {\n    confirmChangesButton.setEnabled(false);\n    confirmAllButton.setEnabled(false);\n    confirmChangesButton.setToolTipText(SymbolicProgBundle.getMessage(\"TipNoRead\"));\n    confirmAllButton.setToolTipText(SymbolicProgBundle.getMessage(\"TipNoRead\"));\n  }\n else {\n    confirmChangesButton.setEnabled(true);\n    confirmAllButton.setEnabled(true);\n  }\n}\n", "nl": "Enable the compare all and compare changes button if possible. This checks to make sure this is appropriate, given the attached programmer's capability."}
{"code": "private String eventName(String taskType,int taskNum,String evtType){\n  assert nodeId != null;\n  return taskType + \" \" + taskNum+ \" \"+ evtType+ \" \"+ nodeId;\n}\n", "nl": "Generate name that consists of some event information."}
{"code": "@Override public NotificationChain eInverseRemove(InternalEObject otherEnd,int featureID,NotificationChain msgs){\nswitch (featureID) {\ncase UmplePackage.ACTION___ANONYMOUS_ACTION_11:\n    return ((InternalEList<?>)getAnonymous_action_1_1()).basicRemove(otherEnd,msgs);\ncase UmplePackage.ACTION___ANONYMOUS_ACTION_21:\n  return ((InternalEList<?>)getAnonymous_action_2_1()).basicRemove(otherEnd,msgs);\n}\nreturn super.eInverseRemove(otherEnd,featureID,msgs);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public static void showPathInFileBrowser(final Path path){\n  try {\n    final boolean isFolder=Files.isDirectory(path);\n    final boolean isFile=!isFolder;\n    if (isFile && LEnv.OS == OpSys.WINDOWS) {\n      new ProcessBuilder(\"explorer.exe\",\"/select,\",path.toAbsolutePath().toString()).start();\n    }\n else     Desktop.getDesktop().open(isFolder ? path.toFile() : path.getParent().toFile());\n  }\n catch (  final IOException ie) {\n    LEnv.LOGGER.warning(\"Failed to open file browser!\",ie);\n  }\n}\n", "nl": "Opens the specified file or folder in the default file browser application of the user's OS. <p> If a file is specified, on Windows it will also be selected. </p>"}
{"code": "private <T>T processExtremes(Stamp forX,Stamp forY,BiFunction<Long,Long,T> op){\n  IntegerStamp xStamp=(IntegerStamp)forX;\n  IntegerStamp yStamp=(IntegerStamp)forY;\n  JavaKind kind=getStackKind();\n  assert kind == JavaKind.Int || kind == JavaKind.Long;\n  long[] xExtremes=getUnsignedExtremes(xStamp);\n  long[] yExtremes=getUnsignedExtremes(yStamp);\n  long min=Long.MAX_VALUE;\n  long max=Long.MIN_VALUE;\n  for (  long a : xExtremes) {\n    for (    long b : yExtremes) {\n      long result=kind == JavaKind.Int ? multiplyHighUnsigned((int)a,(int)b) : multiplyHighUnsigned(a,b);\n      min=Math.min(min,result);\n      max=Math.max(max,result);\n    }\n  }\n  return op.apply(min,max);\n}\n", "nl": "Determines the minimum and maximum result of this node for the given inputs and returns the result of the given BiFunction on the minimum and maximum values. Note that the minima and maxima are calculated using signed min/max functions, while the values themselves are unsigned."}
{"code": "public String toSignatureString(){\n  StringBuilder sb=new StringBuilder();\n  String accessLevel=convertModifiersToAccessLevel(mModifier);\n  if (!\"\".equals(accessLevel)) {\n    sb.append(accessLevel).append(\" \");\n  }\n  if (!JDiffType.INTERFACE.equals(mClassType)) {\n    String modifierString=convertModifersToModifierString(mModifier);\n    if (!\"\".equals(modifierString)) {\n      sb.append(modifierString).append(\" \");\n    }\n    sb.append(\"class \");\n  }\n else {\n    sb.append(\"interface \");\n  }\n  sb.append(mShortClassName);\n  if (mExtendedClass != null) {\n    sb.append(\" extends \").append(mExtendedClass).append(\" \");\n  }\n  if (implInterfaces.size() > 0) {\n    sb.append(\" implements \");\n    for (int x=0; x < implInterfaces.size(); x++) {\n      String interf=implInterfaces.get(x);\n      sb.append(interf);\n      if (x + 1 != implInterfaces.size()) {\n        sb.append(\", \");\n      }\n    }\n  }\n  return sb.toString();\n}\n", "nl": "Convert the class into a printable signature string."}
{"code": "public void showPopup(){\n  if (getPopup() != null) {\n    getPopup().setVisible(true);\n  }\n}\n", "nl": "if a JPopupMenu is set, it is displayed again. Displaying this dialog closes any JPopupMenu automatically."}
{"code": "public boolean isGame(){\n  return true;\n}\n", "nl": "Determines if this marker is a game. Default is true, so override is only necessary if implementation is not a game."}
{"code": "private FigureLayerComparator(){\n}\n", "nl": "Creates a new instance."}
{"code": "public TDoubleDoubleHashMap normalizedDistribution(){\n  return normalizedDistribution(absoluteDistribution());\n}\n", "nl": "Returns a histogram of all samples where the values are normalized so that the sum of all samples equals one."}
{"code": "private void waitForUsers(URI hostUri,String authToken) throws Throwable {\n  URI usersLink=UriUtils.buildUri(hostUri,UserService.FACTORY_LINK);\n  Integer[] numberUsers=new Integer[1];\n  for (int i=0; i < 20; i++) {\n    Operation get=Operation.createGet(usersLink).forceRemote().addRequestHeader(Operation.REQUEST_AUTH_TOKEN_HEADER,authToken).setCompletion(null);\n    this.host.testStart(1);\n    this.host.send(get);\n    this.host.testWait();\n    if (numberUsers[0] == 2) {\n      break;\n    }\n    Thread.sleep(250);\n  }\n  assertTrue(numberUsers[0] == 2);\n}\n", "nl": "Supports createUsers() by waiting for two users to be created. They aren't created immediately, so this polls."}
{"code": "public synchronized int send(byte[] buffer,int offset,int len) throws IOException {\n  if (m_state != PseudoTcpState.TCP_ESTABLISHED) {\n    throw new IOException(\"Socket not connected\");\n  }\n  long available_space;\n  available_space=m_sbuf.getWriteRemaining();\n  if (available_space == 0) {\n    m_bWriteEnable=true;\n    return 0;\n  }\n  int written=queue(buffer,offset,len,false);\n  attemptSend(SendFlags.sfNone);\n  return written;\n}\n", "nl": "Enqueues data in the send buffer"}
{"code": "public SampleAxioms(){\n  super();\n}\n", "nl": "De-serialization ctor."}
{"code": "public void validateTagTypeKey(TagTypeKey tagTypeKey) throws IllegalArgumentException {\n  Assert.notNull(tagTypeKey,\"A tag type key must be specified.\");\n  tagTypeKey.setTagTypeCode(alternateKeyHelper.validateStringParameter(\"tag type code\",tagTypeKey.getTagTypeCode()));\n}\n", "nl": "Validates a tag type key. This method also trims the key parameters."}
{"code": "public static BigInteger nextPrime(long n){\n  long i;\n  boolean found=false;\n  long result=0;\n  if (n <= 1) {\n    return BigInteger.valueOf(2);\n  }\n  if (n == 2) {\n    return BigInteger.valueOf(3);\n  }\n  for (i=n + 1 + (n & 1); (i <= n << 1) && !found; i+=2) {\n    for (long j=3; (j <= i >> 1) && !found; j+=2) {\n      if (i % j == 0) {\n        found=true;\n      }\n    }\n    if (found) {\n      found=false;\n    }\n else {\n      result=i;\n      found=true;\n    }\n  }\n  return BigInteger.valueOf(result);\n}\n", "nl": "Computes the next prime greater than n."}
{"code": "@Override public void addCharacterToOutput(final Entry<Character,GrayscaleMatrix> characterEntry,final int[] sourceImagePixels,final int tileX,final int tileY,final int imageWidth){\n  this.output.append(characterEntry.getKey());\n  if ((tileX + 1) * this.characterCache.getCharacterImageSize().getWidth() == imageWidth) {\n    this.output.append(System.lineSeparator());\n  }\n}\n", "nl": "Append choosen character to StringBuffer."}
{"code": "@VisibleForTesting static int chooseTableSize(int setSize){\n  if (setSize == 1) {\n    return 2;\n  }\n  int tableSize=Integer.highestOneBit(setSize - 1) << 1;\n  while (tableSize * DESIRED_LOAD_FACTOR < setSize) {\n    tableSize<<=1;\n  }\n  return tableSize;\n}\n", "nl": "Returns an array size suitable for the backing array of a hash table that uses open addressing with linear probing in its implementation. The returned size is the smallest power of two that can hold setSize elements with the desired load factor."}
{"code": "public void validateMinimum(){\n  double newMin;\n  try {\n    newMin=Double.parseDouble(this.minimumRangeValue.getText());\n    if (newMin >= this.maximumValue) {\n      newMin=this.minimumValue;\n    }\n  }\n catch (  NumberFormatException e) {\n    newMin=this.minimumValue;\n  }\n  this.minimumValue=newMin;\n  this.minimumRangeValue.setText(Double.toString(this.minimumValue));\n}\n", "nl": "Revalidate the range minimum."}
{"code": "public static void init(ActorSystem actorSystem){\n  if (instance == null) {\n    instance=actorSystem.actorOf(Props.create(BatchSigner.class));\n  }\n}\n", "nl": "Initializes the batch signer with the given actor system."}
{"code": "private static void dump(PrintData pd){\n  dumpHeader(pd);\n  for (int i=0; i < pd.getRowCount(); i++)   dumpRow(pd,i);\n}\n", "nl": "Dump all PrintData - header and rows"}
{"code": "public boolean isHIGHER(){\n  return value == HIGHER;\n}\n", "nl": "Is the condition code HIGHER?"}
{"code": "public Matrix4x3d rotateZ(double ang){\n  return rotateZ(ang,this);\n}\n", "nl": "Apply rotation about the Z axis to this matrix by rotating the given amount of radians. <p> When used with a right-handed coordinate system, the produced rotation will rotate a vector  counter-clockwise around the rotation axis, when viewing along the negative axis direction towards the origin. When used with a left-handed coordinate system, the rotation is clockwise. <p> If <code>M</code> is <code>this</code> matrix and <code>R</code> the rotation matrix, then the new matrix will be <code>M * R</code>. So when transforming a vector <code>v</code> with the new matrix by using <code>M * R * v</code>, the rotation will be applied first! <p> Reference: <a href=\"http://en.wikipedia.org/wiki/Rotation_matrix#Basic_rotations\">http://en.wikipedia.org</a>"}
{"code": "@Override protected URLConnection openConnection(URL url,Proxy proxy) throws IOException {\n  if (url == null || proxy == null) {\n    throw new IllegalArgumentException(\"url == null || proxy == null\");\n  }\n  return new FtpURLConnection(url,proxy);\n}\n", "nl": "Returns a connection, which is established via the <code>proxy</code>, to the FTP server specified by this <code>URL</code>. If <code>proxy</code> is DIRECT type, the connection is made in normal way."}
{"code": "private boolean saveMacro(){\n  if (firstTime) {\n    try {\n      Thread.sleep(firstTimeSleep);\n    }\n catch (    InterruptedException e) {\n      e.printStackTrace();\n    }\n  }\n  firstTime=false;\n  byte[] macroAccy=new byte[macroSize];\n  int index=0;\n  int accyNum=0;\n  accyNum=getAccyRow(macroAccy,index,textAccy1,accyTextField1,cmdButton1);\n  if (accyNum < 0) {\n    return false;\n  }\n  if (accyNum > 0) {\n    index+=2;\n  }\n  accyNum=getAccyRow(macroAccy,index,textAccy2,accyTextField2,cmdButton2);\n  if (accyNum < 0) {\n    return false;\n  }\n  if (accyNum > 0) {\n    index+=2;\n  }\n  accyNum=getAccyRow(macroAccy,index,textAccy3,accyTextField3,cmdButton3);\n  if (accyNum < 0) {\n    return false;\n  }\n  if (accyNum > 0) {\n    index+=2;\n  }\n  accyNum=getAccyRow(macroAccy,index,textAccy4,accyTextField4,cmdButton4);\n  if (accyNum < 0) {\n    return false;\n  }\n  if (accyNum > 0) {\n    index+=2;\n  }\n  accyNum=getAccyRow(macroAccy,index,textAccy5,accyTextField5,cmdButton5);\n  if (accyNum < 0) {\n    return false;\n  }\n  if (accyNum > 0) {\n    index+=2;\n  }\n  accyNum=getAccyRow(macroAccy,index,textAccy6,accyTextField6,cmdButton6);\n  if (accyNum < 0) {\n    return false;\n  }\n  if (accyNum > 0) {\n    index+=2;\n  }\n  accyNum=getAccyRow(macroAccy,index,textAccy7,accyTextField7,cmdButton7);\n  if (accyNum < 0) {\n    return false;\n  }\n  if (accyNum > 0) {\n    index+=2;\n  }\n  if (!isUsb) {\n    accyNum=getAccyRow(macroAccy,index,textAccy8,accyTextField8,cmdButton8);\n    if (accyNum < 0) {\n      return false;\n    }\n    if (accyNum > 0) {\n      index+=2;\n    }\n    accyNum=getAccyRow(macroAccy,index,textAccy9,accyTextField9,cmdButton9);\n    if (accyNum < 0) {\n      return false;\n    }\n    if (accyNum > 0) {\n      index+=2;\n    }\n  }\n  accyNum=getAccyRow(macroAccy,index,textAccy10,accyTextField10,cmdButton10);\n  if (accyNum < 0) {\n    JOptionPane.showMessageDialog(this,rb.getString(\"EnterMacroNumberLine10\"),rb.getString(\"NceMacro\"),JOptionPane.ERROR_MESSAGE);\n    return false;\n  }\n  processMemory(false,true,macroNum,macroAccy);\n  return true;\n}\n", "nl": "Writes all bytes to NCE CS memory as long as there are no user input errors"}
{"code": "private boolean matchesMobile4g(NetworkIdentity ident){\n  ensureSubtypeAvailable();\n  if (ident.mType == TYPE_WIMAX) {\n    return true;\n  }\n else   if (matchesMobile(ident)) {\nswitch (getNetworkClass(ident.mSubType)) {\ncase NETWORK_CLASS_4_G:\n      return true;\n  }\n}\nreturn false;\n}\n", "nl": "Check if mobile network classified 4G with matching IMSI."}
{"code": "public void writeToBuffer(ByteBuf buffer) throws Exception {\n  if (id != -1) {\n    Type.VAR_INT.write(buffer,id);\n  }\n  if (readableObjects.size() > 0) {\n    packetValues.addAll(readableObjects);\n    readableObjects.clear();\n  }\n  int index=0;\n  for (  Pair<Type,Object> packetValue : packetValues) {\n    try {\n      Object value=packetValue.getValue();\n      if (value != null) {\n        if (!packetValue.getKey().getOutputClass().isAssignableFrom(value.getClass())) {\n          if (packetValue.getKey() instanceof TypeConverter) {\n            value=((TypeConverter)packetValue.getKey()).from(value);\n          }\n else {\n            System.out.println(\"Possible type mismatch: \" + value.getClass().getName() + \" -> \"+ packetValue.getKey().getOutputClass());\n          }\n        }\n      }\n      packetValue.getKey().write(buffer,value);\n    }\n catch (    Exception e) {\n      throw new InformativeException(e).set(\"Index\",index).set(\"Type\",packetValue.getKey().getTypeName()).set(\"Packet ID\",getId()).set(\"Data\",packetValues);\n    }\n    index++;\n  }\n  writeRemaining(buffer);\n}\n", "nl": "Write the current output to a buffer."}
{"code": "public RandomDecisionTree(int numFeatures,int maxDepth,int minSamples,TreePruner.PruningMethod pruningMethod,double testProportion){\n  super(maxDepth,minSamples,pruningMethod,testProportion);\n  setRandomFeatureCount(numFeatures);\n}\n", "nl": "Creates a new Random Decision Tree"}
{"code": "protected void fireCommentEvent(char[] chars,int start,int length) throws org.xml.sax.SAXException {\n  if (m_tracer != null) {\n    flushMyWriter();\n    m_tracer.fireGenerateEvent(SerializerTrace.EVENTTYPE_COMMENT,new String(chars,start,length));\n  }\n}\n", "nl": "Report the comment trace event"}
{"code": "private void init(Context context,AttributeSet attrs,RuqusTheme theme){\n  inflate(context,R.layout.rqv_card,this);\n  outlineView=(FrameLayout)findViewById(R.id.outline);\n  outlineTextView=(TextView)findViewById(R.id.outline_text);\n  cardView=(CardView)findViewById(R.id.card);\n  cardTextView=(TextView)findViewById(R.id.card_text);\n  setTheme(theme);\n  TypedArray typedArray=context.obtainStyledAttributes(attrs,R.styleable.RQVCard);\n  mode=typedArray.getInt(R.styleable.RQVCard_rqv_card_mode,0) == 0 ? Mode.OUTLINE : Mode.CARD;\n  outlineTextView.setText(typedArray.getString(R.styleable.RQVCard_rqv_outline_text));\n  cardTextView.setText(typedArray.getString(R.styleable.RQVCard_rqv_card_text));\n  typedArray.recycle();\n}\n", "nl": "Initialize our view."}
{"code": "public void onUndeploy(ClassLoader ldr){\n  for (  Class<?> cls : descByCls.keySet()) {\n    if (ldr.equals(cls.getClassLoader()))     descByCls.remove(cls);\n  }\n  U.clearClassCache(ldr);\n}\n", "nl": "Undeployment callback invoked when class loader is being undeployed. Some marshallers may want to clean their internal state that uses the undeployed class loader somehow."}
{"code": "@Override public int compare(final Long o1,final Long o2){\n  if (o1.longValue() < o2.longValue())   return 1;\n  if (o1.longValue() > o2.longValue())   return -1;\n  return 0;\n}\n", "nl": "Comparator puts the entries into descending order by the query execution time (longest running queries are first)."}
{"code": "public void testResourceParameterOfListType(){\n  doTest();\n}\n", "nl": "Tests that a ResourceParameterInspection error is generated for a resource parameter of List type."}
{"code": "public TeXFormula add(String s) throws ParseException {\n  if (s != null && s.length() != 0) {\n    textStyle=null;\n    add(new TeXFormula(s));\n  }\n  return this;\n}\n", "nl": "Parses the given string and inserts the resulting formula at the end of the current TeXFormula."}
{"code": "public ResponseEntity<List<Recommendation>> defaultRecommendations(int productId){\n  LOG.warn(\"Using fallback method for recommendation-service\");\n  return util.createResponse(Arrays.asList(new Recommendation(productId,1,\"Fallback Author 1\",1,\"Fallback Content 1\")),HttpStatus.OK);\n}\n", "nl": "Fallback method for getRecommendations()"}
{"code": "private void cmd_annotateDifference(){\n  BigDecimal previousValue, actualValue, difference;\n  previousValue=(BigDecimal)v_previousBalance.getValue();\n  actualValue=(BigDecimal)v_ActualBalance.getValue();\n  difference=actualValue.subtract(previousValue);\n  MCashBook cashBook=new MCashBook(p_ctx,p_pos.getC_CashBook_ID(),null);\n  Timestamp today=TimeUtil.getDay(System.currentTimeMillis());\n  MCash cash=MCash.get(p_ctx,cashBook.getC_CashBook_ID(),today,null);\n  if (cash != null && cash.get_ID() != 0 && difference.compareTo(cash.getStatementDifference()) != 0) {\n    MCashLine cl=new MCashLine(cash);\n    cl.setCashType(MCashLine.CASHTYPE_Difference);\n    cl.setAmount(difference);\n    cl.setDescription(Msg.translate(p_pos.getCtx(),\"Cash Scrutiny -> Before: \") + previousValue + \" Now: \"+ actualValue);\n    cl.saveEx();\n  }\n  cash=MCash.get(p_pos.getCtx(),p_pos.getC_CashBook_ID(),today,null);\n  v_previousBalance.setValue(cash.getEndingBalance());\n  v_ActualBalance.setValue(Env.ZERO);\n  v_difference.setValue(Env.ZERO);\n}\n", "nl": "Annotate the difference between previous balance and actual from cash scrutiny in the cash book"}
{"code": "public boolean hasJpgThumbnail(){\n  if (getThumbnailType() != ExifDirectory.COMPRESSION_JPEG)   return false;\n  byte[] thumbData;\n  try {\n    ExifDirectory exif=(ExifDirectory)metadata.getDirectory(ExifDirectory.class);\n    thumbData=exif.getThumbnailData();\n  }\n catch (  MetadataException e) {\n    return false;\n  }\n  if (thumbData.length > 2) {\n    int magicNumber;\n    magicNumber=(thumbData[0] & 0xFF) << 8;\n    magicNumber|=(thumbData[1] & 0xFF);\n    if (magicNumber == ImageMetadataReader.JPEG_FILE_MAGIC_NUMBER)     return true;\n  }\n  return false;\n}\n", "nl": "Performs checks to determine if the image has a JPG thumbnail in the EXIF data. <p> The EXIF TAG_COMPRESION , and the magic number at the beginning of the thumbnail bytes are used to verify that the thumb is in JPG format"}
{"code": "private void waitForRScriptInitialized() throws InterpreterException {\nsynchronized (rScriptInitializeNotifier) {\n    long startTime=System.nanoTime();\n    while (rScriptInitialized == false && rScriptRunning && System.nanoTime() - startTime < 10L * 1000 * 1000000) {\n      try {\n        rScriptInitializeNotifier.wait(1000);\n      }\n catch (      InterruptedException e) {\n        logger.error(e.getMessage(),e);\n      }\n    }\n  }\n  String errorMessage=\"\";\n  try {\n    initialOutput.flush();\n    errorMessage=new String(initialOutput.toByteArray());\n  }\n catch (  IOException e) {\n    e.printStackTrace();\n  }\n  if (rScriptInitialized == false) {\n    throw new InterpreterException(\"sparkr is not responding \" + errorMessage);\n  }\n}\n", "nl": "Wait until src/main/resources/R/zeppelin_sparkr.R is initialized and call onScriptInitialized()"}
{"code": "private DefaultUnitConverter(){\n}\n", "nl": "Constructs a DefaultUnitConverter and registers a listener that handles changes in the look&amp;feel."}
{"code": "public static String morpha(String text,boolean tags){\n  if (text.isEmpty()) {\n    return \"\";\n  }\n  String[] textParts=whitespace.split(text);\n  StringBuilder result=new StringBuilder();\n  try {\n    for (    String textPart : textParts) {\n      Morpha morpha=new Morpha(new StringReader(textPart),tags);\n      if (result.length() != 0) {\n        result.append(\" \");\n      }\n      result.append(morpha.next());\n    }\n  }\n catch (  Error e) {\n    return text;\n  }\ncatch (  java.io.IOException e) {\n    return text;\n  }\n  return result.toString();\n}\n", "nl": "Run the morpha algorithm on the specified string."}
{"code": "protected void readUnzipedResponse(InputStream input) throws IOException {\n  super.readResponse(input);\n}\n", "nl": "This method can be overridden instead of readResponse"}
{"code": "public EventStream<S> events() throws Exception {\n  return EventStream.empty();\n}\n", "nl": "Returns a stream of events that should be recorded. By default, an empty stream returned."}
{"code": "public Object invoke(Remote obj,java.lang.reflect.Method method,Object[] params,long opnum) throws Exception {\n  boolean force=false;\n  RemoteRef localRef;\n  Exception exception=null;\nsynchronized (this) {\n    if (ref == null) {\n      localRef=activate(force);\n      force=true;\n    }\n else {\n      localRef=ref;\n    }\n  }\n  for (int retries=MAX_RETRIES; retries > 0; retries--) {\n    try {\n      return localRef.invoke(obj,method,params,opnum);\n    }\n catch (    NoSuchObjectException e) {\n      exception=e;\n    }\ncatch (    ConnectException e) {\n      exception=e;\n    }\ncatch (    UnknownHostException e) {\n      exception=e;\n    }\ncatch (    ConnectIOException e) {\n      exception=e;\n    }\ncatch (    MarshalException e) {\n      throw e;\n    }\ncatch (    ServerError e) {\n      throw e;\n    }\ncatch (    ServerException e) {\n      throw e;\n    }\ncatch (    RemoteException e) {\nsynchronized (this) {\n        if (localRef == ref) {\n          ref=null;\n        }\n      }\n      throw e;\n    }\n    if (retries > 1) {\nsynchronized (this) {\n        if (localRef.remoteEquals(ref) || ref == null) {\n          RemoteRef newRef=activate(force);\n          if (newRef.remoteEquals(localRef) && exception instanceof NoSuchObjectException && force == false) {\n            newRef=activate(true);\n          }\n          localRef=newRef;\n          force=true;\n        }\n else {\n          localRef=ref;\n          force=false;\n        }\n      }\n    }\n  }\n  throw exception;\n}\n", "nl": "Invoke method on remote object. This method delegates remote method invocation to the underlying ref type.  If the underlying reference is not known (is null), then the object must be activated first.  If an attempt at method invocation fails, the object should force reactivation.  Method invocation must preserve \"at most once\" call semantics.  In RMI, \"at most once\" applies to parameter deserialization at the remote site and the remote object's method execution.  \"At most once\" does not apply to parameter serialization at the client so the parameters of a call don't need to be buffered in anticipation of call retry. Thus, a method call is only be retried if the initial method invocation does not execute at all at the server (including parameter deserialization)."}
{"code": "public String lookupCacheSizeTipText(){\n  return \"Set the maximum size of the lookup cache of evaluated subsets. This is \" + \"expressed as a multiplier of the number of attributes in the data set. \" + \"(default = 1).\";\n}\n", "nl": "Returns the tip text for this property"}
{"code": "private SimpleObject providerToJson(Provider provider){\n  SimpleObject jsonForm=new SimpleObject();\n  if (provider != null) {\n    jsonForm.add(USER_ID,provider.getUuid());\n    jsonForm.add(FULL_NAME,provider.getName());\n    Person person=provider.getPerson();\n    if (person != null) {\n      jsonForm.add(GIVEN_NAME,person.getGivenName());\n      jsonForm.add(FAMILY_NAME,person.getFamilyName());\n    }\n  }\n  return jsonForm;\n}\n", "nl": "Builds a SimpleObject describing the given Provider."}
{"code": "@Override public int next() throws XMLStreamException {\n  log.fine(\"next()\");\n  if (event == START_DOCUMENT) {\n    event=START_ELEMENT;\n    elementIndex.currentElement=parser.getDocument().getBody().getElement();\n  }\n else   if (event == START_ELEMENT) {\n    elementIndex.index=0;\n    event=nextInElement(false);\n  }\n else   if (event == ATTRIBUTE) {\n    elementIndex.index=0;\n    event=nextInElement(false);\n  }\n else   if (event == CHARACTERS) {\n    elementIndex.index++;\n    event=nextInElement(false);\n  }\n else   if (event == SPACE) {\n    elementIndex.index++;\n    event=nextInElement(false);\n  }\n else   if (event == ENTITY_REFERENCE) {\n    elementIndex.index++;\n    event=nextInElement(false);\n  }\n else   if (event == PROCESSING_INSTRUCTION) {\n    elementIndex.index++;\n    event=nextInElement(false);\n  }\n else   if (event == END_ELEMENT) {\n    if (parents.isEmpty()) {\n      event=END_DOCUMENT;\n    }\n else {\n      elementIndex=parents.pop();\n      elementIndex.index++;\n      event=nextInElement(false);\n    }\n  }\n else   if (event == END_DOCUMENT) {\n    throw new XMLStreamException(\"End of coument reached!\");\n  }\n else {\n    throw new XMLStreamException(\"Invalid event state!\");\n  }\n  log.log(Level.FINE,\"next(): {0}\",event);\n  return event;\n}\n", "nl": "Get next parsing event - a processor may return all contiguous character  data in a single chunk, or it may split it into several chunks. If the  property javax.xml.stream.isCoalescing is set to true element content  must be coalesced and only one CHARACTERS event must be returned for  contiguous element content or CDATA Sections. By default entity  references must be expanded and reported transparently to the application.  An exception will be thrown if an entity reference cannot be expanded.  If element content is empty (i.e. content is \"\") then no CHARACTERS  event will be reported. <p>This method marks the current element and index using the elementIndex structure. Besides a queue of parents element index is maintained to cross over all element hierarchy.</p> <p>The WbXMLStreamReader only manages the following states:</p> <ul> <li>START_DOCUMENT</li> <li>PROCESSING_INSTRUCTION</li> <li>START_ELEMENT</li> <li>ATTRIBUTE</li> <lI>CHARACTERS</li> <li>END_ELEMENT</li> <li>SPACE</li> <li>END_DOCUMENT</li> <li>ENTITY_REFERENCE</li> </ul> <p>Therefore the following element does no matter in this stream reader:</p> <ul> <li>CDATA (CHARACTERS are used always).</li> <li>COMMENT (no comments in WBXML).</li> <li>DTD (no DTD section)</li> <li>ENTITY_DECLARATION</li> <li>NAMESPACE</li> <li>NOTATION DECLARATION</li> </ul>"}
{"code": "@SuppressWarnings(\"unchecked\") public synchronized List<Relationship> findAllRelationshipsTo(Vertex vertex){\n  Query query=this.entityManager.createQuery(\"Select r from Relationship r where r.target = :vertex or r.type = :vertex\");\n  setHints(query);\n  query.setParameter(\"vertex\",vertex);\n  return query.getResultList();\n}\n", "nl": "Find all relationships related to the vertex or of the vertex relationship type."}
{"code": "public static String convertMethodSignature(InvokeInstruction inv,ConstantPoolGen cpg){\n  return convertMethodSignature(inv.getClassName(cpg),inv.getName(cpg),inv.getSignature(cpg));\n}\n", "nl": "Convenience method for generating a method signature in human readable form."}
{"code": "@Override public int count(Selector obj){\n  if ((obj.getMask() & Selector.MASK_INSTANCE) > 0) {\n    if (device.findObject(obj.toUiSelector()).exists())     return 1;\n else     return 0;\n  }\n else {\n    UiSelector sel=obj.toUiSelector();\n    if (!device.findObject(sel).exists())     return 0;\n    int low=1;\n    int high=2;\n    sel=sel.instance(high - 1);\n    while (device.findObject(sel).exists()) {\n      low=high;\n      high=high * 2;\n      sel=sel.instance(high - 1);\n    }\n    while (high > low + 1) {\n      int mid=(low + high) / 2;\n      sel=sel.instance(mid - 1);\n      if (device.findObject(sel).exists())       low=mid;\n else       high=mid;\n    }\n    return low;\n  }\n}\n", "nl": "Get the count of the UiObject instances by the selector"}
{"code": "private boolean isComputeHost(ComputeDescription computeDescription){\n  List<String> supportedChildren=computeDescription.supportedChildren;\n  return supportedChildren != null && supportedChildren.contains(ComputeType.VM_GUEST.name());\n}\n", "nl": "Returns if the given compute description is a compute host or not."}
{"code": "public File prepareTestDir(String logDirName) throws Exception {\n  File logDir=new File(logDirName);\n  FilePath path=new FilePath(logDir.getAbsolutePath());\n  fileIO.delete(path,true);\n  fileIO.mkdir(path);\n  return logDir;\n}\n", "nl": "Create an empty test directory or if the directory exists remove any files within it."}
{"code": "public void receiveErrorqueryAssociatedPortsForProcessor(java.lang.Exception e){\n}\n", "nl": "auto generated Axis2 Error handler override this method for handling error response from queryAssociatedPortsForProcessor operation"}
{"code": "@Override public Object clone() throws CloneNotSupportedException {\n  return super.clone();\n}\n", "nl": "Returns a clone of this instance."}
{"code": "private void dump(File from,OutputStream out) throws IOException {\n  writeHeader(from,out);\n  FileInputStream in=null;\n  try {\n    in=new FileInputStream(from);\n    int count;\n    while ((count=in.read(buffer)) != -1) {\n      out.write(buffer,0,count);\n    }\n  }\n  finally {\n    closeQuietly(in);\n  }\n}\n", "nl": "Copies from a file to an output stream."}
{"code": "public static long lastLocalId(){\n  return cntGen.get();\n}\n", "nl": "Gets last generated local ID."}
{"code": "RoleEventImpl(Region region,Operation op,Object callbackArgument,boolean originRemote,DistributedMember distributedMember,Set requiredRoles){\n  super(region,op,callbackArgument,originRemote,distributedMember);\n  this.requiredRoles=Collections.unmodifiableSet(requiredRoles);\n}\n", "nl": "Constructs new RoleEventImpl."}
{"code": "public QLFFilesCollection(File directory,String extension,Class<F> featureClass,String pathRegexFind,String pathRegexRep){\n  this(featureClass,pathRegexFind,pathRegexRep);\n  processDirs(directory,extension);\n}\n", "nl": "Construct the collection from the files in the given directory that have the given file extension. All the files are expected to contain features of the given feature class. The file search is recursive, and will also look in sub-directories of the specified directory. The final two parameters allow a regular-expression find and replace operation for be performed on the found filenames in order to create the document identifier for each QLFDocument. This is useful to ensure only the document name is stored in the index, rather than the absolute path."}
{"code": "public static void main(String[] args) throws IOException {\n  boolean enableOutput=true;\n  boolean outputToFile=false;\n  String inputFolder=LrMc.class.getClassLoader().getResource(\"workload/planetlab\").getPath();\n  String outputFolder=\"output\";\n  String workload=\"20110303\";\n  String vmAllocationPolicy=\"lr\";\n  String vmSelectionPolicy=\"mc\";\n  String parameter=\"1.2\";\n  new PlanetLabRunner(enableOutput,outputToFile,inputFolder,outputFolder,workload,vmAllocationPolicy,vmSelectionPolicy,parameter);\n}\n", "nl": "The main method."}
{"code": "void make(BulkTest bulk){\n  Class c=bulk.getClass();\n  Method[] all=c.getMethods();\n  for (int i=0; i < all.length; i++) {\n    if (isTest(all[i]))     addTest(bulk,all[i]);\n    if (isBulk(all[i]))     addBulk(bulk,all[i]);\n  }\n}\n", "nl": "Appends all the simple tests and bulk tests defined by the given instance's class to the current TestSuite."}
{"code": "private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException {\n  String inName=(String)in.readObject();\n  String inDescription=(String)in.readObject();\n  Object inValue=in.readObject();\n  Class inClass=(Class)in.readObject();\n  boolean inUserModifiable=in.readBoolean();\n  Assert.assertTrue(inName != null);\n  Assert.assertTrue(inDescription != null);\n  Assert.assertTrue(inValue != null);\n  Assert.assertTrue(inClass != null);\n  this.deserialized=true;\n  this.name=inName;\n  setInternalState(inDescription,inValue,inClass,inUserModifiable);\n}\n", "nl": "Override readObject which is used in serialization. Customize serialization of this exception to avoid escape of InternalRole which is not Serializable."}
{"code": "private void returnData(Object ret){\n  if (myHost != null) {\n    myHost.returnData(ret);\n  }\n}\n", "nl": "Used to communicate a return object from a plugin tool to the main Whitebox user-interface."}
{"code": "public static String escape(String s){\n  if (s == null)   return null;\n  StringBuffer sb=new StringBuffer();\n  escape(s,sb);\n  return sb.toString();\n}\n", "nl": "Escape quotes, \\, /, \\r, \\n, \\b, \\f, \\t and other control characters (U+0000 through U+001F)."}
{"code": "public ArrayDeque<E> clone(){\n  try {\n    @SuppressWarnings(\"unchecked\") ArrayDeque<E> result=(ArrayDeque<E>)super.clone();\n    result.elements=Arrays.copyOf(elements,elements.length);\n    return result;\n  }\n catch (  CloneNotSupportedException e) {\n    throw new AssertionError();\n  }\n}\n", "nl": "Returns a copy of this deque."}
{"code": "public void generateCode(BlockScope currentScope){\n  if ((this.bits & IsReachable) == 0) {\n    return;\n  }\n  generateInit: {\n    if (this.initialization == null)     break generateInit;\n    if (this.binding.resolvedPosition < 0) {\n      if (this.initialization.constant != Constant.NotAConstant)       break generateInit;\n      this.initialization.generateCode(currentScope,false);\n      break generateInit;\n    }\n    this.initialization.generateCode(currentScope,true);\n  }\n}\n", "nl": "Code generation for a local declaration: i.e.&nbsp;normal assignment to a local variable + unused variable handling"}
{"code": "public static boolean isPotentialValidLink(File file) throws IOException {\n  boolean isPotentiallyValid;\n  try (InputStream fis=new FileInputStream(file)){\n    final int minimumLength=0x64;\n    isPotentiallyValid=file.isFile() && file.getName().toLowerCase().endsWith(\".lnk\") && fis.available() >= minimumLength && isMagicPresent(getBytes(fis,32));\n  }\n   return isPotentiallyValid;\n}\n", "nl": "Provides a quick test to see if this could be a valid link ! If you try to instantiate a new WindowShortcut and the link is not valid, Exceptions may be thrown and Exceptions are extremely slow to generate, therefore any code needing to loop through several files should first check this."}
{"code": "public IGameMove decideMove(IGameState state){\n  if (state.isDraw())   return null;\n  if (state.isWin())   return null;\n  Collection<IGameMove> moves=logic.validMoves(this,state);\n  if (moves.size() == 0) {\n    return null;\n  }\n else {\n    IGameMove[] mvs=moves.toArray(new IGameMove[]{});\n    int idx=(int)(Math.random() * moves.size());\n    return mvs[idx];\n  }\n}\n", "nl": "Randomly make a move based upon the available logic of the game. Make sure you check that the game is not already won, lost or drawn before calling  this method, because you "}
{"code": "public static int nextPowerOf2(int x){\n  long i=1;\n  while (i < x && i < (Integer.MAX_VALUE / 2)) {\n    i+=i;\n  }\n  return (int)i;\n}\n", "nl": "Get the value that is equal or higher than this value, and that is a power of two."}
{"code": "public Point2D inverseTransform(Point2D viewPoint){\n  Point2D viewCenter=getViewCenter();\n  double viewRadius=getViewRadius();\n  double ratio=getRatio();\n  double dx=viewPoint.getX() - viewCenter.getX();\n  double dy=viewPoint.getY() - viewCenter.getY();\n  dx*=ratio;\n  Point2D pointFromCenter=new Point2D.Double(dx,dy);\n  PolarPoint polar=PolarPoint.cartesianToPolar(pointFromCenter);\n  double radius=polar.getRadius();\n  if (radius > viewRadius)   return delegate.inverseTransform(viewPoint);\n  radius/=viewRadius;\n  radius=Math.abs(Math.tan(radius));\n  radius/=Math.PI / 2;\n  radius*=viewRadius;\n  double mag=Math.tan(Math.PI / 2 * magnification);\n  radius/=mag;\n  polar.setRadius(radius);\n  Point2D projectedPoint=PolarPoint.polarToCartesian(polar);\n  projectedPoint.setLocation(projectedPoint.getX() / ratio,projectedPoint.getY());\n  Point2D translatedBack=new Point2D.Double(projectedPoint.getX() + viewCenter.getX(),projectedPoint.getY() + viewCenter.getY());\n  return delegate.inverseTransform(translatedBack);\n}\n", "nl": "override base class to un-project the fisheye effect"}
{"code": "private boolean iconBoundsIntersectBar(RectF barBounds,Rect icon,double scaleFactor){\n  int iconL=icon.left + scale(icon.width(),scaleFactor);\n  int iconT=icon.top + scale(icon.height(),scaleFactor);\n  int iconR=icon.right - scale(icon.width(),scaleFactor);\n  int iconB=icon.bottom - scale(icon.height(),scaleFactor);\n  return barBounds.intersects(iconL,iconT,iconR,iconB);\n}\n", "nl": "Helper method for calculating intersections for control icons and bars."}
{"code": "public void closeRegistration(){\n  flushDeferrables();\n  for (  Map.Entry<String,ClassPlugins> e : registrations.entrySet()) {\n    e.getValue().initializeMap();\n  }\n}\n", "nl": "Disallows new registrations of new plugins, and creates the internal tables for method lookup."}
{"code": "public static String toGml(final IDirectedGraph<?,? extends IGraphEdge<?>> graph){\n  Preconditions.checkNotNull(graph,\"Graph argument can not be null\");\n  final StringBuilder sb=new StringBuilder();\n  sb.append(\"graph\\n\" + \"[\\n\");\n  int currentId=0;\n  final Map<Object,Integer> nodeMap=new HashMap<>();\n  for (  final Object node : graph.getNodes()) {\n    sb.append(\"\\tnode\\n\" + \"\\t[\\n\" + \"\\tid \"+ \"\\n\");\n    sb.append(currentId);\n    sb.append(\"\\tlabel \\\"\");\n    sb.append(node);\n    sb.append(\"\\\"\\n\" + \"\\t]\\n\");\n    nodeMap.put(node,currentId);\n    ++currentId;\n  }\n  for (  final IGraphEdge<?> edge : graph.getEdges()) {\n    sb.append(\"\\tedge\\n\" + \"\\t[\\n\" + \"\\tsource \");\n    sb.append(nodeMap.get(edge.getSource()));\n    sb.append(\"\\n\" + \"\\ttarget \");\n    sb.append(nodeMap.get(edge.getTarget()));\n    sb.append(\"\\n\" + \"\\tgraphics\\n\" + \"\\t[\\n\"+ \"\\t\\tfill \\\"#000000\\\"\\n\"+ \"\\t\\ttargetArrow \\\"standard\\\"\\n\"+ \"\\t]\\n\"+ \"\\t]\\n\");\n  }\n  sb.append(\"]\\n\");\n  return sb.toString();\n}\n", "nl": "Creates GML code that represents a given directed graph."}
{"code": "void cachePage(long pos,Page page,int memory){\n  if (cache != null) {\n    cache.put(pos,page,memory);\n  }\n}\n", "nl": "Put the page in the cache."}
{"code": "public static Class<?> typeToClass(int type){\n  Class<?> result;\nswitch (type) {\ncase Types.BIGINT:\n    result=Long.class;\n  break;\ncase Types.BINARY:\nresult=String.class;\nbreak;\ncase Types.BIT:\nresult=Boolean.class;\nbreak;\ncase Types.CHAR:\nresult=Character.class;\nbreak;\ncase Types.DATE:\nresult=java.sql.Date.class;\nbreak;\ncase Types.DECIMAL:\nresult=Double.class;\nbreak;\ncase Types.DOUBLE:\nresult=Double.class;\nbreak;\ncase Types.FLOAT:\nresult=Float.class;\nbreak;\ncase Types.INTEGER:\nresult=Integer.class;\nbreak;\ncase Types.LONGVARBINARY:\nresult=String.class;\nbreak;\ncase Types.LONGVARCHAR:\nresult=String.class;\nbreak;\ncase Types.NULL:\nresult=String.class;\nbreak;\ncase Types.NUMERIC:\nresult=Double.class;\nbreak;\ncase Types.OTHER:\nresult=String.class;\nbreak;\ncase Types.REAL:\nresult=Double.class;\nbreak;\ncase Types.SMALLINT:\nresult=Short.class;\nbreak;\ncase Types.TIME:\nresult=java.sql.Time.class;\nbreak;\ncase Types.TIMESTAMP:\nresult=java.sql.Timestamp.class;\nbreak;\ncase Types.TINYINT:\nresult=Short.class;\nbreak;\ncase Types.VARBINARY:\nresult=String.class;\nbreak;\ncase Types.VARCHAR:\nresult=String.class;\nbreak;\ndefault :\nresult=null;\n}\nreturn result;\n}\n", "nl": "Returns the class associated with a SQL type."}
{"code": "private String noteToString(Repository repo,Note note) throws MissingObjectException, IOException, UnsupportedEncodingException {\n  ObjectLoader loader=repo.open(note.getData());\n  ByteArrayOutputStream baos=new ByteArrayOutputStream();\n  loader.copyTo(baos);\n  return new String(baos.toByteArray(),\"UTF-8\");\n}\n", "nl": "Utility method that converts a note to a string (assuming it's UTF-8)."}
{"code": "@TransactionAttribute(TransactionAttributeType.REQUIRES_NEW) public void initTimers() throws ValidationException {\n  initAllTimers();\n}\n", "nl": "Reads the configuration settings for the timer intervals to be used and creates the timers accordingly."}
{"code": "public static String tbiIndexToUniqueString(InputStream is) throws IOException {\n  final StringBuilder ret=new StringBuilder();\n  final byte[] buf=new byte[4096];\n  readIOFully(is,buf,4);\n  final String header=new String(buf,0,4);\n  ret.append(\"Header correct: \").append(header.equals(\"TBI\\u0001\")).append(StringUtils.LS);\n  readIOFully(is,buf,4);\n  final int numRefs=ByteArrayIOUtils.bytesToIntLittleEndian(buf,0);\n  ret.append(\"numRefs: \").append(numRefs).append(StringUtils.LS);\n  readIOFully(is,buf,28);\n  final int format=ByteArrayIOUtils.bytesToIntLittleEndian(buf,0);\n  final int colSeq=ByteArrayIOUtils.bytesToIntLittleEndian(buf,4);\n  final int colBeg=ByteArrayIOUtils.bytesToIntLittleEndian(buf,8);\n  final int colEnd=ByteArrayIOUtils.bytesToIntLittleEndian(buf,12);\n  final int meta=ByteArrayIOUtils.bytesToIntLittleEndian(buf,16);\n  final int skip=ByteArrayIOUtils.bytesToIntLittleEndian(buf,20);\n  final int refNameLength=ByteArrayIOUtils.bytesToIntLittleEndian(buf,24);\n  final String formatStr;\n  formatStr=TbiFormat.values()[format & 0xffff].name();\n  ret.append(\"Format: \").append(formatStr).append(\" 0-based: \").append((format & 0x10000) != 0).append(StringUtils.LS);\n  ret.append(\"Columns: (refName:Start-End) \").append(colSeq).append(\":\").append(colBeg).append(\"-\").append(colEnd).append(StringUtils.LS);\n  ret.append(\"Meta: \").append((char)meta).append(StringUtils.LS);\n  ret.append(\"Skip: \").append(skip).append(StringUtils.LS);\n  final byte[] names=new byte[refNameLength];\n  readIOFully(is,names,names.length);\n  ret.append(\"Sequence names: \");\n  boolean first=true;\n  int off=0;\n  for (int i=0; i < numRefs; i++) {\n    int newOff=off;\n    while (newOff < names.length && names[newOff] != 0) {\n      newOff++;\n    }\n    if (!first) {\n      ret.append(\", \");\n    }\n    ret.append(new String(names,off,newOff - off));\n    off=newOff + 1;\n    first=false;\n  }\n  ret.append(StringUtils.LS);\n  ret.append(indicesToUniqueString(is,numRefs)).append(StringUtils.LS);\n  return ret.toString();\n}\n", "nl": "Creates a string representation of the TABIX index"}
{"code": "public void addFeatureChangeListener(final FeatureChangeListener l){\n  featureListeners.add(l);\n}\n", "nl": "Add a feature change listener."}
{"code": "protected UserPassword(){\n  super();\n}\n", "nl": "Dear JPA..."}
{"code": "public void firePropertyChange(String propertyName,float oldValue,float newValue){\n}\n", "nl": "Overridden for performance reasons. See the <a href=\"#override\">Implementation Note</a> for more information."}
{"code": "public void testUpdate5(){\n  int factor=3;\n  String updateQuery=\"UPDATE \" + DatabaseCreator.TEST_TABLE1 + \" SET field2=field2 *\"+ factor;\n  try {\n    String selectQuery=\"SELECT field2 FROM \" + DatabaseCreator.TEST_TABLE1;\n    ResultSet result=statement.executeQuery(selectQuery);\n    HashSet<BigDecimal> values=new HashSet<BigDecimal>();\n    int num=statement.executeUpdate(updateQuery);\n    assertEquals(\"Not all records in the database were updated\",numberOfRecords,num);\n    result=statement.executeQuery(selectQuery);\n    assertTrue(\"Not all records were updated\",values.isEmpty());\n    result.close();\n  }\n catch (  SQLException e) {\n    fail(\"Unexpected exception\" + e.getMessage());\n  }\n}\n", "nl": "UpdateFunctionalityTest#testUpdate5(). Updates values in one columns in the table using condition"}
{"code": "public final boolean isCaretBlinkEnabled(){\n  return caretBlinks;\n}\n", "nl": "Returns true if the caret is blinking, false otherwise."}
{"code": "public void testBug73663() throws Exception {\n  this.rs=this.stmt.executeQuery(\"show variables like 'collation_server'\");\n  this.rs.next();\n  String collation=this.rs.getString(2);\n  if (collation != null && collation.startsWith(\"utf8mb4\") && \"utf8mb4\".equals(((MySQLConnection)this.conn).getServerVariable(\"character_set_server\"))) {\n    Properties p=new Properties();\n    p.setProperty(\"characterEncoding\",\"UTF-8\");\n    p.setProperty(\"statementInterceptors\",Bug73663StatementInterceptor.class.getName());\n    getConnectionWithProps(p);\n  }\n else {\n    System.out.println(\"testBug73663 was skipped: This test is only run when character_set_server=utf8mb4 and collation-server set to one of utf8mb4 collations.\");\n  }\n}\n", "nl": "Tests fix for Bug#73663 (19479242), utf8mb4 does not work for connector/j >=5.1.13 This test is only run when character_set_server=utf8mb4 and collation-server set to one of utf8mb4 collations (it's better to test two configurations: with default utf8mb4_general_ci and one of non-default, say utf8mb4_bin)"}
{"code": "@Override public void removeEdge(final InstructionGraphEdge edge){\n  super.removeEdge(edge);\n}\n", "nl": "Removes an instruction edge from the instruction graph."}
{"code": "public void addApps(List<AppInfo> apps){\n  mApps.addApps(apps);\n}\n", "nl": "Adds new apps to the list."}
{"code": "public void stop(){\n  final String methodName=\"stop\";\nsynchronized (lifecycle) {\n    log.fine(CLASS_NAME,methodName,\"850\");\n    if (running) {\n      running=false;\n      receiving=false;\n      if (!Thread.currentThread().equals(recThread)) {\n        try {\n          recThread.join();\n        }\n catch (        InterruptedException ex) {\n        }\n      }\n    }\n  }\n  recThread=null;\n  log.fine(CLASS_NAME,methodName,\"851\");\n}\n", "nl": "Stops the Receiver's thread.  This call will block."}
{"code": "First(){\n}\n", "nl": "CONSTRUCTOR <init>"}
{"code": "@Override public String toString(){\n  String temp=\"\";\n  for (int i=0; i < variables.length; i++) {\n    temp+=variables[i].toString();\n    temp+=\"\\n\";\n  }\n  return structName + \"\\n\" + temp;\n}\n", "nl": "Override ToString()."}
{"code": "public void addActionListener(ActionListener l){\n  dispatcher.addListener(l);\n}\n", "nl": "Adds a listener to the switch which will cause an event to dispatch on click"}
{"code": "@Override protected SystemMemberCache createSystemMemberCache(GemFireVM vm) throws org.apache.geode.admin.AdminException {\n  if (managedSystemMemberCache == null) {\n    managedSystemMemberCache=new SystemMemberCacheJmxImpl(vm);\n  }\n  return managedSystemMemberCache;\n}\n", "nl": "Override createSystemMemberCache by instantiating SystemMemberCacheJmxImpl if it was not created earlier."}
{"code": "@Override public void run(){\n  amIActive=true;\n  String inputFile=args[0];\n  if (inputFile.toLowerCase().contains(\".dep\")) {\n    calculateRaster();\n  }\n else   if (inputFile.toLowerCase().contains(\".shp\")) {\n    calculateVector();\n  }\n else {\n    showFeedback(\"There was a problem reading the input file.\");\n  }\n}\n", "nl": "Used to execute this plugin tool."}
{"code": "public void test_compressed_timestamp_01b() throws Exception {\n  new TestHelper(\"compressed-timestamp-01b\",\"compressed-timestamp-01b.rq\",\"compressed-timestamp.ttl\",\"compressed-timestamp-01.srx\").runTest();\n}\n", "nl": "Simple SELECT query returning data typed with the given timestamp, where we have several FILTERs that should evaluate to true."}
{"code": "private void writeAttribute(java.lang.String namespace,java.lang.String attName,java.lang.String attValue,javax.xml.stream.XMLStreamWriter xmlWriter) throws javax.xml.stream.XMLStreamException {\n  if (namespace.equals(\"\")) {\n    xmlWriter.writeAttribute(attName,attValue);\n  }\n else {\n    registerPrefix(xmlWriter,namespace);\n    xmlWriter.writeAttribute(namespace,attName,attValue);\n  }\n}\n", "nl": "Util method to write an attribute without the ns prefix"}
{"code": "private void addTag(String newTag){\n  if (StringUtils.isBlank(newTag)) {\n    return;\n  }\nsynchronized (tagsObservable) {\n    if (tagsObservable.contains(newTag)) {\n      return;\n    }\n    tagsObservable.add(newTag);\n  }\n  firePropertyChange(\"tag\",null,tagsObservable);\n}\n", "nl": "Adds the tag."}
{"code": "public EObject basicGetAstElement(){\n  return astElement;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public void detach(){\n  if (systemOverlay) {\n    getWindowManager().removeView(this);\n  }\n else {\n    ((ViewGroup)getActivityContentView()).removeView(this);\n  }\n}\n", "nl": "Detaches it from the container view."}
{"code": "private static void patternCompile(){\n  try {\n    ptnNumber=Pattern.compile(strNumberPattern);\n    ptnShortDate=Pattern.compile(strShortDatePattern);\n    ptnLongDate=Pattern.compile(strLongDatePattern);\n    ptnPercentage=Pattern.compile(strPercentagePattern);\n    ptnCurrency=Pattern.compile(strCurrencyPattern);\n    ptnViCurrency=Pattern.compile(strViCurrencyPattern);\n  }\n catch (  PatternSyntaxException ex) {\n    System.err.println(ex.getMessage());\n    System.exit(1);\n  }\n}\n", "nl": "Pattern compile."}
{"code": "public NotificationChain basicSetParams(ExpressionList newParams,NotificationChain msgs){\n  ExpressionList oldParams=params;\n  params=newParams;\n  if (eNotificationRequired()) {\n    ENotificationImpl notification=new ENotificationImpl(this,Notification.SET,GamlPackage.PARAMETERS__PARAMS,oldParams,newParams);\n    if (msgs == null)     msgs=notification;\n else     msgs.add(notification);\n  }\n  return msgs;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "static public int unpackInt(DataInput is) throws IOException {\n  int ret=0;\n  byte v;\n  do {\n    v=is.readByte();\n    ret=(ret << 7) | (v & 0x7F);\n  }\n while ((v & 0x80) == 0);\n  return ret;\n}\n", "nl": "Unpack int value from the input stream."}
{"code": "public Object loadWorkflowData(String stepId,String key){\n  Object data=null;\n  String workflowUri=getMainWorkflowUri(stepId);\n  try {\n    if (workflowUri != null) {\n      String dataPath=String.format(_zkStepDataPath,workflowUri) + String.format(_zkWorkflowData,key);\n      if (_dataManager.checkExists(dataPath) != null) {\n        data=_dataManager.getData(dataPath,false);\n      }\n    }\n  }\n catch (  Exception ex) {\n    String exMsg=\"Exception adding global data to workflow from stepId: \" + stepId + \": \"+ ex.getMessage();\n    _log.error(exMsg);\n    data=null;\n  }\n  return data;\n}\n", "nl": "Gets the step workflow data stored under /workflow/stepdata/{workflowURI}/data/{key} where workflowURI is the URI of the main workflow regardless of whether the step belongs in the main workflow or one of its nested workflows."}
{"code": "public static void fillByte(byte[] array,byte x){\n  for (int i=0; i < array.length; i++) {\n    array[i]=x;\n  }\n}\n", "nl": "Fill an array with the given value."}
{"code": "@Override public void addDictionaryChunk(List<byte[]> dictionaryChunk){\n  dictionaryChunks.add(dictionaryChunk);\n  if (null == dictionaryByteArrayToSurrogateKeyMap) {\n    createDictionaryByteArrayToSurrogateKeyMap(dictionaryChunk.size());\n  }\n  addDataToDictionaryMap();\n}\n", "nl": "This method will add a new dictionary chunk to existing list of dictionary chunks"}
{"code": "public OMWarpingImage(BufferedImage bi){\n  setWarp(bi,LatLonGCT.INSTANCE,new DataBounds(-180,-90,180,90));\n}\n", "nl": "Takes an image, assumed to be a world image in the LLXY projection (equal arc) covering -180, 180 longitude to -90, 90 latitude."}
{"code": "private void acquirePrecachingWakeLock(){\n  if (mPrecachingWakeLock == null) {\n    PowerManager pm=(PowerManager)getSystemService(Context.POWER_SERVICE);\n    mPrecachingWakeLock=pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,TAG);\n  }\n  mPrecachingWakeLock.acquire();\n}\n", "nl": "Acquire the precaching WakeLock."}
{"code": "public static List<Long> entropyHybridTest(GeoTimeSerie gts,int buckets_per_period,int periods_per_piece,int k,double alpha) throws WarpScriptException {\n  doubleCheck(gts);\n  List<Long> anomalous_ticks=new ArrayList<Long>();\n  if (!GTSHelper.isBucketized(gts)) {\n    throw new WarpScriptException(\"GTS must be bucketized\");\n  }\n  if (k >= periods_per_piece * buckets_per_period / 2) {\n    throw new WarpScriptException(\"Upper bound of number of outliers must be less than half of the number of observations per piece\");\n  }\n  GeoTimeSerie subgts=null;\n  GeoTimeSerie subsubgts=null;\n  GeoTimeSerie seasonal=null;\n  long pieces=gts.bucketcount / buckets_per_period / periods_per_piece;\n  int bpp=periods_per_piece * buckets_per_period;\n  long lb=gts.lastbucket;\n  long bs=gts.bucketspan;\n  for (int u=0; u < pieces; u++) {\n    long start=lb - bs * ((pieces - u) * bpp - 1);\n    long stop=lb - bs * (pieces - u - 1) * bpp;\n    subgts=GTSHelper.subSerie(gts,start,stop,false,false,subgts);\n    subgts.lastbucket=stop;\n    subgts.bucketcount=bpp;\n    subgts.bucketspan=bs;\n    if (null == seasonal) {\n      seasonal=new GeoTimeSerie(bpp);\n      seasonal.doubleValues=new double[bpp];\n      seasonal.ticks=new long[bpp];\n    }\n else {\n      GTSHelper.reset(seasonal);\n    }\n    seasonal.type=TYPE.DOUBLE;\n    for (int v=0; v < buckets_per_period; v++) {\n      subsubgts=GTSHelper.subCycleSerie(subgts,stop - v * bs,buckets_per_period,true,subsubgts);\n      double[] madsigma=madsigma(subsubgts,true);\n      double median=madsigma[0];\n      double mad=madsigma[1];\n      double sum=0.0D;\n      for (int w=0; w < subsubgts.values; w++) {\n        subsubgts.doubleValues[w]=0.0D != mad ? Math.abs((subsubgts.doubleValues[w] - median) / mad) : 1.0D;\n        sum+=subsubgts.doubleValues[w];\n      }\n      double entropy=0.0D;\n      for (int w=0; w < subsubgts.values; w++) {\n        subsubgts.doubleValues[w]/=sum;\n        double tmp=subsubgts.doubleValues[w];\n        if (0.0D != tmp) {\n          entropy-=tmp * Math.log(tmp);\n        }\n      }\n      if (0.0D != entropy) {\n        entropy/=Math.log(subsubgts.values);\n      }\n else {\n        entropy=1.0D;\n      }\n      for (int w=0; w < subsubgts.values; w++) {\n        GTSHelper.setValue(seasonal,subsubgts.ticks[w],entropy * subsubgts.doubleValues[w]);\n      }\n    }\n    GTSHelper.sort(seasonal);\n    double m=median(seasonal);\n    int idx=0;\n    for (int i=0; i < subgts.values; i++) {\n      idx=Arrays.binarySearch(seasonal.ticks,idx,seasonal.values,subgts.ticks[i]);\n      if (idx < 0) {\n        throw new WarpScriptException(\"Internal bug method entropyHybridTest: can't find tick \" + subgts.ticks[i] + \" in seasonal.ticks\");\n      }\n else {\n        subgts.doubleValues[i]-=(seasonal.doubleValues[idx] + m);\n      }\n    }\n    anomalous_ticks.addAll(ESDTest(subgts,k,true,alpha));\n  }\n  return anomalous_ticks;\n}\n", "nl": "Applying Seasonal Entropy Hybrid test This test is based on piecewise decomposition where trend components are approximated by median and seasonal components by entropy of the cycle sub-series. An ESD test is passed upon the residuals. It differs from hybridTest by approximating seasonal component instead of using STL. But in many cases this approximation is more useful than estimation of STL."}
{"code": "public static void collectAndFireTriggers(final HashSet<PlayerID> players,final Match<TriggerAttachment> triggerMatch,final IDelegateBridge aBridge,final String beforeOrAfter,final String stepName){\n  final HashSet<TriggerAttachment> toFirePossible=collectForAllTriggersMatching(players,triggerMatch,aBridge);\n  if (toFirePossible.isEmpty()) {\n    return;\n  }\n  final HashMap<ICondition,Boolean> testedConditions=collectTestsForAllTriggers(toFirePossible,aBridge);\n  final List<TriggerAttachment> toFireTestedAndSatisfied=Match.getMatches(toFirePossible,AbstractTriggerAttachment.isSatisfiedMatch(testedConditions));\n  if (toFireTestedAndSatisfied.isEmpty()) {\n    return;\n  }\n  TriggerAttachment.fireTriggers(new HashSet<>(toFireTestedAndSatisfied),testedConditions,aBridge,beforeOrAfter,stepName,true,true,true,true);\n}\n", "nl": "This will collect all triggers for the desired players, based on a match provided, and then it will gather all the conditions necessary, then test all the conditions, and then it will fire all the conditions which are satisfied."}
{"code": "public static long[] clone(long[] array){\n  if (array == null) {\n    return null;\n  }\n  return (long[])array.clone();\n}\n", "nl": "<p>Clones an array returning a typecast result and handling <code>null</code>.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>"}
{"code": "public ColorPredicate(String input) throws IllegalArgumentException {\n  String rest=input.trim().toLowerCase();\n  if (rest.startsWith(\"leaf\")) {\n    this.isLeaf=true;\n    rest=rest.substring(4).trim();\n  }\n else {\n    this.isLeaf=false;\n  }\n  int endOfStartToken=0;\n  while (endOfStartToken < rest.length() && Character.isLetter(rest.charAt(endOfStartToken))) {\n    endOfStartToken++;\n  }\n  String startToken=rest.substring(0,endOfStartToken);\n  String macro=getMacro(startToken);\n  if (macro != null) {\n    rest=macro;\n  }\n  if (rest.startsWith(\"some\")) {\n    this.isSome=true;\n    rest=rest.substring(4).trim();\n  }\n else   if (rest.startsWith(\"every\")) {\n    this.isSome=false;\n    rest=rest.substring(5).trim();\n  }\n else {\n    throw new IllegalArgumentException(\"\" + \" Color predicate must start with the optional keyword `leaf'\\n\" + \" followed by a legal macro name or `every' or `some'.\");\n  }\n  this.set=0;\n  while (!rest.equals(\"\")) {\n    if (rest.startsWith(\"omitted\")) {\n      this.set=this.set | (1 << NUMBER_OF_OMITTED_STATE);\n      rest=rest.substring(7).trim();\n    }\n else     if (rest.startsWith(\"missing\")) {\n      this.set=this.set | (1 << NUMBER_OF_MISSING_STATE);\n      rest=rest.substring(7).trim();\n    }\n else     if (rest.startsWith(\"(\")) {\n      rest=rest.substring(1).trim();\n      int[][] stateSetSpec=new int[NUMBER_OF_PROVERS][];\n      for (int i=0; i < NUMBER_OF_PROVERS; i++) {\n        boolean invert=false;\n        if (rest.startsWith(\"-\")) {\n          invert=true;\n          rest=rest.substring(1).trim();\n        }\n        boolean[] appears=new boolean[PROVER_STATUSES[i].length];\n        for (int j=0; j < appears.length; j++) {\n          appears[j]=invert;\n        }\n        String endChar=(i == NUMBER_OF_PROVERS - 1) ? \")\" : \",\";\n        while (rest.length() > 0 && !rest.startsWith(endChar)) {\n          int endOfToken=0;\n          while (endOfToken < rest.length() && Character.isLetter(rest.charAt(endOfToken))) {\n            endOfToken++;\n          }\n          String token=rest.substring(0,endOfToken);\n          rest=rest.substring(endOfToken).trim();\n          int statusNumber;\n          try {\n            statusNumber=numberOfProverStatus(i,token);\n          }\n catch (          IllegalArgumentException e) {\n            String errorMsg=\"Was expecting status of prover \" + PROVER_NAMES[i] + \" but found `\"+ token+ \"' followed by: \\n `\"+ rest+ \"'\";\n            throw new IllegalArgumentException(errorMsg);\n          }\n          appears[statusNumber]=!invert;\n        }\n        if (rest.length() == 0) {\n          throw new IllegalArgumentException(\"Color predicate specifier ended before `(...)' expression complete\");\n        }\n        rest=rest.substring(1).trim();\n        int count=0;\n        for (int j=0; j < appears.length; j++) {\n          if (appears[j]) {\n            count++;\n          }\n        }\n        if (count == 0) {\n          if (invert) {\n            throw new IllegalArgumentException(\"A `-' must be followed by one or more statuses\");\n          }\n else {\n            count=appears.length;\n            for (int j=0; j < count; j++) {\n              appears[j]=true;\n            }\n          }\n        }\n        stateSetSpec[i]=new int[count];\n        int k=0;\n        for (int j=0; j < appears.length; j++) {\n          if (appears[j]) {\n            stateSetSpec[i][k]=j;\n            k++;\n          }\n        }\n      }\n      this.set=this.set | bitVectorOfStates(stateSetSpec);\n    }\n else {\n      throw new IllegalArgumentException(\"Unexpected token at: `\" + rest + \"'\");\n    }\n  }\n}\n", "nl": "Returns a ColorPredicate obtained by parsing its argument. See the beginning of ProofStatus.tla for the grammar of the input."}
{"code": "protected void transferFromFile(File idFile) throws IOException {\n  try (BufferedReader br=new BufferedReader(new FileReader(idFile))){\n    String line;\n    while ((line=br.readLine()) != null) {\n      line=line.trim();\n      if (line.length() > 0) {\n        transfer(line);\n      }\n    }\n  }\n }\n", "nl": "Transfer all the sequences listed in the supplied file, interpreting entries appropriately."}
{"code": "public String toNamespacedString(){\n  return (_namespaceURI != null ? (\"{\" + _namespaceURI + \"}\"+ _localName) : _localName);\n}\n", "nl": "Return the string representation of the qualified name using the  the '{ns}foo' notation. Performs string concatenation, so beware of performance issues."}
{"code": "@SuppressWarnings(\"deprecation\") public void configureManagers(){\n  powerManager=new jmri.jmrix.nce.NcePowerManager(this);\n  InstanceManager.store(powerManager,jmri.PowerManager.class);\n  turnoutManager=new jmri.jmrix.nce.NceTurnoutManager(getNceTrafficController(),getSystemPrefix());\n  InstanceManager.setTurnoutManager(turnoutManager);\n  lightManager=new jmri.jmrix.nce.NceLightManager(getNceTrafficController(),getSystemPrefix());\n  InstanceManager.setLightManager(lightManager);\n  sensorManager=new jmri.jmrix.nce.NceSensorManager(getNceTrafficController(),getSystemPrefix());\n  InstanceManager.setSensorManager(sensorManager);\n  throttleManager=new jmri.jmrix.nce.NceThrottleManager(this);\n  InstanceManager.setThrottleManager(throttleManager);\n  if (getNceUsbSystem() != NceTrafficController.USB_SYSTEM_NONE) {\n    if (getNceUsbSystem() != NceTrafficController.USB_SYSTEM_POWERHOUSE) {\n    }\n  }\n else {\n    InstanceManager.setProgrammerManager(getProgrammerManager());\n  }\n  clockManager=new jmri.jmrix.nce.NceClockControl(getNceTrafficController(),getSystemPrefix());\n  InstanceManager.addClockControl(clockManager);\n  consistManager=new jmri.jmrix.nce.NceConsistManager(this);\n  InstanceManager.setConsistManager(consistManager);\n}\n", "nl": "Configure the common managers for NCE connections. This puts the common manager config in one place."}
{"code": "public void newLine() throws IOException {\n  out.append('\\n');\n  for (int n=0; n < currentIndentLevel; n++)   out.append(indent);\n  currentLine++;\n  currentCol=currentIndentLevel * indent.length();\n}\n", "nl": "Emits a <code>'\\n'</code> plus required indentation characters for the current indentation level."}
{"code": "@Override protected void checkForDuplicatSnapshotName(String name,Volume vplexVolume){\n  Volume snapshotSourceVolume=getVPLEXSnapshotSourceVolume(vplexVolume);\n  super.checkForDuplicatSnapshotName(name,snapshotSourceVolume);\n}\n", "nl": "Check if a snapshot with the same name exists for the passed volume."}
{"code": "public boolean isOneAssetPerUOM(){\n  Object oo=get_Value(COLUMNNAME_IsOneAssetPerUOM);\n  if (oo != null) {\n    if (oo instanceof Boolean)     return ((Boolean)oo).booleanValue();\n    return \"Y\".equals(oo);\n  }\n  return false;\n}\n", "nl": "Get One Asset Per UOM."}
{"code": "public int value(){\n  return this.value;\n}\n", "nl": "Retrieve value for node computed so far. <p> Primarily here for testing"}
{"code": "public boolean isRemove(){\n  boolean is;\n  if (m_editFlag == FolderEditFlag.REMOVE)   is=true;\n else   is=false;\n  return is;\n}\n", "nl": "Devuelve <tt>true</tt> si el campo est? marcado como eliminado"}
{"code": "public static String encodeWebSafe(byte[] source,boolean doPadding){\n  return encode(source,0,source.length,WEBSAFE_ALPHABET,doPadding);\n}\n", "nl": "Encodes a byte array into web safe Base64 notation."}
{"code": "@Override public void commence(HttpServletRequest request,HttpServletResponse response,AuthenticationException arg2) throws IOException, ServletException {\n  log.debug(\"Pre-authenticated entry point called. Rejecting access\");\n  response.sendError(HttpServletResponse.SC_UNAUTHORIZED,\"Access Denied\");\n}\n", "nl": "Always returns a 401 error code to the client."}
{"code": "public int size(){\n  return _size;\n}\n", "nl": "Returns the current number of entries in the map."}
{"code": "private List<Volume> createVolumeData(String name,int numVolumes){\n  List<Volume> volumes=new ArrayList<Volume>();\n  URI cgUri=createBlockConsistencyGroup(name + \"-cg\");\n  for (int i=1; i <= numVolumes; i++) {\n    Volume volume=new Volume();\n    URI volumeURI=URIUtil.createId(Volume.class);\n    testVolumeURIs.add(volumeURI);\n    volume.setId(volumeURI);\n    volume.setLabel(name + i);\n    volume.setConsistencyGroup(cgUri);\n    _dbClient.createObject(volume);\n  }\n  return volumes;\n}\n", "nl": "Creates the BlockObject Volume data."}
{"code": "private void showFeedback(String message){\n  if (myHost != null) {\n    myHost.showFeedback(message);\n  }\n else {\n    System.out.println(message);\n  }\n}\n", "nl": "Used to communicate feedback pop-up messages between a plugin tool and the main Whitebox user-interface."}
{"code": "public static void closeStream(Closeable stream){\n  if (stream != null) {\n    try {\n      stream.close();\n    }\n catch (    IOException e) {\n      android.util.Log.e(\"IO\",\"Could not close stream\",e);\n    }\n  }\n}\n", "nl": "Closes the specified stream."}
{"code": "private static BufferedImage loadImage(final IdocScanInterface ui,int finalWidth,int finalHeight){\n  return loadImage(ui,finalWidth,finalHeight,0);\n}\n", "nl": "Muestra la imagen seleccionada de la lista en el visor del applet a escala real"}
{"code": "private void updateProgress(String progressLabel,int progress){\n  if (myHost != null && ((progress != previousProgress) || (!progressLabel.equals(previousProgressLabel)))) {\n    myHost.updateProgress(progressLabel,progress);\n  }\n  previousProgress=progress;\n  previousProgressLabel=progressLabel;\n}\n", "nl": "Used to communicate a progress update between a plugin tool and the main Whitebox user interface."}
{"code": "public void configure(){\n  XpaSystemConnectionMemo memo=((XpaSystemConnectionMemo)getSystemConnectionMemo());\n  XpaTrafficController tc=memo.getXpaTrafficController();\n  tc.connectPort(this);\n  memo.setPowerManager(new jmri.jmrix.xpa.XpaPowerManager(tc));\n  jmri.InstanceManager.store(memo.getPowerManager(),jmri.PowerManager.class);\n  memo.setTurnoutManager(new jmri.jmrix.xpa.XpaTurnoutManager(memo));\n  jmri.InstanceManager.store(memo.getTurnoutManager(),jmri.TurnoutManager.class);\n  memo.setThrottleManager(new jmri.jmrix.xpa.XpaThrottleManager(memo));\n  jmri.InstanceManager.store(memo.getThrottleManager(),jmri.ThrottleManager.class);\n  tc.startTransmitThread();\n  sinkThread=new Thread(tc);\n  sinkThread.start();\n}\n", "nl": "set up all of the other objects to operate with an XPA+Modem Connected to an XPressNet based command station connected to this port"}
{"code": "public void executeQuery(IMiniTable miniTable){\n  log.info(\"\");\n  String sql=\"\";\n  if (m_DD_Order_ID == null)   return;\n  sql=getOrderSQL();\n  log.fine(sql);\n  int row=0;\n  miniTable.setRowCount(row);\n  try {\n    PreparedStatement pstmt=DB.prepareStatement(sql.toString(),null);\n    pstmt.setInt(1,Integer.parseInt(m_DD_Order_ID.toString()));\n    ResultSet rs=pstmt.executeQuery();\n    while (rs.next()) {\n      miniTable.setRowCount(row + 1);\n      miniTable.setValueAt(new IDColumn(rs.getInt(1)),row,0);\n      miniTable.setValueAt(rs.getBigDecimal(2),row,1);\n      miniTable.setValueAt(rs.getString(3),row,2);\n      miniTable.setValueAt(rs.getString(4),row,4);\n      miniTable.setValueAt(rs.getString(5),row,3);\n      miniTable.setValueAt(rs.getString(6),row,5);\n      row++;\n    }\n    rs.close();\n    pstmt.close();\n  }\n catch (  SQLException e) {\n    log.log(Level.SEVERE,sql.toString(),e);\n  }\n  miniTable.autoSize();\n}\n", "nl": "Query Info"}
{"code": "public ParameterDatabase(){\n  super();\n  accessed=new Hashtable();\n  gotten=new Hashtable();\n  directory=new File(new File(\"\").getAbsolutePath());\n  label=\"Basic Database\";\n  parents=new Vector();\n  checked=false;\n}\n", "nl": "Creates an empty parameter database."}
{"code": "private CTagHelpers(){\n}\n", "nl": "You are not supposed to instantiate this class."}
{"code": "public EventSourceImpl(){\n  LOG.entering(CLASS_NAME,\"<init>\");\n}\n", "nl": "EventSource provides a text-based stream abstraction for Java"}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 13:01:25.281 -0500\",hash_original_method=\"8F9A0D25038BAA53AA87BFFA0D47316A\",hash_generated_method=\"D647B858B68B1333AC193E85FEBDEE73\") public static void registrationComplete(){\nsynchronized (mHandlerMap) {\n    mRegistrationComplete=true;\n    mHandlerMap.notifyAll();\n  }\n}\n", "nl": "The application must call here after it finishes registering handlers."}
{"code": "public long next(){\n  return next(RecurrenceUtil.now());\n}\n", "nl": "Returns the next recurrence from now."}
{"code": "@Override public void writeExternal(ObjectOutput out) throws IOException {\n  super.writeExternal(out);\n  mbr.writeExternal(out);\n}\n", "nl": "Calls the super method and writes the MBR object of this entry to the specified output stream."}
{"code": "protected void validate_return(StorageCapability[] param){\n}\n", "nl": "validate the array for _return"}
{"code": "public static String jQuote(String s){\n  if (s == null) {\n    return \"null\";\n  }\n  int ln=s.length();\n  StringBuilder b=new StringBuilder(ln + 4);\n  b.append('\"');\n  for (int i=0; i < ln; i++) {\n    char c=s.charAt(i);\n    if (c == '\"') {\n      b.append(\"\\\\\\\"\");\n    }\n else     if (c == '\\\\') {\n      b.append(\"\\\\\\\\\");\n    }\n else     if (c < 0x20) {\n      if (c == '\\n') {\n        b.append(\"\\\\n\");\n      }\n else       if (c == '\\r') {\n        b.append(\"\\\\r\");\n      }\n else       if (c == '\\f') {\n        b.append(\"\\\\f\");\n      }\n else       if (c == '\\b') {\n        b.append(\"\\\\b\");\n      }\n else       if (c == '\\t') {\n        b.append(\"\\\\t\");\n      }\n else {\n        b.append(\"\\\\u00\");\n        int x=c / 0x10;\n        b.append(toHexDigit(x));\n        x=c & 0xF;\n        b.append(toHexDigit(x));\n      }\n    }\n else {\n      b.append(c);\n    }\n  }\n  b.append('\"');\n  return b.toString();\n}\n", "nl": "Quotes string as Java Language string literal. Returns string <code>\"null\"</code> if <code>s</code> is <code>null</code>."}
{"code": "public FluentFunction<T3,R> partiallyApply(final T1 param1,final T2 param2){\n  return new FluentFunction<>(PartialApplicator.partial3(param1,param2,fn));\n}\n", "nl": "Partially apply the provided parameters to this BiFunction to generate a Function (single input)"}
{"code": "public static boolean deleteFile(String path){\n  if (Handler_String.isBlank(path)) {\n    return true;\n  }\n  File file=new File(path);\n  if (!file.exists()) {\n    return true;\n  }\n  if (file.isFile()) {\n    return file.delete();\n  }\n  if (!file.isDirectory()) {\n    return false;\n  }\n  for (  File f : file.listFiles()) {\n    if (f.isFile()) {\n      f.delete();\n    }\n else     if (f.isDirectory()) {\n      deleteFile(f.getAbsolutePath());\n    }\n  }\n  return file.delete();\n}\n", "nl": "delete file or directory <ul> <li>if path is null or empty, return true</li> <li>if path not exist, return true</li> <li>if path exist, delete recursion. return true</li> <ul>"}
{"code": "private ImmutableSet<CassandraJmxCompactionClient> createCompactionClients(CassandraJmxCompactionConfig jmxConfig){\n  Set<CassandraJmxCompactionClient> clients=Sets.newHashSet();\n  Set<InetSocketAddress> servers=config.servers();\n  int jmxPort=jmxConfig.port();\n  for (  InetSocketAddress addr : servers) {\n    CassandraJmxCompactionClient client=createCompactionClient(addr.getHostString(),jmxPort,jmxConfig.username(),jmxConfig.password());\n    clients.add(client);\n  }\n  return ImmutableSet.copyOf(clients);\n}\n", "nl": "Return an empty set if no client can be created."}
{"code": "public static String hashKeyForDisk(String key){\n  String cacheKey;\n  try {\n    final MessageDigest mDigest=MessageDigest.getInstance(\"MD5\");\n    mDigest.update(key.getBytes());\n    cacheKey=bytesToHexString(mDigest.digest());\n  }\n catch (  NoSuchAlgorithmException e) {\n    cacheKey=String.valueOf(key.hashCode());\n  }\n  return cacheKey;\n}\n", "nl": "A hashing method that changes a string (like a URL) into a hash suitable for using as a disk filename."}
{"code": "@Nullable public String space(){\n  return space;\n}\n", "nl": "Gets swap space name."}
{"code": "public Object runSafely(Catbert.FastStack stack) throws Exception {\n  SeriesInfo si=getSeriesInfo(stack);\n  return si == null ? \"\" : si.getDescription();\n}\n", "nl": "Returns the description for the specified SeriesInfo"}
{"code": "public UserEntry restoreUser(String username) throws AppsForYourDomainException, ServiceException, IOException {\n  LOGGER.log(Level.INFO,\"Restoring user '\" + username + \"'.\");\n  URL retrieveUrl=new URL(domainUrlBase + \"user/\" + SERVICE_VERSION+ \"/\"+ username);\n  UserEntry userEntry=userService.getEntry(retrieveUrl,UserEntry.class);\n  userEntry.getLogin().setSuspended(false);\n  URL updateUrl=new URL(domainUrlBase + \"user/\" + SERVICE_VERSION+ \"/\"+ username);\n  return userService.update(updateUrl,userEntry);\n}\n", "nl": "Restores a user. Note that executing this method for a user who is not suspended has no effect."}
{"code": "private Class(RVMType type){\n  this.type=type;\n}\n", "nl": "Prevents this class from being instantiated, except by the create method in this class."}
{"code": "public double weightedFMeasure(){\n  double[] classCounts=new double[m_NumClasses];\n  double classCountSum=0;\n  for (int i=0; i < m_NumClasses; i++) {\n    for (int j=0; j < m_NumClasses; j++) {\n      classCounts[i]+=m_ConfusionMatrix[i][j];\n    }\n    classCountSum+=classCounts[i];\n  }\n  double fMeasureTotal=0;\n  for (int i=0; i < m_NumClasses; i++) {\n    double temp=fMeasure(i);\n    fMeasureTotal+=(temp * classCounts[i]);\n  }\n  return fMeasureTotal / classCountSum;\n}\n", "nl": "Calculates the macro weighted (by class size) average F-Measure."}
{"code": "@DSSafe(DSCat.DATA_STRUCTURE) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:55:08.711 -0500\",hash_original_method=\"05A7D65C6D911E0B1F3261A66888CB52\",hash_generated_method=\"3AFFFBA2DDE5D54646A6F203B3BBAF40\") public int lastIndexOf(Object obj){\n  return this.hlist.lastIndexOf(obj);\n}\n", "nl": "Get the last index of the given object."}
{"code": "public Builder showNextButton(boolean showNextButton){\n  this.showNextButton=showNextButton;\n  return this;\n}\n", "nl": "Set the visibility of the next button"}
{"code": "public static ValueLobDb createSmallLob(int type,byte[] small,long precision){\n  return new ValueLobDb(type,small,precision);\n}\n", "nl": "Create a LOB object that fits in memory."}
{"code": "public void invDct8x8(double[][] input,int[][] output){\n  double[][] temp=new double[NJPEG][NJPEG];\n  double temp1=0.0;\n  int i=0;\n  int j=0;\n  int k=0;\n  for (i=0; i < NJPEG; i++) {\n    for (j=0; j < NJPEG; j++) {\n      temp[i][j]=0.0;\n      for (k=0; k < NJPEG; k++) {\n        temp[i][j]+=input[i][k] * this.C[k][j];\n      }\n    }\n  }\n  for (i=0; i < NJPEG; i++) {\n    for (j=0; j < NJPEG; j++) {\n      temp1=0.0;\n      for (k=0; k < NJPEG; k++) {\n        temp1+=this.Ct[i][k] * temp[k][j];\n      }\n      temp1+=128.0;\n      output[i][j]=ImageUtil.pixelRange(round(temp1));\n    }\n  }\n}\n", "nl": "Perform inverse DCT on the 8x8 matrix"}
{"code": "public static InputStream openDataFile(){\n  InputStream stream=SantaFeExample.class.getResourceAsStream(\"santafe.trail\");\n  if (stream == null) {\n    System.err.println(\"Unable to find the file santafe.trail.\");\n    System.exit(-1);\n  }\n  return stream;\n}\n", "nl": "Returns an input stream that contains the ant trail data file."}
{"code": "public ProductionRule(final String name,final GameData data,final IntegerMap<NamedAttachable> results,final IntegerMap<Resource> costs){\n  super(name,data);\n  m_results=results;\n  m_cost=costs;\n}\n", "nl": "Creates new ProductionRule"}
{"code": "public RootConfiguration(ApplicationInformation ai){\n  this(ai,getDefaultContexts(applicationClass(ai,CommonUtils.getCallingClass(2))));\n}\n", "nl": "Initializes the root configuration with default context relative to the calling (instantiating class)."}
{"code": "public void addString(String word,Tuple t){\n  TrieLeaf leaf=new TrieLeaf(word,t);\n  addLeaf(root,leaf,0);\n}\n", "nl": "Add a new word to the trie, associated with the given Tuple."}
{"code": "public void waitOnInitialization() throws InterruptedException {\n  this.initializationLatch.await();\n}\n", "nl": "Wait for the tracker to finishe being initialized"}
{"code": "@Override public Object execute(ExecutionEvent event) throws ExecutionException {\n  IWorkbenchPart viewPart=HandlerUtil.getActivePart(event);\n  if (viewPart instanceof DroidsafeInfoOutlineViewPart) {\n    Command command=event.getCommand();\n    boolean oldValue=HandlerUtil.toggleCommandState(command);\n    ((DroidsafeInfoOutlineViewPart)viewPart).setLongLabel(!oldValue);\n  }\n  return null;\n}\n", "nl": "Command implementation. Retrieves the value of the parameter value, and delegates to the view to set the correct value for the methods labels."}
{"code": "@Override protected EClass eStaticClass(){\n  return UmplePackage.eINSTANCE.getCodeLang_();\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "private static byte[] streamToBytes(InputStream in,int length) throws IOException {\n  byte[] bytes=new byte[length];\n  int count;\n  int pos=0;\n  while (pos < length && ((count=in.read(bytes,pos,length - pos)) != -1)) {\n    pos+=count;\n  }\n  if (pos != length) {\n    throw new IOException(\"Expected \" + length + \" bytes, read \"+ pos+ \" bytes\");\n  }\n  return bytes;\n}\n", "nl": "Reads the contents of an InputStream into a byte[]."}
{"code": "public void testUpdatePathDoesNotExist() throws Exception {\n  final Map<String,String> props=properties(\"owner\",\"group\",\"0555\");\n  assert igfs.update(SUBDIR,props) == null;\n  checkNotExist(igfs,igfsSecondary,SUBDIR);\n}\n", "nl": "Check that exception is thrown in case the path being updated doesn't exist remotely."}
{"code": "public void stopProcess() throws InterruptedException {\n  latch.await();\n  if (this.process != null) {\n    System.out.println(\"ProcessThread.stopProcess() will kill process\");\n    this.process.destroy();\n  }\n}\n", "nl": "Stops the process."}
{"code": "@Override public void run(){\n  amIActive=true;\n  String inputHeader=null;\n  String outputHeader=null;\n  int row, col, x, y;\n  int progress=0;\n  double z;\n  int i, c;\n  int[] dX=new int[]{1,1,1,0,-1,-1,-1,0};\n  int[] dY=new int[]{-1,0,1,1,1,0,-1,-1};\n  double zFactor=0;\n  double slopeThreshold=0;\n  double profCurvThreshold=0;\n  double planCurvThreshold=0;\n  double radToDeg=180 / Math.PI;\n  if (args.length <= 0) {\n    showFeedback(\"Plugin parameters have not been set.\");\n    return;\n  }\n  for (i=0; i < args.length; i++) {\n    if (i == 0) {\n      inputHeader=args[i];\n    }\n else     if (i == 1) {\n      outputHeader=args[i];\n    }\n else     if (i == 2) {\n      zFactor=Double.parseDouble(args[i]);\n    }\n else     if (i == 3) {\n      slopeThreshold=Double.parseDouble(args[i]);\n    }\n else     if (i == 4) {\n      profCurvThreshold=Double.parseDouble(args[i]);\n    }\n else     if (i == 5) {\n      planCurvThreshold=Double.parseDouble(args[i]);\n    }\n  }\n  if ((inputHeader == null) || (outputHeader == null)) {\n    showFeedback(\"One or more of the input parameters have not been set properly.\");\n    return;\n  }\n  try {\n    WhiteboxRaster DEM=new WhiteboxRaster(inputHeader,\"r\");\n    int rows=DEM.getNumberRows();\n    int cols=DEM.getNumberColumns();\n    double noData=DEM.getNoDataValue();\n    double gridResX=DEM.getCellSizeX();\n    double gridResY=DEM.getCellSizeY();\n    double diagGridRes=Math.sqrt(gridResX * gridResX + gridResY * gridResY);\n    double[] gridLengths=new double[]{diagGridRes,gridResX,diagGridRes,gridResY,diagGridRes,gridResX,diagGridRes,gridResY};\n    double Zx, Zy, Zxx, Zyy, Zxy, p, Zx2, q, Zy2;\n    double fx, fy;\n    double gridResTimes2=gridResX * 2;\n    double gridResSquared=gridResX * gridResX;\n    double fourTimesGridResSquared=gridResSquared * 4;\n    double planCurv, profCurv, slope;\n    double eightGridRes=8 * gridResX;\n    double[] N=new double[8];\n    WhiteboxRaster output=new WhiteboxRaster(outputHeader,\"rw\",inputHeader,WhiteboxRaster.DataType.FLOAT,-999);\n    output.setPreferredPalette(\"landclass.pal\");\n    output.setDataScale(WhiteboxRaster.DataScale.CONTINUOUS);\n    for (row=0; row < rows; row++) {\n      for (col=0; col < cols; col++) {\n        z=DEM.getValue(row,col);\n        if (z != noData) {\n          z=z * zFactor;\n          for (c=0; c < 8; c++) {\n            N[c]=DEM.getValue(row + dY[c],col + dX[c]);\n            if (N[c] != noData) {\n              N[c]=N[c] * zFactor;\n            }\n else {\n              N[c]=z;\n            }\n          }\n          Zx=(N[1] - N[5]) / gridResTimes2;\n          Zy=(N[7] - N[3]) / gridResTimes2;\n          Zxx=(N[1] - 2 * z + N[5]) / gridResSquared;\n          Zyy=(N[7] - 2 * z + N[3]) / gridResSquared;\n          Zxy=(-N[6] + N[0] + N[4] - N[2]) / fourTimesGridResSquared;\n          Zx2=Zx * Zx;\n          Zy2=Zy * Zy;\n          p=Zx2 + Zy2;\n          q=p + 1;\n          if (p > 0) {\n            fy=(N[6] - N[4] + 2 * (N[7] - N[3]) + N[0] - N[2]) / eightGridRes;\n            fx=(N[2] - N[4] + 2 * (N[1] - N[5]) + N[0] - N[6]) / eightGridRes;\n            slope=Math.atan(Math.sqrt(fx * fx + fy * fy));\n            slope=slope * radToDeg;\n            planCurv=-1 * (Zxx * Zy2 - 2 * Zxy * Zx* Zy + Zyy * Zx2) / Math.pow(p,1.5);\n            planCurv=(planCurv * radToDeg);\n            profCurv=-1 * (Zxx * Zx2 + 2 * Zxy * Zx* Zy + Zyy * Zy2) / Math.pow(p * q,1.5);\n            profCurv=(profCurv * radToDeg);\n            if (profCurv < -profCurvThreshold && planCurv <= -planCurvThreshold & slope > slopeThreshold) {\n              output.setValue(row,col,1);\n            }\n else             if (profCurv < -profCurvThreshold && planCurv > planCurvThreshold && slope > slopeThreshold) {\n              output.setValue(row,col,2);\n            }\n else             if (profCurv > profCurvThreshold && planCurv <= planCurvThreshold && slope > slopeThreshold) {\n              output.setValue(row,col,3);\n            }\n else             if (profCurv > profCurvThreshold && planCurv > planCurvThreshold && slope > slopeThreshold) {\n              output.setValue(row,col,4);\n            }\n else             if (profCurv >= -profCurvThreshold && profCurv < profCurvThreshold && slope > slopeThreshold && planCurv <= -planCurvThreshold) {\n              output.setValue(row,col,5);\n            }\n else             if (profCurv >= -profCurvThreshold && profCurv < profCurvThreshold && slope > slopeThreshold && planCurv > planCurvThreshold) {\n              output.setValue(row,col,6);\n            }\n else             if (slope <= slopeThreshold) {\n              output.setValue(row,col,7);\n            }\n else {\n              output.setValue(row,col,noData);\n            }\n          }\n else {\n            output.setValue(row,col,noData);\n          }\n        }\n      }\n      if (cancelOp) {\n        cancelOperation();\n        return;\n      }\n      progress=(int)(100f * row / (rows - 1));\n      updateProgress(progress);\n    }\n    output.addMetadataEntry(\"Created by the \" + getDescriptiveName() + \" tool.\");\n    output.addMetadataEntry(\"Created on \" + new Date());\n    DEM.close();\n    output.close();\n    returnData(outputHeader);\n    String retstr=\"LANDFORM CLASSIFICATION KEY\\n\";\n    retstr+=\"\\nValue:\\tClass\";\n    retstr+=\"\\n1\\tConvergent Footslope\";\n    retstr+=\"\\n2\\tDivergent Footslope\";\n    retstr+=\"\\n3\\tConvergent Shoulder\";\n    retstr+=\"\\n4\\tDivergent Shoulder\";\n    retstr+=\"\\n5\\tConvergent Backslope\";\n    retstr+=\"\\n6\\tDivergent Backslope\";\n    retstr+=\"\\n7\\tLevel\";\n    returnData(retstr);\n  }\n catch (  OutOfMemoryError oe) {\n    myHost.showFeedback(\"An out-of-memory error has occurred during operation.\");\n  }\ncatch (  Exception e) {\n    myHost.showFeedback(\"An error has occurred during operation. See log file for details.\");\n    myHost.logException(\"Error in \" + getDescriptiveName(),e);\n  }\n finally {\n    updateProgress(\"Progress: \",0);\n    amIActive=false;\n    myHost.pluginComplete();\n  }\n}\n", "nl": "Used to execute this plugin tool."}
{"code": "public R reduce(R r1,R r2){\n  return r1;\n}\n", "nl": "Reduces two results into a combined result. The default implementation is to return the first parameter. The general contract of the method is that it may take any action whatsoever."}
{"code": "public void numParameters(int num) throws IOException {\n  output.write(num);\n}\n", "nl": "Writes <code>num_parameters</code> in <code>Runtime(In)VisibleParameterAnnotations_attribute</code>. This method must be followed by <code>num</code> calls to <code>numAnnotations()</code>."}
{"code": "public ResultFormatter(Object result){\n  this.result=result;\n  printHeader=true;\n}\n", "nl": "Creates a new formatter for a particular object."}
{"code": "@Override public Eval<String> join(){\n  return Eval.later(null);\n}\n", "nl": "Perform an asynchronous join operation"}
{"code": "public GetRequest type(@Nullable String type){\n  if (type == null) {\n    type=\"_all\";\n  }\n  this.type=type;\n  return this;\n}\n", "nl": "Sets the type of the document to fetch."}
{"code": "@Override public ImmutableSet<Entry<K,V>> entries(){\n  ImmutableSet<Entry<K,V>> result=entries;\n  return result == null ? (entries=new EntrySet<K,V>(this)) : result;\n}\n", "nl": "Returns an immutable collection of all key-value pairs in the multimap. Its iterator traverses the values for the first key, the values for the second key, and so on."}
{"code": "private int luminance(int r,int g,int b){\n  return (int)((0.299 * r) + (0.58 * g) + (0.11 * b));\n}\n", "nl": "Apply the luminance"}
{"code": "private void puntPlay(Team offense){\n  gameYardLine=(int)(100 - (gameYardLine + offense.getK(0).ratKickPow / 3 + 20 - 10 * Math.random()));\n  if (gameYardLine < 0) {\n    gameYardLine=20;\n  }\n  gameDown=1;\n  gameYardsNeed=10;\n  gamePoss=!gamePoss;\n  gameTime-=20 + 15 * Math.random();\n}\n", "nl": "Punt the ball if it is a 4th down and decided not to go for it. Will turnover possession."}
{"code": "private List<String[]> readSentence(BufferedReader aReader) throws IOException {\n  List<String[]> words=new ArrayList<String[]>();\n  String line;\n  boolean beginSentence=true;\n  while ((line=aReader.readLine()) != null) {\n    if (StringUtils.isBlank(line)) {\n      beginSentence=true;\n      break;\n    }\n    if (hasHeader && beginSentence) {\n      beginSentence=false;\n      continue;\n    }\n    String[] fields=line.split(columnSeparator.getValue());\n    if (!hasEmbeddedNamedEntity && fields.length != 2 + FORM) {\n      throw new IOException(String.format(\"Invalid file format. Line needs to have %d %s-separated fields: [%s]\",2 + FORM,columnSeparator.getName(),line));\n    }\n else     if (hasEmbeddedNamedEntity && fields.length != 3 + FORM) {\n      throw new IOException(String.format(\"Invalid file format. Line needs to have %d %s-separated fields: [%s]\",3 + FORM,columnSeparator.getName(),line));\n    }\n    words.add(fields);\n  }\n  if (line == null && words.isEmpty()) {\n    return null;\n  }\n else {\n    return words;\n  }\n}\n", "nl": "Read a single sentence."}
{"code": "public static ConditionOperand OVERFLOW_FROM_SUB(){\n  return new ConditionOperand(OVERFLOW_FROM_SUB);\n}\n", "nl": "Create the condition code operand for OVERFLOW_FROM_SUB"}
{"code": "protected void initCheckLists(){\n  List<IceMediaStream> streams=getStreamsWithPendingConnectivityEstablishment();\n  int streamCount=streams.size();\n  int maxCheckListSize=Integer.getInteger(StackProperties.MAX_CHECK_LIST_SIZE,DEFAULT_MAX_CHECK_LIST_SIZE);\n  int maxPerStreamSize=streamCount == 0 ? 0 : maxCheckListSize / streamCount;\n  for (  IceMediaStream stream : streams) {\n    logger.info(\"Init checklist for stream \" + stream.getName());\n    stream.setMaxCheckListSize(maxPerStreamSize);\n    stream.initCheckList();\n  }\n  if (streamCount > 0)   streams.get(0).getCheckList().computeInitialCheckListPairStates();\n}\n", "nl": "Creates, initializes and orders the list of candidate pairs that would be used for the connectivity checks for all components in this stream."}
{"code": "private void checkSearchables(ArrayList<SearchableInfo> searchablesList){\n  assertNotNull(searchablesList);\n  int count=searchablesList.size();\n  for (int ii=0; ii < count; ii++) {\n    SearchableInfo si=searchablesList.get(ii);\n    checkSearchable(si);\n  }\n}\n", "nl": "Generic health checker for an array of searchables. This is designed to pass for any semi-legal searchable, without knowing much about the format of the underlying data.  It's fairly easy for a non-compliant application to provide meta-data that will pass here (e.g. a non-existent suggestions authority)."}
{"code": "private void generateImplementsParcelableInterface(PsiClass targetPsiClass){\n  PsiJavaCodeReferenceElement referenceElement=factory.createReferenceFromText(PARCELABLE_CLASS_SIMPLE_NAME,null);\n  PsiReferenceList implementsList=targetPsiClass.getImplementsList();\n  if (null != implementsList) {\n    implementsList.add(referenceElement);\n  }\n  generateImportStatement(PARCELABLE_PACKAGE);\n  generateExtraMethods(targetPsiClass);\n}\n", "nl": "Implement android.os.Parcelable interface"}
{"code": "private RemoteDirectorGroup fetchRDFGroupFromCache(Map<URI,RemoteDirectorGroup> rdfGroupCache,URI srdfGroupURI){\n  if (rdfGroupCache.containsKey(srdfGroupURI)) {\n    return rdfGroupCache.get(srdfGroupURI);\n  }\n  RemoteDirectorGroup rdfGroup=this.getDbClient().queryObject(RemoteDirectorGroup.class,srdfGroupURI);\n  if (null != rdfGroup && !rdfGroup.getInactive()) {\n    rdfGroupCache.put(srdfGroupURI,rdfGroup);\n  }\n  return rdfGroup;\n}\n", "nl": "Return the RemoteDirectorGroup from cache otherwise query from db."}
{"code": "public static int minCut(String s){\n  Set<String> palin=new HashSet<String>();\n  return minCut(s,0,palin);\n}\n", "nl": "Backtracking, generate all cuts"}
{"code": "public ObjectWriter withDateFormat(DateFormat df){\n  SerializationConfig newConfig=_config.withDateFormat(df);\n  if (newConfig == _config) {\n    return this;\n  }\n  return new ObjectWriter(this,newConfig);\n}\n", "nl": "Fluent factory method that will construct a new writer instance that will use specified date format for serializing dates; or if null passed, one that will serialize dates as numeric timestamps."}
{"code": "LockMode(final boolean allowsTouch,final boolean allowsCommands){\n  this.allowsTouch=allowsTouch;\n  this.allowsCommands=allowsCommands;\n}\n", "nl": "Constructs a new LockMode instance."}
{"code": "public boolean match(Element e,String pseudoE){\n  return (e instanceof CSSStylableElement) ? ((CSSStylableElement)e).isPseudoInstanceOf(getValue()) : false;\n}\n", "nl": "Tests whether this selector matches the given element."}
{"code": "RandomAccessFile openInputFileAsZip(String fileName) throws IOException {\n  ZipFile zipFile;\n  try {\n    zipFile=new ZipFile(fileName);\n  }\n catch (  FileNotFoundException fnfe) {\n    System.err.println(\"Unable to open '\" + fileName + \"': \"+ fnfe.getMessage());\n    throw fnfe;\n  }\ncatch (  ZipException ze) {\n    return null;\n  }\n  ZipEntry entry=zipFile.getEntry(CLASSES_DEX);\n  if (entry == null) {\n    System.err.println(\"Unable to find '\" + CLASSES_DEX + \"' in '\"+ fileName+ \"'\");\n    zipFile.close();\n    throw new ZipException();\n  }\n  InputStream zis=zipFile.getInputStream(entry);\n  File tempFile=File.createTempFile(\"dexdeps\",\".dex\");\n  RandomAccessFile raf=new RandomAccessFile(tempFile,\"rw\");\n  tempFile.delete();\n  byte copyBuf[]=new byte[32768];\n  int actual;\n  while (true) {\n    actual=zis.read(copyBuf);\n    if (actual == -1)     break;\n    raf.write(copyBuf,0,actual);\n  }\n  zis.close();\n  raf.seek(0);\n  return raf;\n}\n", "nl": "Tries to open an input file as a Zip archive (jar/apk) with a \"classes.dex\" inside."}
{"code": "public boolean generate(Projection proj){\n  setNeedToRegenerate(true);\n  if (proj == null) {\n    Debug.message(\"omgraphic\",\"OMRect: null projection in generate!\");\n    return false;\n  }\nswitch (renderType) {\ncase RENDERTYPE_XY:\n    setShape(createBoxShape((int)Math.min(x2,x1),(int)Math.min(y2,y1),(int)Math.abs(x2 - x1),(int)Math.abs(y2 - y1)));\n  break;\ncase RENDERTYPE_OFFSET:\nif (!proj.isPlotable(lat1,lon1)) {\n  setNeedToRegenerate(true);\n  return false;\n}\nPoint p1=(Point)proj.forward(lat1,lon1,new Point());\nsetShape(createBoxShape((int)Math.min(p1.x + x1,p1.x + x2),(int)Math.min(p1.y + y1,p1.y + y2),(int)Math.abs(x2 - x1),(int)Math.abs(y2 - y1)));\nbreak;\ncase RENDERTYPE_LATLON:\nArrayList<float[]> rects;\nif (proj instanceof GeoProj) {\nrects=((GeoProj)proj).forwardRect(new LatLonPoint.Double(lat1,lon1),new LatLonPoint.Double(lat2,lon2),lineType,nsegs,!isClear(fillPaint));\n}\n else {\nrects=proj.forwardRect(new Point2D.Double(lon1,lat1),new Point2D.Double(lon2,lat2));\n}\nint size=rects.size();\nGeneralPath projectedShape=null;\nfor (int i=0; i < size; i+=2) {\nGeneralPath gp=createShape(rects.get(i),rects.get(i + 1),true);\nprojectedShape=appendShapeEdge(projectedShape,gp,false);\n}\nsetShape(projectedShape);\nbreak;\ncase RENDERTYPE_UNKNOWN:\nSystem.err.println(\"OMRect.generate(): invalid RenderType\");\nreturn false;\n}\nsetLabelLocation(getShape(),proj);\nsetNeedToRegenerate(false);\nreturn true;\n}\n", "nl": "Prepare the rectangle for rendering."}
{"code": "public void stream(OutputStream os) throws IOException {\n  MessageHeader globals=entries.elementAt(0);\n  if (globals.findValue(\"Signature-Version\") == null) {\n    throw new JarException(\"Signature file requires \" + \"Signature-Version: 1.0 in 1st header\");\n  }\n  PrintStream ps=new PrintStream(os);\n  globals.print(ps);\n  for (int i=1; i < entries.size(); ++i) {\n    MessageHeader mh=entries.elementAt(i);\n    mh.print(ps);\n  }\n}\n", "nl": "Add a signature file at current position in a stream"}
{"code": "public long readDateTimeAsLong(int index){\n  return this.readULong(index) << 32 | this.readULong(index + 4);\n}\n", "nl": "Reads the LONGDATETIME at the given index."}
{"code": "public static Value BagToSet(Value b){\n  FcnRcdValue fcn=FcnRcdValue.convert(b);\n  if (fcn == null) {\n    throw new EvalException(EC.TLC_MODULE_APPLYING_TO_WRONG_VALUE,new String[]{\"BagToSet\",\"a function with a finite domain\",Value.ppr(b.toString())});\n  }\n  return fcn.getDomain();\n}\n", "nl": "// For now, we do not override SubBag. So, We are using the TLA+ definition. public static Value SubBag(Value b) { FcnRcdValue fcn = FcnRcdValue.convert(b); if (fcn == null) { String msg = \"Applying SubBag to the following value, which is\\n\" + \"not a function with a finite domain:\\n\" + Value.ppr(b.toString()); throw new EvalException(msg); } throw new EvalException(\"SubBag is not implemented.\"); }"}
{"code": "public static ProjectActionEvent createProjectClosingEvent(ProjectDescriptor project){\n  return new ProjectActionEvent(project,ProjectAction.CLOSING,false);\n}\n", "nl": "Creates a Project Closing Event."}
{"code": "public int fullyConnectSync(Context srcContext,Handler srcHandler,Handler dstHandler){\n  int status=connectSync(srcContext,srcHandler,dstHandler);\n  if (status == STATUS_SUCCESSFUL) {\n    Message response=sendMessageSynchronously(CMD_CHANNEL_FULL_CONNECTION);\n    status=response.arg1;\n  }\n  return status;\n}\n", "nl": "Fully connect two local Handlers synchronously."}
{"code": "public static boolean hasInterface(String intf,String cls){\n  try {\n    return hasInterface(Class.forName(intf),Class.forName(cls));\n  }\n catch (  Exception e) {\n    return false;\n  }\n}\n", "nl": "Checks whether the given class implements the given interface."}
{"code": "public void removePropertyChangeListener(String propertyName,PropertyChangeListener in_pcl){\n  beanContextChildSupport.removePropertyChangeListener(propertyName,in_pcl);\n}\n", "nl": "Method for BeanContextChild interface. Uses the BeanContextChildSupport to remove a listener to this object's property. You don't need this function for objects that extend java.awt.Component."}
{"code": "private boolean isIgnoreLocallyExistingFiles(){\n  return ignoreLocallyExistingFiles;\n}\n", "nl": "Returns true to indicate that locally existing files are treated as they would not exist. This is a extension to the standard cvs-behaviour!"}
{"code": "private boolean isViewDescendantOf(View child,View parent){\n  if (child == parent) {\n    return true;\n  }\n  final ViewParent theParent=child.getParent();\n  return (theParent instanceof ViewGroup) && isViewDescendantOf((View)theParent,parent);\n}\n", "nl": "Return true if child is an descendant of parent, (or equal to the parent)."}
{"code": "public void add(double value){\n  if (count == 0) {\n    count=1;\n    mean=value;\n    min=value;\n    max=value;\n    if (!isFinite(value)) {\n      sumOfSquaresOfDeltas=NaN;\n    }\n  }\n else {\n    count++;\n    if (isFinite(value) && isFinite(mean)) {\n      double delta=value - mean;\n      mean+=delta / count;\n      sumOfSquaresOfDeltas+=delta * (value - mean);\n    }\n else {\n      mean=calculateNewMeanNonFinite(mean,value);\n      sumOfSquaresOfDeltas=NaN;\n    }\n    min=Math.min(min,value);\n    max=Math.max(max,value);\n  }\n}\n", "nl": "Adds the given value to the dataset."}
{"code": "private void init(Context context,RuqusTheme theme,String currClassName){\n  this.currClassName=currClassName;\n  inflate(context,R.layout.sort_field_view,this);\n  setOrientation(VERTICAL);\n  label=(TextView)findViewById(R.id.sort_field_label);\n  sortFieldChooser=(Spinner)findViewById(R.id.sort_field);\n  removeButton=(ImageButton)findViewById(R.id.remove_field);\n  sortDirRg=(RadioGroup)findViewById(R.id.rg_sort_dir);\n  ascRb=(RadioButton)findViewById(R.id.asc);\n  descRb=(RadioButton)findViewById(R.id.desc);\n  setTheme(theme);\n  sortFieldChooser.setOnTouchListener(sortFieldChooserListener);\n  sortFieldChooser.setOnItemSelectedListener(sortFieldChooserListener);\n}\n", "nl": "Initialize our view."}
{"code": "protected Future<Void> closeNoThrow(){\n  Promise<Void> closeFuture;\nsynchronized (this) {\n    if (null != closePromise) {\n      return closePromise;\n    }\n    closeFuture=closePromise=new Promise<Void>();\n  }\n  cancelTruncation();\n  Utils.closeSequence(bkDistributedLogManager.getScheduler(),true,getCachedLogWriter(),getAllocatedLogWriter(),getCachedWriteHandler()).proxyTo(closeFuture);\n  return closeFuture;\n}\n", "nl": "Close the writer and release all the underlying resources"}
{"code": "public Boolean isValidating(){\n  return validating;\n}\n", "nl": "Gets the value of the validating property."}
{"code": "private String scanPlainSpaces(){\n  int length=0;\n  while (reader.peek(length) == ' ' || reader.peek(length) == '\\t') {\n    length++;\n  }\n  String whitespaces=reader.prefixForward(length);\n  String lineBreak=scanLineBreak();\n  if (lineBreak.length() != 0) {\n    this.allowSimpleKey=true;\n    String prefix=reader.prefix(3);\n    if (\"---\".equals(prefix) || \"...\".equals(prefix) && Constant.NULL_BL_T_LINEBR.has(reader.peek(3))) {\n      return \"\";\n    }\n    StringBuilder breaks=new StringBuilder();\n    while (true) {\n      if (reader.peek() == ' ') {\n        reader.forward();\n      }\n else {\n        String lb=scanLineBreak();\n        if (lb.length() != 0) {\n          breaks.append(lb);\n          prefix=reader.prefix(3);\n          if (\"---\".equals(prefix) || \"...\".equals(prefix) && Constant.NULL_BL_T_LINEBR.has(reader.peek(3))) {\n            return \"\";\n          }\n        }\n else {\n          break;\n        }\n      }\n    }\n    if (!\"\\n\".equals(lineBreak)) {\n      return lineBreak + breaks;\n    }\n else     if (breaks.length() == 0) {\n      return \" \";\n    }\n    return breaks.toString();\n  }\n  return whitespaces;\n}\n", "nl": "See the specification for details. SnakeYAML and libyaml allow tabs inside plain scalar"}
{"code": "public static void w(String tag,String s,Throwable e){\n  if (LOG.WARN >= LOGLEVEL)   Log.w(tag,s,e);\n}\n", "nl": "Warning log message."}
{"code": "public static double mean(double[] vector){\n  double sum=0;\n  if (vector.length == 0) {\n    return 0;\n  }\n  for (int i=0; i < vector.length; i++) {\n    sum+=vector[i];\n  }\n  return sum / (double)vector.length;\n}\n", "nl": "Computes the mean for an array of doubles."}
{"code": "protected byte[] toJsonBytes(final Object object) throws Exception {\n  ObjectMapper mapper=new ObjectMapper();\n  mapper.setSerializationInclusion(JsonSerialize.Inclusion.NON_NULL);\n  return mapper.writeValueAsBytes(object);\n}\n", "nl": "Map object to JSON bytes"}
{"code": "public void shuffleInventory(@Nonnull IInventory inv,@Nonnull Random random){\n  final List<ItemStack> list=getInventoryList(inv);\n  Collections.shuffle(list,random);\n  for (int i=0; i < inv.getSizeInventory(); ++i) {\n    inv.setInventorySlotContents(i,list.get(i));\n  }\n}\n", "nl": "Shuffles all items in the inventory"}
{"code": "public QueueCursor(int capacity){\n  this(capacity,false);\n}\n", "nl": "Creates an <tt>QueueCursor</tt> with the given (fixed) capacity and default access policy."}
{"code": "public void destroy(DistributedRegion r){\n}\n", "nl": "Blows away all the data in this object."}
{"code": "public Process executeAsync(final CommandLine command,ExecuteResultHandler handler) throws IOException {\n  return executeAsync(command,null,handler);\n}\n", "nl": "Methods for starting asynchronous execution. The child process inherits all environment variables of the parent process. Result provided to callback handler."}
{"code": "public static void destroy(){\n  try {\n    Region region1=cache.getRegion(Region.SEPARATOR + REGION_NAME);\n    region1.localDestroy(\"key-1\");\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n    fail(\"test failed due to exception in destroy \");\n  }\n}\n", "nl": "destroy key-1"}
{"code": "public boolean isSelected(){\n  return this.selected;\n}\n", "nl": "Check if item is selected"}
{"code": "public String(String string){\n  value=string.value;\n  offset=string.offset;\n  count=string.count;\n}\n", "nl": "Creates a string that is a copy of another string"}
{"code": "private void needNewBuffer(int newSize){\n  int delta=newSize - size;\n  int newBufferSize=Math.max(minChunkLen,delta);\n  currentBufferIndex++;\n  currentBuffer=new int[newBufferSize];\n  offset=0;\n  if (currentBufferIndex >= buffers.length) {\n    int newLen=buffers.length << 1;\n    int[][] newBuffers=new int[newLen][];\n    System.arraycopy(buffers,0,newBuffers,0,buffers.length);\n    buffers=newBuffers;\n  }\n  buffers[currentBufferIndex]=currentBuffer;\n  buffersCount++;\n}\n", "nl": "Prepares next chunk to match new size. The minimal length of new chunk is <code>minChunkLen</code>."}
{"code": "public void patch_splitMax(LinkedList<Patch> patches){\n  short patch_size=Match_MaxBits;\n  String precontext, postcontext;\n  Patch patch;\n  int start1, start2;\n  boolean empty;\n  Operation diff_type;\n  String diff_text;\n  ListIterator<Patch> pointer=patches.listIterator();\n  Patch bigpatch=pointer.hasNext() ? pointer.next() : null;\n  while (bigpatch != null) {\n    if (bigpatch.length1 <= Match_MaxBits) {\n      bigpatch=pointer.hasNext() ? pointer.next() : null;\n      continue;\n    }\n    pointer.remove();\n    start1=bigpatch.start1;\n    start2=bigpatch.start2;\n    precontext=\"\";\n    while (!bigpatch.diffs.isEmpty()) {\n      patch=new Patch();\n      empty=true;\n      patch.start1=start1 - precontext.length();\n      patch.start2=start2 - precontext.length();\n      if (precontext.length() != 0) {\n        patch.length1=patch.length2=precontext.length();\n        patch.diffs.add(new Diff(Operation.EQUAL,precontext));\n      }\n      while (!bigpatch.diffs.isEmpty() && patch.length1 < patch_size - Patch_Margin) {\n        diff_type=bigpatch.diffs.getFirst().operation;\n        diff_text=bigpatch.diffs.getFirst().text;\n        if (diff_type == Operation.INSERT) {\n          patch.length2+=diff_text.length();\n          start2+=diff_text.length();\n          patch.diffs.addLast(bigpatch.diffs.removeFirst());\n          empty=false;\n        }\n else         if (diff_type == Operation.DELETE && patch.diffs.size() == 1 && patch.diffs.getFirst().operation == Operation.EQUAL && diff_text.length() > 2 * patch_size) {\n          patch.length1+=diff_text.length();\n          start1+=diff_text.length();\n          empty=false;\n          patch.diffs.add(new Diff(diff_type,diff_text));\n          bigpatch.diffs.removeFirst();\n        }\n else {\n          diff_text=diff_text.substring(0,Math.min(diff_text.length(),patch_size - patch.length1 - Patch_Margin));\n          patch.length1+=diff_text.length();\n          start1+=diff_text.length();\n          if (diff_type == Operation.EQUAL) {\n            patch.length2+=diff_text.length();\n            start2+=diff_text.length();\n          }\n else {\n            empty=false;\n          }\n          patch.diffs.add(new Diff(diff_type,diff_text));\n          if (diff_text.equals(bigpatch.diffs.getFirst().text)) {\n            bigpatch.diffs.removeFirst();\n          }\n else {\n            bigpatch.diffs.getFirst().text=bigpatch.diffs.getFirst().text.substring(diff_text.length());\n          }\n        }\n      }\n      precontext=diff_text2(patch.diffs);\n      precontext=precontext.substring(Math.max(0,precontext.length() - Patch_Margin));\n      if (diff_text1(bigpatch.diffs).length() > Patch_Margin) {\n        postcontext=diff_text1(bigpatch.diffs).substring(0,Patch_Margin);\n      }\n else {\n        postcontext=diff_text1(bigpatch.diffs);\n      }\n      if (postcontext.length() != 0) {\n        patch.length1+=postcontext.length();\n        patch.length2+=postcontext.length();\n        if (!patch.diffs.isEmpty() && patch.diffs.getLast().operation == Operation.EQUAL) {\n          patch.diffs.getLast().text+=postcontext;\n        }\n else {\n          patch.diffs.add(new Diff(Operation.EQUAL,postcontext));\n        }\n      }\n      if (!empty) {\n        pointer.add(patch);\n      }\n    }\n    bigpatch=pointer.hasNext() ? pointer.next() : null;\n  }\n}\n", "nl": "Look through the patches and break up any which are longer than the maximum limit of the match algorithm. Intended to be called only from within patch_apply."}
{"code": "public static TestResult execJavac(String toCompile,File dir,String jflexTestVersion){\n  Project p=new Project();\n  Javac javac=new Javac();\n  Path path=new Path(p,dir.toString());\n  javac.setProject(p);\n  javac.setSrcdir(path);\n  javac.setDestdir(dir);\n  javac.setTarget(javaVersion);\n  javac.setSource(javaVersion);\n  javac.setSourcepath(new Path(p,\"\"));\n  javac.setIncludes(toCompile);\n  Path classPath=javac.createClasspath();\n  classPath.setPath(System.getProperty(\"user.home\") + \"/.m2/repository/de/jflex/jflex/\" + jflexTestVersion+ \"/jflex-\"+ jflexTestVersion+ \".jar\");\n  ByteArrayOutputStream out=new ByteArrayOutputStream();\n  PrintStream outSafe=System.err;\n  System.setErr(new PrintStream(out));\n  try {\n    javac.execute();\n    return new TestResult(out.toString(),true);\n  }\n catch (  BuildException e) {\n    return new TestResult(e + System.getProperty(\"line.separator\") + out.toString(),false);\n  }\n finally {\n    System.setErr(outSafe);\n  }\n}\n", "nl": "Call javac on toCompile in input dir. If toCompile is null,  all *.java files below dir will be compiled."}
{"code": "private void cloneProperties(BurpCertificate certificate,BurpCertificateBuilder burpCertificateBuilder){\n  burpCertificateBuilder.setVersion(certificate.getVersionNumber());\n  burpCertificateBuilder.setSerial(certificate.getSerialNumberBigInteger());\n  if (certificate.getPublicKeyAlgorithm().equals(\"RSA\")) {\n    burpCertificateBuilder.setSignatureAlgorithm(certificate.getSignatureAlgorithm());\n  }\n else {\n    burpCertificateBuilder.setSignatureAlgorithm(\"SHA256withRSA\");\n  }\n  burpCertificateBuilder.setIssuer(certificate.getIssuer());\n  burpCertificateBuilder.setNotAfter(certificate.getNotAfter());\n  burpCertificateBuilder.setNotBefore(certificate.getNotBefore());\n  burpCertificateBuilder.setKeySize(certificate.getKeySize());\n  for (  BurpCertificateExtension extension : certificate.getAllExtensions()) {\n    burpCertificateBuilder.addExtension(extension);\n  }\n}\n", "nl": "Copy all X.509v3 general information and all extensions 1:1 from one source certificat to one destination certificate."}
{"code": "protected void emit_PropertyMethodDeclaration_SemicolonKeyword_1_q(EObject semanticObject,ISynNavigable transition,List<INode> nodes){\n  acceptNodes(transition,nodes);\n}\n", "nl": "Ambiguous syntax: ';'? This ambiguous syntax occurs at: body=Block (ambiguity) (rule end) declaredName=LiteralOrComputedPropertyName '(' ')' (ambiguity) (rule end) fpars+=FormalParameter ')' (ambiguity) (rule end)"}
{"code": "public void runTest() throws Throwable {\n  Document doc;\n  Element rootNode;\n  Node newChild;\n  NodeList elementList;\n  Node oldChild;\n  Node replacedChild;\n  doc=(Document)load(\"hc_staff\",true);\n  newChild=doc.createAttribute(\"lang\");\n  elementList=doc.getElementsByTagName(\"p\");\n  oldChild=elementList.item(1);\n  rootNode=(Element)oldChild.getParentNode();\n{\n    boolean success=false;\n    try {\n      replacedChild=rootNode.replaceChild(newChild,oldChild);\n    }\n catch (    DOMException ex) {\n      success=(ex.code == DOMException.HIERARCHY_REQUEST_ERR);\n    }\n    assertTrue(\"throw_HIERARCHY_REQUEST_ERR\",success);\n  }\n}\n", "nl": "Runs the test case."}
{"code": "public void preComputeBestReplicaMapping(){\n  Map<String,Map<String,Map<String,String>>> collectionToShardToCoreMapping=getZkClusterData().getCollectionToShardToCoreMapping();\n  for (  String collection : collectionNames) {\n    Map<String,Map<String,String>> shardToCoreMapping=collectionToShardToCoreMapping.get(collection);\n    for (    String shard : shardToCoreMapping.keySet()) {\n      Map<String,String> coreToNodeMap=shardToCoreMapping.get(shard);\n      for (      String core : coreToNodeMap.keySet()) {\n        String currentCore=core;\n        String node=coreToNodeMap.get(core);\n        SolrCore currentReplica=new SolrCore(node,currentCore);\n        try {\n          currentReplica.loadStatus();\n          fillUpAllCoresForShard(currentReplica,coreToNodeMap);\n          break;\n        }\n catch (        Exception e) {\n          logger.info(ExceptionUtils.getFullStackTrace(e));\n          continue;\n        }\n      }\n      shardToBestReplicaMapping.put(shard,coreToBestReplicaMappingByHealth);\n    }\n  }\n}\n", "nl": "For all the collections in zookeeper, compute the best replica for every shard for every collection. Doing this computation at bootup significantly reduces the computation done during streaming."}
{"code": "private void statInit(){\n  lDocumentNo.setLabelFor(fDocumentNo);\n  fDocumentNo.setBackground(AdempierePLAF.getInfoBackground());\n  fDocumentNo.addActionListener(this);\n  lDescription.setLabelFor(fDescription);\n  fDescription.setBackground(AdempierePLAF.getInfoBackground());\n  fDescription.addActionListener(this);\n  lPOReference.setLabelFor(fPOReference);\n  fPOReference.setBackground(AdempierePLAF.getInfoBackground());\n  fPOReference.addActionListener(this);\n  fIsSOTrx.setSelected(!\"N\".equals(Env.getContext(Env.getCtx(),p_WindowNo,\"IsSOTrx\")));\n  fIsSOTrx.addActionListener(this);\n  fBPartner_ID=new VLookup(\"C_BPartner_ID\",false,false,true,MLookupFactory.get(Env.getCtx(),p_WindowNo,0,MColumn.getColumn_ID(MInOut.Table_Name,MInOut.COLUMNNAME_C_BPartner_ID),DisplayType.Search));\n  lBPartner_ID.setLabelFor(fBPartner_ID);\n  fBPartner_ID.setBackground(AdempierePLAF.getInfoBackground());\n  fBPartner_ID.addActionListener(this);\n  fShipper_ID=new VLookup(\"M_Shipper_ID\",false,false,true,MLookupFactory.get(Env.getCtx(),p_WindowNo,0,MColumn.getColumn_ID(MInOut.Table_Name,MInOut.COLUMNNAME_M_Shipper_ID),DisplayType.TableDir));\n  lShipper_ID.setLabelFor(fShipper_ID);\n  fShipper_ID.setBackground(AdempierePLAF.getInfoBackground());\n  fShipper_ID.addActionListener(this);\n  lDateFrom.setLabelFor(fDateFrom);\n  fDateFrom.setBackground(AdempierePLAF.getInfoBackground());\n  fDateFrom.setToolTipText(Msg.translate(Env.getCtx(),\"DateFrom\"));\n  fDateFrom.addActionListener(this);\n  lDateTo.setLabelFor(fDateTo);\n  fDateTo.setBackground(AdempierePLAF.getInfoBackground());\n  fDateTo.setToolTipText(Msg.translate(Env.getCtx(),\"DateTo\"));\n  fDateTo.addActionListener(this);\n  CPanel datePanel=new CPanel();\n  datePanel.setLayout(new ALayout(0,0,true));\n  datePanel.add(fDateFrom,new ALayoutConstraint(0,0));\n  datePanel.add(lDateTo,null);\n  datePanel.add(fDateTo,null);\n  p_criteriaGrid.add(lDocumentNo,new ALayoutConstraint(0,0));\n  p_criteriaGrid.add(fDocumentNo,null);\n  p_criteriaGrid.add(lBPartner_ID,null);\n  p_criteriaGrid.add(fBPartner_ID,null);\n  p_criteriaGrid.add(fIsSOTrx,new ALayoutConstraint(0,5));\n  p_criteriaGrid.add(lDescription,new ALayoutConstraint(1,0));\n  p_criteriaGrid.add(fDescription,null);\n  p_criteriaGrid.add(lDateFrom,null);\n  p_criteriaGrid.add(datePanel,null);\n  p_criteriaGrid.add(lPOReference,new ALayoutConstraint(2,0));\n  p_criteriaGrid.add(fPOReference,null);\n  p_criteriaGrid.add(lShipper_ID,null);\n  p_criteriaGrid.add(fShipper_ID,null);\n}\n", "nl": "Static Setup - add fields to parameterPanel"}
{"code": "@Override public boolean check(final CertificateToken certificateToken){\n  final boolean keyUsage=certificateToken.checkKeyUsage(bit);\n  return keyUsage == value;\n}\n", "nl": "Checks the condition for the given certificate."}
{"code": "public static boolean isValidFolderPath(Path path){\n  if (path == null) {\n    return false;\n  }\n  File f=path.toFile();\n  return path.toString().isEmpty() || (f.isDirectory() && f.canWrite());\n}\n", "nl": "Checks is the parameter path a valid for saving fixed file"}
{"code": "public float[][] extract(int maxFeatureValue,int[] distanceSet,int[][] img){\n  int[] histogram=new int[maxFeatureValue];\n  final int W=img.length;\n  final int H=img[0].length;\n  for (int x=0; x < W; x++) {\n    for (int y=0; y < H; y++) {\n      histogram[img[x][y]]++;\n    }\n  }\n  float[][] correlogram=new float[maxFeatureValue][distanceSet.length];\n  int[] tmpCorrelogram=new int[distanceSet.length];\n  for (int x=0; x < W; x++) {\n    for (int y=0; y < H; y++) {\n      int color=img[x][y];\n      getNumPixelsInNeighbourhood(x,y,img,tmpCorrelogram,maxFeatureValue,distanceSet);\n      for (int i=0; i < distanceSet.length; i++) {\n        correlogram[color][i]+=tmpCorrelogram[i];\n      }\n    }\n  }\n  float[] max=new float[distanceSet.length];\n  for (int c=0; c < maxFeatureValue; c++) {\n    for (int i=0; i < distanceSet.length; i++) {\n      max[i]=Math.max(correlogram[c][i],max[i]);\n    }\n  }\n  for (int c=0; c < maxFeatureValue; c++) {\n    for (int i=0; i < distanceSet.length; i++) {\n      correlogram[c][i]=correlogram[c][i] / max[i];\n    }\n  }\n  return correlogram;\n}\n", "nl": "extract extracts an auto-correlogram from an Image. This method create a cummulated auto-correlogram over different distances instead of standard method. Also, uses a different normalization method"}
{"code": "public static CC parseComponentConstraint(String s){\n  CC cc=new CC();\n  if (s.length() == 0) {\n    return cc;\n  }\n  String[] parts=toTrimmedTokens(s,',');\n  for (  String part : parts) {\n    try {\n      if (part.length() == 0) {\n        continue;\n      }\n      int ix=-1;\n      char c=part.charAt(0);\n      if (c == 'n') {\n        if (part.equals(\"north\")) {\n          cc.setDockSide(0);\n          continue;\n        }\n        if (part.equals(\"newline\")) {\n          cc.setNewline(true);\n          continue;\n        }\n        if (part.startsWith(\"newline \")) {\n          String gapSz=part.substring(7).trim();\n          cc.setNewlineGapSize(parseBoundSize(gapSz,true,true));\n          continue;\n        }\n      }\n      if (c == 'f' && (part.equals(\"flowy\") || part.equals(\"flowx\"))) {\n        cc.setFlowX(part.charAt(4) == 'x' ? Boolean.TRUE : Boolean.FALSE);\n        continue;\n      }\n      if (c == 's') {\n        ix=startsWithLenient(part,\"skip\",4,true);\n        if (ix > -1) {\n          String num=part.substring(ix).trim();\n          cc.setSkip(num.length() != 0 ? Integer.parseInt(num) : 1);\n          continue;\n        }\n        ix=startsWithLenient(part,\"split\",5,true);\n        if (ix > -1) {\n          String split=part.substring(ix).trim();\n          cc.setSplit(split.length() > 0 ? Integer.parseInt(split) : LayoutUtil.INF);\n          continue;\n        }\n        if (part.equals(\"south\")) {\n          cc.setDockSide(2);\n          continue;\n        }\n        ix=startsWithLenient(part,new String[]{\"spany\",\"sy\"},new int[]{5,2},true);\n        if (ix > -1) {\n          cc.setSpanY(parseSpan(part.substring(ix).trim()));\n          continue;\n        }\n        ix=startsWithLenient(part,new String[]{\"spanx\",\"sx\"},new int[]{5,2},true);\n        if (ix > -1) {\n          cc.setSpanX(parseSpan(part.substring(ix).trim()));\n          continue;\n        }\n        ix=startsWithLenient(part,\"span\",4,true);\n        if (ix > -1) {\n          String[] spans=toTrimmedTokens(part.substring(ix).trim(),' ');\n          cc.setSpanX(spans[0].length() > 0 ? Integer.parseInt(spans[0]) : LayoutUtil.INF);\n          cc.setSpanY(spans.length > 1 ? Integer.parseInt(spans[1]) : 1);\n          continue;\n        }\n        ix=startsWithLenient(part,\"shrinkx\",7,true);\n        if (ix > -1) {\n          cc.getHorizontal().setShrink(parseFloat(part.substring(ix).trim(),ResizeConstraint.WEIGHT_100));\n          continue;\n        }\n        ix=startsWithLenient(part,\"shrinky\",7,true);\n        if (ix > -1) {\n          cc.getVertical().setShrink(parseFloat(part.substring(ix).trim(),ResizeConstraint.WEIGHT_100));\n          continue;\n        }\n        ix=startsWithLenient(part,\"shrink\",6,false);\n        if (ix > -1) {\n          String[] shrinks=toTrimmedTokens(part.substring(ix).trim(),' ');\n          cc.getHorizontal().setShrink(parseFloat(part.substring(ix).trim(),ResizeConstraint.WEIGHT_100));\n          if (shrinks.length > 1) {\n            cc.getVertical().setShrink(parseFloat(part.substring(ix).trim(),ResizeConstraint.WEIGHT_100));\n          }\n          continue;\n        }\n        ix=startsWithLenient(part,new String[]{\"shrinkprio\",\"shp\"},new int[]{10,3},true);\n        if (ix > -1) {\n          String sp=part.substring(ix).trim();\n          if (sp.startsWith(\"x\") || sp.startsWith(\"y\")) {\n            (sp.startsWith(\"x\") ? cc.getHorizontal() : cc.getVertical()).setShrinkPriority(Integer.parseInt(sp.substring(2)));\n          }\n else {\n            String[] shrinks=toTrimmedTokens(sp,' ');\n            cc.getHorizontal().setShrinkPriority(Integer.parseInt(shrinks[0]));\n            if (shrinks.length > 1) {\n              cc.getVertical().setShrinkPriority(Integer.parseInt(shrinks[1]));\n            }\n          }\n          continue;\n        }\n        ix=startsWithLenient(part,new String[]{\"sizegroupx\",\"sizegroupy\",\"sgx\",\"sgy\"},new int[]{9,9,2,2},true);\n        if (ix > -1) {\n          String sg=part.substring(ix).trim();\n          char lc=part.charAt(ix - 1);\n          if (lc != 'y') {\n            cc.getHorizontal().setSizeGroup(sg);\n          }\n          if (lc != 'x') {\n            cc.getVertical().setSizeGroup(sg);\n          }\n          continue;\n        }\n      }\n      if (c == 'g') {\n        ix=startsWithLenient(part,\"growx\",5,true);\n        if (ix > -1) {\n          cc.getHorizontal().setGrow(parseFloat(part.substring(ix).trim(),ResizeConstraint.WEIGHT_100));\n          continue;\n        }\n        ix=startsWithLenient(part,\"growy\",5,true);\n        if (ix > -1) {\n          cc.getVertical().setGrow(parseFloat(part.substring(ix).trim(),ResizeConstraint.WEIGHT_100));\n          continue;\n        }\n        ix=startsWithLenient(part,\"grow\",4,false);\n        if (ix > -1) {\n          String[] grows=toTrimmedTokens(part.substring(ix).trim(),' ');\n          cc.getHorizontal().setGrow(parseFloat(grows[0],ResizeConstraint.WEIGHT_100));\n          cc.getVertical().setGrow(parseFloat(grows.length > 1 ? grows[1] : \"\",ResizeConstraint.WEIGHT_100));\n          continue;\n        }\n        ix=startsWithLenient(part,new String[]{\"growprio\",\"gp\"},new int[]{8,2},true);\n        if (ix > -1) {\n          String gp=part.substring(ix).trim();\n          char c0=gp.length() > 0 ? gp.charAt(0) : ' ';\n          if (c0 == 'x' || c0 == 'y') {\n            (c0 == 'x' ? cc.getHorizontal() : cc.getVertical()).setGrowPriority(Integer.parseInt(gp.substring(2)));\n          }\n else {\n            String[] grows=toTrimmedTokens(gp,' ');\n            cc.getHorizontal().setGrowPriority(Integer.parseInt(grows[0]));\n            if (grows.length > 1) {\n              cc.getVertical().setGrowPriority(Integer.parseInt(grows[1]));\n            }\n          }\n          continue;\n        }\n        if (part.startsWith(\"gap\")) {\n          BoundSize[] gaps=parseGaps(part);\n          if (gaps[0] != null) {\n            cc.getVertical().setGapBefore(gaps[0]);\n          }\n          if (gaps[1] != null) {\n            cc.getHorizontal().setGapBefore(gaps[1]);\n          }\n          if (gaps[2] != null) {\n            cc.getVertical().setGapAfter(gaps[2]);\n          }\n          if (gaps[3] != null) {\n            cc.getHorizontal().setGapAfter(gaps[3]);\n          }\n          continue;\n        }\n      }\n      if (c == 'a') {\n        ix=startsWithLenient(part,new String[]{\"aligny\",\"ay\"},new int[]{6,2},true);\n        if (ix > -1) {\n          cc.getVertical().setAlign(parseUnitValueOrAlign(part.substring(ix).trim(),false,null));\n          continue;\n        }\n        ix=startsWithLenient(part,new String[]{\"alignx\",\"ax\"},new int[]{6,2},true);\n        if (ix > -1) {\n          cc.getHorizontal().setAlign(parseUnitValueOrAlign(part.substring(ix).trim(),true,null));\n          continue;\n        }\n        ix=startsWithLenient(part,\"align\",2,true);\n        if (ix > -1) {\n          String[] gaps=toTrimmedTokens(part.substring(ix).trim(),' ');\n          cc.getHorizontal().setAlign(parseUnitValueOrAlign(gaps[0],true,null));\n          if (gaps.length > 1) {\n            cc.getVertical().setAlign(parseUnitValueOrAlign(gaps[1],false,null));\n          }\n          continue;\n        }\n      }\n      if ((c == 'x' || c == 'y') && part.length() > 2) {\n        char c2=part.charAt(1);\n        if (c2 == ' ' || (c2 == '2' && part.charAt(2) == ' ')) {\n          if (cc.getPos() == null) {\n            cc.setPos(new UnitValue[4]);\n          }\n else           if (cc.isBoundsInGrid() == false) {\n            throw new IllegalArgumentException(\"Cannot combine 'position' with 'x/y/x2/y2' keywords.\");\n          }\n          int edge=(c == 'x' ? 0 : 1) + (c2 == '2' ? 2 : 0);\n          UnitValue[] pos=cc.getPos();\n          pos[edge]=parseUnitValue(part.substring(2).trim(),null,c == 'x');\n          cc.setPos(pos);\n          cc.setBoundsInGrid(true);\n          continue;\n        }\n      }\n      if (c == 'c') {\n        ix=startsWithLenient(part,\"cell\",4,true);\n        if (ix > -1) {\n          String[] grs=toTrimmedTokens(part.substring(ix).trim(),' ');\n          if (grs.length < 2) {\n            throw new IllegalArgumentException(\"At least two integers must follow \" + part);\n          }\n          cc.setCellX(Integer.parseInt(grs[0]));\n          cc.setCellY(Integer.parseInt(grs[1]));\n          if (grs.length > 2) {\n            cc.setSpanX(Integer.parseInt(grs[2]));\n          }\n          if (grs.length > 3) {\n            cc.setSpanY(Integer.parseInt(grs[3]));\n          }\n          continue;\n        }\n      }\n      if (c == 'p') {\n        ix=startsWithLenient(part,\"pos\",3,true);\n        if (ix > -1) {\n          if (cc.getPos() != null && cc.isBoundsInGrid()) {\n            throw new IllegalArgumentException(\"Can not combine 'pos' with 'x/y/x2/y2' keywords.\");\n          }\n          String[] pos=toTrimmedTokens(part.substring(ix).trim(),' ');\n          UnitValue[] bounds=new UnitValue[4];\n          for (int j=0; j < pos.length; j++) {\n            bounds[j]=parseUnitValue(pos[j],null,j % 2 == 0);\n          }\n          if (bounds[0] == null && bounds[2] == null || bounds[1] == null && bounds[3] == null) {\n            throw new IllegalArgumentException(\"Both x and x2 or y and y2 can not be null!\");\n          }\n          cc.setPos(bounds);\n          cc.setBoundsInGrid(false);\n          continue;\n        }\n        ix=startsWithLenient(part,\"pad\",3,true);\n        if (ix > -1) {\n          UnitValue[] p=parseInsets(part.substring(ix).trim(),false);\n          cc.setPadding(new UnitValue[]{p[0],p.length > 1 ? p[1] : null,p.length > 2 ? p[2] : null,p.length > 3 ? p[3] : null});\n          continue;\n        }\n        ix=startsWithLenient(part,\"pushx\",5,true);\n        if (ix > -1) {\n          cc.setPushX(parseFloat(part.substring(ix).trim(),ResizeConstraint.WEIGHT_100));\n          continue;\n        }\n        ix=startsWithLenient(part,\"pushy\",5,true);\n        if (ix > -1) {\n          cc.setPushY(parseFloat(part.substring(ix).trim(),ResizeConstraint.WEIGHT_100));\n          continue;\n        }\n        ix=startsWithLenient(part,\"push\",4,false);\n        if (ix > -1) {\n          String[] pushs=toTrimmedTokens(part.substring(ix).trim(),' ');\n          cc.setPushX(parseFloat(pushs[0],ResizeConstraint.WEIGHT_100));\n          cc.setPushY(parseFloat(pushs.length > 1 ? pushs[1] : \"\",ResizeConstraint.WEIGHT_100));\n          continue;\n        }\n      }\n      if (c == 't') {\n        ix=startsWithLenient(part,\"tag\",3,true);\n        if (ix > -1) {\n          cc.setTag(part.substring(ix).trim());\n          continue;\n        }\n      }\n      if (c == 'w' || c == 'h') {\n        if (part.equals(\"wrap\")) {\n          cc.setWrap(true);\n          continue;\n        }\n        if (part.startsWith(\"wrap \")) {\n          String gapSz=part.substring(5).trim();\n          cc.setWrapGapSize(parseBoundSize(gapSz,true,true));\n          continue;\n        }\n        boolean isHor=c == 'w';\n        if (isHor && (part.startsWith(\"w \") || part.startsWith(\"width \"))) {\n          String uvStr=part.substring(part.charAt(1) == ' ' ? 2 : 6).trim();\n          cc.getHorizontal().setSize(parseBoundSize(uvStr,false,true));\n          continue;\n        }\n        if (!isHor && (part.startsWith(\"h \") || part.startsWith(\"height \"))) {\n          String uvStr=part.substring(part.charAt(1) == ' ' ? 2 : 7).trim();\n          cc.getVertical().setSize(parseBoundSize(uvStr,false,false));\n          continue;\n        }\n        if (part.startsWith(\"wmin \") || part.startsWith(\"wmax \") || part.startsWith(\"hmin \")|| part.startsWith(\"hmax \")) {\n          String uvStr=part.substring(5).trim();\n          if (uvStr.length() > 0) {\n            UnitValue uv=parseUnitValue(uvStr,null,isHor);\n            boolean isMin=part.charAt(3) == 'n';\n            DimConstraint dc=isHor ? cc.getHorizontal() : cc.getVertical();\n            dc.setSize(new BoundSize(isMin ? uv : dc.getSize().getMin(),dc.getSize().getPreferred(),isMin ? (dc.getSize().getMax()) : uv,uvStr));\n            continue;\n          }\n        }\n        if (part.equals(\"west\")) {\n          cc.setDockSide(1);\n          continue;\n        }\n        if (part.startsWith(\"hidemode \")) {\n          cc.setHideMode(Integer.parseInt(part.substring(9)));\n          continue;\n        }\n      }\n      if (c == 'i' && part.startsWith(\"id \")) {\n        cc.setId(part.substring(3).trim());\n        int dIx=cc.getId().indexOf('.');\n        if (dIx == 0 || dIx == cc.getId().length() - 1) {\n          throw new IllegalArgumentException(\"Dot must not be first or last!\");\n        }\n        continue;\n      }\n      if (c == 'e') {\n        if (part.equals(\"east\")) {\n          cc.setDockSide(3);\n          continue;\n        }\n        if (part.equals(\"external\")) {\n          cc.setExternal(true);\n          continue;\n        }\n        ix=startsWithLenient(part,new String[]{\"endgroupx\",\"endgroupy\",\"egx\",\"egy\"},new int[]{-1,-1,-1,-1},true);\n        if (ix > -1) {\n          String sg=part.substring(ix).trim();\n          char lc=part.charAt(ix - 1);\n          DimConstraint dc=(lc == 'x' ? cc.getHorizontal() : cc.getVertical());\n          dc.setEndGroup(sg);\n          continue;\n        }\n      }\n      if (c == 'd') {\n        if (part.equals(\"dock north\")) {\n          cc.setDockSide(0);\n          continue;\n        }\n        if (part.equals(\"dock west\")) {\n          cc.setDockSide(1);\n          continue;\n        }\n        if (part.equals(\"dock south\")) {\n          cc.setDockSide(2);\n          continue;\n        }\n        if (part.equals(\"dock east\")) {\n          cc.setDockSide(3);\n          continue;\n        }\n        if (part.equals(\"dock center\")) {\n          cc.getHorizontal().setGrow(new Float(100f));\n          cc.getVertical().setGrow(new Float(100f));\n          cc.setPushX(new Float(100f));\n          cc.setPushY(new Float(100f));\n          continue;\n        }\n      }\n      if (c == 'v') {\n        ix=startsWithLenient(part,new String[]{\"visualpadding\",\"vp\"},new int[]{3,2},true);\n        if (ix > -1) {\n          UnitValue[] p=parseInsets(part.substring(ix).trim(),false);\n          cc.setVisualPadding(new UnitValue[]{p[0],p.length > 1 ? p[1] : null,p.length > 2 ? p[2] : null,p.length > 3 ? p[3] : null});\n          continue;\n        }\n      }\n      UnitValue horAlign=parseAlignKeywords(part,true);\n      if (horAlign != null) {\n        cc.getHorizontal().setAlign(horAlign);\n        continue;\n      }\n      UnitValue verAlign=parseAlignKeywords(part,false);\n      if (verAlign != null) {\n        cc.getVertical().setAlign(verAlign);\n        continue;\n      }\n      throw new IllegalArgumentException(\"Unknown keyword.\");\n    }\n catch (    Exception ex) {\n      ex.printStackTrace();\n      throw new IllegalArgumentException(\"Error parsing Constraint: '\" + part + \"'\");\n    }\n  }\n  return cc;\n}\n", "nl": "Parses one component constraint and returns the parsed value."}
{"code": "SegmentTreeNode<?> computeRightChild(SegmentTreeNode<?> node){\n  if (node.right - node.left > 1) {\n    return constructor.construct((node.left + node.right) / 2,node.right);\n  }\n  return null;\n}\n", "nl": "Compute the right child node, if it exists"}
{"code": "public static boolean isValidIPAddress(String address){\n  if (address == null || address.length() == 0) {\n    return false;\n  }\n  boolean ipv6Expected=false;\n  if (address.charAt(0) == '[') {\n    if (address.length() > 2 && address.charAt(address.length() - 1) == ']') {\n      address=address.substring(1,address.length() - 1);\n      ipv6Expected=true;\n    }\n else {\n      return false;\n    }\n  }\n  if (Character.digit(address.charAt(0),16) != -1 || (address.charAt(0) == ':')) {\n    byte[] addr=null;\n    addr=strToIPv4(address);\n    if (addr == null) {\n      addr=strToIPv6(address);\n    }\n else     if (ipv6Expected) {\n      return false;\n    }\n    if (addr != null) {\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "Checks whether <tt>address</tt> is a valid IP address string."}
{"code": "private void loadVerticesAndRelatives(){\n  List<CnATreeElement> elementList=new LinkedList<CnATreeElement>();\n  for (  IGraphElementLoader loader : getLoaderList()) {\n    loader.setCnaTreeElementDao(getCnaTreeElementDao());\n    elementList.addAll(loader.loadElements());\n  }\n  for (  CnATreeElement element : elementList) {\n    graph.addVertex(element);\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Vertex added: \" + element.getTitle());\n    }\n    uuidMap.put(element.getUuid(),element);\n  }\n  for (  CnATreeElement parent : elementList) {\n    Set<CnATreeElement> children=parent.getChildren();\n    for (    CnATreeElement child : children) {\n      createParentChildEdge(parent,child);\n    }\n  }\n}\n", "nl": "Loads all vertices and adds them to the graph. An edge for each children is added if the child is part of the graph."}
{"code": "private void initializeLiveAttributes(){\n  transform=createLiveAnimatedTransformList(null,SVG_TRANSFORM_ATTRIBUTE,\"\");\n  externalResourcesRequired=createLiveAnimatedBoolean(null,SVG_EXTERNAL_RESOURCES_REQUIRED_ATTRIBUTE,false);\n}\n", "nl": "Initializes the live attribute values of this element."}
{"code": "public void putParcelable(String key,Parcelable value){\n  unparcel();\n  mMap.put(key,value);\n  mFdsKnown=false;\n}\n", "nl": "Inserts a Parcelable value into the mapping of this Bundle, replacing any existing value for the given key.  Either key or value may be null."}
{"code": "public static <T>Collection<T> flatten(Iterable<T> self,Closure<? extends T> flattenUsing){\n  return flatten(self,createSimilarCollection(self),flattenUsing);\n}\n", "nl": "Flatten an Iterable.  This Iterable and any nested arrays or collections have their contents (recursively) added to the new collection. For any non-Array, non-Collection object which represents some sort of collective type, the supplied closure should yield the contained items; otherwise, the closure should just return any element which corresponds to a leaf."}
{"code": "public double semiDeviation(){\n  return Math.sqrt(semiVariance());\n}\n", "nl": "returns the semi deviation, defined as the square root of the semi variance."}
{"code": "public Object runSafely(Catbert.FastStack stack) throws Exception {\n  String val=getString(stack);\n  Sage.put(getString(stack),val);\n  return null;\n}\n", "nl": "Sets the property with the specified name to the specified value. If this is called from a client instance then it will use the properties on the server system for this call and the change will be made on the server system."}
{"code": "protected Preference createUserDictionaryPreference(String locale,Activity activity){\n  final Preference newPref=new Preference(getActivity());\n  final Intent intent=new Intent(USER_DICTIONARY_SETTINGS_INTENT_ACTION);\n  if (null == locale) {\n    newPref.setTitle(Locale.getDefault().getDisplayName());\n  }\n else {\n    if (\"\".equals(locale))     newPref.setTitle(getString(R.string.user_dict_settings_all_languages));\n else     newPref.setTitle(Utils.createLocaleFromString(locale).getDisplayName());\n    intent.putExtra(\"locale\",locale);\n    newPref.getExtras().putString(\"locale\",locale);\n  }\n  newPref.setIntent(intent);\n  newPref.setFragment(com.android.settings.UserDictionarySettings.class.getName());\n  return newPref;\n}\n", "nl": "Create a single User Dictionary Preference object, with its parameters set."}
{"code": "public static <T>T withPrintWriter(Path self,@ClosureParams(value=SimpleType.class,options=\"java.io.PrintWriter\") Closure<T> closure) throws IOException {\n  return IOGroovyMethods.withWriter(newPrintWriter(self),closure);\n}\n", "nl": "Create a new PrintWriter for this file which is then passed it into the given closure.  This method ensures its the writer is closed after the closure returns."}
{"code": "public void testBug77649() throws Exception {\n  Properties props=getPropertiesFromTestsuiteUrl();\n  String host=props.getProperty(NonRegisteringDriver.HOST_PROPERTY_KEY);\n  String port=props.getProperty(NonRegisteringDriver.PORT_PROPERTY_KEY);\n  String[] hosts=new String[]{host,\"address\",\"address.somewhere\",\"addressing\",\"addressing.somewhere\"};\n  UnreliableSocketFactory.flushAllStaticData();\n  for (int i=1; i < hosts.length; i++) {\n    UnreliableSocketFactory.mapHost(hosts[i],host);\n  }\n  props=getHostFreePropertiesFromTestsuiteUrl();\n  props.setProperty(\"socketFactory\",UnreliableSocketFactory.class.getName());\n  for (  String h : hosts) {\n    getConnectionWithProps(String.format(\"jdbc:mysql://%s:%s\",h,port),props).close();\n    getConnectionWithProps(String.format(\"jdbc:mysql://address=(protocol=tcp)(host=%s)(port=%s)\",h,port),props).close();\n  }\n}\n", "nl": "Tests fix for Bug#77649 - URL start with word \"address\",JDBC can't parse the \"host:port\" Correctly."}
{"code": "public final Iterator<PluginPatternMatcher> pathsIterator(){\n  return mDataPaths != null ? mDataPaths.iterator() : null;\n}\n", "nl": "Return an iterator over the filter's data paths."}
{"code": "private void checkInMoving(float x,float y){\n  final int xDiff=(int)Math.abs(x - lastMotionX);\n  final int yDiff=(int)Math.abs(y - lastMotionY);\n  final int touchSlop=this.touchSlop;\n  boolean xMoved=xDiff > touchSlop;\n  boolean yMoved=yDiff > touchSlop;\n  if (xMoved) {\n    touchState=TOUCH_STATE_SCROLLING_X;\n    lastMotionX=x;\n    lastMotionY=y;\n  }\n  if (yMoved) {\n    touchState=TOUCH_STATE_SCROLLING_Y;\n    lastMotionX=x;\n    lastMotionY=y;\n  }\n}\n", "nl": "Check if the user is moving the cell"}
{"code": "public final boolean checkInstance(Instance instance){\n  if (instance.numAttributes() != numAttributes()) {\n    return false;\n  }\n  for (int i=0; i < numAttributes(); i++) {\n    if (instance.isMissing(i)) {\n      continue;\n    }\n else     if (attribute(i).isNominal() || attribute(i).isString()) {\n      if (!(Utils.eq(instance.value(i),(double)(int)instance.value(i)))) {\n        return false;\n      }\n else       if (Utils.sm(instance.value(i),0) || Utils.gr(instance.value(i),attribute(i).numValues())) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n", "nl": "Checks if the given instance is compatible with this dataset. Only looks at the size of the instance and the ranges of the values for  nominal and string attributes."}
{"code": "private static byte[] concatBytes(byte[] array1,byte[] array2){\n  byte[] cBytes=new byte[array1.length + array2.length];\n  try {\n    System.arraycopy(array1,0,cBytes,0,array1.length);\n    System.arraycopy(array2,0,cBytes,array1.length,array2.length);\n  }\n catch (  Exception e) {\n    throw new FacesException(e);\n  }\n  return cBytes;\n}\n", "nl": "This method concatenates two byte arrays"}
{"code": "void layout(int delta,boolean animate){\n  if (mDataChanged) {\n    handleDataChanged();\n  }\n  if (getCount() == 0) {\n    resetList();\n    return;\n  }\n  if (mNextSelectedPosition >= 0) {\n    setSelectedPositionInt(mNextSelectedPosition);\n  }\n  recycleAllViews();\n  detachAllViewsFromParent();\n  int count=getAdapter().getCount();\n  float angleUnit=360.0f / count;\n  float angleOffset=mSelectedPosition * angleUnit;\n  for (int i=0; i < getAdapter().getCount(); i++) {\n    float angle=angleUnit * i - angleOffset;\n    if (angle < 0.0f)     angle=360.0f + angle;\n    makeAndAddView(i,angle);\n  }\n  mRecycler.clear();\n  invalidate();\n  setNextSelectedPositionInt(mSelectedPosition);\n  checkSelectionChanged();\n  mNeedSync=false;\n  updateSelectedItemMetadata();\n}\n", "nl": "Setting up images."}
{"code": "private void updateMenuItems(boolean isGpsStarted,boolean isRecording){\n  boolean hasTrack=listView != null && listView.getCount() != 0;\n  if (startGpsMenuItem != null) {\n    startGpsMenuItem.setVisible(!isRecording);\n    if (!isRecording) {\n      startGpsMenuItem.setTitle(isGpsStarted ? R.string.menu_stop_gps : R.string.menu_start_gps);\n      startGpsMenuItem.setIcon(isGpsStarted ? R.drawable.ic_menu_stop_gps : R.drawable.ic_menu_start_gps);\n      TrackIconUtils.setMenuIconColor(startGpsMenuItem);\n    }\n  }\n  if (playMultipleItem != null) {\n    playMultipleItem.setVisible(hasTrack);\n  }\n  if (syncNowMenuItem != null) {\n    syncNowMenuItem.setTitle(driveSync ? R.string.menu_sync_now : R.string.menu_sync_drive);\n  }\n  if (aggregatedStatisticsMenuItem != null) {\n    aggregatedStatisticsMenuItem.setVisible(hasTrack);\n  }\n  if (exportAllMenuItem != null) {\n    exportAllMenuItem.setVisible(hasTrack && !isRecording);\n  }\n  if (importAllMenuItem != null) {\n    importAllMenuItem.setVisible(!isRecording);\n  }\n  if (deleteAllMenuItem != null) {\n    deleteAllMenuItem.setVisible(hasTrack && !isRecording);\n  }\n}\n", "nl": "Updates the menu items."}
{"code": "public boolean isDuplicateSupported(){\n  return duplicateSupported;\n}\n", "nl": "Indicates whether this connection request supports duplicate entries in the request queue"}
{"code": "public void onStart(){\n}\n", "nl": "Called when the animation starts."}
{"code": "public static int[][] loadPNMFile(InputStream str) throws IOException {\n  BufferedInputStream stream=new BufferedInputStream(str);\n  String type=tokenizeString(stream);\n  if (type.equals(\"P1\"))   return loadPlainPBM(stream);\n else   if (type.equals(\"P2\"))   return loadPlainPGM(stream);\n else   if (type.equals(\"P4\"))   return loadRawPBM(stream);\n else   if (type.equals(\"P5\"))   return loadRawPGM(stream);\n else   throw new IOException(\"Not a viable PBM or PGM stream\");\n}\n", "nl": "Loads plain or raw PGM files or plain or raw PBM files and return the result as an int[][]. The Y dimension is not flipped."}
{"code": "public BiCorpus alignedFromFiles(String f) throws IOException {\n  return new BiCorpus(fpath + f + extf,epath + f + exte,apath + f + exta);\n}\n", "nl": "Generate aligned BiCorpus."}
{"code": "public LognormalDistr(double shape,double scale){\n  numGen=new LogNormalDistribution(scale,shape);\n}\n", "nl": "Instantiates a new Log-normal pseudo random number generator."}
{"code": "private static String contentLengthHeader(final long length){\n  return String.format(\"Content-Length: %d\",length);\n}\n", "nl": "Format Content-Length header."}
{"code": "@Bean @ConditionalOnMissingBean public AmqpSenderService amqpSenderServiceBean(){\n  return new DefaultAmqpSenderService(rabbitTemplate());\n}\n", "nl": "Create default amqp sender service bean."}
{"code": "@Override protected void initialize(){\n  super.initialize();\n  m_Processor=new MarkdownProcessor();\n  m_Markdown=\"\";\n}\n", "nl": "Initializes the members."}
{"code": "public void upperBound(byte[] key) throws IOException {\n  upperBound(key,0,key.length);\n}\n", "nl": "Move the cursor to the first entry whose key is strictly greater than the input key. Synonymous to upperBound(key, 0, key.length). The entry returned by the previous entry() call will be invalid."}
{"code": "public static String replaceLast(String s,char sub,char with){\n  int index=s.lastIndexOf(sub);\n  if (index == -1) {\n    return s;\n  }\n  char[] str=s.toCharArray();\n  str[index]=with;\n  return new String(str);\n}\n", "nl": "Replaces the very last occurrence of a character in a string."}
{"code": "public static void main(String[] args){\n  Thrust simulation=new Thrust();\n  simulation.run();\n}\n", "nl": "Entry point for the example application."}
{"code": "public static <T>T checkNotNull(T reference,@Nullable String errorMessageTemplate,@Nullable Object... errorMessageArgs){\n  if (reference == null) {\n    throw new NullPointerException(format(errorMessageTemplate,errorMessageArgs));\n  }\n  return reference;\n}\n", "nl": "Ensures that an object reference passed as a parameter to the calling method is not null."}
{"code": "public boolean insert(String name,RegExp definition){\n  if (Options.DEBUG)   Out.debug(\"inserting macro \" + name + \" with definition :\"+ Out.NL+ definition);\n  used.put(name,Boolean.FALSE);\n  return macros.put(name,definition) == null;\n}\n", "nl": "Stores a new macro and its definition."}
{"code": "public boolean add(Object o){\n  ensureCapacity(size + 1);\n  elementData[size++]=o;\n  return true;\n}\n", "nl": "Appends the specified element to the end of this list."}
{"code": "public InvocationTargetException(Throwable target,String s){\n  super(s,null);\n  this.target=target;\n}\n", "nl": "Constructs a InvocationTargetException with a target exception and a detail message."}
{"code": "public boolean isExternalSkin(){\n  return !isDefaultSkin && mResources != null;\n}\n", "nl": "whether the skin being used is from external .skin file"}
{"code": "private void updateActions(){\n  actions.removeAll();\n  final ActionGroup mainActionGroup=(ActionGroup)actionManager.getAction(getGroupMenu());\n  if (mainActionGroup == null) {\n    return;\n  }\n  final Action[] children=mainActionGroup.getChildren(null);\n  for (  final Action action : children) {\n    final Presentation presentation=presentationFactory.getPresentation(action);\n    final ActionEvent e=new ActionEvent(ActionPlaces.MAIN_CONTEXT_MENU,presentation,actionManager,0);\n    action.update(e);\n    if (presentation.isVisible()) {\n      actions.add(action);\n    }\n  }\n}\n", "nl": "Updates the list of visible actions."}
{"code": "private void showFeedback(String message){\n  if (myHost != null) {\n    myHost.showFeedback(message);\n  }\n else {\n    System.out.println(message);\n  }\n}\n", "nl": "Used to communicate feedback pop-up messages between a plugin tool and the main Whitebox user-interface."}
{"code": "TechCategory fallthrough(){\nswitch (this) {\ncase OMNI_AERO:\n    return OMNI;\ncase CLAN_AERO:\ncase CLAN_VEE:\n  return CLAN;\ncase IS_ADVANCED_AERO:\ncase IS_ADVANCED_VEE:\nreturn IS_ADVANCED;\ndefault :\nreturn null;\n}\n}\n", "nl": "If no value is provided for ASFs or Vees, use the base value."}
{"code": "static void svd_dscal(int n,double da,double[] dx,int incx){\n  if (n <= 0 || incx == 0)   return;\n  int ix=(incx < 0) ? n - 1 : 0;\n  for (int i=0; i < n; i++) {\n    dx[ix]*=da;\n    ix+=incx;\n  }\n  return;\n}\n", "nl": "Function scales a vector by a constant. * Based on Fortran-77 routine from Linpack by J. Dongarra"}
{"code": "public CampoFechaVO insertValue(final CampoFechaVO value){\n  try {\n    DbConnection conn=getConnection();\n    DbInsertFns.insert(conn,TABLE_NAME,DbUtil.getColumnNames(COL_DEFS),new SigiaDbInputRecord(COL_DEFS,value));\n    return value;\n  }\n catch (  Exception e) {\n    logger.error(\"Error insertando campo de tipo fecha para el descriptor \" + value.getIdObjeto(),e);\n    throw new DBException(\"insertando campo de tipo fecha\",e);\n  }\n}\n", "nl": "Inserta un valor de tipo fecha."}
{"code": "private synchronized void closeActiveFile(){\n  StringWriterFile activeFile=this.activeFile;\n  try {\n    this.activeFile=null;\n    if (activeFile != null) {\n      activeFile.close();\n      getPolicy().closeActiveFile(activeFile.path());\n      activeFile=null;\n    }\n  }\n catch (  IOException e) {\n    trace.error(\"error closing active file '{}'\",activeFile.path(),e);\n  }\n}\n", "nl": "close, finalize, and apply retention policy"}
{"code": "public void testWARTypeEquality(){\n  WAR war1=new WAR(\"/some/path/to/file.war\");\n  WAR war2=new WAR(\"/otherfile.war\");\n  assertEquals(war1.getType(),war2.getType());\n}\n", "nl": "Test equality between WAR deployables."}
{"code": "public static Vector readSignatureAlgorithmsExtension(byte[] extensionData) throws IOException {\n  if (extensionData == null) {\n    throw new IllegalArgumentException(\"'extensionData' cannot be null\");\n  }\n  ByteArrayInputStream buf=new ByteArrayInputStream(extensionData);\n  Vector supported_signature_algorithms=parseSupportedSignatureAlgorithms(false,buf);\n  TlsProtocol.assertEmpty(buf);\n  return supported_signature_algorithms;\n}\n", "nl": "Read 'signature_algorithms' extension data."}
{"code": "public void updateNCharacterStream(int columnIndex,java.io.Reader x,long length) throws SQLException {\n  throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(\"jdbcrowsetimpl.featnotsupp\").toString());\n}\n", "nl": "Updates the designated column with a character stream value, which will have the specified number of bytes. The driver does the necessary conversion from Java character format to the national character set in the database. It is intended for use when updating NCHAR,NVARCHAR and LONGNVARCHAR columns. The updater methods are used to update column values in the current row or the insert row. The updater methods do not update the underlying database; instead the updateRow or insertRow methods are called to update the database."}
{"code": "public boolean isModified(){\n  return isCustom() && !isUserAdded();\n}\n", "nl": "Returns whether the receiver represents a modified template, i.e. a contributed template that has been changed."}
{"code": "public String toString(){\n  return this.getClass().getName() + \"(\" + my_k+ \")\";\n}\n", "nl": "Returns a String representation of the receiver."}
{"code": "private static PostingsEnum termDocs(IndexReader reader,Term term) throws IOException {\n  return MultiFields.getTermDocsEnum(reader,MultiFields.getLiveDocs(reader),term.field(),term.bytes());\n}\n", "nl": "NB: this is a convenient but very slow way of getting termDocs. It is sufficient for testing purposes."}
{"code": "public boolean isSubregion(){\n  return subregion;\n}\n", "nl": "Returns true if the Region is a subregion of a Component, otherwise false. For example, <code>Region.BUTTON</code> corresponds do a <code>Component</code> so that <code>Region.BUTTON.isSubregion()</code> returns false."}
{"code": "public static void encodeToFile(byte[] dataToEncode,String filename) throws java.io.IOException {\n  if (dataToEncode == null) {\n    throw new NullPointerException(\"Data to encode was null.\");\n  }\n  Base64.OutputStream bos=null;\n  try {\n    bos=new Base64.OutputStream(new java.io.FileOutputStream(filename),Base64.ENCODE);\n    bos.write(dataToEncode);\n  }\n catch (  java.io.IOException e) {\n    throw e;\n  }\n finally {\n    try {\n      bos.close();\n    }\n catch (    Exception e) {\n    }\n  }\n}\n", "nl": "Convenience method for encoding data to a file. <p>As of v 2.3, if there is a error, the method will throw an java.io.IOException. <b>This is new to v2.3!</b> In earlier versions, it just returned false, but in retrospect that's a pretty poor way to handle it.</p>"}
{"code": "public synchronized void addDataStatusListener(DataStatusListener l){\n  m_mTab.addDataStatusListener(l);\n}\n", "nl": "Add Data Status Listener - pass on to MTab"}
{"code": "protected void addField(DurationFieldType field,int value){\n  addFieldInto(iValues,field,value);\n}\n", "nl": "Adds the value of a field in this period."}
{"code": "@Override public int perimeter(int size){\n  size=size / 2;\n  int retval=sw.perimeter(size);\n  retval+=se.perimeter(size);\n  retval+=ne.perimeter(size);\n  retval+=nw.perimeter(size);\n  return retval;\n}\n", "nl": "Compute the perimeter for a grey node using Samet's algorithm."}
{"code": "public BigdataStatementIterator addedIterator(){\n  final IChunkedOrderedIterator<ISPO> src=new ChunkedWrappedIterator<ISPO>(added.iterator());\n  return new BigdataStatementIteratorImpl(kb,src).start(kb.getExecutorService());\n}\n", "nl": "Return iterator visiting the inferences that were added to the KB."}
{"code": "public <V extends Object,C extends RTSpan<V>>void applyEffect(Effect<V,C> effect,V value){\n  if (mUseRTFormatting && !mIsSelectionChanging && !mIsSaving) {\n    Spannable oldSpannable=mIgnoreTextChanges ? null : cloneSpannable();\n    effect.applyToSelection(this,value);\nsynchronized (this) {\n      if (mListener != null && !mIgnoreTextChanges) {\n        Spannable newSpannable=cloneSpannable();\n        mListener.onTextChanged(this,oldSpannable,newSpannable,getSelectionStart(),getSelectionEnd(),getSelectionStart(),getSelectionEnd());\n      }\n      mLayoutChanged=true;\n    }\n  }\n}\n", "nl": "Call this to have an effect applied to the current selection. You get the Effect object via the static data members (e.g., RTEditText.BOLD). The value for most effects is a Boolean, indicating whether to add or remove the effect."}
{"code": "public DefaultLmlParser(final LmlData data,final LmlSyntax syntax,final LmlTemplateReader templateReader,final boolean strict){\n  super(data,syntax,templateReader,new DefaultLmlStyleSheet(),strict);\n}\n", "nl": "Creates a new parser with custom syntax, reader and strict setting."}
{"code": "private static void populateFancy(SQLiteDatabase writableDb){\n  long startOfToday=DateUtil.parse(DateUtil.format(System.currentTimeMillis()));\n  ItemDao.saveItem(writableDb,new Item(Item.TYPE_EXPENSE,\"Clothes\",\"New jeans\",10000,startOfToday,Item.NO_ID));\n  ItemDao.saveItem(writableDb,new Item(Item.TYPE_EXPENSE,\"Flat / House\",\"Monthly rent\",35000,startOfToday,Item.NO_ID));\n  ItemDao.saveItem(writableDb,new Item(Item.TYPE_EXPENSE,\"Grocery\",\"Fruits & vegetables\",3567,DateUtil.parse(\"19/08/2015\"),Item.NO_ID));\n  ItemDao.saveItem(writableDb,new Item(Item.TYPE_EXPENSE,\"Fuel\",\"Full gas tank\",7590,DateUtil.parse(\"14/08/2015\"),Item.NO_ID));\n  ItemDao.saveItem(writableDb,new Item(Item.TYPE_EXPENSE,\"Clothes\",\"New shirt\",3599,DateUtil.parse(\"11/08/2015\"),Item.NO_ID));\n  ItemDao.saveItem(writableDb,new Item(Item.TYPE_EXPENSE,\"Restaurant\",\"Family get together\",3691,DateUtil.parse(\"05/08/2015\"),Item.NO_ID));\n  ItemDao.saveItem(writableDb,new Item(Item.TYPE_INCOME,\"Salary\",\"\",90000,DateUtil.parse(\"31/07/2015\"),Item.NO_ID));\n  ItemDao.saveItem(writableDb,new Item(Item.TYPE_EXPENSE,\"Personal care\",\"New perfume\",3865,DateUtil.parse(\"29/07/2015\"),Item.NO_ID));\n  ItemDao.saveItem(writableDb,new Item(Item.TYPE_EXPENSE,\"Grocery\",\"Bottle of milk\",345,DateUtil.parse(\"26/07/2015\"),Item.NO_ID));\n}\n", "nl": "Generates reasonable amount of good-looking income / expense items."}
{"code": "public TestEntity(int index,String text,String value,double minConfidence){\n  super(index,text);\n  this.value=value;\n  this.minConfidence=minConfidence;\n}\n", "nl": "New instance, with a value."}
{"code": "public boolean contains(JComponent a,int b,int c){\n  boolean returnValue=((ComponentUI)(uis.elementAt(0))).contains(a,b,c);\n  for (int i=1; i < uis.size(); i++) {\n    ((ComponentUI)(uis.elementAt(i))).contains(a,b,c);\n  }\n  return returnValue;\n}\n", "nl": "Invokes the <code>contains</code> method on each UI handled by this object."}
{"code": "public boolean isClosed(){\n  return closed;\n}\n", "nl": "Returns true if this contour path is closed (loops back on itself) or false if it is not."}
{"code": "public void store(float val,Offset offset){\n  this.plus(offset).store(val);\n}\n", "nl": "Stores the float value in the memory location pointed to by the current instance."}
{"code": "public List<IvrZone> showIvrZones(boolean active) throws NetworkDeviceControllerException {\n  List<IvrZone> zones=new ArrayList<IvrZone>();\n  SSHPrompt[] prompts={SSHPrompt.POUND,SSHPrompt.GREATER_THAN};\n  StringBuilder buf=new StringBuilder();\n  String cmdKey=active ? \"MDSDialog.ivr.show.zone.active.cmd\" : \"MDSDialog.ivr.show.zone.cmd\";\n  sendWaitFor(MDSDialogProperties.getString(cmdKey),defaultTimeout,prompts,buf);\n  String[] lines=getLines(buf);\n  IvrZone zone=null;\n  IvrZoneMember member=null;\n  String[] regex={MDSDialogProperties.getString(\"MDSDialog.ivr.showZoneset.zone.name.match\"),MDSDialogProperties.getString(\"MDSDialog.ivr.showZoneset.zone.member.match\")};\n  String[] groups=new String[10];\n  for (  String line : lines) {\n    int index=match(line,regex,groups);\nswitch (index) {\ncase 0:\n      zone=new IvrZone(groups[0]);\n    zones.add(zone);\n  break;\ncase 1:\nmember=new IvrZoneMember(groups[0],Integer.valueOf(groups[3]));\nzone.getMembers().add(member);\nbreak;\n}\n}\nreturn zones;\n}\n", "nl": "Get switch ivr zones"}
{"code": "public static void append(File file,Reader reader,String charset) throws IOException {\n  append(file,reader,charset,false);\n}\n", "nl": "Append the text supplied by the Reader at the end of the File without writing a BOM, using a specified encoding."}
{"code": "public static LifetimeAttribute createLifetimeAttribute(int lifetime){\n  LifetimeAttribute attribute=new LifetimeAttribute();\n  attribute.setLifetime(lifetime);\n  return attribute;\n}\n", "nl": "Create a LifetimeAttribute."}
{"code": "public void testFilePrimary() throws Exception {\n  start();\n  igfsPrimary.create(FILE,true).close();\n  checkEvictionPolicy(0,0);\n  int blockSize=igfsPrimary.info(FILE).blockSize();\n  append(FILE,blockSize);\n  checkEvictionPolicy(0,0);\n  read(FILE,0,blockSize);\n  checkEvictionPolicy(0,0);\n}\n", "nl": "Test how evictions are handled for a file working in PRIMARY mode."}
{"code": "public static String createTestPtStationCSVFile(File file){\n  try (BufferedWriter bw=new BufferedWriter(new FileWriter(file))){\n    bw.write(\"id,x,y\");\n    bw.newLine();\n    bw.write(\"1,10,10\");\n    bw.newLine();\n    bw.write(\"2,10, 190\");\n    bw.newLine();\n    bw.write(\"3,190,190\");\n    bw.newLine();\n    bw.write(\"4,190,10\");\n    bw.newLine();\n    return file.getCanonicalPath();\n  }\n catch (  IOException e) {\n    throw new RuntimeException(e);\n  }\n}\n", "nl": "This method creates 4 pt stops for the test network from createTestNetwork(). The information about the coordinates will be written to a csv file. The 4 pt stops are located as a square in the coordinate plane with a side length of 180 meter (see the sketch below)."}
{"code": "@Override public int hashCode(){\n  int result=super.hashCode();\n  return result;\n}\n", "nl": "Returns a hash code for the renderer."}
{"code": "@Override public void eUnset(int featureID){\nswitch (featureID) {\ncase SGenPackage.FEATURE_TYPE__DEPRECATED:\n    setDeprecated(DEPRECATED_EDEFAULT);\n  return;\ncase SGenPackage.FEATURE_TYPE__COMMENT:\nsetComment(COMMENT_EDEFAULT);\nreturn;\ncase SGenPackage.FEATURE_TYPE__PARAMETERS:\ngetParameters().clear();\nreturn;\ncase SGenPackage.FEATURE_TYPE__OPTIONAL:\nsetOptional(OPTIONAL_EDEFAULT);\nreturn;\n}\nsuper.eUnset(featureID);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public boolean isVMAX3VolumeCompressionEnabled(URI blockObjectURI){\n  VirtualPool virtualPool=null;\n  Volume volume=null;\n  if (URIUtil.isType(blockObjectURI,Volume.class)) {\n    volume=_dbClient.queryObject(Volume.class,blockObjectURI);\n  }\n else   if (URIUtil.isType(blockObjectURI,BlockSnapshot.class)) {\n    BlockSnapshot snapshot=_dbClient.queryObject(BlockSnapshot.class,blockObjectURI);\n    volume=_dbClient.queryObject(Volume.class,snapshot.getParent());\n  }\n else   if (URIUtil.isType(blockObjectURI,BlockMirror.class)) {\n    BlockMirror mirror=_dbClient.queryObject(BlockMirror.class,blockObjectURI);\n    virtualPool=_dbClient.queryObject(VirtualPool.class,mirror.getVirtualPool());\n  }\n  if (volume != null) {\n    virtualPool=_dbClient.queryObject(VirtualPool.class,volume.getVirtualPool());\n  }\n  return ((virtualPool != null) && virtualPool.getCompressionEnabled());\n}\n", "nl": "This method is will check if the volume associated with virtual Pool has compression enabled."}
{"code": "public void releaseConnection(Database conn){\n  if (conn != null)   conn.close();\n}\n", "nl": "Releases a connection."}
{"code": "public final void testRemoveHelperTextId(){\n  PasswordEditText passwordEditText=new PasswordEditText(getContext());\n  passwordEditText.addHelperTextId(android.R.string.cancel);\n  passwordEditText.addHelperTextId(android.R.string.copy);\n  passwordEditText.removeHelperTextId(android.R.string.cancel);\n  passwordEditText.removeHelperTextId(android.R.string.cancel);\n  assertEquals(1,passwordEditText.getHelperTexts().size());\n  assertEquals(getContext().getText(android.R.string.copy),passwordEditText.getHelperTexts().iterator().next());\n}\n", "nl": "Tests the functionality of the method, which allows to remove a helper text by its id."}
{"code": "private void logMessage(String msg,Object[] obj){\n  if (getMonitoringPropertiesLoader().isToLogIndications()) {\n    _logger.debug(msg,obj);\n  }\n}\n", "nl": "Log the messages. This method eliminates the logging condition check every time when we need to log a message."}
{"code": "public static Float toRef(float f){\n  return new Float(f);\n}\n", "nl": "cast a float value to his (CFML) reference type Float"}
{"code": "@Override protected boolean shouldComposeCreationImage(){\n  return true;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public synchronized void promote(Tile tile){\n  if (tileQueue.contains(tile)) {\n    try {\n      tileQueue.remove(tile);\n      tile.setPriority(Tile.Priority.High);\n      tileQueue.put(tile);\n    }\n catch (    Exception ex) {\n      ex.printStackTrace();\n    }\n  }\n}\n", "nl": "Increase the priority of this tile so it will be loaded sooner."}
{"code": "public void exitApp(){\n  this.webView.getPluginManager().postMessage(\"exit\",null);\n}\n", "nl": "Exit the Android application."}
{"code": "public void test_getInnerCause01_reject_otherType(){\n  Throwable t=new Throwable();\n  assertNull(getInnerCause(t,Exception.class));\n}\n", "nl": "Does not find cause when it is on top of the stack trace and not either the desired type or a subclass of the desired type."}
{"code": "public Handshake handshake(){\n  return handshake;\n}\n", "nl": "Returns the TLS handshake of the connection that carried this response, or null if the response was received without TLS."}
{"code": "private Coordinate averagePoint(CoordinateSequence seq){\n  Coordinate a=new Coordinate(0,0,0);\n  int n=seq.size();\n  for (int i=0; i < n; i++) {\n    a.x+=seq.getOrdinate(i,CoordinateSequence.X);\n    a.y+=seq.getOrdinate(i,CoordinateSequence.Y);\n    a.z+=seq.getOrdinate(i,CoordinateSequence.Z);\n  }\n  a.x/=n;\n  a.y/=n;\n  a.z/=n;\n  return a;\n}\n", "nl": "Computes a point which is the average of all coordinates in a sequence. If the sequence lies in a single plane, the computed point also lies in the plane."}
{"code": "public static void invokeWebserviceASync(WSDefinition def,SuccessCallback scall,FailureCallback fcall,Object... arguments){\n  WSConnection cr=new WSConnection(def,scall,fcall,arguments);\n  NetworkManager.getInstance().addToQueue(cr);\n}\n", "nl": "Invokes a web asynchronously and calls the callback on completion"}
{"code": "public PutResponseMessage(PutResponseMessage other){\n  if (other.isSetHeader()) {\n    this.header=new AsyncMessageHeader(other.header);\n  }\n}\n", "nl": "Performs a deep copy on <i>other</i>."}
{"code": "private boolean isSynthetic(Method m){\n  if ((m.getAccessFlags() & Constants.ACC_SYNTHETIC) != 0) {\n    return true;\n  }\n  Attribute[] attrs=m.getAttributes();\n  for (  Attribute attr : attrs) {\n    if (attr instanceof Synthetic) {\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "Methods marked with the \"Synthetic\" attribute do not appear in the source code"}
{"code": "public boolean isTagline(){\n  return tagline;\n}\n", "nl": "Checks if is tagline."}
{"code": "protected LocaTable(TrueTypeFont ttf){\n  super(TrueTypeTable.LOCA_TABLE);\n  MaxpTable maxp=(MaxpTable)ttf.getTable(\"maxp\");\n  int numGlyphs=maxp.getNumGlyphs();\n  HeadTable head=(HeadTable)ttf.getTable(\"head\");\n  short format=head.getIndexToLocFormat();\n  isLong=(format == 1);\n  offsets=new int[numGlyphs + 1];\n}\n", "nl": "Creates a new instance of HmtxTable"}
{"code": "public static <T>T create(Class<T> theQueryClass){\n  return AgentClass.createAgent(theQueryClass);\n}\n", "nl": "Create a database query dynamically"}
{"code": "@DSComment(\"From safe class list\") @DSSafe(DSCat.SAFE_LIST) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 13:02:44.163 -0500\",hash_original_method=\"CE28B7D5A93F674A0286463AAF68C789\",hash_generated_method=\"4C5D61097E13A407D793E43190510D41\") public synchronized void addFailure(Test test,AssertionFailedError t){\n  fFailures.addElement(new TestFailure(test,t));\n  for (Enumeration e=cloneListeners().elements(); e.hasMoreElements(); ) {\n    ((TestListener)e.nextElement()).addFailure(test,t);\n  }\n}\n", "nl": "Adds a failure to the list of failures. The passed in exception caused the failure."}
{"code": "public ExtendedKeyUsage(byte[] encoding){\n  super(encoding);\n}\n", "nl": "Creates the extension object on the base of its encoded form."}
{"code": "public Iterator<E> subsetIterator(E from,E to){\n  return new BinarySearchTreeIterator<E>(this.root,from,to);\n}\n", "nl": "Returns the in-order (ascending) iterator."}
{"code": "public int valueForXPosition(int xPos){\n  int value;\n  int minValue=slider.getMinimum();\n  int maxValue=slider.getMaximum();\n  int trackLeft=trackRect.x + thumbRect.width / 2 + trackBorder;\n  int trackRight=trackRect.x + trackRect.width - thumbRect.width / 2 - trackBorder;\n  int trackLength=trackRight - trackLeft;\n  if (xPos <= trackLeft) {\n    value=drawInverted() ? maxValue : minValue;\n  }\n else   if (xPos >= trackRight) {\n    value=drawInverted() ? minValue : maxValue;\n  }\n else {\n    int distanceFromTrackLeft=xPos - trackLeft;\n    double valueRange=(double)maxValue - (double)minValue;\n    double valuePerPixel=valueRange / (double)trackLength;\n    int valueFromTrackLeft=(int)Math.round(distanceFromTrackLeft * valuePerPixel);\n    value=drawInverted() ? maxValue - valueFromTrackLeft : minValue + valueFromTrackLeft;\n  }\n  return value;\n}\n", "nl": "Returns a value give an x position. If xPos is past the track at the left or the right it will set the value to the min or max of the slider, depending if the slider is inverted or not."}
{"code": "@Override protected EClass eStaticClass(){\n  return SRuntimePackage.Literals.COMPOSITE_SLOT;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public static void main(final String[] args){\n  DOMTestCase.doMain(documentcreateattributeNS03.class,args);\n}\n", "nl": "Runs this test from the command line."}
{"code": "public ListIterator<AbstractInsnNode> iterator(){\n  return iterator(0);\n}\n", "nl": "Returns an iterator over the instructions in this list."}
{"code": "public static String escapeXml(String str){\n  if (str == null) {\n    return null;\n  }\n  return EntitiesUtils.XML.escape(str);\n}\n", "nl": "<p>Escapes the characters in a <code>String</code> using XML entities.</p> <p>For example: <tt>\"bread\" & \"butter\"</tt> => <tt>&amp;quot;bread&amp;quot; &amp;amp; &amp;quot;butter&amp;quot;</tt>. </p> <p>Supports only the five basic XML entities (gt, lt, quot, amp, apos). Does not support DTDs or external entities.</p> <p>Note that unicode characters greater than 0x7f are currently escaped to  their numerical \\\\u equivalent. This may change in future releases. </p>"}
{"code": "public boolean isProcessed(){\n  Object oo=get_Value(COLUMNNAME_Processed);\n  if (oo != null) {\n    if (oo instanceof Boolean)     return ((Boolean)oo).booleanValue();\n    return \"Y\".equals(oo);\n  }\n  return false;\n}\n", "nl": "Get Processed."}
{"code": "public void processResponse(SIPResponse response,MessageChannel incomingMessageChannel,SIPDialog dialog){\n  if (sipStack.isLoggingEnabled()) {\n    sipStack.getStackLogger().logDebug(\"PROCESSING INCOMING RESPONSE\" + response.encodeMessage());\n  }\n  if (listeningPoint == null) {\n    if (sipStack.isLoggingEnabled())     sipStack.getStackLogger().logError(\"Dropping message: No listening point\" + \" registered!\");\n    return;\n  }\n  if (sipStack.checkBranchId() && !Utils.getInstance().responseBelongsToUs(response)) {\n    if (sipStack.isLoggingEnabled()) {\n      sipStack.getStackLogger().logError(\"Dropping response - topmost VIA header does not originate from this stack\");\n    }\n    return;\n  }\n  SipProviderImpl sipProvider=listeningPoint.getProvider();\n  if (sipProvider == null) {\n    if (sipStack.isLoggingEnabled()) {\n      sipStack.getStackLogger().logError(\"Dropping message:  no provider\");\n    }\n    return;\n  }\n  if (sipProvider.getSipListener() == null) {\n    if (sipStack.isLoggingEnabled()) {\n      sipStack.getStackLogger().logError(\"No listener -- dropping response!\");\n    }\n    return;\n  }\n  SIPClientTransaction transaction=(SIPClientTransaction)this.transactionChannel;\n  SipStackImpl sipStackImpl=sipProvider.sipStack;\n  if (sipStack.isLoggingEnabled()) {\n    sipStackImpl.getStackLogger().logDebug(\"Transaction = \" + transaction);\n  }\n  if (transaction == null) {\n    if (dialog != null) {\n      if (response.getStatusCode() / 100 != 2) {\n        if (sipStack.isLoggingEnabled()) {\n          sipStack.getStackLogger().logDebug(\"Response is not a final response and dialog is found for response -- dropping response!\");\n        }\n        return;\n      }\n else       if (dialog.getState() == DialogState.TERMINATED) {\n        if (sipStack.isLoggingEnabled()) {\n          sipStack.getStackLogger().logDebug(\"Dialog is terminated -- dropping response!\");\n        }\n        return;\n      }\n else {\n        boolean ackAlreadySent=false;\n        if (dialog.isAckSeen() && dialog.getLastAckSent() != null) {\n          if (dialog.getLastAckSent().getCSeq().getSeqNumber() == response.getCSeq().getSeqNumber()) {\n            ackAlreadySent=true;\n          }\n        }\n        if (ackAlreadySent && response.getCSeq().getMethod().equals(dialog.getMethod())) {\n          try {\n            if (sipStack.isLoggingEnabled()) {\n              sipStack.getStackLogger().logDebug(\"Retransmission of OK detected: Resending last ACK\");\n            }\n            dialog.resendAck();\n            return;\n          }\n catch (          SipException ex) {\n            if (sipStack.isLoggingEnabled())             sipStack.getStackLogger().logError(\"could not resend ack\",ex);\n          }\n        }\n      }\n    }\n    if (sipStack.isLoggingEnabled()) {\n      sipStack.getStackLogger().logDebug(\"could not find tx, handling statelessly Dialog =  \" + dialog);\n    }\n    ResponseEventExt sipEvent=new ResponseEventExt(sipProvider,transaction,dialog,(Response)response);\n    if (response.getCSeqHeader().getMethod().equals(Request.INVITE)) {\n      SIPClientTransaction forked=this.sipStack.getForkedTransaction(response.getTransactionId());\n      sipEvent.setOriginalTransaction(forked);\n    }\n    sipProvider.handleEvent(sipEvent,transaction);\n    return;\n  }\n  ResponseEventExt responseEvent=null;\n  responseEvent=new ResponseEventExt(sipProvider,(ClientTransactionExt)transaction,dialog,(Response)response);\n  if (response.getCSeqHeader().getMethod().equals(Request.INVITE)) {\n    SIPClientTransaction forked=this.sipStack.getForkedTransaction(response.getTransactionId());\n    responseEvent.setOriginalTransaction(forked);\n  }\n  if (dialog != null && response.getStatusCode() != 100) {\n    dialog.setLastResponse(transaction,response);\n    transaction.setDialog(dialog,dialog.getDialogId());\n  }\n  sipProvider.handleEvent(responseEvent,transaction);\n}\n", "nl": "Process the response."}
{"code": "public AnnotationAtttributeProposalInfo(IJavaProject project,CompletionProposal proposal){\n  super(project,proposal);\n}\n", "nl": "Creates a new proposal info."}
{"code": "public static void restoreReminderPreference(Context context){\n  int hour=MehPreferencesManager.getNotificationPreferenceHour(context);\n  int minute=MehPreferencesManager.getNotificationPreferenceMinute(context);\n  scheduleDailyReminder(context,hour,minute);\n}\n", "nl": "Restore the daily reminder, with the times already in preferences. Useful for device reboot or switched on from the settings screen"}
{"code": "@Override public boolean isActive(){\n  return amIActive;\n}\n", "nl": "Used by the Whitebox GUI to tell if this plugin is still running."}
{"code": "BarChart(){\n}\n", "nl": "Instantiates a new bar chart."}
{"code": "public boolean isTransactionRelevant(Transaction tx) throws ScriptException {\n  lock.lock();\n  try {\n    return tx.getValueSentFromMe(this).signum() > 0 || tx.getValueSentToMe(this).signum() > 0 || !findDoubleSpendsAgainst(tx,transactions).isEmpty();\n  }\n  finally {\n    lock.unlock();\n  }\n}\n", "nl": "<p>Returns true if the given transaction sends coins to any of our keys, or has inputs spending any of our outputs, and also returns true if tx has inputs that are spending outputs which are not ours but which are spent by pending transactions.</p> <p>Note that if the tx has inputs containing one of our keys, but the connected transaction is not in the wallet, it will not be considered relevant.</p>"}
{"code": "public void free(GL2 gl){\n  if (vbos[0] >= 0) {\n    gl.glDeleteBuffers(1,vbos,0);\n  }\n  vbos[0]=-1;\n}\n", "nl": "Free all memory allocations."}
{"code": "public Vector3(float x,float y,float z){\n  this.set(x,y,z);\n}\n", "nl": "Creates a vector with the given components"}
{"code": "protected S_ActionImpl(){\n  super();\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public void clear(int maximumCapacity){\n  if (capacity <= maximumCapacity) {\n    clear();\n    return;\n  }\n  zeroValue=null;\n  hasZeroValue=false;\n  size=0;\n  resize(maximumCapacity);\n}\n", "nl": "Clears the map and reduces the size of the backing arrays to be the specified capacity if they are larger."}
{"code": "public void bulkLoad(DBIDs ids){\n  if (ids.size() == 0) {\n    return;\n  }\n  assert (root == null) : \"Tree already initialized.\";\n  DBIDIter it=ids.iter();\n  DBID first=DBIDUtil.deref(it);\n  ModifiableDoubleDBIDList candidates=DBIDUtil.newDistanceDBIDList(ids.size() - 1);\n  for (it.advance(); it.valid(); it.advance()) {\n    candidates.add(distance(first,it),it);\n  }\n  root=bulkConstruct(first,Integer.MAX_VALUE,candidates);\n}\n", "nl": "Bulk-load the index."}
{"code": "protected ExtendedSolrQueryParser createEdismaxQueryParser(QParser qParser,String field){\n  return new ExtendedSolrQueryParser(qParser,field);\n}\n", "nl": "Creates an instance of ExtendedSolrQueryParser, the query parser that's going to be used to parse the query."}
{"code": "protected void appendSummary(StringBuffer buffer,String fieldName,long[] array){\n  appendSummarySize(buffer,fieldName,array.length);\n}\n", "nl": "<p>Append to the <code>toString</code> a summary of a <code>long</code> array.</p>"}
{"code": "protected UndoableEdit editToBeRedone(){\n  int count=edits.size();\n  int i=indexOfNextAdd;\n  while (i < count) {\n    UndoableEdit edit=edits.elementAt(i++);\n    if (edit.isSignificant()) {\n      return edit;\n    }\n  }\n  return null;\n}\n", "nl": "Returns the the next significant edit to be redone if <code>redo</code> is invoked. This returns <code>null</code> if there are no edits to be redone."}
{"code": "public void actionPerformed(ActionEvent e){\n  Box b1=Box.createVerticalBox();\n  Version currentVersion=Version.currentViewableVersion();\n  String copyright=LicenseUtils.copyright();\n  copyright=copyright.replaceAll(\"\\n\",\"<br>\");\n  String latestVersion=LatestClient.getInstance().getLatestResult(60);\n  latestVersion=latestVersion.replaceAll(\"\\n\",\"<br>\");\n  JLabel label=new JLabel();\n  label.setText(\"<html>\" + \"<b>Tetrad \" + currentVersion + \"</b>\"+ \"<br>\"+ \"<br>Laboratory for Symbolic and Educational Computing\"+ \"<br>Department of Philosophy\"+ \"<br>Carnegie Mellon University\"+ \"<br>\"+ \"<br>Project Direction: Clark Glymour, Richard Scheines, Peter Spirtes\"+ \"<br>Lead Developer: Joseph Ramsey\"+ \"<br>\"+ copyright+ \"<br>\"+ latestVersion+ \"</html>\");\n  label.setBackground(Color.LIGHT_GRAY);\n  label.setFont(new Font(\"Dialog\",Font.PLAIN,12));\n  label.setBorder(new CompoundBorder(new LineBorder(Color.DARK_GRAY),new EmptyBorder(10,10,10,10)));\n  b1.add(label);\n  JOptionPane.showMessageDialog(JOptionUtils.centeringComp(),b1,\"About Tetrad...\",JOptionPane.PLAIN_MESSAGE);\n}\n", "nl": "Closes the frontmost session of this action's desktop."}
{"code": "private void redrawMarkers(){\n  UI.execute(null);\n}\n", "nl": "Redraw all markers and set them straight to their current locations without animations."}
{"code": "public void addToolTipSeries(List toolTips){\n  this.toolTipSeries.add(toolTips);\n}\n", "nl": "Adds a list of tooltips for a series."}
{"code": "static private String[] alphaMixedNumeric(){\n  return StringFunctions.combineStringArrays(StringFunctions.alphaMixed(),StringFunctions.numeric);\n}\n", "nl": "Combine the alpha mixed and numeric collections into one"}
{"code": "long incrementInMsgs(){\n  return inMsgs.incrementAndGet();\n}\n", "nl": "Increments the number of messages received on this connection."}
{"code": "public final void yyreset(java.io.Reader reader){\n  zzBuffer=s.array;\n  zzStartRead=s.offset;\n  zzEndRead=zzStartRead + s.count - 1;\n  zzCurrentPos=zzMarkedPos=s.offset;\n  zzLexicalState=YYINITIAL;\n  zzReader=reader;\n  zzAtEOF=false;\n}\n", "nl": "Resets the scanner to read from a new input stream. Does not close the old reader. All internal variables are reset, the old input stream <b>cannot</b> be reused (internal buffer is discarded and lost). Lexical state is set to <tt>YY_INITIAL</tt>."}
{"code": "public IntArraySpliterator(int[] array,int origin,int fence,int additionalCharacteristics){\n  this.array=array;\n  this.index=origin;\n  this.fence=fence;\n  this.characteristics=additionalCharacteristics | Spliterator.SIZED | Spliterator.SUBSIZED;\n}\n", "nl": "Creates a spliterator covering the given array and range"}
{"code": "@Override public void populateDAG(DAG dag,Configuration conf){\n  TweetsInput input=new TweetsInput();\n  Collector collector=new Collector();\n  WindowOption windowOption=new WindowOption.GlobalWindow();\n  ApexStream<String> tags=StreamFactory.fromInput(input,input.output,name(\"tweetSampler\")).flatMap(new ExtractHashtags());\n  tags.window(windowOption,new TriggerOption().accumulatingFiredPanes().withEarlyFiringsAtEvery(1)).addCompositeStreams(ComputeTopCompletions.top(10,true)).print(name(\"console\")).endWith(collector,collector.input,name(\"collector\")).populateDag(dag);\n}\n", "nl": "Populate the dag with High-Level API."}
{"code": "public void testBug21947042() throws Exception {\n  Connection sslConn=null;\n  Properties props=new Properties();\n  props.setProperty(\"logger\",\"StandardLogger\");\n  StandardLogger.startLoggingToBuffer();\n  try {\n    int searchFrom=0;\n    int found=0;\n    sslConn=getConnectionWithProps(props);\n    if (versionMeetsMinimum(5,7)) {\n      assertTrue(((MySQLConnection)sslConn).getUseSSL());\n      assertFalse(((MySQLConnection)sslConn).getVerifyServerCertificate());\n      assertTrue(((MySQLConnection)sslConn).getIO().isSSLEstablished());\n    }\n else {\n      assertFalse(((MySQLConnection)sslConn).getUseSSL());\n      assertTrue(((MySQLConnection)sslConn).getVerifyServerCertificate());\n      assertFalse(((MySQLConnection)sslConn).getIO().isSSLEstablished());\n    }\n    ResultSet rset=sslConn.createStatement().executeQuery(\"SHOW STATUS LIKE 'ssl_cipher'\");\n    assertTrue(rset.next());\n    String cipher=rset.getString(2);\n    System.out.println(\"ssl_cipher=\" + cipher);\n    rset=sslConn.createStatement().executeQuery(\"SHOW STATUS LIKE 'ssl_version'\");\n    assertTrue(rset.next());\n    cipher=rset.getString(2);\n    System.out.println(\"ssl_version=\" + cipher);\n    sslConn.close();\n    String log=StandardLogger.getBuffer().toString();\n    found=log.indexOf(Messages.getString(\"MysqlIO.SSLWarning\"),searchFrom);\n    searchFrom=found + 1;\n    if (versionMeetsMinimum(5,7)) {\n      assertTrue(found != -1);\n    }\n    props.setProperty(\"useSSL\",\"false\");\n    sslConn=getConnectionWithProps(props);\n    assertFalse(((MySQLConnection)sslConn).getUseSSL());\n    assertTrue(((MySQLConnection)sslConn).getVerifyServerCertificate());\n    assertFalse(((MySQLConnection)sslConn).getIO().isSSLEstablished());\n    rset=sslConn.createStatement().executeQuery(\"SHOW STATUS LIKE 'ssl_cipher'\");\n    assertTrue(rset.next());\n    cipher=rset.getString(2);\n    System.out.println(\"ssl_cipher=\" + cipher);\n    rset=sslConn.createStatement().executeQuery(\"SHOW STATUS LIKE 'ssl_version'\");\n    assertTrue(rset.next());\n    cipher=rset.getString(2);\n    System.out.println(\"ssl_version=\" + cipher);\n    sslConn.close();\n    log=StandardLogger.getBuffer().toString();\n    found=log.indexOf(Messages.getString(\"MysqlIO.SSLWarning\"),searchFrom);\n    if (found != -1) {\n      searchFrom=found + 1;\n      fail(\"Warning is not expected when useSSL is explicitly set to 'false'.\");\n    }\n    props.setProperty(\"useSSL\",\"true\");\n    props.setProperty(\"trustCertificateKeyStoreUrl\",\"file:src/testsuite/ssl-test-certs/test-cert-store\");\n    props.setProperty(\"trustCertificateKeyStoreType\",\"JKS\");\n    props.setProperty(\"trustCertificateKeyStorePassword\",\"password\");\n    sslConn=getConnectionWithProps(props);\n    assertTrue(((MySQLConnection)sslConn).getUseSSL());\n    assertTrue(((MySQLConnection)sslConn).getVerifyServerCertificate());\n    assertTrue(((MySQLConnection)sslConn).getIO().isSSLEstablished());\n    rset=sslConn.createStatement().executeQuery(\"SHOW STATUS LIKE 'ssl_cipher'\");\n    assertTrue(rset.next());\n    cipher=rset.getString(2);\n    System.out.println(\"ssl_cipher=\" + cipher);\n    rset=sslConn.createStatement().executeQuery(\"SHOW STATUS LIKE 'ssl_version'\");\n    assertTrue(rset.next());\n    cipher=rset.getString(2);\n    System.out.println(\"ssl_version=\" + cipher);\n    sslConn.close();\n    log=StandardLogger.getBuffer().toString();\n    found=log.indexOf(Messages.getString(\"MysqlIO.SSLWarning\"),searchFrom);\n    if (found != -1) {\n      searchFrom=found + 1;\n      fail(\"Warning is not expected when useSSL is explicitly set to 'false'.\");\n    }\n  }\n  finally {\n    StandardLogger.dropBuffer();\n  }\n}\n", "nl": "Tests fix for BUG#21947042, PREFER TLS WHERE SUPPORTED BY MYSQL SERVER. Requires test certificates from testsuite/ssl-test-certs to be installed on the server being tested."}
{"code": "public JComponent createEmbeddedPropertyGUI(String prefix,Properties props,Properties info){\n  if (Debug.debugging(\"inspectordetail\")) {\n    Debug.output(\"Inspector creating GUI for \" + prefix + \"\\nPROPERTIES \"+ props+ \"\\nPROP INFO \"+ info);\n  }\n  String propertyList=info.getProperty(PropertyConsumer.initPropertiesProperty);\n  Vector<String> sortedKeys;\n  if (propertyList != null) {\n    Vector<String> propertiesToShow=PropUtils.parseSpacedMarkers(propertyList);\n    for (int i=0; i < propertiesToShow.size(); i++) {\n      propertiesToShow.set(i,prefix + \".\" + propertiesToShow.get(i));\n    }\n    sortedKeys=propertiesToShow;\n  }\n else {\n    sortedKeys=sortKeys(props.keySet());\n  }\n  editors=new Hashtable<String,PropertyEditor>(sortedKeys.size());\n  JPanel component=new JPanel();\n  component.setLayout(new BorderLayout());\n  JPanel propertyPanel=new JPanel();\n  GridBagLayout gridbag=new GridBagLayout();\n  GridBagConstraints c=new GridBagConstraints();\n  c.insets=new Insets(2,10,2,10);\n  propertyPanel.setLayout(gridbag);\n  int i=0;\n  for (  String prop : sortedKeys) {\n    String marker=prop;\n    if (prefix != null && prop.startsWith(prefix)) {\n      marker=prop.substring(prefix.length() + 1);\n    }\n    if (marker.startsWith(\".\")) {\n      marker=marker.substring(1);\n    }\n    String editorMarker=marker + PropertyConsumer.ScopedEditorProperty;\n    String editorClass=info.getProperty(editorMarker);\n    if (editorClass == null) {\n      editorClass=defaultEditorClass;\n    }\n    Class<?> propertyEditorClass=null;\n    PropertyEditor editor=null;\n    try {\n      propertyEditorClass=Class.forName(editorClass);\n      editor=(PropertyEditor)propertyEditorClass.newInstance();\n      if (editor instanceof PropertyConsumer) {\n        ((PropertyConsumer)editor).setProperties(marker,info);\n      }\n      editors.put(prop,editor);\n    }\n catch (    Exception e) {\n      e.printStackTrace();\n      editorClass=null;\n    }\n    Component editorFace=null;\n    if (editor != null && editor.supportsCustomEditor()) {\n      editorFace=editor.getCustomEditor();\n    }\n else {\n      editorFace=new JLabel(i18n.get(Inspector.class,\"Does_not_support_custom_editor\",\"Does not support custom editor\"));\n    }\n    if (editor != null) {\n      Object propVal=props.get(prop);\n      if (Debug.debugging(\"inspector\")) {\n        Debug.output(\"Inspector loading \" + prop + \"(\"+ propVal+ \")\");\n      }\n      editor.setValue(propVal);\n    }\n    String labelMarker=marker + PropertyConsumer.LabelEditorProperty;\n    String labelText=info.getProperty(labelMarker);\n    if (labelText == null) {\n      labelText=marker;\n    }\n    JLabel label=new JLabel(labelText + \":\");\n    label.setHorizontalAlignment(SwingConstants.RIGHT);\n    c.gridx=0;\n    c.gridy=i++;\n    c.weightx=0;\n    c.fill=GridBagConstraints.NONE;\n    c.anchor=GridBagConstraints.EAST;\n    gridbag.setConstraints(label,c);\n    propertyPanel.add(label);\n    c.gridx=1;\n    c.anchor=GridBagConstraints.WEST;\n    c.fill=GridBagConstraints.HORIZONTAL;\n    c.weightx=1f;\n    gridbag.setConstraints(editorFace,c);\n    propertyPanel.add(editorFace);\n    String toolTip=(String)info.get(marker);\n    label.setToolTipText(toolTip == null ? i18n.get(Inspector.class,\"No_further_information_available\",\"No further information available.\") : toolTip);\n  }\n  JScrollPane scrollPane=new JScrollPane(propertyPanel,ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED,ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);\n  scrollPane.setBorder(null);\n  scrollPane.setAlignmentY(Component.TOP_ALIGNMENT);\n  component.add(scrollPane,BorderLayout.CENTER);\n  return component;\n}\n", "nl": "Creates a JComponent with the properties to be changed. This component is suitable for inclusion into a GUI. Don't use this method directly! Use the createPropertyGUI(PropertyConsumer) instead. You will get a NullPointerException if you use this method without setting the PropertyConsumer in the Inspector."}
{"code": "public void onScanImageClick(View v){\n  Intent intent=new Intent(this,ScanImageActivity.class);\n  intent.putExtra(ExtrasKeys.EXTRAS_LICENSE_KEY,LICENSE_KEY);\n  intent.putExtra(ExtrasKeys.EXTRAS_RECOGNITION_SETTINGS,mRecognitionSettings);\n  startActivityForResult(intent,MY_REQUEST_CODE);\n}\n", "nl": "Handler for \"Scan Image\" button"}
{"code": "public boolean isReadOnly(){\n  Object oo=get_Value(COLUMNNAME_IsReadOnly);\n  if (oo != null) {\n    if (oo instanceof Boolean)     return ((Boolean)oo).booleanValue();\n    return \"Y\".equals(oo);\n  }\n  return false;\n}\n", "nl": "Get Read Only."}
{"code": "public static <K,V>Map<K,V> asSynchronized(Map<K,V> self){\n  return Collections.synchronizedMap(self);\n}\n", "nl": "A convenience method for creating a synchronized Map."}
{"code": "private boolean isRecursive(Nonterminal nonterm){\n  return comp.getNodes().contains(nonterm);\n}\n", "nl": "Return true if the nonterminal is recursive."}
{"code": "private void initInfo(int record_id,String value){\n  if (!(record_id == 0) && value != null && value.length() > 0) {\n    log.severe(\"Received both a record_id and a value: \" + record_id + \" - \"+ value);\n  }\n  if (!(record_id == 0)) {\n    fieldID=record_id;\n  }\n else {\n    if (value != null && value.length() > 0) {\n      fDocumentNo.setValue(value);\n    }\n else {\n      String id;\n      id=Env.getContext(Env.getCtx(),p_WindowNo,p_TabNo,\"M_InOut_ID\",true);\n      if (id != null && id.length() != 0 && (new Integer(id).intValue() > 0)) {\n        fieldID=new Integer(id).intValue();\n      }\n      id=Env.getContext(Env.getCtx(),p_WindowNo,p_TabNo,\"C_BPartner_ID\",true);\n      if (id != null && id.length() != 0 && (new Integer(id).intValue() > 0))       fBPartner_ID.setValue(new Integer(id));\n      id=Env.getContext(Env.getCtx(),p_WindowNo,p_TabNo,\"M_Shipper_ID\",true);\n      if (id != null && id.length() != 0 && (new Integer(id).intValue() > 0)) {\n        fShipper_ID.setValue(new Integer(id).intValue());\n      }\n    }\n  }\n}\n", "nl": "General Init"}
{"code": "public IssueMatcher add(){\n  IssueMatcher issueMatcher=new IssueMatcher();\n  issueMatchers.add(issueMatcher);\n  return issueMatcher;\n}\n", "nl": "Creates a new issue matcher and adds it to this matcher."}
{"code": "protected ParameterizedPropertyAccessExpression_IMImpl(){\n  super();\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "private void loadFinishScreen(){\n  CoordinatorLayout.LayoutParams lp=new CoordinatorLayout.LayoutParams(CoordinatorLayout.LayoutParams.WRAP_CONTENT,CoordinatorLayout.LayoutParams.WRAP_CONTENT);\n  mFloatingActionButton.setLayoutParams(lp);\n  mFloatingActionButton.setVisibility(View.INVISIBLE);\n  NestedScrollView contentLayout=(NestedScrollView)findViewById(R.id.challenge_rootcontainer);\n  if (contentLayout != null) {\n    contentLayout.removeAllViews();\n    View view=getLayoutInflater().inflate(R.layout.fragment_finish_challenge,contentLayout,false);\n    contentLayout.addView(view);\n  }\n}\n", "nl": "Loads the finish screen and unloads all other screens"}
{"code": "private void compactSegment(Segment segment,OffsetPredicate predicate,Segment compactSegment){\n  for (long i=segment.firstIndex(); i <= segment.lastIndex(); i++) {\n    checkEntry(i,segment,predicate,compactSegment);\n  }\n}\n", "nl": "Compacts the given segment."}
{"code": "public static Class<?> forName(String name,ClassLoader classLoader) throws ClassNotFoundException, LinkageError {\n  Assert.notNull(name,\"Name must not be null\");\n  Class<?> clazz=resolvePrimitiveClassName(name);\n  if (clazz == null) {\n    clazz=commonClassCache.get(name);\n  }\n  if (clazz != null) {\n    return clazz;\n  }\n  if (name.endsWith(ARRAY_SUFFIX)) {\n    String elementClassName=name.substring(0,name.length() - ARRAY_SUFFIX.length());\n    Class<?> elementClass=forName(elementClassName,classLoader);\n    return Array.newInstance(elementClass,0).getClass();\n  }\n  if (name.startsWith(NON_PRIMITIVE_ARRAY_PREFIX) && name.endsWith(\";\")) {\n    String elementName=name.substring(NON_PRIMITIVE_ARRAY_PREFIX.length(),name.length() - 1);\n    Class<?> elementClass=forName(elementName,classLoader);\n    return Array.newInstance(elementClass,0).getClass();\n  }\n  if (name.startsWith(INTERNAL_ARRAY_PREFIX)) {\n    String elementName=name.substring(INTERNAL_ARRAY_PREFIX.length());\n    Class<?> elementClass=forName(elementName,classLoader);\n    return Array.newInstance(elementClass,0).getClass();\n  }\n  ClassLoader classLoaderToUse=classLoader;\n  if (classLoaderToUse == null) {\n    classLoaderToUse=getDefaultClassLoader();\n  }\n  try {\n    return classLoaderToUse.loadClass(name);\n  }\n catch (  ClassNotFoundException ex) {\n    int lastDotIndex=name.lastIndexOf('.');\n    if (lastDotIndex != -1) {\n      String innerClassName=name.substring(0,lastDotIndex) + ' ' + name.substring(lastDotIndex + 1);\n      try {\n        return classLoaderToUse.loadClass(innerClassName);\n      }\n catch (      ClassNotFoundException ex2) {\n      }\n    }\n    throw ex;\n  }\n}\n", "nl": "Replacement for <code>Class.forName()</code> that also returns Class instances for primitives (e.g.\"int\") and array class names (e.g. \"String[]\"). Furthermore, it is also capable of resolving inner class names in Java source style (e.g. \"java.lang.Thread.State\" instead of \"java.lang.Thread State\")."}
{"code": "public String toString(int indentFactor) throws JSONException {\n  return toString(indentFactor,0);\n}\n", "nl": "Make a prettyprinted JSON text of this JSONObject. <p> Warning: This method assumes that the data structure is acyclical."}
{"code": "@SuppressWarnings(\"MethodWithMultipleReturnPoints\") public static boolean checkSu(){\n  if (!new File(\"/system/bin/su\").exists() && !new File(\"/system/xbin/su\").exists()) {\n    Log.e(TAG,\"su binary does not exist!!!\");\n    return false;\n  }\n  try {\n    if (runSuCommand(\"ls /data/app-private\").success()) {\n      Log.i(TAG,\" SU exists and we have permission\");\n      return true;\n    }\n else {\n      Log.i(TAG,\" SU exists but we don't have permission\");\n      return false;\n    }\n  }\n catch (  NullPointerException e) {\n    Log.e(TAG,\"NullPointer throw while looking for su binary\",e);\n    return false;\n  }\n}\n", "nl": "Checks device for SuperUser permission"}
{"code": "public String toString(int indentFactor) throws JSONException {\n  StringWriter sw=new StringWriter();\nsynchronized (sw.getBuffer()) {\n    return this.write(sw,indentFactor,0).toString();\n  }\n}\n", "nl": "Make a prettyprinted JSON text of this JSONArray. Warning: This method assumes that the data structure is acyclical."}
{"code": "public Boolean isHttpSupportInformation(){\n  return httpSupportInformation;\n}\n", "nl": "Ruft den Wert der httpSupportInformation-Eigenschaft ab."}
{"code": "public static URLConnection createConnectionToURL(final String url,final Map<String,String> requestHeaders) throws IOException {\n  final URL connectionURL=URLUtility.stringToUrl(url);\n  if (connectionURL == null) {\n    throw new IOException(\"Invalid url format: \" + url);\n  }\n  final URLConnection urlConnection=connectionURL.openConnection();\n  urlConnection.setConnectTimeout(CONNECTION_TIMEOUT);\n  urlConnection.setReadTimeout(READ_TIMEOUT);\n  if (requestHeaders != null) {\n    for (    final Map.Entry<String,String> entry : requestHeaders.entrySet()) {\n      urlConnection.setRequestProperty(entry.getKey(),entry.getValue());\n    }\n  }\n  return urlConnection;\n}\n", "nl": "Create URLConnection instance."}
{"code": "public ASN1Primitive toASN1Primitive(){\n  try {\n    if (certificateType == profileType) {\n      return profileToASN1Object();\n    }\n    if (certificateType == requestType) {\n      return requestToASN1Object();\n    }\n  }\n catch (  IOException e) {\n    return null;\n  }\n  return null;\n}\n", "nl": "create a \"request\" or \"profile\" type Iso7816CertificateBody according to the variables sets."}
{"code": "public Builder mapper(final Mapper<ObjectMapper> mapper){\n  this.mapper=mapper;\n  return this;\n}\n", "nl": "Override all of the builder options with this mapper.  If this value is set to something other than null then that value will be used to construct the writer."}
{"code": "private int[][] div(int[] a,int[] f){\n  int df=computeDegree(f);\n  int da=computeDegree(a) + 1;\n  if (df == -1) {\n    throw new ArithmeticException(\"Division by zero.\");\n  }\n  int[][] result=new int[2][];\n  result[0]=new int[1];\n  result[1]=new int[da];\n  int hc=headCoefficient(f);\n  hc=field.inverse(hc);\n  result[0][0]=0;\n  System.arraycopy(a,0,result[1],0,result[1].length);\n  while (df <= computeDegree(result[1])) {\n    int[] q;\n    int[] coeff=new int[1];\n    coeff[0]=field.mult(headCoefficient(result[1]),hc);\n    q=multWithElement(f,coeff[0]);\n    int n=computeDegree(result[1]) - df;\n    q=multWithMonomial(q,n);\n    coeff=multWithMonomial(coeff,n);\n    result[0]=add(coeff,result[0]);\n    result[1]=add(q,result[1]);\n  }\n  return result;\n}\n", "nl": "Compute the result of the division of two polynomials over the field <tt>GF(2^m)</tt>."}
{"code": "public static short toShort(byte[] bytes,int start){\n  return toShort(bytes[start],bytes[start + 1]);\n}\n", "nl": "Returns short from given array of bytes. <br> Array must have at least start + 2 elements in it."}
{"code": "public void addAttribute(AttributedCharacterIterator.Attribute attribute,Object value,int start,int end){\n  if (attribute == null) {\n    throw new NullPointerException(\"attribute == null\");\n  }\n  if (start < 0 || end > text.length() || start >= end) {\n    throw new IllegalArgumentException();\n  }\n  if (value == null) {\n    return;\n  }\n  List<Range> ranges=attributeMap.get(attribute);\n  if (ranges == null) {\n    ranges=new ArrayList<Range>(1);\n    ranges.add(new Range(start,end,value));\n    attributeMap.put(attribute,ranges);\n    return;\n  }\n  ListIterator<Range> it=ranges.listIterator();\n  while (it.hasNext()) {\n    Range range=it.next();\n    if (end <= range.start) {\n      it.previous();\n      break;\n    }\n else     if (start < range.end || (start == range.end && value.equals(range.value))) {\n      Range r1=null, r3;\n      it.remove();\n      r1=new Range(range.start,start,range.value);\n      r3=new Range(end,range.end,range.value);\n      while (end > range.end && it.hasNext()) {\n        range=it.next();\n        if (end <= range.end) {\n          if (end > range.start || (end == range.start && value.equals(range.value))) {\n            it.remove();\n            r3=new Range(end,range.end,range.value);\n            break;\n          }\n        }\n else {\n          it.remove();\n        }\n      }\n      if (value.equals(r1.value)) {\n        if (value.equals(r3.value)) {\n          it.add(new Range(r1.start < start ? r1.start : start,r3.end > end ? r3.end : end,r1.value));\n        }\n else {\n          it.add(new Range(r1.start < start ? r1.start : start,end,r1.value));\n          if (r3.start < r3.end) {\n            it.add(r3);\n          }\n        }\n      }\n else {\n        if (value.equals(r3.value)) {\n          if (r1.start < r1.end) {\n            it.add(r1);\n          }\n          it.add(new Range(start,r3.end > end ? r3.end : end,r3.value));\n        }\n else {\n          if (r1.start < r1.end) {\n            it.add(r1);\n          }\n          it.add(new Range(start,end,value));\n          if (r3.start < r3.end) {\n            it.add(r3);\n          }\n        }\n      }\n      return;\n    }\n  }\n  it.add(new Range(start,end,value));\n}\n", "nl": "Applies a given attribute to the given range of this string."}
{"code": "@Override public Double hincrByFloat(final String key,final String field,final double value){\n  checkIsInMultiOrPipeline();\n  client.hincrByFloat(key,field,value);\n  final String dval=client.getBulkReply();\n  return (dval != null ? new Double(dval) : null);\n}\n", "nl": "Increment the number stored at field in the hash at key by a double precision floating point value. If key does not exist, a new key holding a hash is created. If field does not exist or holds a string, the value is set to 0 before applying the operation. Since the value argument is signed you can use this command to perform both increments and decrements. <p> The range of values supported by HINCRBYFLOAT is limited to double precision floating point values. <p> <b>Time complexity:</b> O(1)"}
{"code": "public DrawerBuilder withFooter(@NonNull View footerView){\n  this.mFooterView=footerView;\n  return this;\n}\n", "nl": "Add a footer to the DrawerBuilder ListView. This can be any view"}
{"code": "@Override public int compareTo(final Object obj) throws ClassCastException {\n  final URI another=(URI)obj;\n  if (!equals(_authority,another.getRawAuthority())) {\n    return -1;\n  }\n  return toString().compareTo(another.toString());\n}\n", "nl": "Compare this URI to another object."}
{"code": "public boolean isNavigationAtBottom(){\n  return (mSmallestWidthDp >= 600 || mInPortrait);\n}\n", "nl": "Should a navigation bar appear at the bottom of the screen in the current device configuration? A navigation bar may appear on the right side of the screen in certain configurations."}
{"code": "@Override public void execute(String filePath){\n  final CurrentProject currentProject=appContext.getCurrentProject();\n  if (filePath != null && !filePath.startsWith(\"/\")) {\n    filePath=\"/\".concat(filePath);\n  }\n  if (currentProject != null) {\n    String fullPath=currentProject.getRootProject().getPath() + filePath;\n    log.debug(\"Open file {0}\",fullPath);\n    currentProject.getCurrentTree().getNodeByPath(fullPath,new TreeNodeAsyncCallback());\n  }\n}\n", "nl": "Open a file for the current given path."}
{"code": "public void executionDetailsEnd(final ConcurrentHashMap<Integer,TradeOrder> tradeOrders){\n  try {\n    Tradingday todayTradingday=m_tradingdays.getTradingday(TradingCalendar.getTradingDayStart(TradingCalendar.getDateTimeNowMarketTimeZone()),TradingCalendar.getTradingDayEnd(TradingCalendar.getDateTimeNowMarketTimeZone()));\n    if (null == todayTradingday) {\n      return;\n    }\n    tradingdayPanel.doRefresh(todayTradingday);\n    tradingdayPanel.doRefreshTradingdayTable(todayTradingday);\n  }\n catch (  Exception ex) {\n    this.setErrorMessage(\"Error starting PositionManagerRule.\",ex.getMessage(),ex);\n  }\n}\n", "nl": "This method is fired when the Brokermodel has completed the request for Execution Details see doFetchExecution or connectionOpened i.e from a BrokerModel event all executions for the filter have now been received. Check to see if we need to close any trades for these order fills."}
{"code": "public void successfullyCreated(){\n  if (notification != null) {\n    notification.setStatus(SUCCESS);\n    notification.setTitle(locale.createSnapshotSuccess());\n  }\n}\n", "nl": "Changes notification state to successfully finished."}
{"code": "public HybridTimestampFactory(int counterBits){\n  if (counterBits < 0 || counterBits > 31) {\n    throw new IllegalArgumentException(\"counterBits must be in [0:31]\");\n  }\n  lastTimestamp=0L;\n  this.counterBits=counterBits;\n  maxCounter=BigInteger.valueOf(2).pow(counterBits).intValue() - 1;\n  log.warn(\"#counterBits=\" + counterBits + \", maxCounter=\"+ maxCounter);\n}\n", "nl": "Allows up to <code>2^counterBits</code> distinct timestamps per millisecond."}
{"code": "@Override public void clear(){\n  this._map.clear();\n}\n", "nl": "Empties the map."}
{"code": "public boolean removeElement(int s){\n  if (null == m_map)   return false;\n  for (int i=0; i < m_firstFree; i++) {\n    int node=m_map[i];\n    if (node == s) {\n      if (i > m_firstFree)       System.arraycopy(m_map,i + 1,m_map,i - 1,m_firstFree - i);\n else       m_map[i]=DTM.NULL;\n      m_firstFree--;\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "Removes the first occurrence of the argument from this vector. If the object is found in this vector, each component in the vector with an index greater or equal to the object's index is shifted downward to have an index one smaller than the value it had previously."}
{"code": "private void addSingleton(TempCluster clus,DBIDRef id,double dist,boolean asCluster){\n  if (asCluster) {\n    clus.addChild(makeSingletonCluster(id,dist));\n  }\n else {\n    clus.add(id);\n  }\n  clus.depth=dist;\n}\n", "nl": "Add a singleton object, as point or cluster."}
{"code": "public int size(){\n  return values.length;\n}\n", "nl": "Returns the number of values in this kernel."}
{"code": "private void testServerJoinLate(Member.Type type,CopycatServer.State state) throws Throwable {\n  createServers(3);\n  CopycatClient client=createClient();\n  submit(client,0,1000);\n  await(30000);\n  CopycatServer joiner=createServer(nextMember(type));\n  joiner.onStateChange(null);\n  joiner.join(members.stream().map(null).collect(Collectors.toList())).thenRun(null);\n  await(30000,2);\n}\n", "nl": "Tests joining a server after many entries have been committed."}
{"code": "public Shape createRadioButton(int x,int y,int diameter){\n  return createEllipseInternal(x,y,diameter,diameter);\n}\n", "nl": "Return a path for a radio button's concentric sections."}
{"code": "@DSComment(\"From safe class list\") @DSSafe(DSCat.SAFE_LIST) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:57:11.638 -0500\",hash_original_method=\"3CEC44303CC022BBEC9F119BC403FDBC\",hash_generated_method=\"FD349EDA389F166F5AB5B32AD7B69928\") public int size(){\n  return al.size();\n}\n", "nl": "Returns the number of elements in this set."}
{"code": "public static String formatRateString(float rate){\n  return String.format(java.util.Locale.US,\"%.2fx\",rate);\n}\n", "nl": "Get the formatted current playback speed in the form of 1.00x"}
{"code": "private static BitmapFactory.Options decodeImageForOption(ContentResolver resolver,Uri uri) throws FileNotFoundException {\n  InputStream stream=null;\n  try {\n    stream=resolver.openInputStream(uri);\n    BitmapFactory.Options options=new BitmapFactory.Options();\n    options.inJustDecodeBounds=true;\n    BitmapFactory.decodeStream(stream,EMPTY_RECT,options);\n    options.inJustDecodeBounds=false;\n    return options;\n  }\n  finally {\n    closeSafe(stream);\n  }\n}\n", "nl": "Decode image from uri using \"inJustDecodeBounds\" to get the image dimensions."}
{"code": "public FinalSQLString(BasicSQLString sqlstring){\n  this.delegate=sqlstring;\n}\n", "nl": "Should only be called inside SQLString because this class essentially verifies that we've checked for updates."}
{"code": "public void loadArgArray(){\n  push(argumentTypes.length);\n  newArray(OBJECT_TYPE);\n  for (int i=0; i < argumentTypes.length; i++) {\n    dup();\n    push(i);\n    loadArg(i);\n    box(argumentTypes[i]);\n    arrayStore(OBJECT_TYPE);\n  }\n}\n", "nl": "Generates the instructions to load all the method arguments on the stack, as a single object array."}
{"code": "public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {\n  WebUtil.createLoginPage(request,response,this,null,null);\n}\n", "nl": "Process the HTTP Get request"}
{"code": "private DeferredFileOutputStream(int threshold,File outputFile,String prefix,String suffix,File directory){\n  super(threshold);\n  this.outputFile=outputFile;\n  memoryOutputStream=new ByteArrayOutputStream();\n  currentOutputStream=memoryOutputStream;\n  this.prefix=prefix;\n  this.suffix=suffix;\n  this.directory=directory;\n}\n", "nl": "Constructs an instance of this class which will trigger an event at the specified threshold, and save data either to a file beyond that point."}
{"code": "public final void testSetSystemScope(){\n  IdentityScope systemScope=IdentityScope.getSystemScope();\n  try {\n    is=new IdentityScopeStub(\"Aleksei Semenov\");\n    IdentityScopeStub.mySetSystemScope(is);\n    assertSame(is,IdentityScope.getSystemScope());\n  }\n  finally {\n    IdentityScopeStub.mySetSystemScope(systemScope);\n  }\n}\n", "nl": "check that if permission given - set/get works if permission is denied than SecurityException is thrown"}
{"code": "public static void main(String[] args){\n  runEvaluator(new WrapperSubsetEval(),args);\n}\n", "nl": "Main method for testing this class."}
{"code": "public static void v(String tag,String msg,Object... args){\n  if (sLevel > LEVEL_VERBOSE) {\n    return;\n  }\n  if (args.length > 0) {\n    msg=String.format(msg,args);\n  }\n  Log.v(tag,msg);\n}\n", "nl": "Send a VERBOSE log message."}
{"code": "@DSComment(\"Package priviledge\") @DSBan(DSCat.DEFAULT_MODIFIER) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:58:04.267 -0500\",hash_original_method=\"2CE5F24A4C571BEECB25C40400E44908\",hash_generated_method=\"A3579B97578194B5EA0183D0F747142C\") void computeNextElement(){\n  while (true) {\n    if (currentBits != 0) {\n      mask=currentBits & -currentBits;\n      return;\n    }\n else     if (++index < bits.length) {\n      currentBits=bits[index];\n    }\n else {\n      mask=0;\n      return;\n    }\n  }\n}\n", "nl": "Assigns mask and index to the next available value, cycling currentBits as necessary."}
{"code": "public HierarchyEvent(Component source,int id,Component changed,Container changedParent,long changeFlags){\n  super(source,id);\n  this.changed=changed;\n  this.changedParent=changedParent;\n  this.changeFlags=changeFlags;\n}\n", "nl": "Constructs an <code>HierarchyEvent</code> object to identify a change in the <code>Component</code> hierarchy. <p> This method throws an <code>IllegalArgumentException</code> if <code>source</code> is <code>null</code>."}
{"code": "public void step(SimState state){\n}\n", "nl": "This method is performed when the next step for the agent is computed. This agent does nothing, so nothing is inside the body of the method."}
{"code": "public static void resetRuntime(){\n  currentTime=1392409281320L;\n  wasTimeAccessed=false;\n  hashKeys.clear();\n  restoreProperties();\n  needToRestoreProperties=false;\n}\n", "nl": "Reset runtime to initial state"}
{"code": "public ExpandCaseMultipliersAction(DataEditor editor){\n  super(\"Expand Case Multipliers\");\n  if (editor == null) {\n    throw new NullPointerException();\n  }\n  this.dataEditor=editor;\n}\n", "nl": "Creates a new action to split by collinear columns."}
{"code": "public ScaleFake(){\n}\n", "nl": "Creates a new instance of ScaleFake"}
{"code": "protected ArrayElementImpl(){\n  super();\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public FilterRowIterator(IntIterator rows,Table t,Predicate p){\n  this.predicate=p;\n  this.rows=rows;\n  this.t=t;\n  next=advance();\n}\n", "nl": "Create a new FilterRowIterator."}
{"code": "private void scanJar(JarURLConnection conn,List<String> tldNames,boolean isLocal) throws JasperException {\n  String resourcePath=conn.getJarFileURL().toString();\n  TldInfo[] tldInfos=jarTldCacheLocal.get(resourcePath);\n  if (tldInfos != null && tldInfos.length == 0) {\n    try {\n      conn.getJarFile().close();\n    }\n catch (    IOException ex) {\n    }\n    return;\n  }\n  if (tldInfos == null) {\n    JarFile jarFile=null;\n    ArrayList<TldInfo> tldInfoA=new ArrayList<TldInfo>();\n    try {\n      jarFile=conn.getJarFile();\n      if (tldNames != null) {\n        for (        String tldName : tldNames) {\n          JarEntry entry=jarFile.getJarEntry(tldName);\n          InputStream stream=jarFile.getInputStream(entry);\n          tldInfoA.add(scanTld(resourcePath,tldName,stream));\n        }\n      }\n else {\n        Enumeration<JarEntry> entries=jarFile.entries();\n        while (entries.hasMoreElements()) {\n          JarEntry entry=entries.nextElement();\n          String name=entry.getName();\n          if (!name.startsWith(\"META-INF/\"))           continue;\n          if (!name.endsWith(\".tld\"))           continue;\n          InputStream stream=jarFile.getInputStream(entry);\n          tldInfoA.add(scanTld(resourcePath,name,stream));\n        }\n      }\n    }\n catch (    IOException ex) {\n      if (resourcePath.startsWith(FILE_PROTOCOL) && !((new File(resourcePath)).exists())) {\n        if (log.isLoggable(Level.WARNING)) {\n          log.log(Level.WARNING,Localizer.getMessage(\"jsp.warn.nojar\",resourcePath),ex);\n        }\n      }\n else {\n        throw new JasperException(Localizer.getMessage(\"jsp.error.jar.io\",resourcePath),ex);\n      }\n    }\n finally {\n      if (jarFile != null) {\n        try {\n          jarFile.close();\n        }\n catch (        Throwable t) {\n        }\n      }\n    }\n    tldInfos=tldInfoA.toArray(new TldInfo[tldInfoA.size()]);\n    jarTldCacheLocal.put(resourcePath,tldInfos);\n    if (!isLocal) {\n      jarTldCache.put(resourcePath,tldInfos);\n    }\n  }\n  for (  TldInfo tldInfo : tldInfos) {\n    if (scanListeners) {\n      addListener(tldInfo,isLocal);\n    }\n    mapTldLocation(resourcePath,tldInfo,isLocal);\n  }\n}\n", "nl": "Scans the given JarURLConnection for TLD files located in META-INF (or a subdirectory of it).  If the scanning in is done as part of the ServletContextInitializer, the listeners in the tlds in this jar file are added to the servlet context, and for any  TLD that has a <uri> element, an implicit map entry is added to the taglib map."}
{"code": "public static void cosft1(double[] y){\n  com.nr.fft.FFT.cosft1(y);\n}\n", "nl": "Calculates the cosine transform of a set y[0..n] of real-valued data points. The transformed data replace the original data in array y. n must be a power of 2. This program, without changes, also calculates the inverse cosine transform, but in this case the output array should be multiplied by 2/n."}
{"code": "public void stop(){\n  mRunning=false;\n  mStop=true;\n}\n", "nl": "Stops the animation in place. It does not snap the image to its final translation."}
{"code": "public boolean hasNext(){\n  return cursor > 0;\n}\n", "nl": "This is used to determine if the cursor has reached the start of the list. When the cursor reaches the start of the list then this method returns false."}
{"code": "@Override protected void onFinished(final Player player,final boolean successful){\n  if (successful) {\n    final String itemName=items[Rand.rand(items.length)];\n    final Item item=SingletonRepository.getEntityManager().getItem(itemName);\n    int amount=1;\n    if (itemName.equals(\"dark dagger\") || itemName.equals(\"horned golden helmet\")) {\n      item.setBoundTo(player.getName());\n    }\n else     if (itemName.equals(\"money\")) {\n      amount=Rand.roll1D100();\n      ((StackableItem)item).setQuantity(amount);\n    }\n    player.equipOrPutOnGround(item);\n    player.incObtainedForItem(item.getName(),item.getQuantity());\n    SingletonRepository.getAchievementNotifier().onObtain(player);\n    player.sendPrivateText(\"You were lucky and found \" + Grammar.quantityplnoun(amount,itemName,\"a\") + \".\");\n  }\n else {\n    player.sendPrivateText(\"Your wish didn't come true.\");\n  }\n}\n", "nl": "Called when the activity has finished."}
{"code": "public void saveWalletAndWalletInfoSimple(WalletData perWalletModelData,String walletFilename,String walletInfoFilename){\n  File walletFile=new File(walletFilename);\n  WalletInfoData walletInfo=perWalletModelData.getWalletInfo();\n  FileOutputStream fileOutputStream=null;\n  try {\n    if (perWalletModelData.getWallet() != null) {\n      if (walletInfo != null) {\n        String walletDescriptionInInfoFile=walletInfo.getProperty(WalletInfoData.DESCRIPTION_PROPERTY);\n        if (walletDescriptionInInfoFile != null) {\n          perWalletModelData.getWallet().setDescription(walletDescriptionInInfoFile);\n        }\n      }\n      log.debug(\"Saving wallet file '\" + walletFile.getAbsolutePath() + \"' ...\");\n      if (MultiBitWalletVersion.SERIALIZED == walletInfo.getWalletVersion()) {\n        throw new WalletSaveException(\"Cannot save wallet '\" + walletFile.getAbsolutePath() + \"'. Serialized wallets are no longer supported.\");\n      }\n else {\n        boolean walletIsActuallyEncrypted=false;\n        Wallet wallet=perWalletModelData.getWallet();\n        for (        ECKey key : wallet.getKeychain()) {\n          if (key.isEncrypted()) {\n            walletIsActuallyEncrypted=true;\n            break;\n          }\n        }\n        if (walletIsActuallyEncrypted) {\n          walletInfo.setWalletVersion(MultiBitWalletVersion.PROTOBUF_ENCRYPTED);\n        }\n        if (MultiBitWalletVersion.PROTOBUF == walletInfo.getWalletVersion()) {\n          perWalletModelData.getWallet().saveToFile(walletFile);\n        }\n else         if (MultiBitWalletVersion.PROTOBUF_ENCRYPTED == walletInfo.getWalletVersion()) {\n          fileOutputStream=new FileOutputStream(walletFile);\n          walletProtobufSerializer.writeWallet(perWalletModelData.getWallet(),fileOutputStream);\n        }\n else {\n          throw new WalletVersionException(\"Cannot save wallet '\" + perWalletModelData.getWalletFilename() + \"'. Its wallet version is '\"+ walletInfo.getWalletVersion().toString()+ \"' but this version of MultiBit does not understand that format.\");\n        }\n      }\n      log.debug(\"... done saving wallet file.\");\n    }\n  }\n catch (  IOException ioe) {\n    throw new WalletSaveException(\"Cannot save wallet '\" + perWalletModelData.getWalletFilename(),ioe);\n  }\n finally {\n    if (fileOutputStream != null) {\n      try {\n        fileOutputStream.flush();\n        fileOutputStream.close();\n      }\n catch (      IOException e) {\n        throw new WalletSaveException(\"Cannot save wallet '\" + perWalletModelData.getWalletFilename(),e);\n      }\n    }\n  }\n  walletInfo.writeToFile(walletInfoFilename,walletInfo.getWalletVersion());\n}\n", "nl": "Simply save the wallet and wallet info files. Used for backup writes."}
{"code": "@Override public Object clone() throws CloneNotSupportedException {\n  DefaultIntervalXYDataset clone=(DefaultIntervalXYDataset)super.clone();\n  clone.seriesKeys=new java.util.ArrayList(this.seriesKeys);\n  clone.seriesList=new ArrayList(this.seriesList.size());\n  for (int i=0; i < this.seriesList.size(); i++) {\n    double[][] data=(double[][])this.seriesList.get(i);\n    double[] x=data[0];\n    double[] xStart=data[1];\n    double[] xEnd=data[2];\n    double[] y=data[3];\n    double[] yStart=data[4];\n    double[] yEnd=data[5];\n    double[] xx=new double[x.length];\n    double[] xxStart=new double[xStart.length];\n    double[] xxEnd=new double[xEnd.length];\n    double[] yy=new double[y.length];\n    double[] yyStart=new double[yStart.length];\n    double[] yyEnd=new double[yEnd.length];\n    System.arraycopy(x,0,xx,0,x.length);\n    System.arraycopy(xStart,0,xxStart,0,xStart.length);\n    System.arraycopy(xEnd,0,xxEnd,0,xEnd.length);\n    System.arraycopy(y,0,yy,0,y.length);\n    System.arraycopy(yStart,0,yyStart,0,yStart.length);\n    System.arraycopy(yEnd,0,yyEnd,0,yEnd.length);\n    clone.seriesList.add(i,new double[][]{xx,xxStart,xxEnd,yy,yyStart,yyEnd});\n  }\n  return clone;\n}\n", "nl": "Returns a clone of this dataset."}
{"code": "public EveningActivityMovement(Settings settings){\n  super(settings);\n  super.backAllowed=false;\n  pathFinder=new DijkstraPathFinder(null);\n  mode=WALKING_TO_MEETING_SPOT_MODE;\n  nrOfMeetingSpots=settings.getInt(NR_OF_MEETING_SPOTS_SETTING);\n  minGroupSize=settings.getInt(MIN_GROUP_SIZE_SETTING);\n  maxGroupSize=settings.getInt(MAX_GROUP_SIZE_SETTING);\n  MapNode[] mapNodes=(MapNode[])getMap().getNodes().toArray(new MapNode[0]);\n  String shoppingSpotsFile=null;\n  try {\n    shoppingSpotsFile=settings.getSetting(MEETING_SPOTS_FILE_SETTING);\n  }\n catch (  Throwable t) {\n  }\n  List<Coord> meetingSpotLocations=null;\n  if (shoppingSpotsFile == null) {\n    meetingSpotLocations=new LinkedList<Coord>();\n    for (int i=0; i < mapNodes.length; i++) {\n      if ((i % (mapNodes.length / nrOfMeetingSpots)) == 0) {\n        startAtLocation=mapNodes[i].getLocation().clone();\n        meetingSpotLocations.add(startAtLocation.clone());\n      }\n    }\n  }\n else {\n    try {\n      meetingSpotLocations=new LinkedList<Coord>();\n      List<Coord> locationsRead=(new WKTReader()).readPoints(new File(shoppingSpotsFile));\n      for (      Coord coord : locationsRead) {\n        SimMap map=getMap();\n        Coord offset=map.getOffset();\n        if (map.isMirrored()) {\n          coord.setLocation(coord.getX(),-coord.getY());\n        }\n        coord.translate(offset.getX(),offset.getY());\n        meetingSpotLocations.add(coord);\n      }\n    }\n catch (    Exception e) {\n      e.printStackTrace();\n    }\n  }\n  this.id=nextID++;\n  int scsID=settings.getInt(EVENING_ACTIVITY_CONTROL_SYSTEM_NR_SETTING);\n  scs=EveningActivityControlSystem.getEveningActivityControlSystem(scsID);\n  scs.setRandomNumberGenerator(rng);\n  scs.addEveningActivityNode(this);\n  scs.setMeetingSpots(meetingSpotLocations);\n  maxPathLength=100;\n  minPathLength=10;\n  maxWaitTime=settings.getInt(MAX_WAIT_TIME_SETTING);\n  minWaitTime=settings.getInt(MIN_WAIT_TIME_SETTING);\n}\n", "nl": "Creates a new instance of EveningActivityMovement"}
{"code": "protected Polygon makeHullComplex(double[][] pc){\n  GrahamScanConvexHull2D hull=new GrahamScanConvexHull2D();\n  double[] diag=new double[]{0,0};\n  for (int j=0; j < pc.length; j++) {\n    hull.add(pc[j]);\n    hull.add(times(pc[j],-1));\n    for (int k=j + 1; k < pc.length; k++) {\n      double[] q=pc[k];\n      double[] ppq=timesEquals(plus(pc[j],q),MathUtil.SQRTHALF);\n      double[] pmq=timesEquals(minus(pc[j],q),MathUtil.SQRTHALF);\n      hull.add(ppq);\n      hull.add(times(ppq,-1));\n      hull.add(pmq);\n      hull.add(times(pmq,-1));\n      for (int l=k + 1; l < pc.length; l++) {\n        double[] r=pc[k];\n        double[] ppqpr=timesEquals(plus(ppq,r),Math.sqrt(1 / 3.));\n        double[] pmqpr=timesEquals(plus(pmq,r),Math.sqrt(1 / 3.));\n        double[] ppqmr=timesEquals(minus(ppq,r),Math.sqrt(1 / 3.));\n        double[] pmqmr=timesEquals(minus(pmq,r),Math.sqrt(1 / 3.));\n        hull.add(ppqpr);\n        hull.add(times(ppqpr,-1));\n        hull.add(pmqpr);\n        hull.add(times(pmqpr,-1));\n        hull.add(ppqmr);\n        hull.add(times(ppqmr,-1));\n        hull.add(pmqmr);\n        hull.add(times(pmqmr,-1));\n      }\n    }\n    plusEquals(diag,pc[j]);\n  }\n  timesEquals(diag,1.0 / Math.sqrt(pc.length));\n  hull.add(diag);\n  hull.add(times(diag,-1));\n  return hull.getHull();\n}\n", "nl": "Build a convex hull to approximate the sphere."}
{"code": "public void visitAnnotations(AnnotatedNode node){\n  super.visitAnnotations(node);\n  for (  AnnotationNode annotation : node.getAnnotations()) {\n    if (transforms.containsKey(annotation)) {\n      targetNodes.add(new ASTNode[]{annotation,node});\n    }\n  }\n}\n", "nl": "Adds the annotation to the internal target list if a match is found."}
{"code": "Node(Node<K,V> next){\n  this.key=null;\n  this.value=this;\n  this.next=next;\n}\n", "nl": "Creates a new marker node. A marker is distinguished by having its value field point to itself.  Marker nodes also have null keys, a fact that is exploited in a few places, but this doesn't distinguish markers from the base-level header node (head.node), which also has a null key."}
{"code": "public void onDrawerClosed(View view){\n  super.onDrawerClosed(view);\n}\n", "nl": "Called when a drawer has settled in a completely closed state."}
{"code": "public static List<String> deserializeAddressList(String serializedAddresses){\n  return Arrays.asList(serializedAddresses.split(\",\"));\n}\n", "nl": "Deserialize a list of IP addresses from a string."}
{"code": "void challengeReceived(String challenge) throws IOException {\n  currentMechanism.challengeReceived(challenge);\n}\n", "nl": "The server is challenging the SASL authentication we just sent. Forward the challenge to the current SASLMechanism we are using. The SASLMechanism will send a response to the server. The length of the challenge-response sequence varies according to the SASLMechanism in use."}
{"code": "public boolean fitsType(Environment env,Context ctx,Type t){\n  if (this.type.isType(TC_CHAR)) {\n    return super.fitsType(env,ctx,t);\n  }\nswitch (t.getTypeCode()) {\ncase TC_BYTE:\n    return value == (byte)value;\ncase TC_SHORT:\n  return value == (short)value;\ncase TC_CHAR:\nreturn value == (char)value;\n}\nreturn super.fitsType(env,ctx,t);\n}\n", "nl": "See if this number fits in the given type."}
{"code": "public ServiceManager(Iterable<? extends Service> services){\n  ImmutableList<Service> copy=ImmutableList.copyOf(services);\n  if (copy.isEmpty()) {\n    logger.log(Level.WARNING,\"ServiceManager configured with no services.  Is your application configured properly?\",new EmptyServiceManagerWarning());\n    copy=ImmutableList.<Service>of(new NoOpService());\n  }\n  this.state=new ServiceManagerState(copy);\n  this.services=copy;\n  WeakReference<ServiceManagerState> stateReference=new WeakReference<ServiceManagerState>(state);\n  for (  Service service : copy) {\n    service.addListener(new ServiceListener(service,stateReference),directExecutor());\n    checkArgument(service.state() == NEW,\"Can only manage NEW services, %s\",service);\n  }\n  this.state.markReady();\n}\n", "nl": "Constructs a new instance for managing the given services."}
{"code": "public boolean hasModule(String moduleName){\n  return moduleStore.containsKey(moduleName) || moduleStore.containsValue(moduleName);\n}\n", "nl": "Looks up a module"}
{"code": "private void removeUnusedTilesets(final Map map){\n  for (final Iterator<?> sets=map.getTileSets().iterator(); sets.hasNext(); ) {\n    final TileSet tileset=(TileSet)sets.next();\n    if (!isUsedTileset(map,tileset)) {\n      sets.remove();\n    }\n  }\n}\n", "nl": "Remove any tilesets in a map that are not actually in use."}
{"code": "public vec3 transformPoint(vec3 v){\n  vec3 result=new vec3();\n  result.m[0]=this.m[0] * v.m[0] + this.m[4] * v.m[1] + this.m[8] * v.m[2] + this.m[12];\n  result.m[1]=this.m[1] * v.m[0] + this.m[5] * v.m[1] + this.m[9] * v.m[2] + this.m[13];\n  result.m[2]=this.m[2] * v.m[0] + this.m[6] * v.m[1] + this.m[10] * v.m[2] + this.m[14];\n  return result;\n}\n", "nl": "\\fn transformPoint \\brief Returns a transformed point \\param v [vec3]"}
{"code": "static AttrSessionID createFromString(final String str){\n  return new AttrSessionID(str);\n}\n", "nl": "Creates a new attribute instance from the provided String."}
{"code": "Spinner(ListModel model,ListCellRenderer rendererInstance){\n  super(model);\n  ios7Mode=UIManager.getInstance().isThemeConstant(\"ios7SpinnerBool\",false);\n  if (ios7Mode) {\n    super.setMinElementHeight(6);\n  }\n  SpinnerRenderer.iOS7Mode=ios7Mode;\n  setRenderer(rendererInstance);\n  setUIID(\"Spinner\");\n  setFixedSelection(FIXED_CENTER);\n  setOrientation(VERTICAL);\n  setInputOnFocus(false);\n  setIsScrollVisible(false);\n  initSpinnerRenderer();\n  quickType.setReplaceMenu(false);\n  quickType.setInputModeOrder(new String[]{\"123\"});\n  quickType.setFocus(true);\n  quickType.setRTL(false);\n  quickType.setAlignment(LEFT);\n  quickType.setConstraint(TextField.NUMERIC);\n  setIgnoreFocusComponentWhenUnfocused(true);\n  setRenderingPrototype(model.getItemAt(model.getSize() - 1));\n  if (getRenderer() instanceof DateTimeRenderer) {\n    quickType.setColumns(2);\n  }\n}\n", "nl": "Creates a new spinner instance with the given spinner model"}
{"code": "@SuppressWarnings(\"resource\") @Override public void start(){\n  paused=false;\n  log.info(\"Starting text-only user interface...\");\n  log.info(\"Local address: \" + system.getLocalAddress());\n  log.info(\"Press Ctrl + C to exit\");\n  new Thread(null).start();\n}\n", "nl": "Starts the interface."}
{"code": "public static byte[] encodeBase64(byte[] binaryData){\n  return org.apache.commons.codec.binary.Base64.encodeBase64(binaryData);\n}\n", "nl": "Encodes binary data using the base64 algorithm but does not chunk the output."}
{"code": "public int previousNode(){\n  if (!m_cacheNodes)   throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_CANNOT_ITERATE,null));\n  if ((m_next - 1) > 0) {\n    m_next--;\n    return this.elementAt(m_next);\n  }\n else   return DTM.NULL;\n}\n", "nl": "Returns the previous node in the set and moves the position of the iterator backwards in the set."}
{"code": "public synchronized void decrease(Bitmap bitmap){\n  final int bitmapSize=BitmapUtil.getSizeInBytes(bitmap);\n  Preconditions.checkArgument(mCount > 0,\"No bitmaps registered.\");\n  Preconditions.checkArgument(bitmapSize <= mSize,\"Bitmap size bigger than the total registered size: %d, %d\",bitmapSize,mSize);\n  mSize-=bitmapSize;\n  mCount--;\n}\n", "nl": "Excludes given bitmap from the count."}
{"code": "public void addExcludedName(String name){\n  Object obj=lookupQualifiedName(scope,name);\n  if (!(obj instanceof Scriptable)) {\n    throw new IllegalArgumentException(\"Object for excluded name \" + name + \" not found.\");\n  }\n  table.put(obj,name);\n}\n", "nl": "Adds a qualified name to the list of objects to be excluded from serialization. Names excluded from serialization are looked up in the new scope and replaced upon deserialization."}
{"code": "public void normalizeExcitatoryFanIn(){\n  double sum=0;\n  double str=0;\n  for (int i=0, n=fanIn.size(); i < n; i++) {\n    str=fanIn.get(i).getStrength();\n    if (str > 0) {\n      sum+=str;\n    }\n  }\n  Synapse s=null;\n  for (int i=0, n=fanIn.size(); i < n; i++) {\n    s=fanIn.get(i);\n    str=s.getStrength();\n    if (str > 0) {\n      s.setStrength(s.getStrength() / sum);\n    }\n  }\n}\n", "nl": "Normalizes the excitatory synaptic strengths impinging on this neuron, that is finds the sum of the exctiatory weights and divides each weight value by that sum;"}
{"code": "@MethodDesc(description=\"Configure properties by either rereading them or setting all properties from outside.\",usage=\"configure <properties>\") public void configure(@ParamDesc(name=\"tp\",description=\"Optional properties to replace replicator.properties\") TungstenProperties tp) throws Exception {\n  handleEventSynchronous(new ConfigureEvent(tp));\n}\n", "nl": "Local wrapper of configure to help with unit testing."}
{"code": "public boolean isArrayIndex(){\n  return true;\n}\n", "nl": "Return true if variable is an array"}
{"code": "public Object runSafely(Catbert.FastStack stack) throws Exception {\n  return NetworkClient.getConnectedClients();\n}\n", "nl": "Returns a list of all the clients that are currently connected to this server."}
{"code": "public Debug(String filename){\n  this(filename,1000000,1);\n}\n", "nl": "logs the output to the specified file (and stdout). Size is 1,000,000 bytes  and 1 file."}
{"code": "private String createKeywordDisplayName(TaxonKeyword keyword){\n  String combined=null;\n  if (keyword != null) {\n    String scientificName=StringUtils.trimToNull(keyword.getScientificName());\n    String commonName=StringUtils.trimToNull(keyword.getCommonName());\n    if (scientificName != null && commonName != null) {\n      combined=scientificName + \" (\" + commonName+ \")\";\n    }\n else     if (scientificName != null) {\n      combined=scientificName;\n    }\n else     if (commonName != null) {\n      combined=commonName;\n    }\n  }\n  return combined;\n}\n", "nl": "Construct display name from TaxonKeyword's scientific name and common name properties. It will look like: scientific name (common name) provided both properties are not null."}
{"code": "public static void w(String tag,String msg){\n  w(tag,msg,null);\n}\n", "nl": "Prints a message at WARN priority."}
{"code": "public BehaviorEvent(FacesContext facesContext,UIComponent component,Behavior behavior){\n  super(facesContext,component);\n  if (null == behavior) {\n    throw new IllegalArgumentException(\"Behavior agrument cannot be null\");\n  }\n  this.behavior=behavior;\n}\n", "nl": "<p class=\"changed_added_2_3\">Construct a new event object  from the Faces context, specified source component and behavior.</p>"}
{"code": "public static Number intdiv(Number left,Character right){\n  return intdiv(left,Integer.valueOf(right));\n}\n", "nl": "Integer Divide a Number by a Character. The ordinal value of the Character is used in the division (the ordinal value is the unicode value which for simple character sets is the ASCII value)."}
{"code": "public SQLDataException(String reason,Throwable cause){\n  super(reason,cause);\n}\n", "nl": "Creates an SQLDataException object. The Reason string is set to the given and the cause Throwable object is set to the given cause Throwable object."}
{"code": "public boolean isSetHeader(){\n  return this.header != null;\n}\n", "nl": "Returns true if field header is set (has been assigned a value) and false otherwise"}
{"code": "public boolean increment(float key){\n  return adjustValue(key,1);\n}\n", "nl": "Increments the primitive value mapped to key by 1"}
{"code": "public boolean finish(){\n  if (!started)   return false;\n  boolean ok=true;\n  started=false;\n  try {\n    out.write(0x3b);\n    out.flush();\n    if (closeStream) {\n      out.close();\n    }\n  }\n catch (  IOException e) {\n    ok=false;\n  }\n  transIndex=0;\n  out=null;\n  image=null;\n  pixels=null;\n  indexedPixels=null;\n  colorTab=null;\n  closeStream=false;\n  firstFrame=true;\n  return ok;\n}\n", "nl": "Flushes any pending data and closes output file. If writing to an OutputStream, the stream is not closed."}
{"code": "public void initializeDefinition(String tableName,boolean isUnique){\n  m_table=tableName;\n  m_isUnique=isUnique;\n  s_logger.log(Level.FINEST,toString());\n}\n", "nl": "initialize detailed definitions forindex"}
{"code": "private static String concatHeirTokens(SyntaxTreeNode stn){\n  SyntaxTreeNode[] heirs=stn.getHeirs();\n  if (heirs.length == 0) {\n    if (stn.getKind() < SyntaxTreeConstants.NULL_ID) {\n      return stn.getImage();\n    }\n else {\n      return \"\";\n    }\n  }\n  String val=\"\";\n  for (int i=0; i < heirs.length; i++) {\n    val=val + concatHeirTokens(heirs[i]);\n  }\n  return val;\n}\n", "nl": "Returns the concatenation of the images of all leaf nodes of the node stn that correspond to actual tokens"}
{"code": "public Object jjtAccept(ParserVisitor visitor,Object data){\n  return visitor.visit(this,data);\n}\n", "nl": "Accept the visitor."}
{"code": "public static Bitmap createImageThumbnail(String filePath,int kind){\n  boolean wantMini=(kind == Images.Thumbnails.MINI_KIND);\n  int targetSize=wantMini ? TARGET_SIZE_MINI_THUMBNAIL : TARGET_SIZE_MICRO_THUMBNAIL;\n  int maxPixels=wantMini ? MAX_NUM_PIXELS_THUMBNAIL : MAX_NUM_PIXELS_MICRO_THUMBNAIL;\n  SizedThumbnailBitmap sizedThumbnailBitmap=new SizedThumbnailBitmap();\n  Bitmap bitmap=null;\n  MediaFileType fileType=MediaFile.getFileType(filePath);\n  if (fileType != null && fileType.fileType == MediaFile.FILE_TYPE_JPEG) {\n    createThumbnailFromEXIF(filePath,targetSize,maxPixels,sizedThumbnailBitmap);\n    bitmap=sizedThumbnailBitmap.mBitmap;\n  }\n  if (bitmap == null) {\n    FileInputStream stream=null;\n    try {\n      stream=new FileInputStream(filePath);\n      FileDescriptor fd=stream.getFD();\n      BitmapFactory.Options options=new BitmapFactory.Options();\n      options.inSampleSize=1;\n      options.inJustDecodeBounds=true;\n      BitmapFactory.decodeFileDescriptor(fd,null,options);\n      if (options.mCancel || options.outWidth == -1 || options.outHeight == -1) {\n        return null;\n      }\n      options.inSampleSize=computeSampleSize(options,targetSize,maxPixels);\n      options.inJustDecodeBounds=false;\n      options.inDither=false;\n      options.inPreferredConfig=Bitmap.Config.ARGB_8888;\n      bitmap=BitmapFactory.decodeFileDescriptor(fd,null,options);\n    }\n catch (    IOException ex) {\n      Log.e(TAG,\"\",ex);\n    }\ncatch (    OutOfMemoryError oom) {\n      Log.e(TAG,\"Unable to decode file \" + filePath + \". OutOfMemoryError.\",oom);\n    }\n finally {\n      try {\n        if (stream != null) {\n          stream.close();\n        }\n      }\n catch (      IOException ex) {\n        Log.e(TAG,\"\",ex);\n      }\n    }\n  }\n  if (kind == Images.Thumbnails.MICRO_KIND) {\n    bitmap=extractThumbnail(bitmap,TARGET_SIZE_MICRO_THUMBNAIL,TARGET_SIZE_MICRO_THUMBNAIL,OPTIONS_RECYCLE_INPUT);\n  }\n  return bitmap;\n}\n", "nl": "This method first examines if the thumbnail embedded in EXIF is bigger than our target size. If not, then it'll create a thumbnail from original image. Due to efficiency consideration, we want to let MediaThumbRequest avoid calling this method twice for both kinds, so it only requests for MICRO_KIND and set saveImage to true. This method always returns a \"square thumbnail\" for MICRO_KIND thumbnail."}
{"code": "public static <T extends Annotation>T checkAnnotationPresent(AnnotatedElement annotatedType,Class<T> annotationClass){\n  return getAnnotation(annotatedType,annotationClass);\n}\n", "nl": "Check if the annotation is present and if not throws an exception, this is just an overload for more clear naming."}
{"code": "public Element store(Object o){\n  PortalIcon p=(PortalIcon)o;\n  if (!p.isActive()) {\n    return null;\n  }\n  Element element=new Element(\"PortalIcon\");\n  storeCommonAttributes(p,element);\n  element.setAttribute(\"scale\",String.valueOf(p.getScale()));\n  element.setAttribute(\"rotate\",String.valueOf(p.getDegrees()));\n  Portal portal=p.getPortal();\n  if (portal == null) {\n    log.info(\"PortalIcon has no associated Portal.\");\n    return null;\n  }\n  element.setAttribute(\"portalName\",portal.getName());\n  if (portal.getToBlock() != null) {\n    element.setAttribute(\"toBlockName\",portal.getToBlockName());\n  }\n  if (portal.getFromBlockName() != null) {\n    element.setAttribute(\"fromBlockName\",portal.getFromBlockName());\n  }\n  element.setAttribute(\"arrowSwitch\",\"\" + (p.getArrowSwitch() ? \"yes\" : \"no\"));\n  element.setAttribute(\"arrowHide\",\"\" + (p.getArrowHide() ? \"yes\" : \"no\"));\n  element.setAttribute(\"class\",\"jmri.jmrit.display.controlPanelEditor.configurexml.PortalIconXml\");\n  return element;\n}\n", "nl": "Default implementation for storing the contents of a PortalIcon"}
{"code": "public Address __rxor__(final Object rhs){\n  return new Address(m_value.xor(getBigInteger(rhs)));\n}\n", "nl": "Used to support reverse XOR operations on addresses in Python scripts."}
{"code": "public SimpleUser(String username,Collection<String> userIdentifiers,Collection<String> connectionIdentifiers,Collection<String> connectionGroupIdentifiers){\n  this(username);\n  addReadPermissions(userPermissions,userIdentifiers);\n  addReadPermissions(connectionPermissions,connectionIdentifiers);\n  addReadPermissions(connectionGroupPermissions,connectionGroupIdentifiers);\n}\n", "nl": "Creates a new SimpleUser having the given username and READ access to the users, connections, and groups having the given identifiers."}
{"code": "public void startDocument() throws org.xml.sax.SAXException {\n}\n", "nl": "Receive notification of the beginning of a document. <p>The SAX parser will invoke this method only once, before any other methods in this interface or in DTDHandler (except for setDocumentLocator).</p>"}
{"code": "protected AbstractIntSpliterator(long est,int additionalCharacteristics){\n  this.est=est;\n  this.characteristics=((additionalCharacteristics & Spliterator.SIZED) != 0) ? additionalCharacteristics | Spliterator.SUBSIZED : additionalCharacteristics;\n}\n", "nl": "Creates a spliterator reporting the given estimated size and characteristics."}
{"code": "private Set<DefUseCoverageTestFitness> preAnalyzeMethods(){\n  Set<DefUseCoverageTestFitness> r=new HashSet<DefUseCoverageTestFitness>();\n  LinkedList<ClassCallNode> toAnalyze=new LinkedList<ClassCallNode>();\n  toAnalyze.addAll(getInitialPreAnalyzeableMethods());\n  while (!toAnalyze.isEmpty()) {\n    ClassCallNode currentMethod=toAnalyze.poll();\n    CCFGMethodEntryNode analyzeableEntry=ccfg.getMethodEntryNodeForClassCallNode(currentMethod);\n    if (analyzedMethods.contains(analyzeableEntry))     continue;\n    r.addAll(determineIntraInterMethodPairs(analyzeableEntry));\n    Set<ClassCallNode> parents=ccfg.getCcg().getParents(currentMethod);\n    for (    ClassCallNode parent : parents) {\n      if (toAnalyze.contains(parent))       continue;\n      if (analyzedMethods.contains(ccfg.getMethodEntryNodeForClassCallNode(parent)))       continue;\n      Set<ClassCallNode> parentsChildren=ccfg.getCcg().getChildren(parent);\n      boolean canAnalyzeNow=true;\n      for (      ClassCallNode parentsChild : parentsChildren) {\n        if (parentsChild == null)         continue;\n        if (!parentsChild.equals(parent) && !(toAnalyze.contains(parentsChild) || analyzedMethods.contains(ccfg.getMethodEntryNodeForClassCallNode(parentsChild)))) {\n          canAnalyzeNow=false;\n          break;\n        }\n      }\n      if (canAnalyzeNow) {\n        toAnalyze.offer(parent);\n      }\n    }\n  }\n  return r;\n}\n", "nl": "Checks if there are methods in the CCG that dont call any other methods except for maybe itself. For these we can predetermine free uses and activeDefs prior to looking for inter_method_pairs. After that we can even repeat this process for methods we now have determined free uses and activeDefs! that way you can save a lot of computation. Map activeDefs and freeUses according to the variable so you can easily determine which defs will be active and which uses are free once you encounter a methodCall to that method without looking at its part of the CCFG"}
{"code": "public SimpleProjectDescription createSimpleProjectDescription(){\n  SimpleProjectDescriptionImpl simpleProjectDescription=new SimpleProjectDescriptionImpl();\n  return simpleProjectDescription;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public void writeAll(){\n  for (int row=0; row < _numRows; row++) {\n    writeState[row]=WRITE;\n  }\n  issueNextOperation();\n}\n", "nl": "Start writing all rows out"}
{"code": "public String str(){\n  return (m_obj != null) ? m_obj.toString() : \"\";\n}\n", "nl": "Cast result object to a string."}
{"code": "public int checkThreadIDAllow0(int uid){\n  if (uid == 0) {\n    uid=currentThread.uid;\n  }\n  if (!threadMap.containsKey(uid)) {\n    log.warn(String.format(\"checkThreadID not found thread 0x%08X\",uid));\n    throw new SceKernelErrorException(ERROR_KERNEL_NOT_FOUND_THREAD);\n  }\n  if (!SceUidManager.checkUidPurpose(uid,\"ThreadMan-thread\",true)) {\n    throw new SceKernelErrorException(ERROR_KERNEL_NOT_FOUND_THREAD);\n  }\n  return uid;\n}\n", "nl": "Check the validity of the thread UID. Allow uid=0."}
{"code": "public boolean isPowerOfThreeB(int n){\n  return n > 0 && maxPow3 % n == 0;\n}\n", "nl": "Find the max power of 3 within int range. It should be divisible by all power of 3s."}
{"code": "protected void addDefinitionRef(Element defRef){\n  String ref=defRef.getAttributeNS(null,XBL_REF_ATTRIBUTE);\n  Element e=ctx.getReferencedElement(defRef,ref);\n  if (!XBL_NAMESPACE_URI.equals(e.getNamespaceURI()) || !XBL_DEFINITION_TAG.equals(e.getLocalName())) {\n    throw new BridgeException(ctx,defRef,ErrorConstants.ERR_URI_BAD_TARGET,new Object[]{ref});\n  }\n  ImportRecord ir=new ImportRecord(defRef,e);\n  imports.put(defRef,ir);\n  NodeEventTarget et=(NodeEventTarget)defRef;\n  et.addEventListenerNS(XMLConstants.XML_EVENTS_NAMESPACE_URI,\"DOMAttrModified\",refAttrListener,false,null);\n  XBLOMDefinitionElement d=(XBLOMDefinitionElement)defRef;\n  String ns=d.getElementNamespaceURI();\n  String ln=d.getElementLocalName();\n  addDefinition(ns,ln,(XBLOMDefinitionElement)e,defRef);\n}\n", "nl": "Adds a definition through its referring definition element (one with a 'ref' attribute)."}
{"code": "public ActiveMQRATopicSubscriber(final TopicSubscriber consumer,final ActiveMQRASession session){\n  super(consumer,session);\n  if (ActiveMQRATopicSubscriber.trace) {\n    ActiveMQRALogger.LOGGER.trace(\"constructor(\" + consumer + \", \"+ session+ \")\");\n  }\n}\n", "nl": "Create a new wrapper"}
{"code": "private void fieldInsn(final int opcode,final Type ownerType,final String name,final Type fieldType){\n  mv.visitFieldInsn(opcode,ownerType.getInternalName(),name,fieldType.getDescriptor());\n}\n", "nl": "Generates a get field or set field instruction."}
{"code": "@Override public void doFrame(long frameTimeNanos){\n  if (isPaused.get()) {\n    return;\n  }\n  long frameTimeMillis=frameTimeNanos / 1000000;\n  WritableArray timersToCall=null;\nsynchronized (mTimerGuard) {\n    while (!mTimers.isEmpty() && mTimers.peek().mTargetTime < frameTimeMillis) {\n      Timer timer=mTimers.poll();\n      if (timersToCall == null) {\n        timersToCall=Arguments.createArray();\n      }\n      timersToCall.pushInt(timer.mCallbackID);\n      if (timer.mRepeat) {\n        timer.mTargetTime=frameTimeMillis + timer.mInterval;\n        mTimers.add(timer);\n      }\n else {\n        mTimerIdsToTimers.remove(timer.mCallbackID);\n      }\n    }\n  }\n  if (timersToCall != null) {\n    Assertions.assertNotNull(mJSTimersModule).callTimers(timersToCall);\n  }\n  Assertions.assertNotNull(mReactChoreographer).postFrameCallback(ReactChoreographer.CallbackType.TIMERS_EVENTS,this);\n}\n", "nl": "Calls all timers that have expired since the last time this frame callback was called."}
{"code": "protected void executeLogoutCommand(){\n  shoppingCartCommandFactory.execute(ShoppingCartCommand.CMD_LOGIN,cartMixin.getCurrentCart(),new HashMap<String,Object>(){\n{\n      put(ShoppingCartCommand.CMD_LOGOUT,ShoppingCartCommand.CMD_LOGOUT);\n    }\n  }\n);\n}\n", "nl": "Execute logout command."}
{"code": "public boolean equals(Object obj){\n  if (obj == this) {\n    return true;\n  }\n  if (obj instanceof CharSet == false) {\n    return false;\n  }\n  CharSet other=(CharSet)obj;\n  return set.equals(other.set);\n}\n", "nl": "<p>Compares two CharSet objects, returning true if they represent exactly the same set of characters defined in the same way.</p> <p>The two sets <code>abc</code> and <code>a-c</code> are <i>not</i> equal according to this method.</p>"}
{"code": "private PlatformUtils(){\n}\n", "nl": "Creates a new PlatformUtils object."}
{"code": "@Override @TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED) public InstanceStatus deleteInstance(String instanceId,ProvisioningSettings settings) throws APPlatformException {\n  PropertyHandler paramHandler=new PropertyHandler(settings);\n  paramHandler.setState(Status.DELETION_REQUESTED);\n  InstanceStatus result=new InstanceStatus();\n  result.setChangedParameters(settings.getParameters());\n  return result;\n}\n", "nl": "Starts the deletion of an application instance. <p> The internal status <code>DELETION_REQUESTED</code> is stored as a controller configuration setting. It is evaluated and handled by the status dispatcher, which is invoked at regular intervals by APP through the <code>getInstanceStatus</code> method."}
{"code": "public boolean isOnline(){\n  Object oo=get_Value(COLUMNNAME_IsOnline);\n  if (oo != null) {\n    if (oo instanceof Boolean)     return ((Boolean)oo).booleanValue();\n    return \"Y\".equals(oo);\n  }\n  return false;\n}\n", "nl": "Get Online Access."}
{"code": "public EditSensorsAction(final VisionWorld visionWorld){\n  super(\"Edit selected sensor(s)...\");\n  if (visionWorld == null) {\n    throw new IllegalArgumentException(\"visionWorld must not be null\");\n  }\n  this.visionWorld=visionWorld;\n  this.visionWorld.getSensorSelectionModel().addSensorSelectionListener(new SelectionListener());\n}\n", "nl": "Create a new edit sensors action."}
{"code": "@Override public final V replace(K key,V value){\n  long hash, allocIndex;\n  Segment<K,V> segment;\n  V oldValue;\n  if ((allocIndex=(segment=segment(segmentIndex(hash=keyHashCode(key)))).find(this,hash,key)) > 0) {\n    oldValue=segment.readValue(allocIndex);\n    segment.writeValue(allocIndex,value);\n    return oldValue;\n  }\n  return null;\n}\n", "nl": "Replaces the entry for the specified key only if it is currently mapped to some value."}
{"code": "public UserResource user(){\n  return user;\n}\n", "nl": "Get the subresource containing all of the commands related to a tenant's users."}
{"code": "private boolean isExportable(Step step){\n  return Exporter.class.getResource(String.format(\"/edu/wpi/grip/ui/codegeneration/%s/operations/%s.vm\",lang.filePath,step.getOperationDescription().name().replace(' ','_'))) != null;\n}\n", "nl": "Checks if a step is exportable to this exporter's language."}
{"code": "public static List<Long> view(long[] array,int length){\n  return new LongList(array,length);\n}\n", "nl": "Creates and returns a view of the given long array that  requires only a small object allocation."}
{"code": "final public MutableString insert(final int index,final Object o){\n  return insert(index,String.valueOf(o));\n}\n", "nl": "Inserts the string representation of an object in this mutable string, starting from index <code>index</code>."}
{"code": "public boolean checkAttributeValuesChanged(BlockVirtualPoolUpdateParam param,VirtualPool vpool){\n  return super.checkAttributeValuesChanged(param,vpool) || checkPathParameterModified(vpool.getNumPaths(),param.getMaxPaths()) || checkPathParameterModified(vpool.getMinPaths(),param.getMinPaths())|| checkPathParameterModified(vpool.getPathsPerInitiator(),param.getPathsPerInitiator())|| checkPathParameterModified(vpool.getHostIOLimitBandwidth(),param.getHostIOLimitBandwidth())|| checkPathParameterModified(vpool.getHostIOLimitIOPs(),param.getHostIOLimitIOPs())|| VirtualPoolUtil.checkRaidLevelsChanged(vpool.getArrayInfo(),param.getRaidLevelChanges())|| VirtualPoolUtil.checkForVirtualPoolAttributeModification(vpool.getDriveType(),param.getDriveType())|| VirtualPoolUtil.checkThinVolumePreAllocationChanged(vpool.getThinVolumePreAllocationPercentage(),param.getThinVolumePreAllocationPercentage())|| VirtualPoolUtil.checkProtectionChanged(vpool,param.getProtection())|| VirtualPoolUtil.checkHighAvailabilityChanged(vpool,param.getHighAvailability());\n}\n", "nl": "Check if any VirtualPool attribute values have changed."}
{"code": "@Override public Boolean visitIntersection_Intersection(final AnnotatedIntersectionType type1,final AnnotatedIntersectionType type2,final VisitHistory visited){\n  if (!arePrimeAnnosEqual(type1,type2)) {\n    return false;\n  }\n  visited.add(type1,type2);\n  return areAllEqual(type1.directSuperTypes(),type2.directSuperTypes(),visited);\n}\n", "nl": "//TODO: SHOULD PRIMARY ANNOTATIONS OVERRIDE INDIVIDUAL BOUND ANNOTATIONS? //TODO: IF SO THEN WE SHOULD REMOVE THE arePrimeAnnosEqual AND FIX AnnotatedIntersectionType Two intersection types are equal if: 1) Their sets of primary annotations are equal 2) Their sets of bounds (the types being intersected) are equal"}
{"code": "public void writeEnum(final int fieldNumber,final int value) throws IOException {\n  writeTag(fieldNumber,WireFormat.WIRETYPE_VARINT);\n  writeEnumNoTag(value);\n}\n", "nl": "Write an enum field, including tag, to the stream.  Caller is responsible for converting the enum value to its numeric value."}
{"code": "@Override protected char[] escape(int cp){\n  if (cp < safeOctets.length && safeOctets[cp]) {\n    return null;\n  }\n else   if (cp == ' ' && plusForSpace) {\n    return PLUS_SIGN;\n  }\n else   if (cp <= 0x7F) {\n    char[] dest=new char[3];\n    dest[0]='%';\n    dest[2]=UPPER_HEX_DIGITS[cp & 0xF];\n    dest[1]=UPPER_HEX_DIGITS[cp >>> 4];\n    return dest;\n  }\n else   if (cp <= 0x7ff) {\n    char[] dest=new char[6];\n    dest[0]='%';\n    dest[3]='%';\n    dest[5]=UPPER_HEX_DIGITS[cp & 0xF];\n    cp>>>=4;\n    dest[4]=UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];\n    cp>>>=2;\n    dest[2]=UPPER_HEX_DIGITS[cp & 0xF];\n    cp>>>=4;\n    dest[1]=UPPER_HEX_DIGITS[0xC | cp];\n    return dest;\n  }\n else   if (cp <= 0xffff) {\n    char[] dest=new char[9];\n    dest[0]='%';\n    dest[1]='E';\n    dest[3]='%';\n    dest[6]='%';\n    dest[8]=UPPER_HEX_DIGITS[cp & 0xF];\n    cp>>>=4;\n    dest[7]=UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];\n    cp>>>=2;\n    dest[5]=UPPER_HEX_DIGITS[cp & 0xF];\n    cp>>>=4;\n    dest[4]=UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];\n    cp>>>=2;\n    dest[2]=UPPER_HEX_DIGITS[cp];\n    return dest;\n  }\n else   if (cp <= 0x10ffff) {\n    char[] dest=new char[12];\n    dest[0]='%';\n    dest[1]='F';\n    dest[3]='%';\n    dest[6]='%';\n    dest[9]='%';\n    dest[11]=UPPER_HEX_DIGITS[cp & 0xF];\n    cp>>>=4;\n    dest[10]=UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];\n    cp>>>=2;\n    dest[8]=UPPER_HEX_DIGITS[cp & 0xF];\n    cp>>>=4;\n    dest[7]=UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];\n    cp>>>=2;\n    dest[5]=UPPER_HEX_DIGITS[cp & 0xF];\n    cp>>>=4;\n    dest[4]=UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];\n    cp>>>=2;\n    dest[2]=UPPER_HEX_DIGITS[cp & 0x7];\n    return dest;\n  }\n else {\n    throw new IllegalArgumentException(\"Invalid unicode character value \" + cp);\n  }\n}\n", "nl": "Escapes the given Unicode code point in UTF-8."}
{"code": "public X509CRLImpl(InputStream inStrm) throws CRLException {\n  try {\n    parse(new DerValue(inStrm));\n  }\n catch (  IOException e) {\n    signedCRL=null;\n    throw new CRLException(\"Parsing error: \" + e.getMessage());\n  }\n}\n", "nl": "Unmarshals an X.509 CRL from an input stream. Only one CRL is expected at the end of the input stream."}
{"code": "protected boolean removeTurntable(LayoutTurntable o){\n  if (!noWarnTurntable) {\n    int selectedValue=JOptionPane.showOptionDialog(this,rb.getString(\"Question4r\"),Bundle.getMessage(\"WarningTitle\"),JOptionPane.YES_NO_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE,null,new Object[]{Bundle.getMessage(\"ButtonYes\"),Bundle.getMessage(\"ButtonNo\"),rb.getString(\"ButtonYesPlus\")},Bundle.getMessage(\"ButtonNo\"));\n    if (selectedValue == 1) {\n      return (false);\n    }\n    if (selectedValue == 2) {\n      noWarnTurntable=true;\n    }\n  }\n  if (selectedObject == o) {\n    selectedObject=null;\n  }\n  if (prevSelectedObject == o) {\n    prevSelectedObject=null;\n  }\n  for (int j=0; j < o.getNumberRays(); j++) {\n    TrackSegment t=o.getRayConnectOrdered(j);\n    if (t != null) {\n      substituteAnchor(o.getRayCoordsIndexed(j),o,t);\n    }\n  }\n  for (int i=0; i < turntableList.size(); i++) {\n    LayoutTurntable lx=turntableList.get(i);\n    if (lx == o) {\n      turntableList.remove(i);\n      o.remove();\n      setDirty(true);\n      repaint();\n      return (true);\n    }\n  }\n  return (false);\n}\n", "nl": "Remove a Layout Turntable"}
{"code": "protected void emptyTag(Element elem) throws BadLocationException, IOException {\n  if (!inContent && !inPre) {\n    indentSmart();\n  }\n  AttributeSet attr=elem.getAttributes();\n  closeOutUnwantedEmbeddedTags(attr);\n  writeEmbeddedTags(attr);\n  if (matchNameAttribute(attr,HTML.Tag.CONTENT)) {\n    inContent=true;\n    text(elem);\n  }\n else   if (matchNameAttribute(attr,HTML.Tag.COMMENT)) {\n    comment(elem);\n  }\n else {\n    boolean isBlock=isBlockTag(elem.getAttributes());\n    if (inContent && isBlock) {\n      writeLineSeparator();\n      indentSmart();\n    }\n    Object nameTag=(attr != null) ? attr.getAttribute(StyleConstants.NameAttribute) : null;\n    Object endTag=(attr != null) ? attr.getAttribute(HTML.Attribute.ENDTAG) : null;\n    boolean outputEndTag=false;\n    if (nameTag != null && endTag != null && (endTag instanceof String) && endTag.equals(\"true\")) {\n      outputEndTag=true;\n    }\n    if (completeDoc && matchNameAttribute(attr,HTML.Tag.HEAD)) {\n      if (outputEndTag) {\n        writeStyles(((HTMLDocument)getDocument()).getStyleSheet());\n      }\n      wroteHead=true;\n    }\n    write('<');\n    if (outputEndTag) {\n      write('/');\n    }\n    write(elem.getName());\n    writeAttributes(attr);\n    write('>');\n    if (matchNameAttribute(attr,HTML.Tag.TITLE) && !outputEndTag) {\n      Document doc=elem.getDocument();\n      String title=(String)doc.getProperty(Document.TitleProperty);\n      write(title);\n    }\n else     if (!inContent || isBlock) {\n      writeLineSeparator();\n      if (isBlock && inContent) {\n        indentSmart();\n      }\n    }\n  }\n}\n", "nl": "Writes out all empty elements (all tags that have no corresponding end tag)."}
{"code": "public boolean isPending(){\n  return getConfidence().getConfidenceType() == TransactionConfidence.ConfidenceType.PENDING;\n}\n", "nl": "Convenience wrapper around getConfidence().getConfidenceType()"}
{"code": "public final void fireSensorMatrixChanged(final SensorMatrix oldSensorMatrix,final SensorMatrix sensorMatrix){\n  if (oldSensorMatrix == null) {\n    throw new IllegalArgumentException(\"oldSensorMatrix must not be null\");\n  }\n  if (sensorMatrix == null) {\n    throw new IllegalArgumentException(\"sensorMatrix must not be null\");\n  }\n  Object[] listeners=listenerList.getListenerList();\n  VisionWorldModelEvent event=null;\n  for (int i=listeners.length - 2; i >= 0; i-=2) {\n    if (listeners[i] == VisionWorldModelListener.class) {\n      if (event == null) {\n        event=new VisionWorldModelEvent(source,oldSensorMatrix,sensorMatrix);\n      }\n      ((VisionWorldModelListener)listeners[i + 1]).sensorMatrixChanged(event);\n    }\n  }\n}\n", "nl": "Fire a sensor matrix changed event to all registered vision world model listeners."}
{"code": "public DNameConstraints(JDialog parent){\n  super(parent);\n  setTitle(res.getString(\"DNameConstraints.Title\"));\n  initComponents();\n}\n", "nl": "Creates a new DNameConstraints dialog."}
{"code": "@Override public void visit(NodeVisitor v){\n  v.visit(this);\n}\n", "nl": "Visits this node.  There are no children."}
{"code": "@Override public void LDC(int x){\n  env.topFrame().operandStack.pushBv32(ExpressionFactory.buildNewIntegerConstant(x));\n}\n", "nl": "Bytecode instruction stream: ... ,0x12, index, ... <p> Push corresponding symbolic constant from constant pool (at index) onto the operand stack. http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2. doc8.html#ldc"}
{"code": "@SuppressWarnings(\"unused\") private SentenceFilteredTrie filter_regexp(Trie unfilteredTrie){\n  SentenceFilteredTrie trie=null;\n  if (unfilteredTrie.hasRules())   if (matchesSentence(unfilteredTrie))   trie=new SentenceFilteredTrie(unfilteredTrie);\n else   return null;\n  if (unfilteredTrie.hasExtensions())   for (  Entry<Integer,? extends Trie> arc : unfilteredTrie.getChildren().entrySet()) {\n    Trie unfilteredChildTrie=arc.getValue();\n    SentenceFilteredTrie nextTrie=filter_regexp(unfilteredChildTrie);\n    if (nextTrie != null) {\n      if (trie == null)       trie=new SentenceFilteredTrie(unfilteredTrie);\n      trie.children.put(arc.getKey(),nextTrie);\n    }\n  }\n  return trie;\n}\n", "nl": "Alternate filter that uses regular expressions, walking the grammar trie and matching the source side of each rule collection against the input sentence. Failed matches are discarded, and trie nodes extending from that position need not be explored."}
{"code": "protected void engineUpdate(byte input){\n  if (first == true) {\n    md.update(k_ipad);\n    first=false;\n  }\n  md.update(input);\n}\n", "nl": "Processes the given byte."}
{"code": "@Override public void configureZone(final StendhalRPZone zone,final Map<String,String> attributes){\n  buildAdosGreetingSoldier(zone);\n}\n", "nl": "Configure a zone."}
{"code": "public static KerberosTime parse(DerInputStream data,byte explicitTag,boolean optional) throws Asn1Exception, IOException {\n  if ((optional) && (((byte)data.peekByte() & (byte)0x1F) != explicitTag))   return null;\n  DerValue der=data.getDerValue();\n  if (explicitTag != (der.getTag() & (byte)0x1F)) {\n    throw new Asn1Exception(Krb5.ASN1_BAD_ID);\n  }\n else {\n    DerValue subDer=der.getData().getDerValue();\n    Date temp=subDer.getGeneralizedTime();\n    return new KerberosTime(temp.getTime(),0);\n  }\n}\n", "nl": "Parse (unmarshal) a kerberostime from a DER input stream.  This form parsing might be used when expanding a value which is part of a constructed sequence and uses explicitly tagged type."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 13:02:38.770 -0500\",hash_original_method=\"C464D16A28A9DCABA3B0B8FD02F52155\",hash_generated_method=\"0A183B7841054C14E915336FD1A0DC9E\") public static boolean hasExtension(String extension){\n  if (extension == null || extension.isEmpty()) {\n    return false;\n  }\n  return extensionToMimeTypeMap.containsKey(extension);\n}\n", "nl": "Returns true if the given extension has a registered MIME type."}
{"code": "public void testExhaustContentSource() throws Exception {\n  String algLines[]={\"# ----- properties \",\"content.source=org.apache.lucene.benchmark.byTask.feeds.SingleDocSource\",\"content.source.log.step=1\",\"doc.term.vector=false\",\"content.source.forever=false\",\"directory=RAMDirectory\",\"doc.stored=false\",\"doc.tokenized=false\",\"# ----- alg \",\"CreateIndex\",\"{ AddDoc } : * \",\"ForceMerge(1)\",\"CloseIndex\",\"OpenReader\",\"{ CountingSearchTest } : 100\",\"CloseReader\",\"[ CountingSearchTest > : 30\",\"[ CountingSearchTest > : 9\"};\n  CountingSearchTestTask.numSearches=0;\n  Benchmark benchmark=execBenchmark(algLines);\n  assertEquals(\"TestSearchTask was supposed to be called!\",139,CountingSearchTestTask.numSearches);\n  assertTrue(\"Index does not exist?...!\",DirectoryReader.indexExists(benchmark.getRunData().getDirectory()));\n  IndexWriter iw=new IndexWriter(benchmark.getRunData().getDirectory(),new IndexWriterConfig(new MockAnalyzer(random())).setOpenMode(OpenMode.APPEND));\n  iw.close();\n  IndexReader ir=DirectoryReader.open(benchmark.getRunData().getDirectory());\n  assertEquals(\"1 docs were added to the index, this is what we expect to find!\",1,ir.numDocs());\n  ir.close();\n}\n", "nl": "Test Exhasting Doc Maker logic"}
{"code": "@DSSource({DSSourceKind.NETWORK}) @DSSafe(DSCat.SAFE_LIST) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2014-02-25 10:38:10.723 -0500\",hash_original_method=\"8EB7107FA2367D701AF7CBC234A81F19\",hash_generated_method=\"B23ED7B4CA5FBA5E6343C71EA6EDB1E4\") public String toString(){\n  StringBuffer header=new StringBuffer();\n  header.append(\"From: \");\n  header.append(__from);\n  header.append(\"\\nNewsgroups: \");\n  header.append(__newsgroups.toString());\n  header.append(\"\\nSubject: \");\n  header.append(__subject);\n  header.append('\\n');\n  if (__headerFields.length() > 0)   header.append(__headerFields.toString());\n  header.append('\\n');\n  return header.toString();\n}\n", "nl": "Converts the SimpleNNTPHeader to a properly formatted header in the form of a String, including the blank line used to separate the header from the article body. <p>"}
{"code": "private void sincronizarBase(){\n  listaOrganizacao=ControleDAO.getBanco().getOrganizacaoDAO().listar();\n}\n", "nl": "Sincronizar dados com banco de dados"}
{"code": "protected int newlines(char[] text){\n  int result=0;\n  for (int i=0; i < text.length; i++) {\n    if (text[i] == 10) {\n      result++;\n    }\n  }\n  return result;\n}\n", "nl": "Returns the number of newlines in the given char array."}
{"code": "protected BinaryBitmap toBitmap(LuminanceSource source){\n  return new BinaryBitmap(new HybridBinarizer(source));\n}\n", "nl": "Given an image source, convert to a binary bitmap. Override this to use a custom binarizer."}
{"code": "protected void handleMergeException(Directory dir,Throwable exc){\n  throw new MergePolicy.MergeException(exc,dir);\n}\n", "nl": "Called when an exception is hit in a background merge thread"}
{"code": "public FactoryDto merge(FactoryDto factory,ProjectConfigDto computedProjectConfig){\n  final List<ProjectConfigDto> projects=factory.getWorkspace().getProjects();\n  if (projects == null || projects.isEmpty()) {\n    factory.getWorkspace().setProjects(singletonList(computedProjectConfig));\n    return factory;\n  }\n  if (projects.size() == 1) {\n    ProjectConfigDto projectConfig=projects.get(0);\n    if (projectConfig.getSource() == null)     projectConfig.setSource(computedProjectConfig.getSource());\n  }\n  return factory;\n}\n", "nl": "Apply the merging of project config dto including source storage dto into the existing factory <p> here are the following rules <ul> <li>no projects --> add whole project</li> <li>if projects <ul> <li>: if there is only one project: add source if missing</li> <li> if many projects: do nothing</li> </ul></li> </ul>"}
{"code": "public StatusLine parseSIPStatusLine(String statusLine) throws ParseException {\n  statusLine+=\"\\n\";\n  return new StatusLineParser(statusLine).parse();\n}\n", "nl": "Parse the SIP Response message status line"}
{"code": "public void initQuitAction(QuitAction quitAction){\n  if (quitAction == null)   throw new IllegalArgumentException(\"quitAction is null\");\n  if (this.quitAction != null)   throw new IllegalArgumentException(\"The method is once-call.\");\n  this.quitAction=quitAction;\n}\n", "nl": "Set the action to call from quit()."}
{"code": "public static boolean isFileStoragePool(StoragePool storagePool,DbClient dbClient){\n  URI storageSystemUri=storagePool.getStorageDevice();\n  StorageSystem storageSystem=dbClient.queryObject(StorageSystem.class,storageSystemUri);\n  ArgValidator.checkEntity(storageSystem,storageSystemUri,false);\n  StorageSystem.Type storageSystemType=StorageSystem.Type.valueOf(storageSystem.getSystemType());\n  return (storageSystemType.equals(StorageSystem.Type.isilon) || storageSystemType.equals(StorageSystem.Type.vnxfile));\n}\n", "nl": "Finds if a pool is file storage pool"}
{"code": "public static Object invokeStatic(String clazz,String methodName,Class[] types,Object[] values,Object defaultValue){\n  try {\n    return invokeStatic(Class.forName(clazz),methodName,types,values);\n  }\n catch (  ClassNotFoundException e) {\n    return defaultValue;\n  }\ncatch (  NoSuchMethodException e) {\n    return defaultValue;\n  }\n}\n", "nl": "Invokes the specified parameterless method if it exists."}
{"code": "String internalsprintf(double s) throws IllegalArgumentException {\n  String s2=\"\";\nswitch (conversionCharacter) {\ncase 'f':\n    s2=printFFormat(s);\n  break;\ncase 'E':\ncase 'e':\ns2=printEFormat(s);\nbreak;\ncase 'G':\ncase 'g':\ns2=printGFormat(s);\nbreak;\ndefault :\nthrow new IllegalArgumentException(\"Cannot \" + \"format a double with a format using a \" + conversionCharacter + \" conversion character.\");\n}\nreturn s2;\n}\n", "nl": "Format a double argument using this conversion specification."}
{"code": "@Override public NotificationChain eInverseRemove(InternalEObject otherEnd,int featureID,NotificationChain msgs){\nswitch (featureID) {\ncase N4mfPackage.MODULE_FILTER__MODULE_SPECIFIERS:\n    return ((InternalEList<?>)getModuleSpecifiers()).basicRemove(otherEnd,msgs);\n}\nreturn super.eInverseRemove(otherEnd,featureID,msgs);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public boolean hasUiObjectExpression(){\n  return !StringUtils.isEmpty(getUiObjectExpression);\n}\n", "nl": "If this databinding reference an ui element that is not the widget bound to this binding,  then an expression is used to retrieve the target ui element"}
{"code": "public void restore(){\n  try {\n    if (inCurrentStorage)     currentStorage.insertElementSafe(element);\n else     currentStorage.removeElement(element);\n    if (inApiStorage)     apiStorage.insertElementSafe(element);\n else     apiStorage.removeElement(element);\n  }\n catch (  StorageException e) {\n    e.printStackTrace();\n  }\n  element.osmId=osmId;\n  element.osmVersion=osmVersion;\n  element.state=state;\n  element.setTags(tags);\n  if (parentRelations != null) {\n    element.parentRelations=new ArrayList<Relation>();\n    element.parentRelations.addAll(parentRelations);\n  }\n else {\n    element.parentRelations=null;\n  }\n}\n", "nl": "Restores the saved state of the element"}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:36:00.382 -0500\",hash_original_method=\"A7CC818E7F384DAEC54D76069E9C5019\",hash_generated_method=\"E8FCEBA0D995DB6EE22CA1B5390C8697\") protected int available() throws IOException {\n  return getInputStream().available();\n}\n", "nl": "Returns the number of bytes available for reading without blocking."}
{"code": "public boolean isOverwriteMode(){\n  return hexEditControl == null || hexEditControl.isOverwriteMode();\n}\n", "nl": "Tells whether the input is in overwrite or insert mode"}
{"code": "public String[] loadStrings(String filename){\n  InputStream is=createInput(filename);\n  if (is != null)   return loadStrings(is);\n  System.err.println(\"The file \\\"\" + filename + \"\\\" \"+ \"is missing or inaccessible, make sure \"+ \"the URL is valid or that the file has been \"+ \"added to your sketch and is readable.\");\n  return null;\n}\n", "nl": "Load data from a file and shove it into a String array. <p/> Exceptions are handled internally, when an error, occurs, an exception is printed to the console and 'null' is returned, but the program continues running. This is a tradeoff between 1) showing the user that there was a problem but 2) not requiring that all i/o code is contained in try/catch blocks, for the sake of new users (or people who are just trying to get things done in a \"scripting\" fashion. If you want to handle exceptions, use Java methods for I/O."}
{"code": "private Iterable<Field> fieldsWithAnnotation(Class<?> cls){\nsynchronized (mux) {\n    List<Field> fields=fieldCache.get(cls);\n    if (fields == null) {\n      fields=new ArrayList<>();\n      for (      Field field : cls.getDeclaredFields()) {\n        Annotation ann=field.getAnnotation(annCls);\n        if (ann != null || needsRecursion(field))         fields.add(field);\n      }\n      if (!fields.isEmpty())       fieldCache.put(cls,fields);\n    }\n    return fields;\n  }\n}\n", "nl": "Gets all entries from the specified class or its super-classes that have been annotated with annotation provided."}
{"code": "public Resource mapRelations(Resource object,JSONObject jsonObject,List<Resource> included) throws Exception {\n  HashMap<String,String> relationshipNames=getRelationshipNames(object.getClass());\n  for (  String relationship : relationshipNames.keySet()) {\n    JSONObject relationJsonObject=null;\n    try {\n      relationJsonObject=jsonObject.getJSONObject(relationship);\n    }\n catch (    JSONException e) {\n      Logger.debug(\"Relationship named \" + relationship + \"not found in JSON\");\n      continue;\n    }\n    JSONObject relationDataObject=null;\n    try {\n      relationDataObject=relationJsonObject.getJSONObject(\"data\");\n      Resource relationObject=Factory.newObjectFromJSONObject(relationDataObject,null);\n      relationObject=matchIncludedToRelation(relationObject,included);\n      mDeserializer.setField(object,relationshipNames.get(relationship),relationObject);\n    }\n catch (    JSONException e) {\n      Logger.debug(\"JSON relationship does not contain data\");\n    }\n    JSONArray relationDataArray=null;\n    try {\n      relationDataArray=relationJsonObject.getJSONArray(\"data\");\n      List<Resource> relationArray=Factory.newObjectFromJSONArray(relationDataArray,null);\n      relationArray=matchIncludedToRelation(relationArray,included);\n      mDeserializer.setField(object,relationshipNames.get(relationship),relationArray);\n    }\n catch (    JSONException e) {\n      Logger.debug(\"JSON relationship does not contain data\");\n    }\n  }\n  return object;\n}\n", "nl": "Loops through relation JSON array and maps annotated objects."}
{"code": "@Override public void onDestroyView(){\n  mIsWebViewAvailable=false;\n  super.onDestroyView();\n}\n", "nl": "Called when the WebView has been detached from the fragment. The WebView is no longer available after this time."}
{"code": "public void clearMovementData(){\n  pathSprites=new ArrayList<StepSprite>();\n  movementTarget=null;\n  checkFoVHexImageCacheClear();\n  repaint();\n  refreshMoveVectors();\n}\n", "nl": "Clears current movement data from the screen"}
{"code": "public ActionForward execute(ActionMapping mapping,ActionForm form,HttpServletRequest request,HttpServletResponse response) throws Exception {\n  EditRoomDeptForm editRoomDeptForm=(EditRoomDeptForm)form;\n  MessageResources rsc=getResources(request);\n  String doit=editRoomDeptForm.getDoit();\n  if (doit != null) {\n    if (doit.equals(rsc.getMessage(\"button.update\"))) {\n      ActionMessages errors=new ActionMessages();\n      errors=editRoomDeptForm.validate(mapping,request);\n      if (errors.size() == 0) {\n        doUpdate(editRoomDeptForm,request);\n        return mapping.findForward(\"showRoomDetail\");\n      }\n else {\n        saveErrors(request,errors);\n      }\n    }\n    if (doit.equals(rsc.getMessage(\"button.returnToRoomDetail\"))) {\n      response.sendRedirect(\"roomDetail.do?id=\" + editRoomDeptForm.getId());\n      return null;\n    }\n    if (doit.equals(rsc.getMessage(\"button.addRoomDept\"))) {\n      if (editRoomDeptForm.getDept() == null || editRoomDeptForm.getDept().length() == 0) {\n        ActionMessages errors=new ActionMessages();\n        errors.add(\"roomDept\",new ActionMessage(\"errors.required\",\"Department\"));\n        saveErrors(request,errors);\n      }\n else       if (editRoomDeptForm.getDepartmentIds().contains(new Long(editRoomDeptForm.getDept()))) {\n        ActionMessages errors=new ActionMessages();\n        errors.add(\"roomDept\",new ActionMessage(\"errors.alreadyPresent\",\"Department\"));\n        saveErrors(request,errors);\n      }\n else {\n        editRoomDeptForm.addDepartment(editRoomDeptForm.getDept());\n      }\n    }\n    if (doit.equals(rsc.getMessage(\"button.removeRoomDept\"))) {\n      if (editRoomDeptForm.getDept() == null || editRoomDeptForm.getDept().length() == 0) {\n        ActionMessages errors=new ActionMessages();\n        errors.add(\"roomDept\",new ActionMessage(\"errors.required\",\"Department\"));\n        saveErrors(request,errors);\n      }\n else       if (!editRoomDeptForm.getDepartmentIds().contains(new Long(editRoomDeptForm.getDept()))) {\n        ActionMessages errors=new ActionMessages();\n        errors.add(\"roomDept\",new ActionMessage(\"errors.notPresent\",\"Department\"));\n        saveErrors(request,errors);\n      }\n else {\n        editRoomDeptForm.removeDepartment(editRoomDeptForm.getDept());\n      }\n    }\n  }\n  Long id=Long.valueOf(request.getParameter(\"id\"));\n  LocationDAO ldao=new LocationDAO();\n  Location location=ldao.get(id);\n  sessionContext.checkPermission(location,Right.RoomEditAvailability);\n  if (doit != null && doit.equals(rsc.getMessage(\"button.modifyRoomDepts\"))) {\n    TreeSet roomDepts=new TreeSet(location.getRoomDepts());\n    for (Iterator i=roomDepts.iterator(); i.hasNext(); ) {\n      RoomDept roomDept=(RoomDept)i.next();\n      editRoomDeptForm.addDepartment(roomDept.getDepartment().getUniqueId().toString());\n    }\n  }\n  boolean timeVertical=CommonValues.VerticalGrid.eq(UserProperty.GridOrientation.get(sessionContext.getUser()));\n  RequiredTimeTable rtt=location.getRoomSharingTable(sessionContext.getUser(),editRoomDeptForm.getDepartmentIds());\n  rtt.getModel().setDefaultSelection(UserProperty.GridSize.get(sessionContext.getUser()));\n  if (doit != null && (doit.equals(rsc.getMessage(\"button.removeRoomDept\")) || doit.equals(rsc.getMessage(\"button.addRoomDept\")))) {\n    rtt.update(request);\n  }\n  editRoomDeptForm.setSharingTable(rtt.print(true,timeVertical));\n  if (location instanceof Room) {\n    Room r=(Room)location;\n    editRoomDeptForm.setName(r.getLabel());\n    editRoomDeptForm.setNonUniv(false);\n  }\n else   if (location instanceof NonUniversityLocation) {\n    NonUniversityLocation nonUnivLocation=(NonUniversityLocation)location;\n    editRoomDeptForm.setName(nonUnivLocation.getName());\n    editRoomDeptForm.setNonUniv(true);\n  }\n else {\n    ActionMessages errors=new ActionMessages();\n    errors.add(\"editRoomDept\",new ActionMessage(\"errors.lookup.notFound\",\"Room Department\"));\n    saveErrors(request,errors);\n  }\n  setupDepartments(editRoomDeptForm,request,location);\n  return mapping.findForward(\"showEditRoomDept\");\n}\n", "nl": "Method execute"}
{"code": "@Override public void execute(MetricTimeSeries timeSeries,FunctionValueMap functionValueMap){\n  if (timeSeries.isEmpty()) {\n    functionValueMap.add(this,false,null);\n    return;\n  }\n  DoubleList points=timeSeries.getValues();\n  double q1=Percentile.evaluate(points,.25);\n  double q3=Percentile.evaluate(points,.75);\n  double threshold=(q3 - q1) * 1.5 + q3;\n  for (int i=0; i < points.size(); i++) {\n    double point=points.get(i);\n    if (point > threshold) {\n      functionValueMap.add(this,true,null);\n      return;\n    }\n  }\n  functionValueMap.add(this,false,null);\n}\n", "nl": "Detects outliers using the default box plot implementation. An outlier every value that is above (q3-q1)*1.5*q3 where qN is the nth percentile"}
{"code": "public DuplicatePrimaryPartitionException(String message){\n  super(message);\n}\n", "nl": "Creates a new <code>DuplicatePrimaryPartitionException</code> with the given detail message."}
{"code": "public void buildFieldTypes(TableDefinition tableDef){\n  ((JPAMTableDefinition)tableDef).buildFieldTypes(getSession());\n}\n", "nl": "INTERNAL: builds the field names based on the type read in from the builder"}
{"code": "public static void clearCache(){\n  softCache=new SoftReference<String[]>(null);\n}\n", "nl": "Clear the cache. This method is used for testing."}
{"code": "public void clear(){\n  oredCriteria.clear();\n  orderByClause=null;\n  distinct=false;\n}\n", "nl": "This method was generated by MyBatis Generator. This method corresponds to the database table activity"}
{"code": "protected void remove(int id){\n  nodes.remove(id);\n}\n", "nl": "Removes the node with the specified identifier from this problem instance."}
{"code": "public void addHaptic(int id){\n  mHapticFeedback.add(id);\n}\n", "nl": "Adds haptic feedback to this utterance."}
{"code": "private void init(){\n  Grid grid=new Grid();\n  appendChild(grid);\n  grid.setWidth(\"100%\");\n  grid.setStyle(\"margin:0; padding:0; position: absolute;\");\n  grid.makeNoStrip();\n  grid.setOddRowSclass(\"even\");\n  Rows rows=new Rows();\n  grid.appendChild(rows);\n  for (int i=0; i < m_goals.length; i++) {\n    Row row=new Row();\n    rows.appendChild(row);\n    row.setWidth(\"100%\");\n    WPerformanceIndicator pi=new WPerformanceIndicator(m_goals[i]);\n    row.appendChild(pi);\n    pi.addEventListener(Events.ON_CLICK,this);\n  }\n}\n", "nl": "Static/Dynamic Init"}
{"code": "public int deleteBack(){\n  int oldBack=getBack();\n  size=size - 1;\n  return oldBack;\n}\n", "nl": "Deletes item from back of the list and returns deleted item."}
{"code": "public boolean isLicensed(){\n  return resourceExists(thresholdFileResource) && resourceExists(overlappingFileResource);\n}\n", "nl": "This method returns true if the threshold and overlap files are present."}
{"code": "protected SimplePhase(String name){\n  super(name);\n}\n", "nl": "Construct a phase given just a name and a global/local ordering scheme."}
{"code": "private void URIUtil(){\n}\n", "nl": "Prevent instance creation."}
{"code": "public synchronized void processResponse(SIPResponse transactionResponse,MessageChannel sourceChannel,SIPDialog dialog){\n  if (getState() == null)   return;\n  if ((TransactionState.COMPLETED == this.getState() || TransactionState.TERMINATED == this.getState()) && transactionResponse.getStatusCode() / 100 == 1) {\n    return;\n  }\n  if (sipStack.isLoggingEnabled()) {\n    sipStack.getStackLogger().logDebug(\"processing \" + transactionResponse.getFirstLine() + \"current state = \"+ getState());\n    sipStack.getStackLogger().logDebug(\"dialog = \" + dialog);\n  }\n  this.lastResponse=transactionResponse;\n  try {\n    if (isInviteTransaction())     inviteClientTransaction(transactionResponse,sourceChannel,dialog);\n else     nonInviteClientTransaction(transactionResponse,sourceChannel,dialog);\n  }\n catch (  IOException ex) {\n    if (sipStack.isLoggingEnabled())     sipStack.getStackLogger().logException(ex);\n    this.setState(TransactionState.TERMINATED);\n    raiseErrorEvent(SIPTransactionErrorEvent.TRANSPORT_ERROR);\n  }\n}\n", "nl": "Process a new response message through this transaction. If necessary, this message will also be passed onto the TU."}
{"code": "public void disable(BluetoothAdapter adapter){\n  int mask=(BluetoothReceiver.STATE_TURNING_OFF_FLAG | BluetoothReceiver.STATE_OFF_FLAG | BluetoothReceiver.SCAN_MODE_NONE_FLAG);\n  long start=-1;\n  BluetoothReceiver receiver=getBluetoothReceiver(mask);\n  int state=adapter.getState();\nswitch (state) {\ncase BluetoothAdapter.STATE_OFF:\n    assertFalse(adapter.isEnabled());\n  removeReceiver(receiver);\nreturn;\ncase BluetoothAdapter.STATE_TURNING_ON:\nassertFalse(adapter.isEnabled());\nstart=System.currentTimeMillis();\nbreak;\ncase BluetoothAdapter.STATE_ON:\nassertTrue(adapter.isEnabled());\nstart=System.currentTimeMillis();\nassertTrue(adapter.disable());\nbreak;\ncase BluetoothAdapter.STATE_TURNING_OFF:\nassertFalse(adapter.isEnabled());\nmask=0;\nbreak;\ndefault :\nremoveReceiver(receiver);\nfail(String.format(\"disable() invalid state: state=%d\",state));\n}\nlong s=System.currentTimeMillis();\nwhile (System.currentTimeMillis() - s < ENABLE_DISABLE_TIMEOUT) {\nstate=adapter.getState();\nif (state == BluetoothAdapter.STATE_OFF && (receiver.getFiredFlags() & mask) == mask) {\nassertFalse(adapter.isEnabled());\nlong finish=receiver.getCompletedTime();\nif (start != -1 && finish != -1) {\nwriteOutput(String.format(\"disable() completed in %d ms\",(finish - start)));\n}\n else {\nwriteOutput(\"disable() completed\");\n}\nremoveReceiver(receiver);\nreturn;\n}\nsleep(POLL_TIME);\n}\nint firedFlags=receiver.getFiredFlags();\nremoveReceiver(receiver);\nfail(String.format(\"disable() timeout: state=%d (expected %d), flags=0x%x (expected 0x%x)\",state,BluetoothAdapter.STATE_OFF,firedFlags,mask));\n}\n", "nl": "Disables Bluetooth and checks to make sure that Bluetooth was turned off and that the correct actions were broadcast."}
{"code": "public boolean isLocal(){\n  return local;\n}\n", "nl": "Indicates if the ejb referenced is a local ejb."}
{"code": "public PowerDecay(){\n  this(10,0.5);\n}\n", "nl": "Creates a new Power Decay rate"}
{"code": "public Boolean isStorageIORMSupported(){\n  return storageIORMSupported;\n}\n", "nl": "Gets the value of the storageIORMSupported property."}
{"code": "public final byte[] array(){\n  return array;\n}\n", "nl": "Returns the underlying byte array."}
{"code": "public void buildClassifier(Instances D) throws Exception {\n  Random r=new Random(m_seed);\n  if (fastaram) {\n    networks=new ARAMNetworkfast[numberofnetworks];\n  }\n else   if (sparsearam) {\n    networks=new ARAMNetworkSparse[numberofnetworks];\n  }\n else   if (sparsearamH) {\n    networks=new ARAMNetworkSparseV[numberofnetworks];\n  }\n else   if (sparsearamHT) {\n    networks=new ARAMNetworkSparseHT[numberofnetworks];\n  }\n else {\n    networks=new ARAMNetwork[numberofnetworks];\n  }\n  numClasses=D.classIndex();\n  if (tfastaram) {\n    BuildClassifier[] bc=new BuildClassifier[numberofnetworks];\n    for (int i=0; i < numberofnetworks; i++) {\n      List<Integer> list=new ArrayList<Integer>();\n      for (int j=0; j < D.numInstances(); j++) {\n        list.add(j);\n      }\n      java.util.Collections.shuffle(list,r);\n      if (fastaram) {\n        networks[i]=new ARAMNetworkfast();\n      }\n else       if (sparsearam) {\n        networks[i]=new ARAMNetworkSparse();\n      }\n else       if (sparsearamH) {\n        networks[i]=new ARAMNetworkSparseV();\n      }\n else       if (sparsearamHT) {\n        networks[i]=new ARAMNetworkSparseHT();\n      }\n else {\n        networks[i]=new ARAMNetwork();\n      }\n      networks[i].order=list;\n      networks[i].roa=roa;\n      bc[i]=new BuildClassifier(networks[i]);\n      bc[i].setinstances(D);\n      bc[i].start();\n    }\n    for (int i=0; i < numberofnetworks; i++) {\n      bc[i].join();\n      networks[i]=bc[i].m_network;\n      networks[i].learningphase=false;\n    }\n  }\n else {\n    for (int i=0; i < numberofnetworks; i++) {\n      if (fastaram) {\n        networks[i]=new ARAMNetworkfast();\n      }\n else       if (sparsearam) {\n        networks[i]=new ARAMNetworkSparse();\n      }\n else       if (sparsearamH) {\n        networks[i]=new ARAMNetworkSparseV();\n      }\n else       if (sparsearamHT) {\n        networks[i]=new ARAMNetworkSparseHT();\n      }\n else {\n        networks[i]=new ARAMNetwork();\n      }\n      networks[i].roa=roa;\n      networks[i].buildClassifier(D);\n      networks[i].learningphase=false;\n      D.randomize(r);\n    }\n  }\n  dc=new DistributionCalc[numberofnetworks];\n}\n", "nl": "Generates the classifier."}
{"code": "private void startCameraSource(){\n  int code=GoogleApiAvailability.getInstance().isGooglePlayServicesAvailable(getApplicationContext());\n  if (code != ConnectionResult.SUCCESS) {\n    Dialog dlg=GoogleApiAvailability.getInstance().getErrorDialog(this,code,RC_HANDLE_GMS);\n    dlg.show();\n  }\n  if (mCameraSource != null) {\n    try {\n      mPreview.start(mCameraSource,mGraphicOverlay);\n    }\n catch (    IOException e) {\n      Log.e(TAG,\"Unable to start camera source.\",e);\n      mCameraSource.release();\n      mCameraSource=null;\n    }\n  }\n}\n", "nl": "Starts or restarts the camera source, if it exists.  If the camera source doesn't exist yet (e.g., because onResume was called before the camera source was created), this will be called again when the camera source is created."}
{"code": "public Timezone(String text){\n  this(null,text);\n}\n", "nl": "Creates a timezone property."}
{"code": "public static <K,V>V putAt(Map<K,V> self,K key,V value){\n  self.put(key,value);\n  return value;\n}\n", "nl": "A helper method to allow maps to work with subscript operators"}
{"code": "@Override public String toString(){\n  return toString(\",\");\n}\n", "nl": "Form a string listing all elements with comma as the separator character."}
{"code": "@DSSafe(DSCat.SAFE_LIST) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2014-09-03 14:59:51.857 -0400\",hash_original_method=\"8DBE36D3CC23C0C9E5FAAD9804EB9F8E\",hash_generated_method=\"B8E268DF01A1D59287B8F2ED5303EAE7\") private void processInput(boolean endOfInput) throws IOException {\n  decoderIn.flip();\n  CoderResult coderResult;\n  while (true) {\n    coderResult=decoder.decode(decoderIn,decoderOut,endOfInput);\n    if (coderResult.isOverflow()) {\n      flushOutput();\n    }\n else     if (coderResult.isUnderflow()) {\n      break;\n    }\n else {\n      throw new IOException(\"Unexpected coder result\");\n    }\n  }\n  decoderIn.compact();\n}\n", "nl": "Decode the contents of the input ByteBuffer into a CharBuffer."}
{"code": "public static float byte52ToFloat(byte b){\n  if (b == 0)   return 0.0f;\n  int bits=(b & 0xff) << (24 - 5);\n  bits+=(63 - 2) << 24;\n  return Float.intBitsToFloat(bits);\n}\n", "nl": "byteToFloat(b, mantissaBits=5, zeroExponent=2)"}
{"code": "private void createAndRegisterObserverProxyLocked(IContentObserver observer){\n  if (mObserver != null) {\n    throw new IllegalStateException(\"an observer is already registered\");\n  }\n  mObserver=new ContentObserverProxy(observer,this);\n  mCursor.registerContentObserver(mObserver);\n}\n", "nl": "Create a ContentObserver from the observer and register it as an observer on the underlying cursor."}
{"code": "public int compressEstim(byte[] src,int srcOff,final int srcLen){\n  if (srcLen < 10)   return srcLen;\n  int stride=LZ4_64K_LIMIT - 1;\n  int segments=(srcLen + stride - 1) / stride;\n  stride=srcLen / segments;\n  if (stride >= LZ4_64K_LIMIT - 1 || stride * segments > srcLen || segments < 1 || stride < 1)   throw new RuntimeException(\"?? \" + srcLen);\n  int bytesIn=0;\n  int bytesOut=0;\n  int len=srcLen;\n  while (len > 0) {\n    if (len > stride)     len=stride;\n    bytesOut+=compress64k(src,srcOff,len);\n    srcOff+=len;\n    bytesIn+=len;\n    len=srcLen - bytesIn;\n  }\n  double ratio=bytesOut / (double)bytesIn;\n  return bytesIn == srcLen ? bytesOut : (int)(ratio * srcLen + 0.5);\n}\n", "nl": "Estimates the length of the compressed bytes, as compressed by Lz4 WARNING: if larger than LZ4_64K_LIMIT it cuts it in fragments WARNING: if some part of the input is discarded, this should return the proportional (so that returnValue/srcLen=compressionRatio)"}
{"code": "@Override public boolean eIsSet(int featureID){\nswitch (featureID) {\ncase N4JSPackage.ARRAY_LITERAL__ELEMENTS:\n    return elements != null && !elements.isEmpty();\ncase N4JSPackage.ARRAY_LITERAL__TRAILING_COMMA:\n  return trailingComma != TRAILING_COMMA_EDEFAULT;\n}\nreturn super.eIsSet(featureID);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public FilterStreamSpecRaw(){\n}\n", "nl": "Default ctor."}
{"code": "void onMenuVisibilityChanged(boolean isVisible){\n  for (int i=0; i < mObservers.size(); ++i) {\n    mObservers.get(i).onMenuVisibilityChanged(isVisible);\n  }\n}\n", "nl": "Called by AppMenu to report that the App Menu visibility has changed."}
{"code": "public void updateDownload(){\n  ArrayList<DownloadInfoRunnable> ongoingDownloads=getOngoingDownloads();\n  if (!ongoingDownloads.isEmpty()) {\n    updateProgress();\n  }\n else {\n    timer.cancel();\n    timer.purge();\n    stopSelf();\n    mBuilder=null;\n    stopForeground(true);\n    isStopped=true;\n  }\n}\n", "nl": "Updates the download list and stops the service if it's empty. If not, updates the progress in the Notification bar"}
{"code": "private int remoteAddPois(List<Poi> pois,String changeSetId){\n  int count=0;\n  for (  Poi poi : pois) {\n    if (remoteAddPoi(poi,changeSetId)) {\n      count++;\n    }\n  }\n  return count;\n}\n", "nl": "Add a List of POIs to the backend."}
{"code": "public CopyOnWriteArraySet(Collection<? extends E> c){\n  al=new CopyOnWriteArrayList<E>();\n  al.addAllAbsent(c);\n}\n", "nl": "Creates a set containing all of the elements of the specified collection."}
{"code": "@Override public void close() throws SQLException {\n  try {\n    super.close();\n  }\n  finally {\n    this.outputLogger.close();\n  }\n}\n", "nl": "This method will close the connection to the output."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:55:41.688 -0500\",hash_original_method=\"1623111994CBCA0890DA0FF2A1E140E0\",hash_generated_method=\"478ACA79A313929F4EF55B9242DEEF4D\") public boolean isBackToBackUserAgent(){\n  return super.isBackToBackUserAgent;\n}\n", "nl": "Get the \"back to back User Agent\" flag. return the value of the flag"}
{"code": "public EnglishMinimalStemFilterFactory(Map<String,String> args){\n  super(args);\n  if (!args.isEmpty()) {\n    throw new IllegalArgumentException(\"Unknown parameters: \" + args);\n  }\n}\n", "nl": "Creates a new EnglishMinimalStemFilterFactory"}
{"code": "public AABB(ReadonlyVec3D pos,float extent){\n  super(pos);\n  setExtent(new Vec3D(extent,extent,extent));\n}\n", "nl": "Creates a new instance from centre point and uniform extent in all directions."}
{"code": "public static <T>JavaslangSubscriber<T> subscriber(){\n  return new JavaslangSubscriber<T>();\n}\n", "nl": "A reactive-streams subscriber than can generate Javaslang traversable types"}
{"code": "public SQLNonTransientException(String reason,Throwable cause){\n  super(reason,cause);\n}\n", "nl": "Creates an SQLNonTransientException object. The Reason string is set to the given and the cause Throwable object is set to the given cause Throwable object."}
{"code": "public void localTransactionCommitted(ConnectionEvent event){\n}\n", "nl": "Ignored event callback"}
{"code": "protected boolean runAndReset(){\n  if (state != NEW || !UNSAFE.compareAndSwapObject(this,runnerOffset,null,Thread.currentThread()))   return false;\n  boolean ran=false;\n  int s=state;\n  try {\n    Callable<V> c=callable;\n    if (c != null && s == NEW) {\n      try {\n        c.call();\n        ran=true;\n      }\n catch (      Throwable ex) {\n        setException(ex);\n      }\n    }\n  }\n  finally {\n    runner=null;\n    s=state;\n    if (s >= INTERRUPTING)     handlePossibleCancellationInterrupt(s);\n  }\n  return ran && s == NEW;\n}\n", "nl": "Executes the computation without setting its result, and then resets this future to initial state, failing to do so if the computation encounters an exception or is cancelled.  This is designed for use with tasks that intrinsically execute more than once."}
{"code": "public void addCookie(GoogleCookie cookie){\n  if (cookieManager != null) {\n    cookieManager.addCookie(cookie);\n  }\n}\n", "nl": "Adds a new GoogleCookie instance to the cache."}
{"code": "public void debug(String trace){\n  printTrace(trace,DEBUG_LEVEL);\n}\n", "nl": "Debug trace"}
{"code": "public boolean isAutoIndentEnabled(){\n  return autoIndentEnabled;\n}\n", "nl": "Returns whether or not auto-indent is enabled."}
{"code": "public void disableHardwareLayersForContent(){\n  View widget=getContent();\n  if (widget != null) {\n    widget.setLayerType(LAYER_TYPE_NONE,null);\n  }\n}\n", "nl": "Because this view has fading outlines, it is essential that we enable hardware layers on the content (child) so that updating the alpha of the outlines doesn't result in the content layer being recreated."}
{"code": "public PaymentGatewayDescriptorImpl(final String description,final String label,final String url){\n  super(description,label);\n  this.url=url;\n}\n", "nl": "Construct payment gateway descriptor."}
{"code": "public static Date parseDateLong(String dateString,String pattern) throws ParseException {\n  return getSimplDateFormat(pattern).parse(dateString);\n}\n", "nl": "Returns date parsed from string by given pattern"}
{"code": "public void add(int i,Coordinate coord,boolean allowRepeated){\n  if (!allowRepeated) {\n    int size=size();\n    if (size > 0) {\n      if (i > 0) {\n        Coordinate prev=(Coordinate)get(i - 1);\n        if (prev.equals2D(coord))         return;\n      }\n      if (i < size) {\n        Coordinate next=(Coordinate)get(i);\n        if (next.equals2D(coord))         return;\n      }\n    }\n  }\n  super.add(i,coord);\n}\n", "nl": "Inserts the specified coordinate at the specified position in this list."}
{"code": "private void loadAppThemeDefaults(){\n  TypedValue typedValue=new TypedValue();\n  TypedArray a=getContext().obtainStyledAttributes(typedValue.data,new int[]{R.attr.colorAccent,android.R.attr.textColorPrimary,R.attr.colorControlNormal});\n  dialColor=a.getColor(0,dialColor);\n  textColor=a.getColor(1,textColor);\n  clockColor=a.getColor(2,clockColor);\n  a.recycle();\n}\n", "nl": "Sets default theme attributes for picker These will be used if picker's attributes are'nt set"}
{"code": "public void increaseRefcount(){\n  refcount++;\n}\n", "nl": "Increase number of data points by one."}
{"code": "public static double computePolygonAreaFromVertices(Iterable<? extends Vec4> points){\n  if (points == null) {\n    String message=Logging.getMessage(\"nullValue.IterableIsNull\");\n    Logging.logger().severe(message);\n    throw new IllegalArgumentException(message);\n  }\n  java.util.Iterator<? extends Vec4> iter=points.iterator();\n  if (!iter.hasNext()) {\n    return 0;\n  }\n  double area=0;\n  Vec4 firstPoint=iter.next();\n  Vec4 point=firstPoint;\n  while (iter.hasNext()) {\n    Vec4 nextLocation=iter.next();\n    area+=point.x * nextLocation.y;\n    area-=nextLocation.x * point.y;\n    point=nextLocation;\n  }\n  if (!point.equals(firstPoint)) {\n    area+=point.x * firstPoint.y;\n    area-=firstPoint.x * point.y;\n  }\n  area/=2.0;\n  return area;\n}\n", "nl": "Returns the area enclosed by the specified (x, y) points (the z and w coordinates are ignored). If the specified points do not define a closed loop, then the loop is automatically closed by simulating appending the first point to the last point."}
{"code": "public void init(KeyGenerationParameters param){\n  this.params=(NTRUEncryptionKeyGenerationParameters)param;\n}\n", "nl": "Constructs a new instance with a set of encryption parameters."}
{"code": "public static JPanel createDemoPanel(){\n  JFreeChart chart=createChart(createDataset());\n  ChartPanel panel=new ChartPanel(chart,false);\n  panel.setFillZoomRectangle(true);\n  panel.setMouseWheelEnabled(true);\n  return panel;\n}\n", "nl": "Creates a panel for the demo (used by SuperDemo.java)."}
{"code": "public static void deleteVMsOnThisEndpoint(VerificationHost host,boolean isMock,String parentComputeLink,List<String> instanceIdsToDelete) throws Throwable {\n  deleteVMsOnThisEndpoint(host,null,isMock,parentComputeLink,instanceIdsToDelete,null);\n}\n", "nl": "A utility method that deletes the VMs on the specified endpoint filtered by the instanceIds that are passed in."}
{"code": "public boolean isIn(byte i){\n  return (i >= this.min) && (i <= this.max);\n}\n", "nl": "Check if given number is in range."}
{"code": "public void completeAll(){\n  long currentCompleted=completedCount;\n  int size=Math.max(1,actionList.size());\n  while (completedCount - currentCompleted < size) {\n    if (getState() != Thread.State.BLOCKED && getState() != Thread.State.RUNNABLE)     break;\n    try {\n      Thread.sleep(50);\n    }\n catch (    InterruptedException ex) {\n      break;\n    }\n  }\n}\n", "nl": "<p>Complete all scheduled actions at the time of this call. Since other threads may keep adding actions, this method makes sure that only the actions in the queue at the time of the call are waited upon.  </p>"}
{"code": "public String toString(){\n  return image;\n}\n", "nl": "Returns the image."}
{"code": "public KtVisualPanel1(){\n  initComponents();\n}\n", "nl": "Creates new form KtVisualPanel1"}
{"code": "public URI(String p_scheme,String p_schemeSpecificPart) throws MalformedURIException {\n  if (p_scheme == null || p_scheme.trim().length() == 0) {\n    throw new MalformedURIException(\"Cannot construct URI with null/empty scheme!\");\n  }\n  if (p_schemeSpecificPart == null || p_schemeSpecificPart.trim().length() == 0) {\n    throw new MalformedURIException(\"Cannot construct URI with null/empty scheme-specific part!\");\n  }\n  setScheme(p_scheme);\n  setPath(p_schemeSpecificPart);\n}\n", "nl": "Construct a new URI that does not follow the generic URI syntax. Only the scheme and scheme-specific part (stored as the path) are initialized."}
{"code": "public boolean isDoingRangedAttack(){\n  return isDoingRangedAttack;\n}\n", "nl": "Check if the currently performed attack is ranged."}
{"code": "public SdfReaderWrapper(File sdfDir,boolean useMem,boolean checkConsistency) throws IOException {\n  mIsPaired=ReaderUtils.isPairedEndDirectory(sdfDir);\n  if (mIsPaired) {\n    mSingle=null;\n    mLeft=createSequencesReader(ReaderUtils.getLeftEnd(sdfDir),useMem);\n    mRight=createSequencesReader(ReaderUtils.getRightEnd(sdfDir),useMem);\n    if (checkConsistency) {\n      if (mLeft.numberSequences() != mRight.numberSequences() || !mLeft.type().equals(mRight.type()) || mLeft.hasQualityData() != mRight.hasQualityData() || mLeft.hasNames() != mRight.hasNames()) {\n        throw new NoTalkbackSlimException(ErrorType.INFO_ERROR,\"Paired end SDF has inconsistencies between arms.\");\n      }\n    }\n  }\n else {\n    mLeft=null;\n    mRight=null;\n    mSingle=createSequencesReader(sdfDir,useMem);\n  }\n}\n", "nl": "Wrapper for the readers."}
{"code": "public DefaultRenderStack(){\n  stack=new ArrayDeque<>();\n}\n", "nl": "Constructs the stack."}
{"code": "public void onLocationChanged(Location location){\n  if (location == null) {\n    return;\n  }\n  float distance=getDistanceFromNetwork(location);\n  mTrackerData.writeEntry(location,distance);\n}\n", "nl": "Writes details of location update to tracking file, including recording the distance between this location update and the last network location update"}
{"code": "public static File secondaryIndexFileName(File data){\n  final int extensionIndex=data.getName().lastIndexOf('.');\n  if (extensionIndex != -1) {\n    return new File(data.getParentFile(),data.getName().substring(0,extensionIndex) + BamIndexer.BAM_INDEX_EXTENSION);\n  }\n  return indexFileName(data);\n}\n", "nl": "Get the secondary possible name for an index to have for a given data file (Will return same as indexFileName if there is no file extension)"}
{"code": "private void cancelOrder(Contract contract,TradeOrder order) throws IOException {\n  OrderState orderState=new OrderState();\n  orderState.m_status=OrderStatus.CANCELLED;\n  this.brokerModel.openOrder(order.getOrderKey(),contract,order,orderState);\n  order.setStatus(OrderStatus.CANCELLED);\n}\n", "nl": "Method cancelOrder."}
{"code": "private TempTripleStore(final TemporaryStore store,final Properties properties){\n  this(store,UUID.randomUUID() + \"kb\",ITx.UNISOLATED,properties);\n}\n", "nl": "Note: This is here just to make it easy to have the reference to the [store] and its [uuid] when we create one in the calling ctor."}
{"code": "public static <T>T[] newSameSize(List<?> list,Class<T> cpType){\n  if (list == null)   return create(cpType,0);\n else   return create(cpType,list.size());\n}\n", "nl": "Creates an array with the same size as the given list. If the list is null, a zero-length array is created."}
{"code": "public void addPaintListener(PaintListener pl){\n  if (m_painters == null) {\n    m_painters=new CopyOnWriteArrayList();\n  }\n  m_painters.add(pl);\n}\n", "nl": "Add a PaintListener to this Display to receive notifications about paint events."}
{"code": "@Override public boolean isNamed(){\n  return (flags & NO_NAME) == 0;\n}\n", "nl": "Returns true if this method is anonymous."}
{"code": "public CopyOnWriteMap(){\n  internalMap=new HashMap<K,V>();\n}\n", "nl": "Creates a new instance of CopyOnWriteMap."}
{"code": "public static void runTrialParallel(int size,TrialSuite set,IPoint[] pts,IPivotIndex selector,int numThreads,int ratio){\n  Integer[] ar=new Integer[size];\n  for (int i=0, idx=0; i < pts.length; i++) {\n    ar[idx++]=(int)(pts[i].getX() * BASE);\n    ar[idx++]=(int)(pts[i].getY() * BASE);\n  }\n  MultiThreadQuickSort<Integer> qs=new MultiThreadQuickSort<Integer>(ar);\n  qs.setPivotMethod(selector);\n  qs.setNumberHelperThreads(numThreads);\n  qs.setThresholdRatio(ratio);\n  System.gc();\n  long start=System.currentTimeMillis();\n  qs.qsort(0,size - 1);\n  long end=System.currentTimeMillis();\n  set.addTrial(size,start,end);\n  for (int i=0; i < ar.length - 1; i++) {\n    assert (ar[i] <= ar[i + 1]);\n  }\n}\n", "nl": "Change the number of helper threads inside to try different configurations. <p> Set to NUM_THREADS by default."}
{"code": "private void initResumableMediaRequest(GDataRequest request,MediaFileSource file,String title){\n  initMediaRequest(request,title);\n  request.setHeader(GDataProtocol.Header.X_UPLOAD_CONTENT_TYPE,file.getContentType());\n  request.setHeader(GDataProtocol.Header.X_UPLOAD_CONTENT_LENGTH,new Long(file.getContentLength()).toString());\n}\n", "nl": "Initialize a resumable media upload request."}
{"code": "public static short[] toShortArray(Short[] array){\n  short[] result=new short[array.length];\n  for (int i=0; i < array.length; i++) {\n    result[i]=array[i];\n  }\n  return result;\n}\n", "nl": "Coverts given shorts array to array of shorts."}
{"code": "public static void createTable(SQLiteDatabase db,boolean ifNotExists){\n  String constraint=ifNotExists ? \"IF NOT EXISTS \" : \"\";\n  db.execSQL(\"CREATE TABLE \" + constraint + \"'SIMPLE_ADDRESS_ITEM' (\"+ \"'_id' INTEGER PRIMARY KEY ,\"+ \"'NAME' TEXT,\"+ \"'ADDRESS' TEXT,\"+ \"'CITY' TEXT,\"+ \"'STATE' TEXT,\"+ \"'PHONE' INTEGER);\");\n}\n", "nl": "Creates the underlying database table."}
{"code": "@Override public NotificationChain eInverseRemove(InternalEObject otherEnd,int featureID,NotificationChain msgs){\nswitch (featureID) {\ncase UmplePackage.ABSTRACT_METHOD_DECLARATION___METHOD_DECLARATOR_1:\n    return ((InternalEList<?>)getMethodDeclarator_1()).basicRemove(otherEnd,msgs);\n}\nreturn super.eInverseRemove(otherEnd,featureID,msgs);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "protected void emit_N4SetterDeclaration_SemicolonKeyword_5_q(EObject semanticObject,ISynNavigable transition,List<INode> nodes){\n  acceptNodes(transition,nodes);\n}\n", "nl": "Ambiguous syntax: ';'? This ambiguous syntax occurs at: body=Block (ambiguity) (rule end) fpar=FormalParameter ')' (ambiguity) (rule end)"}
{"code": "private void updateProgress(String progressLabel,int progress){\n  if (myHost != null && ((progress != previousProgress) || (!progressLabel.equals(previousProgressLabel)))) {\n    myHost.updateProgress(progressLabel,progress);\n  }\n  previousProgress=progress;\n  previousProgressLabel=progressLabel;\n}\n", "nl": "Used to communicate a progress update between a plugin tool and the main Whitebox user interface."}
{"code": "public FitsDate(String dStr) throws FitsException {\n  if (dStr == null || dStr.isEmpty()) {\n    return;\n  }\n  Matcher match=FitsDate.NORMAL_REGEX.matcher(dStr);\n  if (match.matches()) {\n    this.year=getInt(match,FitsDate.NEW_FORMAT_YEAR_GROUP);\n    this.month=getInt(match,FitsDate.NEW_FORMAT_MONTH_GROUP);\n    this.mday=getInt(match,FitsDate.NEW_FORMAT_DAY_OF_MONTH_GROUP);\n    this.hour=getInt(match,FitsDate.NEW_FORMAT_HOUR_GROUP);\n    this.minute=getInt(match,FitsDate.NEW_FORMAT_MINUTE_GROUP);\n    this.second=getInt(match,FitsDate.NEW_FORMAT_SECOND_GROUP);\n    this.millisecond=getMilliseconds(match,FitsDate.NEW_FORMAT_MILLISECOND_GROUP);\n  }\n else {\n    match=FitsDate.OLD_REGEX.matcher(dStr);\n    if (match.matches()) {\n      this.year=getInt(match,FitsDate.OLD_FORMAT_YEAR_GROUP) + FitsDate.YEAR_OFFSET;\n      this.month=getInt(match,FitsDate.OLD_FORMAT_MONTH_GROUP);\n      this.mday=getInt(match,FitsDate.OLD_FORMAT_DAY_OF_MONTH_GROUP);\n    }\n else {\n      if (dStr.trim().isEmpty()) {\n        return;\n      }\n      throw new FitsException(\"Bad FITS date string \\\"\" + dStr + '\"');\n    }\n  }\n}\n", "nl": "Convert a FITS date string to a Java <CODE>Date</CODE> object."}
{"code": "public static <T>T fromBytes(byte[] value,Class<T> clazz){\n  try {\n    Input input=new Input(new ByteArrayInputStream(value));\n    return clazz.cast(kryo.get().readClassAndObject(input));\n  }\n catch (  Throwable t) {\n    LOG.error(\"Unable to deserialize  because \" + t.getMessage(),t);\n    throw t;\n  }\n}\n", "nl": "Deserialize a profile measurement's value. The value produced by a Profile definition can be any numeric data type.  The data type depends on how the profile is defined by the user.  The user should be able to choose the data type that is most suitable for their use case."}
{"code": "public SequencesWriter(SequenceDataSource source,File outputDir,long sizeLimit,PrereadType type,boolean compressed){\n  this(source,outputDir,sizeLimit,null,type,compressed,null);\n}\n", "nl": "Creates a writer for processing sequences from provided data source."}
{"code": "public HtmlPolicyBuilder allowStyling(){\n  allowStyling(CssSchema.DEFAULT);\n  return this;\n}\n", "nl": "Convert <code>style=\"&lt;CSS&gt;\"</code> to sanitized CSS which allows color, font-size, type-face, and other styling using the default schema; but which does not allow content to escape its clipping context."}
{"code": "private PhoneUtil(){\n  throw new Error(\"Do not need instantiate!\");\n}\n", "nl": "Don't let anyone instantiate this class."}
{"code": "@Override public void unregisterTap(Tap tap){\n  mTaps.remove(tap);\n}\n", "nl": "Remove instrumentation tap"}
{"code": "public boolean isNavBarTintEnabled(){\n  return mNavBarTintEnabled;\n}\n", "nl": "Is tinting enabled for the system navigation bar?"}
{"code": "@Override public boolean equals(Object other){\n  if (_map.equals(other)) {\n    return true;\n  }\n else   if (other instanceof Map) {\n    Map that=(Map)other;\n    if (that.size() != _map.size()) {\n      return false;\n    }\n else {\n      Iterator it=that.entrySet().iterator();\n      for (int i=that.size(); i-- > 0; ) {\n        Map.Entry e=(Map.Entry)it.next();\n        Object key=e.getKey();\n        Object val=e.getValue();\n        if (key instanceof Float) {\n          float k=unwrapKey(key);\n          Object v=unwrapValue((V)val);\n          if (_map.containsKey(k) && v == _map.get(k)) {\n          }\n else {\n            return false;\n          }\n        }\n else {\n          return false;\n        }\n      }\n      return true;\n    }\n  }\n else {\n    return false;\n  }\n}\n", "nl": "Compares this map with another map for equality of their stored entries."}
{"code": "public boolean becomePrimary(boolean isRebalance){\n  initializationGate();\n  long startTime=getPartitionedRegionStats().startPrimaryTransfer(isRebalance);\n  try {\n    long waitTime=2000;\n    while (!isPrimary()) {\n      this.getAdvisee().getCancelCriterion().checkCancelInProgress(null);\n      boolean attemptToBecomePrimary=false;\n      boolean attemptToDeposePrimary=false;\n      if (Thread.currentThread().isInterrupted()) {\n        if (logger.isDebugEnabled()) {\n          logger.debug(\"Breaking from becomePrimary loop due to thread interrupt flag being set\");\n        }\n        break;\n      }\n      if (isClosed() || !isHosting()) {\n        if (logger.isDebugEnabled()) {\n          logger.debug(\"Breaking from becomePrimary loop because {} is closed or not hosting\",this);\n        }\n        break;\n      }\n      VolunteeringDelegate vDelegate=null;\nsynchronized (this) {\n        if (isVolunteering()) {\n          if (logger.isDebugEnabled()) {\n            logger.debug(\"Waiting for volunteering thread {}. Time left: {} ms\",this,waitTime);\n          }\n          this.wait(waitTime);\n          continue;\n        }\n else         if (isBecomingPrimary()) {\n          attemptToDeposePrimary=true;\n        }\n else {\n          vDelegate=this.volunteeringDelegate;\n          if (vDelegate == null) {\n            vDelegate=new VolunteeringDelegate();\n            this.volunteeringDelegate=vDelegate;\n          }\n        }\n      }\n      if (vDelegate != null) {\n        attemptToBecomePrimary=vDelegate.reserveForBecomePrimary();\n      }\n      if (attemptToBecomePrimary) {\nsynchronized (this) {\n          if (this.volunteeringDelegate == null) {\n            this.volunteeringDelegate=new VolunteeringDelegate();\n          }\n          this.volunteeringDelegate.volunteerForPrimary();\n          attemptToDeposePrimary=true;\n        }\n        Thread.sleep(10);\n      }\n      if (attemptToDeposePrimary) {\n        InternalDistributedMember otherPrimary=getPrimary();\n        if (otherPrimary != null && !getDistributionManager().getId().equals(otherPrimary)) {\n          if (logger.isDebugEnabled()) {\n            logger.debug(\"Attempting to depose primary on {} for {}\",otherPrimary,this);\n          }\n          DeposePrimaryBucketResponse response=DeposePrimaryBucketMessage.send(otherPrimary,this.pRegion,getBucket().getId());\n          if (response != null) {\n            response.waitForRepliesUninterruptibly();\n            if (logger.isDebugEnabled()) {\n              logger.debug(\"Deposed primary on {}\",otherPrimary);\n            }\n          }\n        }\n        Thread.sleep(10);\n      }\n    }\n  }\n catch (  InterruptedException e) {\n    Thread.currentThread().interrupt();\n  }\n finally {\n    getPartitionedRegionStats().endPrimaryTransfer(startTime,isPrimary(),isRebalance);\n  }\n  return isPrimary();\n}\n", "nl": "Makes this <code>BucketAdvisor</code> become the primary if it is already a secondary."}
{"code": "private void declareExtensions(){\n  new BlogCommentFeed().declareExtensions(extProfile);\n  new BlogFeed().declareExtensions(extProfile);\n  new BlogPostFeed().declareExtensions(extProfile);\n  new PostCommentFeed().declareExtensions(extProfile);\n}\n", "nl": "Declare the extensions of the feeds for the Blogger service."}
{"code": "@Override public boolean eIsSet(int featureID){\nswitch (featureID) {\ncase UmplePackage.ANONYMOUS_GEN_EXPR_2__INDEX_1:\n    return INDEX_1_EDEFAULT == null ? index_1 != null : !INDEX_1_EDEFAULT.equals(index_1);\n}\nreturn super.eIsSet(featureID);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public ReferenceSequence sequence(final String name){\n  return mReferences.get(name);\n}\n", "nl": "Get the <code>ReferenceSequence</code> selected by name."}
{"code": "private ChainBuilder(JFrame frame){\n  super(new BorderLayout());\n  this.frame=frame;\n  THIS=this;\n  JPanel customPanel=createCustomizationPanel();\n  JPanel presetPanel=createPresetPanel();\n  label=new JLabel(\"Click the \\\"Begin Generating\\\" button\" + \" to begin generating phrases\",JLabel.CENTER);\n  Border padding=BorderFactory.createEmptyBorder(20,20,5,20);\n  customPanel.setBorder(padding);\n  presetPanel.setBorder(padding);\n  JTabbedPane tabbedPane=new JTabbedPane();\n  tabbedPane.addTab(\"Build your own\",null,customPanel,customizationPanelDescription);\n  tabbedPane.addTab(\"Presets\",null,presetPanel,presetPanelDescription);\n  add(tabbedPane,BorderLayout.CENTER);\n  add(label,BorderLayout.PAGE_END);\n  label.setBorder(BorderFactory.createEmptyBorder(10,10,10,10));\n}\n", "nl": "Creates the GUI shown inside the frame's content pane."}
{"code": "public String toString(){\n  return this.materialPackageBO.toString();\n}\n", "nl": "A method that returns a string representation of a parsed MaterialPackage object"}
{"code": "protected VirtualBaseTypeImpl(){\n  super();\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "private void removeParserNotices(Parser parser){\n  if (noticesToHighlights != null) {\n    RSyntaxTextAreaHighlighter h=(RSyntaxTextAreaHighlighter)textArea.getHighlighter();\n    for (Iterator i=noticesToHighlights.entrySet().iterator(); i.hasNext(); ) {\n      Map.Entry entry=(Map.Entry)i.next();\n      ParserNotice notice=(ParserNotice)entry.getKey();\n      if (notice.getParser() == parser && entry.getValue() != null) {\n        h.removeParserHighlight(entry.getValue());\n        i.remove();\n      }\n    }\n  }\n}\n", "nl": "Removes all parser notices (and clears highlights in the editor) from a particular parser."}
{"code": "public TextLineDecoder(Charset charset,String delimiter){\n  this(charset,new LineDelimiter(delimiter));\n}\n", "nl": "Creates a new instance with the spcified <tt>charset</tt> and the specified <tt>delimiter</tt>."}
{"code": "@Override public void resetViewableArea(){\n  throw new RuntimeException(\"resetViewableArea called in PdfDecoderFx\");\n}\n", "nl": "NOT PART OF API turns off the viewable area, scaling the page back to original scaling"}
{"code": "private void postResults(){\n  this.reportTestCase.host.updateSystemInfo(false);\n  this.trState.systemInfo=this.reportTestCase.host.getSystemInfo();\n  Operation factoryPost=Operation.createPost(this.remoteTestResultService).setReferer(this.reportTestCase.host.getReferer()).setBody(this.trState).setCompletion(null);\n  this.reportTestCase.host.testStart(1);\n  this.reportTestCase.host.sendRequest(factoryPost);\n  try {\n    this.reportTestCase.host.testWait();\n  }\n catch (  Throwable throwable) {\n    throwable.printStackTrace();\n  }\n}\n", "nl": "Send current test state to a remote server, by creating an instance for this particular run."}
{"code": "static void clear(Iterator<?> iterator){\n  checkNotNull(iterator);\n  while (iterator.hasNext()) {\n    iterator.next();\n    iterator.remove();\n  }\n}\n", "nl": "Clears the iterator using its remove method."}
{"code": "@Override public boolean isTop(BitSet fact){\n  return fact.get(topBit);\n}\n", "nl": "Return whether or not given fact is the special TOP value."}
{"code": "public void eraseMap(){\n  if (MAP_STORE.getMap(MAP_STORE.getSelectedMapName()) == null) {\n    return;\n  }\n  for (  Route r : MAP_STORE.getMap(MAP_STORE.getSelectedMapName()).getRoutes()) {\n    eraseRoute(r);\n  }\n}\n", "nl": "Non-destructively erases all displayed content from the map display"}
{"code": "public void doTestTransfer(int size){\n  Thread.setDefaultUncaughtExceptionHandler(this);\n  long start, elapsed;\n  int received;\n  sendData=createDummyData(size);\n  sendStreamSize=size;\n  recvStream=new ByteArrayOutputStream(size);\n  start=PseudoTCPBase.now();\n  startClocks();\n  try {\n    connect();\n  }\n catch (  IOException ex) {\n    fail(ex.getMessage());\n  }\n  assert_Connected_wait(kConnectTimeoutMs);\n  long transferTout=maxTransferTime(sendData.length,kMinTransferRate);\n  boolean transfferInTime=assert_Disconnected_wait(transferTout);\n  elapsed=PseudoTCPBase.now() - start;\n  stopClocks();\n  received=recvStream.size();\n  assertEquals(\"Transfer timeout, transferred: \" + received + \" required: \"+ sendData.length+ \" elapsed: \"+ elapsed+ \" limit: \"+ transferTout,true,transfferInTime);\n  assertEquals(size,received);\n  byte[] recvdArray=recvStream.toByteArray();\n  assertArrayEquals(sendData,recvdArray);\n  logger.log(Level.INFO,\"Transferred \" + received + \" bytes in \"+ elapsed+ \" ms (\"+ (size * 8 / elapsed)+ \" Kbps\");\n}\n", "nl": "Transfers the data of <tt>size</tt> bytes"}
{"code": "protected void sequence_SkillFakeDefinition(ISerializationContext context,SkillFakeDefinition semanticObject){\n  if (errorAcceptor != null) {\n    if (transientValues.isValueTransient(semanticObject,GamlPackage.Literals.GAML_DEFINITION__NAME) == ValueTransient.YES)     errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject,GamlPackage.Literals.GAML_DEFINITION__NAME));\n  }\n  SequenceFeeder feeder=createSequencerFeeder(context,semanticObject);\n  feeder.accept(grammarAccess.getSkillFakeDefinitionAccess().getNameIDTerminalRuleCall_1_0(),semanticObject.getName());\n  feeder.finish();\n}\n", "nl": "Contexts: GamlDefinition returns SkillFakeDefinition SkillFakeDefinition returns SkillFakeDefinition Constraint: name=ID"}
{"code": "public void closeDriver(){\n  if (camera != null) {\n    FlashlightManager.disableFlashlight();\n    camera.release();\n    camera=null;\n  }\n}\n", "nl": "Closes the camera driver if still in use."}
{"code": "public void removeSecurityManager(Password password,String id) throws PageException {\n  checkWriteAccess();\n  ((ConfigServerImpl)ConfigImpl.getConfigServer(config,password)).removeSecurityManager(id);\n  Element security=_getRootElement(\"security\");\n  Element[] children=XMLConfigWebFactory.getChildren(security,\"accessor\");\n  for (int i=0; i < children.length; i++) {\n    if (id.equals(children[i].getAttribute(\"id\"))) {\n      security.removeChild(children[i]);\n    }\n  }\n}\n", "nl": "remove security manager matching given id"}
{"code": "public static void circle(double x,double y,double r){\n  if (r < 0)   throw new IllegalArgumentException(\"circle radius must be nonnegative\");\n  double xs=scaleX(x);\n  double ys=scaleY(y);\n  double ws=factorX(2 * r);\n  double hs=factorY(2 * r);\n  if (ws <= 1 && hs <= 1)   pixel(x,y);\n else   offscreen.draw(new Ellipse2D.Double(xs - ws / 2,ys - hs / 2,ws,hs));\n  draw();\n}\n", "nl": "Draw a circle of radius r, centered on (x, y)."}
{"code": "@Override public void run(){\n  amIActive=true;\n  String inputFile=args[0];\n  if (inputFile.toLowerCase().contains(\".dep\")) {\n    calculateRaster();\n  }\n else   if (inputFile.toLowerCase().contains(\".shp\")) {\n    calculateVector();\n  }\n else {\n    showFeedback(\"There was a problem reading the input file.\");\n  }\n}\n", "nl": "Used to execute this plugin tool."}
{"code": "@SuppressWarnings({\"unchecked\",\"rawtypes\"}) private static <T>T create(Class<T> cls,QName qname){\n  return (T)Configuration.getBuilderFactory().getBuilder(qname).buildObject(qname);\n}\n", "nl": "Create object using OpenSAML's builder system."}
{"code": "public HttpConnection createHttpConnection(){\n  return new AndroidHttpConnection();\n}\n", "nl": "Create an HTTP connection"}
{"code": "@SuppressWarnings(\"unchecked\") private Map<Integer,float[]> parseWaveformsFromJsonFile(File waveformsFile){\n  Map<Integer,float[]> waveformsMap;\n  try {\n    waveformsMap=(Map<Integer,float[]>)parseJsonFile(waveformsFile);\n    LOG.info(\"Loaded waveform images from {}\",waveformsFile);\n  }\n catch (  IOException exception) {\n    waveformsMap=new HashMap<>();\n    LOG.error(\"Error loading waveform thumbnails: {}\",exception.getMessage(),exception);\n  }\n  return waveformsMap;\n}\n", "nl": "Loads the waveforms from a saved file formatted in JSON"}
{"code": "public static final void drawShape(GL2 gl,Shape s,boolean points){\n  if (s instanceof Circle) {\n    RenderUtilities.drawCircle(gl,(Circle)s,points,true);\n  }\n else   if (s instanceof Rectangle) {\n    RenderUtilities.drawRectangle(gl,(Rectangle)s,points);\n  }\n else   if (s instanceof Polygon) {\n    RenderUtilities.drawPolygon(gl,(Polygon)s,points);\n  }\n else   if (s instanceof Segment) {\n    RenderUtilities.drawLineSegment(gl,(Segment)s,points);\n  }\n else {\n  }\n}\n", "nl": "Draws the given shape."}
{"code": "public void write(Writer writer) throws IOException {\n  Map<String,Object> map=new HashMap<String,Object>();\n  map.put(\"vcards\",vcards);\n  map.put(\"utils\",new TemplateUtils());\n  map.put(\"translucentBg\",readImage(\"translucent-bg.png\",ImageType.PNG));\n  map.put(\"noProfile\",readImage(\"no-profile.png\",ImageType.PNG));\n  map.put(\"ezVCardVersion\",Ezvcard.VERSION);\n  map.put(\"ezVCardUrl\",Ezvcard.URL);\n  map.put(\"scribeIndex\",new ScribeIndex());\n  try {\n    template.process(map,writer);\n  }\n catch (  TemplateException e) {\n    throw new RuntimeException(e);\n  }\n  writer.flush();\n}\n", "nl": "Writes the HTML document to a writer."}
{"code": "@Override public String toString(String field){\n  StringBuilder buffer=new StringBuilder();\n  if (!getField().equals(field)) {\n    buffer.append(getField());\n    buffer.append(\":\");\n  }\n  buffer.append(includeLower ? '[' : '{');\n  buffer.append(lowerTerm != null ? (\"*\".equals(Term.toString(lowerTerm)) ? \"\\\\*\" : Term.toString(lowerTerm)) : \"*\");\n  buffer.append(\" TO \");\n  buffer.append(upperTerm != null ? (\"*\".equals(Term.toString(upperTerm)) ? \"\\\\*\" : Term.toString(upperTerm)) : \"*\");\n  buffer.append(includeUpper ? ']' : '}');\n  return buffer.toString();\n}\n", "nl": "Prints a user-readable version of this query."}
{"code": "public void prepare(PluginContext context) throws ReplicatorException, InterruptedException {\n  logger.info(\"Import tables from \" + this.uri.getPath() + \" to the \"+ this.getDefaultSchema()+ \" schema\");\n  tableNames=new ArrayList<String>();\n  columnDefinitions=new HashMap<String,ArrayList<ColumnSpec>>();\n  parser=new CSVParser(',','\"');\n  File importDirectory=new File(this.uri.getPath());\n  if (!importDirectory.exists()) {\n    throw new ReplicatorException(\"The \" + this.uri.getPath() + \" directory does not exist\");\n  }\n  for (  File f : importDirectory.listFiles()) {\n    if (f.getName().endsWith(\".def\")) {\n      this.prepareTableDefinition(f);\n    }\n  }\n  if (this.tableNames.size() == 0) {\n    throw new ReplicatorException(\"There are no tables to load\");\n  }\n}\n", "nl": "Prepare plug-in for use. This method is assumed to allocate all required resources. It is called before the plug-in performs any operations."}
{"code": "public void plot(AbstractDrawer draw){\n  if (!visible)   return;\n  draw.setColor(color);\n  draw.setFont(font);\n  draw.setBaseOffset(base_offset);\n  draw.setTextOffset(cornerE,cornerN);\n  draw.setTextAngle(angle);\n  draw.drawText(label,coord);\n  draw.setBaseOffset(null);\n}\n", "nl": "see Text for formatted text output"}
{"code": "public void testShiftRight4(){\n  byte aBytes[]={1,-128,56,100,-2,-76,89,45,91,3,-15,35,26};\n  int aSign=1;\n  int number=45;\n  byte rBytes[]={12,1,-61,39,-11,-94,-55};\n  BigInteger aNumber=new BigInteger(aSign,aBytes);\n  BigInteger result=aNumber.shiftRight(number);\n  byte resBytes[]=new byte[rBytes.length];\n  resBytes=result.toByteArray();\n  for (int i=0; i < resBytes.length; i++) {\n    assertTrue(resBytes[i] == rBytes[i]);\n  }\n  assertEquals(\"incorrect sign\",1,result.signum());\n}\n", "nl": "shiftRight(int n), n > 32"}
{"code": "public void fixStatsError(int sendCommand){\n  for (; this.affectedRows.length < sendCommand; ) {\n    this.affectedRows[currentStat++]=Statement.EXECUTE_FAILED;\n  }\n}\n", "nl": "Add missing information when Exception is thrown."}
{"code": "public byte[] readRawBytes(final int size) throws IOException {\n  if (size < 0) {\n    throw InvalidProtocolBufferNanoException.negativeSize();\n  }\n  if (bufferPos + size > currentLimit) {\n    skipRawBytes(currentLimit - bufferPos);\n    throw InvalidProtocolBufferNanoException.truncatedMessage();\n  }\n  if (size <= bufferSize - bufferPos) {\n    final byte[] bytes=new byte[size];\n    System.arraycopy(buffer,bufferPos,bytes,0,size);\n    bufferPos+=size;\n    return bytes;\n  }\n else {\n    throw InvalidProtocolBufferNanoException.truncatedMessage();\n  }\n}\n", "nl": "Read a fixed size of bytes from the input."}
{"code": "private void resetToXMLSAXHandler(){\n  this.m_escapeSetting=true;\n}\n", "nl": "Reset all of the fields owned by ToXMLSAXHandler class"}
{"code": "public static cuComplex cuCmplx(float r,float i){\n  cuComplex res=new cuComplex();\n  res.x=r;\n  res.y=i;\n  return res;\n}\n", "nl": "Creates a new complex number consisting of the given real and imaginary part."}
{"code": "public static MethodRepository make(String rawSig,GenericsFactory f){\n  return new MethodRepository(rawSig,f);\n}\n", "nl": "Static factory method."}
{"code": "public void add(final T object){\n  mObjects.add(object);\n  notifyItemInserted(getItemCount() - 1);\n}\n", "nl": "Adds the specified object at the end of the array."}
{"code": "public static String compareHardware(Map<String,String> hwMap,boolean checkDisk){\n  String localMemSizeStr=ServerProbe.getInstance().getMemorySize();\n  String localCpuCoreStr=ServerProbe.getInstance().getCpuCoreNum();\n  hwMap.get(PropertyConstants.PROPERTY_KEY_DISK_CAPACITY);\n  if (!localMemSizeStr.equals(hwMap.get(PropertyConstants.PROPERTY_KEY_MEMORY_SIZE))) {\n    log.warn(\"Local memory {} is not the same as selected cluster {}\",localMemSizeStr,hwMap.get(PropertyConstants.PROPERTY_KEY_MEMORY_SIZE));\n    return String.format(\"Local memory {%s} is not the same as selected cluster {%s}\",localMemSizeStr,hwMap.get(PropertyConstants.PROPERTY_KEY_MEMORY_SIZE));\n  }\n  if (!localCpuCoreStr.equals(hwMap.get(PropertyConstants.PROPERTY_KEY_CPU_CORE))) {\n    log.warn(\"Local CPU core number {} is not the same as selected cluster {}\",localCpuCoreStr,hwMap.get(PropertyConstants.PROPERTY_KEY_CPU_CORE));\n    return String.format(\"Local CPU core number {%s} is not the same as selected cluster {%s}\",localCpuCoreStr,hwMap.get(PropertyConstants.PROPERTY_KEY_CPU_CORE));\n  }\n  if (checkDisk && !hasSameDiskInfo(hwMap.get(PropertyConstants.PROPERTY_KEY_DISK),hwMap.get(PropertyConstants.PROPERTY_KEY_DISK_CAPACITY))) {\n    log.warn(\"Local disk(s) are not the same as selected cluster capacity {}\",hwMap.get(PropertyConstants.PROPERTY_KEY_DISK_CAPACITY));\n    return String.format(\"Local disk(s) are not the same as selected cluster capacity {%s}\",hwMap.get(PropertyConstants.PROPERTY_KEY_DISK_CAPACITY));\n  }\n  return null;\n}\n", "nl": "Check local node hardware (i.e. Memory size, CPU core, Disk Capacity) are the same as in the input map."}
{"code": "public static void tearDown(SWTWorkbenchBot bot){\n  SwtBotUtils.print(\"Tear Down\");\n  bot.resetWorkbench();\n  SwtBotUtils.print(\"Tear Down Done\");\n}\n", "nl": "Performs the necessary tear down work for most SWTBot tests."}
{"code": "private void handleMessage(byte[] data){\n  Buffer buffer=new Buffer();\n  buffer.write(data);\n  int type=(buffer.readShort() & 0xffff) & ~(APP_MSG_RESPONSE_BIT);\n  if (type == BeanMessageID.SERIAL_DATA.getRawValue()) {\n    beanListener.onSerialMessageReceived(buffer.readByteArray());\n  }\n else   if (type == BeanMessageID.BT_GET_CONFIG.getRawValue()) {\n    returnConfig(buffer);\n  }\n else   if (type == BeanMessageID.CC_TEMP_READ.getRawValue()) {\n    returnTemperature(buffer);\n  }\n else   if (type == BeanMessageID.BL_GET_META.getRawValue()) {\n    returnMetadata(buffer);\n  }\n else   if (type == BeanMessageID.BT_GET_SCRATCH.getRawValue()) {\n    returnScratchData(buffer);\n  }\n else   if (type == BeanMessageID.CC_LED_READ_ALL.getRawValue()) {\n    returnLed(buffer);\n  }\n else   if (type == BeanMessageID.CC_ACCEL_READ.getRawValue()) {\n    returnAcceleration(buffer);\n  }\n else   if (type == BeanMessageID.CC_ACCEL_GET_RANGE.getRawValue()) {\n    returnAccelerometerRange(buffer);\n  }\n else   if (type == BeanMessageID.CC_GET_AR_POWER.getRawValue()) {\n    returnArduinoPowerState(buffer);\n  }\n else   if (type == BeanMessageID.BL_STATUS.getRawValue()) {\n    try {\n      Status status=Status.fromPayload(buffer);\n      handleStatus(status);\n    }\n catch (    NoEnumFoundException e) {\n      Log.e(TAG,\"Unable to parse status from buffer: \" + buffer.toString());\n      e.printStackTrace();\n    }\n  }\n else {\n    String fourDigitHex=Integer.toHexString(type);\n    while (fourDigitHex.length() < 4) {\n      fourDigitHex=\"0\" + fourDigitHex;\n    }\n    Log.e(TAG,\"Received message of unknown type 0x\" + fourDigitHex);\n    returnError(BeanError.UNKNOWN_MESSAGE_ID);\n  }\n}\n", "nl": "Handles incoming messages from the Bean and dispatches them to the proper handlers."}
{"code": "public static <K,V>HashMap<K,V> newEmptyHashMap(Iterable<?> iterable){\n  if (iterable instanceof Collection<?>)   return Maps.newHashMapWithExpectedSize(((Collection<?>)iterable).size());\n  return Maps.newHashMap();\n}\n", "nl": "Returns an empty map with expected size matching the iterable size if it's of type Collection. Otherwise, an empty map with the default size is returned."}
{"code": "public int calculateScrollY(int firstVisiblePosition,int visibleItemCount){\n  mFirstVisiblePosition=firstVisiblePosition;\n  if (mReferencePosition < 0) {\n    mReferencePosition=mFirstVisiblePosition;\n  }\n  if (visibleItemCount > 0) {\n    View c=mListView.getListChildAt(0);\n    int scrollY=-c.getTop();\n    mListViewItemHeights.put(firstVisiblePosition,c.getMeasuredHeight());\n    if (mFirstVisiblePosition >= mReferencePosition) {\n      for (int i=mReferencePosition; i < firstVisiblePosition; ++i) {\n        if (mListViewItemHeights.get(i) == null) {\n          mListViewItemHeights.put(i,c.getMeasuredHeight());\n        }\n        scrollY+=mListViewItemHeights.get(i);\n      }\n      return scrollY;\n    }\n else {\n      for (int i=mReferencePosition - 1; i >= firstVisiblePosition; --i) {\n        if (mListViewItemHeights.get(i) == null) {\n          mListViewItemHeights.put(i,c.getMeasuredHeight());\n        }\n        scrollY-=mListViewItemHeights.get(i);\n      }\n      return scrollY;\n    }\n  }\n  return 0;\n}\n", "nl": "Call from an AbsListView.OnScrollListener to calculate the scrollY (Here we definite as the distance in pixels compared to the position representing the current date)."}
{"code": "public DynamicRegionFactoryImpl(){\n}\n", "nl": "create an instance of the factory. This is normally only done by DynamicRegionFactory's static initialization"}
{"code": "public DViewAsymmetricKeyFields(JDialog parent,String title,DSAPublicKey dsaPublicKey){\n  super(parent,title,Dialog.ModalityType.DOCUMENT_MODAL);\n  key=dsaPublicKey;\n  initFields();\n}\n", "nl": "Creates new DViewAsymmetricKeyFields dialog."}
{"code": "public void removeAllActions(CCNode target){\n  if (target == null)   return;\n  HashElement element=targets.get(target);\n  if (element != null) {\n    deleteHashElement(element);\n  }\n else {\n  }\n}\n", "nl": "Removes all actions from a certain target. All the actions that belongs to the target will be removed."}
{"code": "private static String normalizeName(String name){\n  name=(name == null) ? \"\" : name.trim();\n  return name.isEmpty() ? MISSING_NAME : name;\n}\n", "nl": "Normalizes a name to something OpenMRS will accept."}
{"code": "@Override public Object build(QueryNode queryNode) throws QueryNodeException {\n  process(queryNode);\n  return queryNode.getTag(QUERY_TREE_BUILDER_TAGID);\n}\n", "nl": "Builds some kind of object from a query tree. Each node in the query tree is built using an specific builder associated to it."}
{"code": "public boolean isEnableLighting(){\n  return false;\n}\n", "nl": "Returns false."}
{"code": "protected void prepare(){\n  ProcessInfoParameter[] para=getParameter();\n  for (int i=0; i < para.length; i++) {\n    String name=para[i].getParameterName();\n    if (para[i].getParameter() == null)     ;\n else     log.log(Level.SEVERE,\"prepare - Unknown Parameter: \" + name);\n  }\n}\n", "nl": "Prepare - e.g., get Parameters."}
{"code": "public void fling(int velocityX,int velocityY){\n  if (getChildCount() > 0) {\n    int height=getHeight() - getPaddingBottom() - getPaddingTop();\n    int bottom=getChildAt(0).getHeight();\n    int width=getWidth() - getPaddingRight() - getPaddingLeft();\n    int right=getChildAt(0).getWidth();\n    mScroller.fling(getScrollX(),getScrollY(),velocityX,velocityY,0,right - width,0,bottom - height);\n    final boolean movingDown=velocityY > 0;\n    final boolean movingRight=velocityX > 0;\n    View newFocused=findFocusableViewInMyBounds(movingRight,mScroller.getFinalX(),movingDown,mScroller.getFinalY(),findFocus());\n    if (newFocused == null) {\n      newFocused=this;\n    }\n    if (newFocused != findFocus() && newFocused.requestFocus(movingDown ? View.FOCUS_DOWN : View.FOCUS_UP)) {\n      mTwoDScrollViewMovedFocus=true;\n      mTwoDScrollViewMovedFocus=false;\n    }\n    awakenScrollBars(mScroller.getDuration());\n    invalidate();\n  }\n}\n", "nl": "Fling the scroll view"}
{"code": "protected Socket createSocket(){\n  return new Socket();\n}\n", "nl": "Creates a new unconnected Socket instance. Subclasses may use this method to override the default socket implementation."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:36:21.616 -0500\",hash_original_method=\"F5BF0DDF083843E14FDE0C117BAE250E\",hash_generated_method=\"E1C3BB6772CE07721D8608A1E4D81EE1\") public static int netmaskIntToPrefixLength(int netmask){\n  return Integer.bitCount(netmask);\n}\n", "nl": "Convert a IPv4 netmask integer to a prefix length"}
{"code": "public WritableRaster createWritableChild(int x,int y,int width,int height,int x0,int y0,int[] bandList){\n  if (x < this.minX) {\n    throw new RasterFormatException(\"x lies outside the raster\");\n  }\n  if (y < this.minY) {\n    throw new RasterFormatException(\"y lies outside the raster\");\n  }\n  if ((x + width < x) || (x + width > this.minX + this.width)) {\n    throw new RasterFormatException(\"(x + width) is outside of Raster\");\n  }\n  if ((y + height < y) || (y + height > this.minY + this.height)) {\n    throw new RasterFormatException(\"(y + height) is outside of Raster\");\n  }\n  SampleModel sm;\n  if (bandList != null)   sm=sampleModel.createSubsetSampleModel(bandList);\n else   sm=sampleModel;\n  int deltaX=x0 - x;\n  int deltaY=y0 - y;\n  return new ShortInterleavedRaster(sm,dataBuffer,new Rectangle(x0,y0,width,height),new Point(sampleModelTranslateX + deltaX,sampleModelTranslateY + deltaY),this);\n}\n", "nl": "Creates a Writable subRaster given a region of the Raster. The x and y coordinates specify the horizontal and vertical offsets from the upper-left corner of this Raster to the upper-left corner of the subRaster.  A subset of the bands of the parent Raster may be specified.  If this is null, then all the bands are present in the subRaster. A translation to the subRaster may also be specified. Note that the subRaster will reference the same DataBuffers as the parent Raster, but using different offsets."}
{"code": "private boolean isBlockCommented(int startLine,int endLine,String[] prefixes,IDocument document){\n  try {\n    for (int i=startLine; i <= endLine; i++) {\n      IRegion line=document.getLineInformation(i);\n      String text=document.get(line.getOffset(),line.getLength());\n      int[] found=TextUtilities.indexOf(prefixes,text,0);\n      if (found[0] == -1)       return false;\n      String s=document.get(line.getOffset(),found[0]);\n      s=s.trim();\n      if (s.length() != 0)       return false;\n    }\n    return true;\n  }\n catch (  BadLocationException x) {\n  }\n  return false;\n}\n", "nl": "Determines whether each line is prefixed by one of the prefixes."}
{"code": "@Override public void eUnset(int featureID){\nswitch (featureID) {\ncase GamlPackage.PARAMETERS__PARAMS:\n    setParams((ExpressionList)null);\n  return;\n}\nsuper.eUnset(featureID);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public static void main(String[] args){\n  String matrixFilename=null;\n  String coordinateFilename=null;\n  String externalZonesFilename=null;\n  String networkFilename=null;\n  String plansFilename=null;\n  Double populationFraction=null;\n  if (args.length != 6) {\n    throw new IllegalArgumentException(\"Wrong number of arguments\");\n  }\n else {\n    matrixFilename=args[0];\n    coordinateFilename=args[1];\n    externalZonesFilename=args[2];\n    networkFilename=args[3];\n    plansFilename=args[4];\n    populationFraction=Double.parseDouble(args[5]);\n  }\n  List<String> list=new ArrayList<>();\n  try {\n    BufferedReader br=IOUtils.getBufferedReader(externalZonesFilename);\n    try {\n      String line=null;\n      while ((line=br.readLine()) != null) {\n        list.add(line);\n      }\n    }\n  finally {\n      br.close();\n    }\n  }\n catch (  FileNotFoundException e) {\n    e.printStackTrace();\n  }\ncatch (  IOException e) {\n    e.printStackTrace();\n  }\n  MyDemandMatrix mdm=new MyDemandMatrix();\n  mdm.readLocationCoordinates(coordinateFilename,2,0,1);\n  mdm.parseMatrix(matrixFilename,\"Saturn\",\"Saturn model received for Sanral project\");\n  Scenario sc=mdm.generateDemand(list,new Random(5463),populationFraction,\"car\");\n  NetworkReaderMatsimV1 nr=new NetworkReaderMatsimV1(sc.getNetwork());\n  nr.readFile(networkFilename);\n  XY2Links xy=new XY2Links(sc.getNetwork(),null);\n  xy.run(sc.getPopulation());\n  PopulationWriter pw=new PopulationWriter(sc.getPopulation(),sc.getNetwork());\n  pw.write(plansFilename);\n}\n", "nl": "Class to generate plans files from the Saturn OD-matrices provided  by Sanral's modelling consultant, Alan Robinson."}
{"code": "private int partition(int[] a,int left,int right){\n  int pivot=a[left + (right - left) / 2];\n  while (left <= right) {\n    while (a[left] > pivot)     left++;\n    while (a[right] < pivot)     right--;\n    if (left <= right) {\n      int temp=a[left];\n      a[left]=a[right];\n      a[right]=temp;\n      left++;\n      right--;\n    }\n  }\n  return left;\n}\n", "nl": "Choose mid value as pivot Move two pointers Swap and move on Return left pointer"}
{"code": "public boolean isDone(){\n  return one.getHand().empty() || two.getHand().empty();\n}\n", "nl": "Returns true if either hand is empty."}
{"code": "public ClassNotFoundException(@Nullable String s,@Nullable Throwable ex){\n  super(s,null);\n  this.ex=ex;\n}\n", "nl": "Constructs a <code>ClassNotFoundException</code> with the specified detail message and optional exception that was raised while loading the class."}
{"code": "@Override public boolean eIsSet(int featureID){\nswitch (featureID) {\ncase BasePackage.DOCUMENTED_ELEMENT__DOCUMENTATION:\n    return DOCUMENTATION_EDEFAULT == null ? documentation != null : !DOCUMENTATION_EDEFAULT.equals(documentation);\n}\nreturn super.eIsSet(featureID);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "@Override public void drawRangeLine(Graphics2D g2,CategoryPlot plot,ValueAxis axis,Rectangle2D dataArea,double value,Paint paint,Stroke stroke){\n  Range range=axis.getRange();\n  if (!range.contains(value)) {\n    return;\n  }\n  Rectangle2D adjusted=new Rectangle2D.Double(dataArea.getX(),dataArea.getY() + getYOffset(),dataArea.getWidth() - getXOffset(),dataArea.getHeight() - getYOffset());\n  Line2D line1=null;\n  Line2D line2=null;\n  PlotOrientation orientation=plot.getOrientation();\n  if (orientation == PlotOrientation.HORIZONTAL) {\n    double x0=axis.valueToJava2D(value,adjusted,plot.getRangeAxisEdge());\n    double x1=x0 + getXOffset();\n    double y0=dataArea.getMaxY();\n    double y1=y0 - getYOffset();\n    double y2=dataArea.getMinY();\n    line1=new Line2D.Double(x0,y0,x1,y1);\n    line2=new Line2D.Double(x1,y1,x1,y2);\n  }\n else   if (orientation == PlotOrientation.VERTICAL) {\n    double y0=axis.valueToJava2D(value,adjusted,plot.getRangeAxisEdge());\n    double y1=y0 - getYOffset();\n    double x0=dataArea.getMinX();\n    double x1=x0 + getXOffset();\n    double x2=dataArea.getMaxX();\n    line1=new Line2D.Double(x0,y0,x1,y1);\n    line2=new Line2D.Double(x1,y1,x2,y1);\n  }\n  g2.setPaint(paint);\n  g2.setStroke(stroke);\n  g2.draw(line1);\n  g2.draw(line2);\n}\n", "nl": "Draws a line perpendicular to the range axis."}
{"code": "void startFading(){\n  mHandler.removeMessages(MSG_FADE);\n  scheduleFade();\n}\n", "nl": "Start up the pulse to fade the screen, clearing any existing pulse to ensure that we don't have multiple pulses running at a time."}
{"code": "protected Connection createConnection() throws Exception {\n  ActiveMQConnectionFactory factory=new ActiveMQConnectionFactory(\"vm://localhost?broker.persistent=false\");\n  return factory.createConnection();\n}\n", "nl": "Creates a connection."}
{"code": "protected void drawView(Graphics2D g,Rectangle r,View view,int fontHeight,int y){\n  float x=r.x;\n  LayeredHighlighter h=(LayeredHighlighter)host.getHighlighter();\n  RSyntaxDocument document=(RSyntaxDocument)getDocument();\n  Element map=getElement();\n  int p0=view.getStartOffset();\n  int lineNumber=map.getElementIndex(p0);\n  int p1=view.getEndOffset();\n  setSegment(p0,p1 - 1,document,drawSeg);\n  int start=p0 - drawSeg.offset;\n  Token token=document.getTokenListForLine(lineNumber);\n  if (token != null && token.type == Token.NULL) {\n    h.paintLayeredHighlights(g,p0,p1,r,host,this);\n    return;\n  }\n  while (token != null && token.isPaintable()) {\n    int p=calculateBreakPosition(p0,token,x);\n    x=r.x;\n    h.paintLayeredHighlights(g,p0,p,r,host,this);\n    while (token != null && token.isPaintable() && token.offset + token.textCount - 1 < p) {\n      x=token.paint(g,x,y,host,this);\n      token=token.getNextToken();\n    }\n    if (token != null && token.isPaintable() && token.offset < p) {\n      int tokenOffset=token.offset;\n      Token temp=new DefaultToken(drawSeg,tokenOffset - start,p - 1 - start,tokenOffset,token.type);\n      temp.paint(g,x,y,host,this);\n      temp=null;\n      token.makeStartAt(p);\n    }\n    p0=(p == p0) ? p1 : p;\n    y+=fontHeight;\n  }\n  if (host.getEOLMarkersVisible()) {\n    g.setColor(host.getForegroundForTokenType(Token.WHITESPACE));\n    g.setFont(host.getFontForTokenType(Token.WHITESPACE));\n    g.drawString(\"\\u00B6\",x,y - fontHeight);\n  }\n}\n", "nl": "Draws a single view (i.e., a line of text for a wrapped view), wrapping the text onto multiple lines if necessary."}
{"code": "@Override public boolean containsKey(Object key){\n  if (key == null) {\n    key=NULL_OBJECT;\n  }\n  int index=findIndex(key,elementData);\n  return elementData[index] == key;\n}\n", "nl": "Returns whether this map contains the specified key."}
{"code": "public boolean autoCorrectText(){\n  return preferences.getBoolean(resources.getString(R.string.key_autocorrect_text),Boolean.parseBoolean(resources.getString(R.string.default_autocorrect_text)));\n}\n", "nl": "Whether message text should be autocorrected."}
{"code": "protected void removeNode(int id) throws Exception {\n  int idx;\n  FolderTokenDocTreeNode node=null;\n  idx=findIndexById(id);\n  if (idx == -1) {\n    throw new IeciTdException(FolderBaseError.EC_NOT_FOUND,FolderBaseError.EM_NOT_FOUND);\n  }\n  node=(FolderTokenDocTreeNode)m_nodes.get(idx);\n  if (node.isNew())   m_nodes.remove(idx);\n else   node.setEditFlag(FolderEditFlag.REMOVE);\n}\n", "nl": "Elimina de la lista de nodos el nodo con el id especificado"}
{"code": "public void deleteAttributes(int[] columnIndices){\n  ((ArffTableModel)getModel()).deleteAttributes(columnIndices);\n}\n", "nl": "deletes the attributes at the given indices"}
{"code": "public void onSuccess(int statusCode,Header[] headers,JSONObject response){\n  Log.w(LOG_TAG,\"onSuccess(int, Header[], JSONObject) was not overriden, but callback was received\");\n}\n", "nl": "Returns when request succeeds"}
{"code": "public int lastIndexOfFromTo(byte element,int from,int to){\n  if (size == 0)   return -1;\n  checkRangeFromTo(from,to,size);\n  byte[] theElements=elements;\n  for (int i=to; i >= from; i--) {\n    if (element == theElements[i]) {\n      return i;\n    }\n  }\n  return -1;\n}\n", "nl": "Returns the index of the last occurrence of the specified element. Returns <code>-1</code> if the receiver does not contain this element. Searches beginning at <code>to</code>, inclusive until <code>from</code>, inclusive. Tests for identity."}
{"code": "public void put(final long key){\n  if (key == FREE_KEY) {\n    m_hasFreeKey=true;\n    return;\n  }\n  int ptr=(int)((Tools.phiMix(key) & m_mask));\n  long e=m_data[ptr];\n  if (e == FREE_KEY) {\n    m_data[ptr]=key;\n    if (m_size >= m_threshold) {\n      rehash(m_data.length * 2);\n    }\n else {\n      ++m_size;\n    }\n    return;\n  }\n else   if (e == key) {\n    return;\n  }\n  while (true) {\n    ptr=(int)((ptr + 1) & m_mask);\n    e=m_data[ptr];\n    if (e == FREE_KEY) {\n      m_data[ptr]=key;\n      if (m_size >= m_threshold) {\n        rehash(m_data.length * 2);\n      }\n else {\n        ++m_size;\n      }\n      return;\n    }\n else     if (e == key) {\n      return;\n    }\n  }\n}\n", "nl": "Add a single element to the map"}
{"code": "public PredictiveInfoCalculatorKraskov(String calculatorName) throws InstantiationException, IllegalAccessException, ClassNotFoundException {\n  super(calculatorName);\n  if (!calculatorName.equalsIgnoreCase(MI_CALCULATOR_KRASKOV1) && !calculatorName.equalsIgnoreCase(MI_CALCULATOR_KRASKOV2)) {\n    throw new ClassNotFoundException(\"Must be an underlying Kraskov-Grassberger calculator\");\n  }\n}\n", "nl": "Creates a new instance of the Kraskov-Stoegbauer-Grassberger estimator for PI, with the supplied MI calculator name."}
{"code": "public DefaultDirectAdjacentSelector(short type,Selector parent,SimpleSelector simple){\n  super(type,parent,simple);\n}\n", "nl": "Creates a new DefaultDirectAdjacentSelector object."}
{"code": "@Inline public void postCopy(ObjectReference object,boolean majorGC){\n  initializeHeader(object,false);\n  if (!HEADER_MARK_BITS) {\n    testAndSetLiveBit(object);\n  }\n}\n", "nl": "Perform any required post copy (i.e. in-GC allocation) initialization. This is relevant (for example) when MS is used as the mature space in a copying GC."}
{"code": "public static LinkedHashMap<Pattern,String> parseRulesFile(InputStream is){\n  LinkedHashMap<Pattern,String> rules=new LinkedHashMap<>();\n  BufferedReader br=new BufferedReader(IOUtils.getDecodingReader(is,StandardCharsets.UTF_8));\n  String line;\n  try {\n    int linenum=0;\n    while ((line=br.readLine()) != null) {\n      linenum++;\n      String[] arr=line.split(\"#\");\n      if (arr.length > 0)       line=arr[0].trim();\n      if (line.length() == 0)       continue;\n      int sep=line.indexOf(\"=\");\n      if (sep <= 0) {\n        log.warn(\"Wrong format of password line \" + linenum);\n        continue;\n      }\n      String pass=line.substring(sep + 1).trim();\n      String regex=line.substring(0,sep).trim();\n      try {\n        Pattern pattern=Pattern.compile(regex);\n        rules.put(pattern,pass);\n      }\n catch (      PatternSyntaxException pse) {\n        log.warn(\"Key of line \" + linenum + \" was not a valid regex pattern\",pse);\n        continue;\n      }\n    }\n    is.close();\n  }\n catch (  IOException e) {\n    throw new RuntimeException(e);\n  }\n  return rules;\n}\n", "nl": "Parses rule file from stream and returns a Map of all rules found"}
{"code": "public boolean isItemForce(){\n  return true;\n}\n", "nl": "Returns true."}
{"code": "public Builder document(InputStream document,String mediaType){\n  documentInputStream=document;\n  this.mediaType=mediaType;\n  return this;\n}\n", "nl": "Sets the document as an input stream and its media type."}
{"code": "public final String toString(){\n  StringBuffer text=new StringBuffer();\n  text.append(\"Print statistic values of instances (\" + first + \"-\"+ last+ \"\\n\");\n  text.append(\"    Number of instances:\\t\" + numInstances + \"\\n\");\n  text.append(\"    NUmber of instances with unknowns:\\t\" + missingInstances + \"\\n\");\n  text.append(\"    Attribute:\\t\\t\\t:\" + attr + \"\\n\");\n  text.append(\"    Sum:\\t\\t\\t\" + sum + \"\\n\");\n  text.append(\"    Squared sum:\\t\\t\" + sqrSum + \"\\n\");\n  text.append(\"    Stanard Deviation:\\t\\t\" + sd + \"\\n\");\n  return text.toString();\n}\n", "nl": "Converts the stats to a string"}
{"code": "private void scanAndLock(Object key,int hash){\n  HashEntry<K,V> first=entryForHash(this,hash);\n  HashEntry<K,V> e=first;\n  int retries=-1;\n  while (!tryLock()) {\n    HashEntry<K,V> f;\n    if (retries < 0) {\n      if (e == null || key.equals(e.key))       retries=0;\n else       e=e.next;\n    }\n else     if (++retries > MAX_SCAN_RETRIES) {\n      lock();\n      break;\n    }\n else     if ((retries & 1) == 0 && (f=entryForHash(this,hash)) != first) {\n      e=first=f;\n      retries=-1;\n    }\n  }\n}\n", "nl": "Scans for a node containing the given key while trying to acquire lock for a remove or replace operation. Upon return, guarantees that lock is held.  Note that we must lock even if the key is not found, to ensure sequential consistency of updates."}
{"code": "public IntentBuilder oldColor(int oldColor){\n  mOldColor=oldColor;\n  return this;\n}\n", "nl": "Sets the old color to show on the bottom \"Cancel\" half circle, and also the initial value for the picked color. The default value is black."}
{"code": "public void __setDaoSession(DaoSession daoSession){\n  this.daoSession=daoSession;\n  myDao=daoSession != null ? daoSession.getUserDBDao() : null;\n}\n", "nl": "called by internal mechanisms, do not call yourself."}
{"code": "@Override public boolean equals(Object obj){\n  if (obj == this) {\n    return true;\n  }\n  if (!(obj instanceof TimeTableXYDataset)) {\n    return false;\n  }\n  TimeTableXYDataset that=(TimeTableXYDataset)obj;\n  if (this.domainIsPointsInTime != that.domainIsPointsInTime) {\n    return false;\n  }\n  if (this.xPosition != that.xPosition) {\n    return false;\n  }\n  if (!this.workingCalendar.getTimeZone().equals(that.workingCalendar.getTimeZone())) {\n    return false;\n  }\n  if (!this.values.equals(that.values)) {\n    return false;\n  }\n  return true;\n}\n", "nl": "Tests this dataset for equality with an arbitrary object."}
{"code": "private void startContext(CrawlJob crawlJob){\n  LOGGER.debug(\"Starting context\");\n  PathSharingContext ac=crawlJob.getJobContext();\n  ac.addApplicationListener(this);\n  try {\n    ac.start();\n  }\n catch (  BeansException be) {\n    LOGGER.warn(be.getMessage());\n    ac.close();\n  }\ncatch (  Exception e) {\n    LOGGER.warn(e.getMessage());\n    try {\n      ac.close();\n    }\n catch (    Exception e2) {\n      e2.printStackTrace(System.err);\n    }\n finally {\n    }\n  }\n  LOGGER.debug(\"Context started\");\n}\n", "nl": "Start the context, catching and reporting any BeansExceptions."}
{"code": "@Override public boolean performCancel(){\n  CnAElementFactory.getInstance().reloadModelFromDatabase();\n  return true;\n}\n", "nl": "Cause update to risk analysis object in loaded model."}
{"code": "public boolean isOpaque(){\n  checkOpacityMethodClient();\n  return explicitlyOpaque;\n}\n", "nl": "Returns whether the background of this <code>BasicPanel</code> will be painted when it is rendered."}
{"code": "private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {\n  s.defaultReadObject();\n}\n", "nl": "Adds semantic checks to the default deserialization method. This method must have the standard signature for a readObject method, and the body of the method must begin with \"s.defaultReadObject();\". Other than that, any semantic checks can be specified and do not need to stay the same from version to version. A readObject method of this form may be added to any class, even if Tetrad sessions were previously saved out using a version of the class that didn't include it. (That's what the \"s.defaultReadObject();\" is for. See J. Bloch, Effective Java, for help."}
{"code": "@Override public void resetDistribution(Instances data) throws Exception {\n  Instances insts=new Instances(data,data.numInstances());\n  for (int i=0; i < data.numInstances(); i++) {\n    if (whichSubset(data.instance(i)) > -1) {\n      insts.add(data.instance(i));\n    }\n  }\n  Distribution newD=new Distribution(insts,this);\n  newD.addInstWithUnknown(data,m_attIndex);\n  m_distribution=newD;\n}\n", "nl": "Sets distribution associated with model."}
{"code": "public static <T,R>R readStaticField(Class<T> klass,String fieldName) throws NoSuchFieldException {\n  return readAvailableField(klass,null,fieldName);\n}\n", "nl": "Reads the static field with given fieldName in given klass."}
{"code": "public static String extractFactor_Display(String laggedFactor){\n  int colonIndex=laggedFactor.indexOf(\":L\");\n  String factor=laggedFactor.substring(0,colonIndex);\n  return factor;\n}\n", "nl": "Parses the given string representing a lagged factor and return the part that represents the factor."}
{"code": "protected void deployCargoPing(WebLogicLocalContainer container) throws IOException {\n  String deployDir=getFileHandler().createDirectory(getDomainHome(),container.getAutoDeployDirectory());\n  getResourceUtils().copyResource(RESOURCE_PATH + \"cargocpc.war\",getFileHandler().append(deployDir,\"cargocpc.war\"),getFileHandler());\n}\n", "nl": "Deploy the Cargo Ping utility to the container."}
{"code": "public int size(){\n  return this.count;\n}\n", "nl": "Returns the number of mappings in this map"}
{"code": "protected void parse(DataInputStream stream) throws Exception {\n  int size=stream.readInt();\n  int ret, read=0;\n  data=new byte[size];\n  while (size > 0) {\n    ret=stream.read(data,read,size);\n    size-=ret;\n    read+=ret;\n  }\n}\n", "nl": "Loading method. (see NBT_Tag)"}
{"code": "@Ignore(\"NaN behavior TBD\") @Test public void testLinearAzimuth_WithNaN() throws Exception {\n  Location begin=new Location(Double.NaN,Double.NaN);\n  Location end=new Location(34.2,-119.2);\n  double azimuth=begin.linearAzimuth(end);\n  assertTrue(\"expecting NaN\",Double.isNaN(azimuth));\n}\n", "nl": "Ensures linear azimuth is NaN when NaN members are used."}
{"code": "public MutableValueBuffer(final int capacity,final IRaba src){\n  if (src == null)   throw new IllegalArgumentException();\n  checkCapacity(capacity);\n  if (capacity < src.capacity())   throw new IllegalArgumentException();\n  nvalues=src.size();\n  values=new byte[capacity][];\n  int i=0;\n  for (  byte[] a : src) {\n    values[i++]=a;\n  }\n}\n", "nl": "Builds a mutable value buffer."}
{"code": "private void checkCircuits(){\n  _portalIconMap.clear();\n  _darkTrack.clear();\n  _unconvertedTrack.clear();\n  PortalManager portalMgr=InstanceManager.getDefault(jmri.jmrit.logix.PortalManager.class);\n  Iterator<Positionable> it=_editor.getContents().iterator();\n  while (it.hasNext()) {\n    Positionable pos=it.next();\n    if (pos instanceof IndicatorTrack) {\n      OBlock block=((IndicatorTrack)pos).getOccBlock();\n      ((IndicatorTrack)pos).removePath(EditCircuitPaths.TEST_PATH);\n      if (block != null) {\n        addIcon(block,pos);\n      }\n else {\n        _darkTrack.add(pos);\n      }\n    }\n else     if (pos instanceof PortalIcon) {\n      PortalIcon pIcon=(PortalIcon)pos;\n      String name=pIcon.getName();\n      Portal portal=portalMgr.getByUserName(name);\n      if (portal == null) {\n        log.error(\"No Portal for PortalIcon called \\\"\" + name + \"\\\". Discarding icon.\");\n        pIcon.remove();\n      }\n else {\n        PortalIcon pi=_portalIconMap.get(name);\n        if (pi != null) {\n          log.error(\"Removing duplicate PortalIcon for Portal \\\"\" + name + \"\\\".\");\n          pi.remove();\n        }\n        _portalIconMap.put(name,pIcon);\n      }\n    }\n  }\n  Iterator<Entry<OBlock,ArrayList<Positionable>>> iters=_circuitMap.entrySet().iterator();\n  while (iters.hasNext()) {\n    Entry<OBlock,ArrayList<Positionable>> entry=iters.next();\n    Iterator<Positionable> iter=entry.getValue().iterator();\n    while (iter.hasNext()) {\n      Positionable pos=iter.next();\n      if (isUnconvertedTrack(pos)) {\n        if (!_unconvertedTrack.contains(pos)) {\n          _unconvertedTrack.add(pos);\n        }\n      }\n    }\n  }\n  _bareBlock.clear();\n  _convertBlock.clear();\n  _badPortalIcon.clear();\n  OBlockManager manager=InstanceManager.getDefault(jmri.jmrit.logix.OBlockManager.class);\n  String[] sysNames=manager.getSystemNameArray();\n  hasOBlocks=(sysNames.length > 0);\n  for (int i=0; i < sysNames.length; i++) {\n    OBlock block=manager.getBySystemName(sysNames[i]);\n    java.util.List<Portal> list=block.getPortals();\n    if (list != null) {\n      Iterator<Portal> iter=list.iterator();\n      while (iter.hasNext()) {\n        Portal portal=iter.next();\n        PortalIcon pi=_portalIconMap.get(portal.getName());\n        if (pi != null) {\n          addIcon(block,pi);\n        }\n      }\n    }\n    java.util.List<Positionable> icons=_circuitMap.get(block);\n    if (log.isDebugEnabled()) {\n      log.debug(\"checkCircuits: block \" + block.getDisplayName() + \" has \"+ icons.size()+ \" icons.\");\n    }\n    if (icons == null || icons.size() == 0) {\n      _bareBlock.add(block);\n    }\n else {\n      _bareBlock.remove(block);\n      for (int k=0; k < icons.size(); k++) {\n        Positionable pos=icons.get(k);\n        if (!(pos instanceof IndicatorTrack) && !(pos instanceof PortalIcon)) {\n          if (!_convertBlock.contains(block)) {\n            _convertBlock.add(block);\n            break;\n          }\n        }\n      }\n    }\n  }\n  List<NamedBean> list=portalMgr.getNamedBeanList();\n  Iterator<NamedBean> iter=list.iterator();\n  while (iter.hasNext()) {\n    Portal portal=(Portal)iter.next();\n    String name=portal.getName();\n    PortalIcon pi=_portalIconMap.get(name);\n    if (pi != null) {\n      if (!checkPortalIcon(portal,pi)) {\n        _badPortalIcon.put(name,portal);\n      }\n    }\n else {\n      _badPortalIcon.put(name,portal);\n    }\n  }\n  makeToDoMenu();\n}\n", "nl": "Find the blocks with no icons and the blocks with icons that need conversion Setup for main Frame - used in both initialization and close of an editing frame Build Lists that are used to create menu items"}
{"code": "public OutOfLineContent(){\n  super(KEY);\n}\n", "nl": "Constructs a new instance using the default metadata."}
{"code": "private static List<String> rewriteTermBruteForce(String term){\n  List<String> termsList=rewriteBrute(term);\n  if (term == \"\" || !term.equals(termsList.get(termsList.size() - 1)))   termsList.add(term);\n  return termsList;\n}\n", "nl": "Wrapper over main recursive method, rewriteBrute which performs the fuzzy tokenization of a term The original term may not be a valid dictionary word, but be a term particular to the database The method rewriteBrute only considers terms which are valid dictionary words In case original term is not a dictionary word, it will not be added to queryList by method rewriteBrute This wrapper ensures that if rewriteBrute does not include the original term, it will still be included For example, for the term \"newyork\", rewriteBrute will return the list <\"new york\"> But \"newyork\" also needs to be included in the list to support particular user queries This wrapper includes \"newyork\" in this list"}
{"code": "public void test_sssp_linkType_constraint() throws Exception {\n  final SmallWeightedGraphProblem p=setupSmallWeightedGraphProblem();\n  final IGASEngine gasEngine=getGraphFixture().newGASEngine(1);\n  try {\n    final IGraphAccessor graphAccessor=getGraphFixture().newGraphAccessor(null);\n    final IGASContext<SSSP.VS,SSSP.ES,Integer> gasContext=gasEngine.newGASContext(graphAccessor,new SSSP());\n    gasContext.setLinkType((URI)p.getFoafKnows());\n    final IGASState<SSSP.VS,SSSP.ES,Integer> gasState=gasContext.getGASState();\n    gasState.setFrontier(gasContext,p.getV1());\n    gasContext.call();\n    assertEquals(0.0,gasState.getState(p.getV1()).dist());\n    assertEquals(1.0,gasState.getState(p.getV2()).dist());\n    assertEquals(1.0,gasState.getState(p.getV3()).dist());\n    assertEquals(2.0,gasState.getState(p.getV4()).dist());\n    assertEquals(2.0,gasState.getState(p.getV5()).dist());\n  }\n  finally {\n    gasEngine.shutdownNow();\n  }\n}\n", "nl": "A unit test based on graph with link weights - in this version of the test we constrain the link type but do not specify the link attribute type. Hence it ignores the link weights. This provides a test of the optimized access path when just the link type constraint is specified."}
{"code": "public Id<DgCrossingNode> convertNodeId2NotExpandedCrossingNodeId(Id<Node> nodeId){\n  String idString=nodeId.toString();\n  return idPool.createId(idString,DgCrossingNode.class);\n}\n", "nl": "converts a matsim node ID of a node outside the signals bounding box  to the single crossing node ID existing for the not expanded crossing in the ks-model. (the signals bounding box determines the region of spatial expansion: all nodes within this area will be expanded.)"}
{"code": "public Object runSafely(Catbert.FastStack stack) throws Exception {\n  String k=getString(stack);\n  String r=getString(stack);\n  if (!Sage.WINDOWS_OS)   return Pooler.EMPTY_STRING_ARRAY;\n  return Sage.getRegistryNames(Sage.getHKEYForName(r),k);\n}\n", "nl": "Returns a list of the Windows registry names which exist under the specified root &amp; key (Windows only) Acceptable values for the Root are: \"HKCR\", \"HKEY_CLASSES_ROOT\", \"HKCC\", \"HKEY_CURRENT_CONFIG\", \"HKCU\", \"HKEY_CURRENT_USER\", \"HKU\", \"HKEY_USERS\", \"HKLM\" or \"HKEY_LOCAL_MACHINE\" (HKLM is the default if nothing matches)"}
{"code": "public APIPermissionSet(){\n}\n", "nl": "Creates a new permission set which contains no granted permissions. Any permissions must be added by manipulating or replacing the applicable permission collection."}
{"code": "@RequestMapping(value=\"/upload/single/initiation\",method=RequestMethod.POST,consumes={\"application/xml\",\"application/json\"}) @Secured(SecurityFunctions.FN_UPLOAD_POST) public UploadSingleInitiationResponse initiateUploadSingle(@RequestBody UploadSingleInitiationRequest uploadSingleInitiationRequest){\n  UploadSingleInitiationResponse uploadSingleInitiationResponse=uploadDownloadService.initiateUploadSingle(uploadSingleInitiationRequest);\n  for (  BusinessObjectData businessObjectData : Arrays.asList(uploadSingleInitiationResponse.getSourceBusinessObjectData(),uploadSingleInitiationResponse.getTargetBusinessObjectData())) {\n    BusinessObjectDataKey businessObjectDataKey=businessObjectDataHelper.getBusinessObjectDataKey(businessObjectData);\n    for (    NotificationEventTypeEntity.EventTypesBdata eventType : Arrays.asList(NotificationEventTypeEntity.EventTypesBdata.BUS_OBJCT_DATA_RGSTN,NotificationEventTypeEntity.EventTypesBdata.BUS_OBJCT_DATA_STTS_CHG)) {\n      notificationEventService.processBusinessObjectDataNotificationEventAsync(eventType,businessObjectDataKey,businessObjectData.getStatus(),null);\n    }\n    for (    StorageUnit storageUnit : businessObjectData.getStorageUnits()) {\n      notificationEventService.processStorageUnitNotificationEventAsync(NotificationEventTypeEntity.EventTypesStorageUnit.STRGE_UNIT_STTS_CHG,businessObjectDataKey,storageUnit.getStorage().getName(),storageUnit.getStorageUnitStatus(),null);\n    }\n  }\n  return uploadSingleInitiationResponse;\n}\n", "nl": "Initiates a single file upload capability by creating the relative business object data instance in UPLOADING state and allowing write access to a specific location in S3_MANAGED_LOADING_DOCK storage. <p>Requires WRITE permission on namespace</p>"}
{"code": "public ArrayIntCompressed(int size,int leadingClearBits,int trailingClearBits){\n  init(size,BIT_LENGTH - leadingClearBits - trailingClearBits,trailingClearBits);\n}\n", "nl": "Create <code>IntArrayCompressed</code> from number of ints to be stored, the number of leading and trailing clear bits. Everything else is stored in the internal data structure."}
{"code": "public String compXmlStringAt(byte[] arr,int strOff){\n  int strLen=arr[strOff + 1] << 8 & 0xff00 | arr[strOff] & 0xff;\n  char[] chars=new char[strLen];\n  for (int ii=0; ii < strLen; ii++) {\n    int p0=strOff + 2 + ii * 2;\n    if (p0 >= arr.length - 1)     break;\n    chars[ii]=(char)(((arr[p0 + 1] & 0x00FF) << 8) + (arr[p0] & 0x00FF));\n  }\n  return new String(chars);\n}\n", "nl": "Return the string stored in StringTable format at offset strOff. This offset points to the 16 bit string length, which is followed by that number of 16 bit (Unicode) chars."}
{"code": "public AbstractExportOperation(File archiveFile,IFile mainFile,IN4JSEclipseProject project){\n  this.targetFile=archiveFile;\n  this.mainFile=mainFile;\n  this.project=project;\n  this.workspace=project.getProject().getWorkspace();\n  rootLocation=project.getLocation().appendSegment(\"\");\n}\n", "nl": "Create an operation that will export the given project to the given zip file."}
{"code": "@Override public boolean supportsMixedCaseQuotedIdentifiers() throws SQLException {\n  debugCodeCall(\"supportsMixedCaseQuotedIdentifiers\");\n  String m=conn.getMode();\n  if (m.equals(\"MySQL\")) {\n    return false;\n  }\n  return true;\n}\n", "nl": "Checks if a table created with CREATE TABLE \"Test\"(ID INT) is a different table than a table created with CREATE TABLE TEST(ID INT)."}
{"code": "private static Shape leftEdge(BufferedImage image){\n  GeneralPath path=new GeneralPath();\n  Point2D p1=null;\n  Point2D p2=null;\n  Line2D line=new Line2D.Float();\n  Point2D p=new Point2D.Float();\n  int foundPointY=-1;\n  for (int i=0; i < image.getHeight(); i++) {\n    for (int j=0; j < image.getWidth(); j++) {\n      if ((image.getRGB(j,i) & 0xff000000) != 0) {\n        p=new Point2D.Float(j,i);\n        foundPointY=i;\n        break;\n      }\n    }\n    if (foundPointY >= 0) {\n      if (p2 == null) {\n        p1=new Point2D.Float(image.getWidth() - 1,foundPointY);\n        path.moveTo(p1.getX(),p1.getY());\n        p2=new Point2D.Float();\n        p2.setLocation(p);\n      }\n else {\n        p2=detectLine(p1,p2,p,line,path);\n      }\n    }\n  }\n  path.lineTo(p.getX(),p.getY());\n  if (foundPointY >= 0) {\n    path.lineTo(image.getWidth() - 1,foundPointY);\n  }\n  path.closePath();\n  return path;\n}\n", "nl": "trace the left side of the image"}
{"code": "public void testSetMaxRows() throws Exception {\n  Statement maxRowsStmt=null;\n  try {\n    maxRowsStmt=this.conn.createStatement();\n    maxRowsStmt.setMaxRows(1);\n    this.rs=maxRowsStmt.executeQuery(\"SELECT 1\");\n  }\n  finally {\n    if (maxRowsStmt != null) {\n      maxRowsStmt.close();\n    }\n  }\n}\n", "nl": "Tests fix for BUG#907"}
{"code": "public static void unregisterMbeans(){\n  unregisterMbeans(ManagementFactory.getPlatformMBeanServer());\n}\n", "nl": "unRegister all jamon related mbeans"}
{"code": "public boolean free(T value){\n  return _ringQueue.offer(value);\n}\n", "nl": "Frees the object.  If the free list is full, the object will be garbage collected."}
{"code": "public NotificationChain basicSet_lok(LocalArgumentsVariable new_lok,NotificationChain msgs){\n  LocalArgumentsVariable old_lok=_lok;\n  _lok=new_lok;\n  if (eNotificationRequired()) {\n    ENotificationImpl notification=new ENotificationImpl(this,Notification.SET,N4JSPackage.FUNCTION_DECLARATION__LOK,old_lok,new_lok);\n    if (msgs == null)     msgs=notification;\n else     msgs.add(notification);\n  }\n  return msgs;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public void query(boolean onlyCurrentRows,int onlyCurrentDays,int maxRows){\n  m_mTab.query(onlyCurrentRows,onlyCurrentDays,maxRows);\n  if (!isSingleRow())   vTable.autoSize(true);\n  activateChilds();\n}\n", "nl": "Query Tab and resize Table (called from APanel)"}
{"code": "@Override public EmpiricalDistribution queryProb(Query.ProbQuery query){\n  LikelihoodWeighting isquery=new LikelihoodWeighting(query,nbSamples,maxSamplingTime);\n  List<Sample> samples=isquery.getSamples();\n  return new EmpiricalDistribution(samples);\n}\n", "nl": "Queries for the probability distribution of the set of random variables in the Bayesian network, given the provided evidence"}
{"code": "public char loadChar(Offset offset){\n  if (VM.VerifyAssertions)   VM._assert(VM.NOT_REACHED);\n  return (char)0;\n}\n", "nl": "Loads a char from the memory location pointed to by the current instance."}
{"code": "public FloatBuffer put(float[] src,int off,int len){\n  int length=src.length;\n  if (off < 0 || len < 0 || (long)off + (long)len > length) {\n    throw new IndexOutOfBoundsException();\n  }\n  if (len > remaining()) {\n    throw new BufferOverflowException();\n  }\n  for (int i=off; i < off + len; i++) {\n    put(src[i]);\n  }\n  return this;\n}\n", "nl": "Writes floats from the given float array, starting from the specified offset, to the current position and increases the position by the number of floats written."}
{"code": "public static void deleteCollectionLevelSnapshot(SolrZkClient zkClient,String collectionName,String commitName) throws InterruptedException, KeeperException {\n  String zkPath=getSnapshotMetaDataZkPath(collectionName,Optional.of(commitName));\n  zkClient.delete(zkPath,-1,true);\n}\n", "nl": "This method deletes an entry for the named snapshot for the specified collection in Zookeeper."}
{"code": "private void sortAndPrintSQL() throws SQLException {\n  final Vector<String> statements=new Vector<String>(1000,500);\n  final Vector<String> sortedStatements=new Vector<String>(1000,500);\n  for (int i=0; i < m_newTables.size(); i++) {\n    statements.add(m_newTables.get(i).getCreateStatement());\n  }\n  for (int i=0; i < m_changedTables.size(); i++) {\n    if (m_changedTables.get(i).isAlterAdd()) {\n      statements.add(m_changedTables.get(i).getAlterAddStatement());\n    }\n else     if (m_changedTables.get(i).isAlterDrop()) {\n      statements.add(m_changedTables.get(i).getAlterDropStatement());\n    }\n else     if (m_changedTables.get(i).isAlterModify()) {\n      statements.add(m_changedTables.get(i).getAlterModifyStatement());\n    }\n  }\n  for (int i=0; i < m_constraintsToDrop.size(); i++) {\n    statements.add(m_constraintsToDrop.get(i).getDropString());\n  }\n  for (int i=0; i < m_newConstraints.size(); i++) {\n    statements.add(m_newConstraints.get(i).getAlterTableString());\n  }\n  Vector<String> tempVector=sortStatements(statements);\n  for (int i=0; i < tempVector.size(); i++) {\n    sortedStatements.add(tempVector.get(i));\n  }\n  sortedStatements.add(\"COMMIT;\");\n  sortedStatements.add(\"SET DEFINE OFF;\");\n  statements.clear();\n  for (int i=0; i < m_newTableEntry.size(); i++) {\n    statements.add(m_newTableEntry.get(i).replaceAll(\"\\n\",\" \"));\n  }\n  tempVector=sortStatements(statements);\n  for (int i=0; i < tempVector.size(); i++) {\n    sortedStatements.add(tempVector.get(i));\n  }\n  sortedStatements.add(\"COMMIT;\");\n  sortedStatements.add(\"SET DEFINE OFF;\");\n  statements.clear();\n  for (int i=0; i < m_alterADEntry.size(); i++) {\n    statements.add(m_alterADEntry.get(i).replaceAll(\"\\n\",\" \"));\n  }\n  tempVector=sortStatements(statements);\n  for (int i=0; i < tempVector.size(); i++) {\n    sortedStatements.add(tempVector.get(i));\n  }\n  sortedStatements.add(\"COMMIT;\");\n  sortedStatements.add(\"SET DEFINE OFF;\");\n  statements.clear();\n  for (int i=0; i < m_deleteADEntry.size(); i++) {\n    statements.add(m_deleteADEntry.get(i).replaceAll(\"\\n\",\" \"));\n  }\n  tempVector=sortStatements(statements);\n  for (int i=0; i < tempVector.size(); i++) {\n    sortedStatements.add(tempVector.get(i));\n  }\n  System.out.println();\n  System.out.println(\"---------------------------\");\n  System.out.println(\"--   SCRIPT STARTS HERE!\");\n  System.out.println(\"---------------------------\");\n  System.out.println(\"-- UNABLE TO APPLY THESE STATEMENTS - START\");\n  for (int i=0; i < m_unappliableStatements.size(); i++) {\n    System.out.println(m_unappliableStatements.get(i));\n  }\n  System.out.println(\"-- UNABLE TO APPLY THESE STATEMENTS - END\");\n  System.out.println();\n  System.out.println(\"-- NEW/CHANGED TABLES - NEW/CHANGED AD_ENTRIES\");\n  for (int i=0; i < sortedStatements.size(); i++) {\n    System.out.println(sortedStatements.get(i));\n  }\n  System.out.println();\n  System.out.println(\"-- NEW VIEWS\");\n  for (int i=0; i < m_newViews.size(); i++) {\n    System.out.println(m_newViews.get(i).getCreateStatement());\n  }\n  System.out.println();\n  System.out.println(\"-- CHANGED VIEWS - but check them first - don't overwrite your customizations...\");\n  for (int i=0; i < m_changedViews.size(); i++) {\n    System.out.println(m_changedViews.get(i).getCreateStatement());\n  }\n  System.out.println();\n  System.out.println(\"-- NEW OR CHANGED FUNCTIONS/PROCEDURES\");\n  for (int i=0; i < m_newFunctionStatements.size(); i++) {\n    System.out.println(m_newFunctionStatements.get(i));\n  }\n  System.out.println();\n  System.out.println(\"-- DROP FUNCTIONS/PROCEDURES\");\n  for (int i=0; i < m_dropFunctionStatements.size(); i++) {\n    System.out.println(m_dropFunctionStatements.get(i));\n  }\n  System.out.println();\n  System.out.println(\"-- DROP TRIGGERS\");\n  for (int i=0; i < m_dropTriggerStatements.size(); i++) {\n    System.out.println(m_dropTriggerStatements.get(i));\n  }\n  System.out.println();\n  System.out.println(\"-- DROP INDEXES\");\n  for (int i=0; i < m_dropIndexStatements.size(); i++) {\n    System.out.println(m_dropIndexStatements.get(i));\n  }\n  System.out.println();\n  System.out.println(\"-- NEW OR CHANGED INDEXES\");\n  for (int i=0; i < m_newIndexStatements.size(); i++) {\n    System.out.println(m_newIndexStatements.get(i));\n  }\n  System.out.println();\n  System.out.println(\"-- PLEASE CHECK THE SEQUENCES BY HAND - USE:\");\n  System.out.println(\"-- select * from user_sequences;\");\n  System.out.println();\n  System.out.println(getUpdateVersionStatement());\n  System.out.println(\"COMMIT;\");\n}\n", "nl": "Sorts the generated sql statements by applying them to db1 and prints the sorted statement list."}
{"code": "final private void turn22(IntGrid2D grid,int x,int y){\n  int p1, p2, p3, p4;\n  p1=grid.get(grid.stx(x),grid.sty(y));\n  p2=grid.get(grid.stx(x + 1),grid.sty(y));\n  p3=grid.get(grid.stx(x + 1),grid.sty(y + 1));\n  p4=grid.get(grid.stx(x),grid.sty(y + 1));\n  if (p.r.nextBoolean()) {\n    grid.set(grid.stx(x),grid.sty(y),p4);\n    grid.set(grid.stx(x + 1),grid.sty(y),p1);\n    grid.set(grid.stx(x + 1),grid.sty(y + 1),p2);\n    grid.set(grid.stx(x),grid.sty(y + 1),p3);\n  }\n else {\n    grid.set(grid.stx(x),grid.sty(y),p2);\n    grid.set(grid.stx(x + 1),grid.sty(y),p3);\n    grid.set(grid.stx(x + 1),grid.sty(y + 1),p4);\n    grid.set(grid.stx(x),grid.sty(y + 1),p1);\n  }\n}\n", "nl": "Diffuse a 2x2 block clockwise or counter-clockwise. This procedure was published by Toffoli and Margolus to simulate the diffusion in an ideal gas. The 2x2 blocks will be turned by random in one direction (clockwise or counter clockwise). Usually a second run will be done but this time with a offset of one to the previous run"}
{"code": "public static double magnitude(double[] u){\n  return Math.sqrt(dot(u,u));\n}\n", "nl": "Returns the magnitude (Euclidean norm) of the specified vector."}
{"code": "public String toString(){\n  return statusString;\n}\n", "nl": "Returns the String representation for thiz."}
{"code": "public void chopFrame(int offsetDelta,int k){\n  numOfEntries++;\n  output.write(251 - k);\n  write16(offsetDelta);\n}\n", "nl": "Writes a <code>chop_frame</code>."}
{"code": "public AsyncHttpClient(boolean fixNoHttpResponseException,int httpPort,int httpsPort){\n  this(getDefaultSchemeRegistry(fixNoHttpResponseException,httpPort,httpsPort));\n}\n", "nl": "Creates new AsyncHttpClient using given params"}
{"code": "public boolean verify(byte[] signature){\n  return verify(signature,false);\n}\n", "nl": "Verifies the data (computes the secure hash and compares it to the input)"}
{"code": "public synchronized void reqHistoricalData(int tickerId,Contract contract,String endDateTime,String durationStr,String barSizeSetting,String whatToShow,int useRTH,int formatDate,List<TagValue> chartOptions){\n  if (!m_connected) {\n    notConnected();\n    return;\n  }\n  final int VERSION=6;\n  try {\n    if (m_serverVersion < 16) {\n      error(EClientErrors.NO_VALID_ID,EClientErrors.UPDATE_TWS,\"  It does not support historical data backfill.\");\n      return;\n    }\n    if (m_serverVersion < MIN_SERVER_VER_TRADING_CLASS) {\n      if (!IsEmpty(contract.m_tradingClass) || (contract.m_conId > 0)) {\n        error(tickerId,EClientErrors.UPDATE_TWS,\"  It does not support conId and tradingClass parameters in reqHistroricalData.\");\n        return;\n      }\n    }\n    send(REQ_HISTORICAL_DATA);\n    send(VERSION);\n    send(tickerId);\n    if (m_serverVersion >= MIN_SERVER_VER_TRADING_CLASS) {\n      send(contract.m_conId);\n    }\n    send(contract.m_symbol);\n    send(contract.m_secType);\n    send(contract.m_expiry);\n    send(contract.m_strike);\n    send(contract.m_right);\n    send(contract.m_multiplier);\n    send(contract.m_exchange);\n    send(contract.m_primaryExch);\n    send(contract.m_currency);\n    send(contract.m_localSymbol);\n    if (m_serverVersion >= MIN_SERVER_VER_TRADING_CLASS) {\n      send(contract.m_tradingClass);\n    }\n    if (m_serverVersion >= 31) {\n      send(contract.m_includeExpired ? 1 : 0);\n    }\n    if (m_serverVersion >= 20) {\n      send(endDateTime);\n      send(barSizeSetting);\n    }\n    send(durationStr);\n    send(useRTH);\n    send(whatToShow);\n    if (m_serverVersion > 16) {\n      send(formatDate);\n    }\n    if (BAG_SEC_TYPE.equalsIgnoreCase(contract.m_secType)) {\n      if (contract.m_comboLegs == null) {\n        send(0);\n      }\n else {\n        send(contract.m_comboLegs.size());\n        ComboLeg comboLeg;\n        for (int i=0; i < contract.m_comboLegs.size(); i++) {\n          comboLeg=contract.m_comboLegs.get(i);\n          send(comboLeg.m_conId);\n          send(comboLeg.m_ratio);\n          send(comboLeg.m_action);\n          send(comboLeg.m_exchange);\n        }\n      }\n    }\n    if (m_serverVersion >= MIN_SERVER_VER_LINKING) {\n      StringBuilder chartOptionsStr=new StringBuilder();\n      int chartOptionsCount=chartOptions == null ? 0 : chartOptions.size();\n      if (chartOptionsCount > 0) {\n        for (int i=0; i < chartOptionsCount; ++i) {\n          TagValue tagValue=(TagValue)chartOptions.get(i);\n          chartOptionsStr.append(tagValue.m_tag);\n          chartOptionsStr.append(\"=\");\n          chartOptionsStr.append(tagValue.m_value);\n          chartOptionsStr.append(\";\");\n        }\n      }\n      send(chartOptionsStr.toString());\n    }\n  }\n catch (  Exception e) {\n    error(tickerId,EClientErrors.FAIL_SEND_REQHISTDATA,\"\" + e);\n    close();\n  }\n}\n", "nl": "Note that formatData parameter affects intra-day bars only; 1-day bars always return with date in YYYYMMDD format."}
{"code": "@Override public String toString(){\n  return name().toLowerCase();\n}\n", "nl": "Returns the string representation of this instance, suitable for use in output. This is a lowercase version of the name."}
{"code": "public StringBand(int initialCapacity){\n  if (initialCapacity <= 0) {\n    throw new IllegalArgumentException(\"Invalid initial capacity\");\n  }\n  array=new String[initialCapacity];\n}\n", "nl": "Creates an empty <code>StringBand</code> with provided capacity. Capacity refers to internal string array (i.e. number of joins) and not the total string size."}
{"code": "public boolean removeConstraint(ParticleConstraint2D c){\n  return constraints.remove(c);\n}\n", "nl": "Attempts to remove the given constraint instance from the list of active constraints."}
{"code": "private DoneCallback(GridClientFutureCallback<R,T> cb,GridClientFutureListener<R> lsnr,GridClientFutureAdapter<T> chainedFut){\n  this.cb=cb;\n  this.lsnr=lsnr;\n  this.chainedFut=chainedFut;\n}\n", "nl": "Constructs future finished notification callback."}
{"code": "private void addSignatureProfile(SignatureWrapper signature,XmlSignature xmlSignature){\n  SignatureType signatureType=SignatureType.NA;\n  String certificateId=signature.getSigningCertificateId();\n  if (certificateId != null) {\n    signatureType=getSignatureType(certificateId);\n  }\n  xmlSignature.setSignatureLevel(signatureType.name());\n}\n", "nl": "Here we determine the type of the signature."}
{"code": "public boolean isArray(){\n  return false;\n}\n", "nl": "Determines if this Class object represents an array class."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2014-09-03 15:00:03.708 -0400\",hash_original_method=\"AD50C4AE43C84CAFDA529E78BF7FE7D8\",hash_generated_method=\"C8CCC8804046A2687F8D3D90AEE56A06\") public Collection<? extends Certificate> engineGenerateCertificates(InputStream inStream) throws CertificateException {\n  if (inStream == null) {\n    throw new CertificateException(\"inStream == null\");\n  }\n  ArrayList<Certificate> result=new ArrayList<Certificate>();\n  try {\n    if (!inStream.markSupported()) {\n      inStream=new RestoringInputStream(inStream);\n    }\n    byte[] encoding=null;\n    int second_asn1_tag=-1;\n    inStream.mark(1);\n    int ch;\n    while ((ch=inStream.read()) != -1) {\n      if (ch == '-') {\n        encoding=decodePEM(inStream,FREE_BOUND_SUFFIX);\n      }\n else       if (ch == 0x30) {\n        encoding=null;\n        inStream.reset();\n        inStream.mark(CERT_CACHE_SEED_LENGTH);\n      }\n else {\n        if (result.size() == 0) {\n          throw new CertificateException(\"Unsupported encoding\");\n        }\n else {\n          inStream.reset();\n          return result;\n        }\n      }\n      BerInputStream in=(encoding == null) ? new BerInputStream(inStream) : new BerInputStream(encoding);\n      second_asn1_tag=in.next();\n      if (encoding == null) {\n        inStream.reset();\n      }\n      if (second_asn1_tag != ASN1Constants.TAG_C_SEQUENCE) {\n        if (result.size() == 0) {\n          break;\n        }\n else {\n          return result;\n        }\n      }\n else {\n        if (encoding == null) {\n          result.add(getCertificate(inStream));\n        }\n else {\n          result.add(getCertificate(encoding));\n        }\n      }\n      inStream.mark(1);\n    }\n    if (result.size() != 0) {\n      return result;\n    }\n else     if (ch == -1) {\n      return result;\n    }\n    if (second_asn1_tag == ASN1Constants.TAG_OID) {\n      ContentInfo info=(ContentInfo)((encoding != null) ? ContentInfo.ASN1.decode(encoding) : ContentInfo.ASN1.decode(inStream));\n      SignedData data=info.getSignedData();\n      if (data == null) {\n        throw new CertificateException(\"Invalid PKCS7 data provided\");\n      }\n      List<org.apache.harmony.security.x509.Certificate> certs=data.getCertificates();\n      if (certs != null) {\n        for (        org.apache.harmony.security.x509.Certificate cert : certs) {\n          result.add(new X509CertImpl(cert));\n        }\n      }\n      return result;\n    }\n    throw new CertificateException(\"Unsupported encoding\");\n  }\n catch (  IOException e) {\n    throw new CertificateException(e);\n  }\n}\n", "nl": "Generates the collection of the certificates on the base of provided via input stream encodings."}
{"code": "public NewSessionAction(){\n  super(\"New Session\");\n}\n", "nl": "Creates a new session action for the given desktop."}
{"code": "private StringBuilder appendIfNotNull(StringBuilder source,String addStr,String delimiter){\n  if (addStr != null) {\n    if (addStr.length() == 0) {\n      delimiter=\"\";\n    }\n    return source.append(addStr).append(delimiter);\n  }\n  return source;\n}\n", "nl": "Takes a string and adds to it, with a separator, if the bit to be added isn't null. Since the logger takes so many arguments that might be null, this method helps cut out some of the agonizing tedium of writing the same 3 lines over and over."}
{"code": "public void write(OutStream out) throws IOException {\n  out.flushBits();\n  out.writeUBits(5,getBitSize());\n  out.writeSBits(bitSize,minX);\n  out.writeSBits(bitSize,maxX);\n  out.writeSBits(bitSize,minY);\n  out.writeSBits(bitSize,maxY);\n  out.flushBits();\n}\n", "nl": "Write the rect contents to the output stream"}
{"code": "@SuppressWarnings(\"unused\") private void checkCenter(LatLon center){\n  System.out.println(\"Testing fromLatLngToPoint using: \" + center);\n  Point2D p=googleMap.fromLatLngToPoint(center.toLatLong());\n  System.out.println(\"Testing fromLatLngToPoint result: \" + p);\n  System.out.println(\"Testing fromLatLngToPoint expected: \" + mapComponent.getWidth() / 2 + \", \" + mapComponent.getHeight() / 2);\n  System.out.println(\"type = \" + MarkerType.BROWN.iconPath());\n}\n", "nl": "Demonstrates how to go from lat/lon to pixel coordinates."}
{"code": "public BusinessObjectDataAttributeEntity createBusinessObjectDataAttributeEntity(String namespaceCode,String businessObjectDefinitionName,String businessObjectFormatUsage,String businessObjectFormatFileType,Integer businessObjectFormatVersion,String businessObjectDataPartitionValue,List<String> businessObjectDataSubPartitionValues,Integer businessObjectDataVersion,String businessObjectDataAttributeName,String businessObjectDataAttributeValue){\n  BusinessObjectDataKey businessObjectDataKey=new BusinessObjectDataKey(namespaceCode,businessObjectDefinitionName,businessObjectFormatUsage,businessObjectFormatFileType,businessObjectFormatVersion,businessObjectDataPartitionValue,businessObjectDataSubPartitionValues,businessObjectDataVersion);\n  return createBusinessObjectDataAttributeEntity(businessObjectDataKey,businessObjectDataAttributeName,businessObjectDataAttributeValue);\n}\n", "nl": "Creates and persists a new business object data attribute entity."}
{"code": "private synchronized boolean containsMapping(Object key,Object value){\n  int hash=Collections.secondaryHash(key);\n  HashtableEntry<K,V>[] tab=table;\n  int index=hash & (tab.length - 1);\n  for (HashtableEntry<K,V> e=tab[index]; e != null; e=e.next) {\n    if (e.hash == hash && e.key.equals(key)) {\n      return e.value.equals(value);\n    }\n  }\n  return false;\n}\n", "nl": "Returns true if this map contains the specified mapping."}
{"code": "public Setting(Object value,int type,boolean save,String file){\n  this.value=value;\n  if (type == MAP) {\n    this.defaultValue=new HashMap<>((Map)value);\n  }\n else   if (type == LIST) {\n    this.defaultValue=copyCollection((Collection)value);\n  }\n else {\n    this.defaultValue=value;\n  }\n  this.save=save;\n  this.type=type;\n  this.file=file;\n}\n", "nl": "Creates a new Setting object with some initial values."}
{"code": "protected void layoutGraphicModifiers(DrawContext dc,AVList modifiers,OrderedSymbol osym){\n}\n", "nl": "Layout static graphic modifiers around the symbol. Static modifiers are not expected to change due to changes in view. The static layout is computed when a modifier is changed, but may not be computed each frame. For example, a text modifier indicating a symbol identifier would only need to be laid out when the text is changed, so this is best treated as a static modifier. However a direction of movement line that needs to be computed based on the current eye position should be treated as a dynamic modifier."}
{"code": "@HLEFunction(nid=0xE1D621D7,version=150,checkInsideInterrupt=true) public int sceNetAdhocInit(){\n  log.info(String.format(\"sceNetAdhocInit: using MAC address=%s, nick name='%s'\",sceNet.convertMacAddressToString(Wlan.getMacAddress()),sceUtility.getSystemParamNickname()));\n  if (isInitialized) {\n    return SceKernelErrors.ERROR_NET_ADHOC_ALREADY_INITIALIZED;\n  }\n  isInitialized=true;\n  return 0;\n}\n", "nl": "Initialize the adhoc library."}
{"code": "public Assignment(List<String> booleanAssigns){\n  this();\n  booleanAssigns.stream().forEach(null);\n}\n", "nl": "Creates an assignment with a list of boolean assignments (cf. method above)."}
{"code": "public void testMergeSameFilterInTwoDocuments() throws Exception {\n  String srcXml=\"<web-app>\" + \"  <filter>\" + \"    <filter-name>f1</filter-name>\"+ \"    <filter-class>fclass1</filter-class>\"+ \"  </filter>\"+ \"  <filter-mapping>\"+ \"    <filter-name>f1</filter-name>\"+ \"    <url-pattern>/f1mapping1</url-pattern>\"+ \"  </filter-mapping>\"+ \"</web-app>\";\n  WebXml srcWebXml=WebXmlIo.parseWebXml(new ByteArrayInputStream(srcXml.getBytes(\"UTF-8\")),null);\n  String mergeXml=\"<web-app>\" + \"  <filter>\" + \"    <filter-name>f1</filter-name>\"+ \"    <filter-class>fclass1</filter-class>\"+ \"  </filter>\"+ \"  <filter-mapping>\"+ \"    <filter-name>f1</filter-name>\"+ \"    <url-pattern>/f1mapping1</url-pattern>\"+ \"  </filter-mapping>\"+ \"</web-app>\";\n  WebXml mergeWebXml=WebXmlIo.parseWebXml(new ByteArrayInputStream(mergeXml.getBytes(\"UTF-8\")),null);\n  WebXmlMerger merger=new WebXmlMerger(srcWebXml);\n  merger.mergeFilters(mergeWebXml);\n  assertTrue(WebXmlUtils.hasFilter(srcWebXml,\"f1\"));\n  List<String> filterMappings=WebXmlUtils.getFilterMappings(srcWebXml,\"f1\");\n  assertEquals(1,filterMappings.size());\n  assertEquals(\"/f1mapping1\",filterMappings.get(0));\n}\n", "nl": "Tests whether the same filter in two different files is mapped correctly (i.e., once)."}
{"code": "public static int countPeriods(String haystack){\n  return StringUtils.countOccurrencesOf(haystack,\".\");\n}\n", "nl": "Count the number of periods in a value."}
{"code": "public TwoColumnOutput(Writer out,int leftWidth,int rightWidth,String spacer){\n  if (out == null) {\n    throw new NullPointerException(\"out == null\");\n  }\n  if (leftWidth < 1) {\n    throw new IllegalArgumentException(\"leftWidth < 1\");\n  }\n  if (rightWidth < 1) {\n    throw new IllegalArgumentException(\"rightWidth < 1\");\n  }\n  if (spacer == null) {\n    throw new NullPointerException(\"spacer == null\");\n  }\n  StringWriter leftWriter=new StringWriter(1000);\n  StringWriter rightWriter=new StringWriter(1000);\n  this.out=out;\n  this.leftWidth=leftWidth;\n  this.leftBuf=leftWriter.getBuffer();\n  this.rightBuf=rightWriter.getBuffer();\n  this.leftColumn=new IndentingWriter(leftWriter,leftWidth);\n  this.rightColumn=new IndentingWriter(rightWriter,rightWidth,spacer);\n}\n", "nl": "Constructs an instance."}
{"code": "public static void main(final String[] args){\n  DOMTestCase.doMain(nodegetfirstchildnull.class,args);\n}\n", "nl": "Runs this test from the command line."}
{"code": "public void actionPerformed(ActionEvent e){\n  JTextComponent target=getTextComponent(e);\n  if ((target != null) && (e != null)) {\n    if ((!target.isEditable()) || (!target.isEnabled())) {\n      UIManager.getLookAndFeel().provideErrorFeedback(target);\n      return;\n    }\n    String content=target.getText();\n    if (content != null && target.getSelectionStart() > 0) {\n      content=content.substring(0,target.getSelectionStart());\n    }\n    if (content != null) {\n      target.setText(getNextMatch(content));\n      adaptor.markText(content.length());\n    }\n  }\n}\n", "nl": "Shows the next match."}
{"code": "public void clear(){\n  super.clear();\n  LEFT_PARENTHESES=\"\";\n  RIGHT_PARENTHESES=\"\";\n}\n", "nl": "removes the stored data but retains the dimensions of the matrix."}
{"code": "public void deleteChannel(CumulusChannel jsonChannel){\n  String jsonString=jsonChannel.toString();\n  Intent i=new Intent(\"com.felkertech.cumulustv.RECEIVER\");\n  i.putExtra(INTENT_EXTRA_JSON,jsonString);\n  i.putExtra(INTENT_EXTRA_ACTION,INTENT_EXTRA_ACTION_DELETE);\n  sendBroadcast(i);\n  finish();\n}\n", "nl": "Deletes the provided channel and resyncs. Then the app closes."}
{"code": "public static String toStringExclude(Object object,Collection excludeFieldNames){\n  return toStringExclude(object,toNoNullStringArray(excludeFieldNames));\n}\n", "nl": "Builds a String for a toString method excluding the given field names."}
{"code": "public StringDict(BufferedReader reader){\n  String[] lines=PApplet.loadStrings(reader);\n  keys=new String[lines.length];\n  values=new String[lines.length];\n  for (int i=0; i < lines.length; i++) {\n    String[] pieces=PApplet.split(lines[i],'\\t');\n    if (pieces.length == 2) {\n      keys[count]=pieces[0];\n      values[count]=pieces[1];\n      count++;\n    }\n  }\n}\n", "nl": "Read a set of entries from a Reader that has each key/value pair on a single line, separated by a tab."}
{"code": "static <K,V>void writeMap(Map<K,V> map,ObjectOutputStream stream) throws IOException {\n  stream.writeInt(map.size());\n  for (  Map.Entry<K,V> entry : map.entrySet()) {\n    stream.writeObject(entry.getKey());\n    stream.writeObject(entry.getValue());\n  }\n}\n", "nl": "Stores the contents of a map in an output stream, as part of serialization. It does not support concurrent maps whose content may change while the method is running. <p>The serialized output consists of the number of entries, first key, first value, second key, second value, and so on."}
{"code": "public NioDatagramAcceptor(){\n  this(new DefaultDatagramSessionConfig(),null);\n}\n", "nl": "Creates a new instance."}
{"code": "public final <V>V callWithRetry(Callable<V> callable,Predicate<Throwable> isRetryable){\n  int failures=0;\n  while (true) {\n    try {\n      return callable.call();\n    }\n catch (    Throwable e) {\n      if (++failures == attempts || !isRetryable.apply(e)) {\n        throwIfUnchecked(e);\n        throw new RuntimeException(e);\n      }\n      logger.info(e,\"Retrying transient error, attempt \" + failures);\n      try {\n        sleeper.sleep(Duration.millis(pow(2,failures) * 100));\n      }\n catch (      InterruptedException e2) {\n        Thread.currentThread().interrupt();\n        throwIfUnchecked(e);\n        throw new RuntimeException(e);\n      }\n    }\n  }\n}\n", "nl": "Retries a unit of work in the face of transient errors. <p>Retrying is done a fixed number of times, with exponential backoff, if the exception that is thrown is deemed retryable by the predicate. If the error is not considered retryable, or if the thread is interrupted, or if the allowable number of attempts has been exhausted, the original exception is propagated through to the caller."}
{"code": "public int size(){\n  return n;\n}\n", "nl": "Returns the number of items in this queue."}
{"code": "public String toXML(Network network){\n  StringWriter writer=new StringWriter();\n  writeXML(network,writer);\n  writer.flush();\n  return writer.toString();\n}\n", "nl": "Covert the network into xml."}
{"code": "private String parseEntityAttribute(String fieldName){\n  Matcher m=_fnPattern.matcher(fieldName);\n  if (m.find()) {\n    return m.group(1);\n  }\n  return null;\n}\n", "nl": "check whether this field is one entity attribute or not"}
{"code": "void addScrapView(View scrap,int position,int viewType){\n  if (viewTypeCount == 1) {\n    currentScrapViews.put(position,scrap);\n  }\n else {\n    scrapViews[viewType].put(position,scrap);\n  }\n  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH) {\n    scrap.setAccessibilityDelegate(null);\n  }\n}\n", "nl": "Put a view into the ScrapViews list. These views are unordered."}
{"code": "public AStart(){\n}\n", "nl": "Construct the applet"}
{"code": "public static void dispose(){\n  disposeColors();\n  disposeImages();\n  disposeFonts();\n  disposeCursors();\n}\n", "nl": "Dispose of cached objects and their underlying OS resources. This should only be called when the cached objects are no longer needed (e.g. on application shutdown)."}
{"code": "protected int bends(Geo g1,Geo g2,Geo g3){\n  double bend=g1.crossNormalize(g2).distance(g3) - (Math.PI / 2.0);\n  if (Math.abs(bend) < .0001) {\n    return STRAIGHT;\n  }\n else {\n    if (bend < 0) {\n      return BENDS_LEFT;\n    }\n  }\n  return BENDS_RIGHT;\n}\n", "nl": "Method that determines which way the angle between the three points bends."}
{"code": "@Override public boolean eIsSet(int featureID){\nswitch (featureID) {\ncase TypesPackage.PRIMITIVE_TYPE__DECLARED_ELEMENT_TYPE:\n    return declaredElementType != null;\ncase TypesPackage.PRIMITIVE_TYPE__ASSIGNMENT_COMPATIBLE:\n  return assignmentCompatible != null;\ncase TypesPackage.PRIMITIVE_TYPE__AUTOBOXED_TYPE:\nreturn autoboxedType != null;\n}\nreturn super.eIsSet(featureID);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "@Description(summary=\"Create h2client.jar with only the remote JDBC implementation.\") public void jarClient(){\n  compile(true,true,false);\n  FileList files=files(\"temp\").exclude(\"temp/org/h2/build/*\").exclude(\"temp/org/h2/dev/*\").exclude(\"temp/org/h2/jaqu/*\").exclude(\"temp/org/h2/java/*\").exclude(\"temp/org/h2/jcr/*\").exclude(\"temp/org/h2/mode/*\").exclude(\"temp/org/h2/samples/*\").exclude(\"temp/org/h2/test/*\").exclude(\"*.bat\").exclude(\"*.sh\").exclude(\"*.txt\").exclude(\"*.DS_Store\");\n  files=excludeTestMetaInfFiles(files);\n  long kb=jar(\"bin/h2-client\" + getJarSuffix(),files,\"temp\");\n  if (kb < 350 || kb > 450) {\n    throw new RuntimeException(\"Expected file size 350 - 450 KB, got: \" + kb);\n  }\n}\n", "nl": "Create the h2client.jar. This only contains the remote JDBC implementation."}
{"code": "public Messages(String name){\n  this((Messages)null,name);\n}\n", "nl": "Creates a messages bundle by full name."}
{"code": "public void providesSingletonInScope(){\n  Binding.this.singletonInScope();\n  isProvidingSingletonInScope=true;\n}\n", "nl": "to provide a singleton using the binding's scope and reuse it inside the binding's scope"}
{"code": "public void dispose(){\n  m_table.getColumn(m_field).removeColumnListener(this);\n}\n", "nl": "Dispose of this metadata, freeing any resources and unregistering any listeners."}
{"code": "public void updateUI(){\n  super.updateUI();\n  if (myTree != null) {\n    myTree.updateUI();\n  }\n  LookAndFeel.installColorsAndFont(this,\"Tree.background\",\"Tree.foreground\",\"Tree.font\");\n}\n", "nl": "Overridden to message super and forward the method to the tree. Since the tree is not actually in the component hierarchy it will never receive this unless we forward it in this manner."}
{"code": "public ResourceNotificationException(String message){\n  super(message);\n}\n", "nl": "Creates a new <code>ResourceNotificationException</code> object"}
{"code": "public static double variance(double[] vector){\n  double sum=0, sumSquared=0;\n  if (vector.length <= 1) {\n    return 0;\n  }\n  for (int i=0; i < vector.length; i++) {\n    sum+=vector[i];\n    sumSquared+=(vector[i] * vector[i]);\n  }\n  double result=(sumSquared - (sum * sum / (double)vector.length)) / (double)(vector.length - 1);\n  if (result < 0) {\n    return 0;\n  }\n else {\n    return result;\n  }\n}\n", "nl": "Computes the variance for an array of doubles."}
{"code": "@Override public Class<? extends Task> taskClass(){\n  return IgniteSinkTask.class;\n}\n", "nl": "Obtains a sink task class to be instantiated for feeding data into grid."}
{"code": "public String createNode(final String path,final boolean watch,final boolean ephimeral){\n  String createdNodePath=null;\n  try {\n    final Stat nodeStat=zooKeeper.exists(path,watch);\n    if (nodeStat == null) {\n      createdNodePath=zooKeeper.create(path,new byte[0],Ids.OPEN_ACL_UNSAFE,(ephimeral ? CreateMode.EPHEMERAL_SEQUENTIAL : CreateMode.PERSISTENT));\n    }\n else {\n      createdNodePath=path;\n    }\n  }\n catch (  KeeperException|InterruptedException e) {\n    throw new IllegalStateException(e);\n  }\n  return createdNodePath;\n}\n", "nl": "Create a zookeeper node"}
{"code": "static ClassLoader findClassLoader() throws ConfigurationError {\n  SecuritySupport ss=SecuritySupport.getInstance();\n  ClassLoader context=ss.getContextClassLoader();\n  ClassLoader system=ss.getSystemClassLoader();\n  ClassLoader chain=system;\n  while (true) {\n    if (context == chain) {\n      ClassLoader current=ObjectFactory.class.getClassLoader();\n      chain=system;\n      while (true) {\n        if (current == chain) {\n          return system;\n        }\n        if (chain == null) {\n          break;\n        }\n        chain=ss.getParentClassLoader(chain);\n      }\n      return current;\n    }\n    if (chain == null) {\n      break;\n    }\n    chain=ss.getParentClassLoader(chain);\n  }\n  ;\n  return context;\n}\n", "nl": "Figure out which ClassLoader to use.  For JDK 1.2 and later use the context ClassLoader."}
{"code": "private void updateProgress(String progressLabel,int progress){\n  if (myHost != null && ((progress != previousProgress) || (!progressLabel.equals(previousProgressLabel)))) {\n    myHost.updateProgress(progressLabel,progress);\n  }\n  previousProgress=progress;\n  previousProgressLabel=progressLabel;\n}\n", "nl": "Used to communicate a progress update between a plugin tool and the main Whitebox user interface."}
{"code": "public boolean isCellEditable(EventObject anEvent){\n  if (!m_mField.isEditable(false))   return false;\n  log.fine(m_mField.getHeader());\n  if (anEvent instanceof MouseEvent && ((MouseEvent)anEvent).getClickCount() < CLICK_TO_START)   return false;\n  if (m_editor == null)   createEditor();\n  return true;\n}\n", "nl": "Ask the editor if it can start editing using anEvent. If editing can be started this method returns true. Previously called: MTable.isCellEditable"}
{"code": "public void applyAll(Collection<? extends IChange> changes) throws BadLocationException {\n  final Map<URI,List<IAtomicChange>> changesPerFile=organize(changes);\n  for (  URI currURI : changesPerFile.keySet()) {\n    final IXtextDocument document=getDocument(currURI);\n    applyAllInSameDocument(changesPerFile.get(currURI),document);\n  }\n}\n", "nl": "Applies all given changes."}
{"code": "public void beginApplyInterval(){\n  intervalStartMillis=System.currentTimeMillis();\n  endMillis=intervalStartMillis;\n  state=TaskState.apply;\n}\n", "nl": "Start an apply interval."}
{"code": "public void updateDataset(CandleDataset source,int seriesIndex,boolean newBar){\n  if (source == null) {\n    throw new IllegalArgumentException(\"Null source (CandleDataset).\");\n  }\n  for (int i=0; i < this.getSeriesCount(); i++) {\n    CandleSeries series=this.getSeries(i);\n    series.updateSeries(source.getSeries(seriesIndex),source.getSeries(seriesIndex).getItemCount() - 1,newBar);\n  }\n}\n", "nl": "Method updateDataset."}
{"code": "public int optInt(String key){\n  return this.optInt(key,0);\n}\n", "nl": "Get an optional int value associated with a key, or zero if there is no such key or if the value is not a number. If the value is a string, an attempt will be made to evaluate it as a number."}
{"code": "@DSSafe(DSCat.SAFE_LIST) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:30:28.318 -0500\",hash_original_method=\"FEDEC1668E99CC7AC8B63903F046C2E4\",hash_generated_method=\"270B33800028B49BD2EC75D7757AD67D\") @Override protected void onStartLoading(){\n  if (mCursor != null) {\n    deliverResult(mCursor);\n  }\n  if (takeContentChanged() || mCursor == null) {\n    forceLoad();\n  }\n}\n", "nl": "Starts an asynchronous load of the contacts list data. When the result is ready the callbacks will be called on the UI thread. If a previous load has been completed and is still valid the result may be passed to the callbacks immediately. Must be called from the UI thread"}
{"code": "public boolean sameAs(DiskStore other){\n  if (this.autoCompact != other.getAutoCompact()) {\n    throw new RuntimeException(LocalizedStrings.DiskStoreAttributesCreation_AUTOCOMPACT_OF_0_IS_NOT_THE_SAME_THIS_1_OTHER_2.toLocalizedString(new Object[]{name,this.autoCompact,other.getAutoCompact()}));\n  }\n  if (this.compactionThreshold != other.getCompactionThreshold()) {\n    throw new RuntimeException(LocalizedStrings.DiskStoreAttributesCreation_COMPACTIONTHRESHOLD_OF_0_IS_NOT_THE_SAME_THIS_1_OTHER_2.toLocalizedString(new Object[]{name,this.compactionThreshold,other.getCompactionThreshold()}));\n  }\n  if (this.allowForceCompaction != other.getAllowForceCompaction()) {\n    throw new RuntimeException(LocalizedStrings.DiskStoreAttributesCreation_ALLOWFORCECOMPACTION_OF_0_IS_NOT_THE_SAME_THIS_1_OTHER_2.toLocalizedString(new Object[]{name,this.allowForceCompaction,other.getAllowForceCompaction()}));\n  }\n  if (this.maxOplogSizeInBytes != other.getMaxOplogSize() * 1024 * 1024) {\n    throw new RuntimeException(LocalizedStrings.DiskStoreAttributesCreation_MAXOPLOGSIZE_OF_0_IS_NOT_THE_SAME_THIS_1_OTHER_2.toLocalizedString(new Object[]{name,this.maxOplogSizeInBytes / 1024 / 1024,other.getMaxOplogSize()}));\n  }\n  if (this.timeInterval != other.getTimeInterval()) {\n    throw new RuntimeException(LocalizedStrings.DiskStoreAttributesCreation_TIMEINTERVAL_OF_0_IS_NOT_THE_SAME_THIS_1_OTHER_2.toLocalizedString(new Object[]{name,this.timeInterval,other.getTimeInterval()}));\n  }\n  if (this.writeBufferSize != other.getWriteBufferSize()) {\n    throw new RuntimeException(LocalizedStrings.DiskStoreAttributesCreation_WRITEBUFFERSIZE_OF_0_IS_NOT_THE_SAME_THIS_1_OTHER_2.toLocalizedString(new Object[]{name,this.writeBufferSize,other.getWriteBufferSize()}));\n  }\n  if (this.queueSize != other.getQueueSize()) {\n    throw new RuntimeException(LocalizedStrings.DiskStoreAttributesCreation_QUEUESIZE_OF_0_IS_NOT_THE_SAME_THIS_1_OTHER_2.toLocalizedString(new Object[]{name,this.queueSize,other.getQueueSize()}));\n  }\n  if (!equal(this.diskDirs,other.getDiskDirs())) {\n    throw new RuntimeException(LocalizedStrings.DiskStoreAttributesCreation_DISK_DIRS_OF_0_ARE_NOT_THE_SAME.toLocalizedString(name));\n  }\n  if (!equal(this.diskDirSizes,other.getDiskDirSizes())) {\n    throw new RuntimeException(LocalizedStrings.DiskStoreAttributesCreation_DISK_DIR_SIZES_OF_0_ARE_NOT_THE_SAME.toLocalizedString(name));\n  }\n  if (!equal(getDiskUsageWarningPercentage(),other.getDiskUsageWarningPercentage())) {\n    throw new RuntimeException(LocalizedStrings.DiskStoreAttributesCreation_DISK_USAGE_WARN_ARE_NOT_THE_SAME.toLocalizedString(name));\n  }\n  if (!equal(getDiskUsageCriticalPercentage(),other.getDiskUsageCriticalPercentage())) {\n    throw new RuntimeException(LocalizedStrings.DiskStoreAttributesCreation_DISK_USAGE_CRITICAL_ARE_NOT_THE_SAME.toLocalizedString(name));\n  }\n  return true;\n}\n", "nl": "Returns whether or not this <code>DiskStoreCreation</code> is equivalent to another <code>DiskStore</code>."}
{"code": "public JsonWriter name(String name) throws IOException {\n  if (name == null) {\n    throw new NullPointerException(\"name == null\");\n  }\n  beforeName();\n  string(name);\n  return this;\n}\n", "nl": "Encodes the property name."}
{"code": "protected void changeTimeBy(long amount){\n  changeTimeBy(amount,timeWrap,(amount >= 0 ? TimerStatus.FORWARD : TimerStatus.BACKWARD));\n}\n", "nl": "Call setTime with the amount given added to the current time. The amount should be negative if you are going backward through time. You need to make sure manageGraphics is called for the map to update. <p>"}
{"code": "public void testCreateRenameNoClose() throws Exception {\n  if (dual)   return;\n  create(igfs,paths(DIR,SUBDIR),null);\n  IgfsOutputStream os=null;\n  try {\n    os=igfs.create(FILE,true);\n    igfs.rename(FILE,FILE2);\n    os.close();\n  }\n  finally {\n    U.closeQuiet(os);\n  }\n}\n", "nl": "Test rename on the file when it was opened for write(create) and is not closed yet."}
{"code": "public boolean equals(Object other){\n  if (other == null)   return false;\n  if (getClass() != other.getClass()) {\n    return false;\n  }\n  HostPort that=(HostPort)other;\n  return port == that.port && host.equals(that.host);\n}\n", "nl": "returns true if the two objects are equals, false otherwise."}
{"code": "public static void ensureParentFolderHierarchyExists(IFolder folder){\n  IContainer parent=folder.getParent();\n  if (parent instanceof IFolder) {\n    ensureFolderHierarchyExists((IFolder)parent);\n  }\n}\n", "nl": "Ensures the given folder's parent hierarchy is created if they do not already exist."}
{"code": "private Trees(){\n  throw new UnsupportedOperationException();\n}\n", "nl": "Utility classes should not be instantiated."}
{"code": "private Element drawLine(DBIDRef iter){\n  SVGPath path=new SVGPath();\n  final SpatialComparable obj=relation.get(iter);\n  final int dims=proj.getVisibleDimensions();\n  boolean drawn=false;\n  int valid=0;\n  double prevpos=Double.NaN;\n  for (int i=0; i < dims; i++) {\n    final int d=proj.getDimForAxis(i);\n    double minPos=proj.fastProjectDataToRenderSpace(obj.getMin(d),i);\n    if (minPos != minPos) {\n      valid=0;\n      continue;\n    }\n    ++valid;\n    if (valid > 1) {\n      if (valid == 2) {\n        path.moveTo(getVisibleAxisX(d - 1),prevpos);\n      }\n      path.lineTo(getVisibleAxisX(d),minPos);\n      drawn=true;\n    }\n    prevpos=minPos;\n  }\n  valid=0;\n  for (int i=dims - 1; i >= 0; i--) {\n    final int d=proj.getDimForAxis(i);\n    double maxPos=proj.fastProjectDataToRenderSpace(obj.getMax(d),i);\n    if (maxPos != maxPos) {\n      valid=0;\n      continue;\n    }\n    ++valid;\n    if (valid > 1) {\n      if (valid == 2) {\n        path.moveTo(getVisibleAxisX(d + 1),prevpos);\n      }\n      path.lineTo(getVisibleAxisX(d),maxPos);\n      drawn=true;\n    }\n    prevpos=maxPos;\n  }\n  if (!drawn) {\n    return null;\n  }\n  return path.makeElement(svgp);\n}\n", "nl": "Draw a single line."}
{"code": "public void testExceptionWithEmpty() throws Exception {\n  ObjectMapper mapper=new ObjectMapper();\n  try {\n    Object result=mapper.readValue(\"    \",Object.class);\n    fail(\"Expected an exception, but got result value: \" + result);\n  }\n catch (  Exception e) {\n    verifyException(e,EOFException.class,\"No content\");\n  }\n}\n", "nl": "Simple test to check behavior when end-of-stream is encountered without content. Should throw EOFException."}
{"code": "@Override public void dropUser(User user,boolean ignore) throws SQLException {\n  String sql=String.format(\"drop user %s\",user.getLogin());\n  try {\n    execute(sql);\n  }\n catch (  SQLException e) {\n    if (!ignore) {\n      throw e;\n    }\n else     if (logger.isDebugEnabled()) {\n      logger.debug(\"Drop user failed: \" + sql,e);\n    }\n  }\n}\n", "nl": "Drops user, ignoring errors if desired by caller."}
{"code": "public boolean loadSoundEffects(){\n  int attempts=3;\n  LoadSoundEffectReply reply=new LoadSoundEffectReply();\nsynchronized (reply) {\n    sendMsg(mAudioHandler,MSG_LOAD_SOUND_EFFECTS,SENDMSG_QUEUE,0,0,reply,0);\n    while ((reply.mStatus == 1) && (attempts-- > 0)) {\n      try {\n        reply.wait(SOUND_EFECTS_LOAD_TIMEOUT_MS);\n      }\n catch (      InterruptedException e) {\n        Log.w(TAG,\"loadSoundEffects Interrupted while waiting sound pool loaded.\");\n      }\n    }\n  }\n  return (reply.mStatus == 0);\n}\n", "nl": "Loads samples into the soundpool. This method must be called at first when sound effects are enabled"}
{"code": "public static final int gcd(int p,int q){\n  if (q == 0) {\n    return p;\n  }\n  return gcd(q,p % q);\n}\n", "nl": "Computes the Greatest Common Devisor of integers p and q."}
{"code": "public static void sort(int[] keys,int[] values,int offset,int length){\n  hybridsort(keys,values,offset,offset + length - 1);\n}\n", "nl": "Sorts a range from the keys in an increasing order. Elements key[i] and values[i] are always swapped together in the corresponding arrays. <p> A mixture of several sorting algorithms is used: <p> A radix sort performs better on the numeric data we sort, but requires additional storage to perform the sorting. Therefore only the not-very-large parts produced by a quick sort are sorted with radix sort. An insertion sort is used to sort the smallest arrays, where the the overhead of the radix sort is also bigger"}
{"code": "public boolean isRegistered(ObjectName name){\n  return mbsInterceptor.isRegistered(name);\n}\n", "nl": "Checks whether an MBean, identified by its object name, is already registered with the MBean server."}
{"code": "private void startItemListItem(StringBuilder result,String rootId,String itemId){\n  result.append(\"<div class=\\\"subtree\\\">\");\n  result.append(\"<div class=\\\"alone \" + itemId + \"\\\" id=\\\"alone_\"+ rootId+ \":\"+ itemId+ \"\\\">\");\n}\n", "nl": "Called to start adding an item to an item list."}
{"code": "void write(ImageOutputStream ios) throws IOException {\n}\n", "nl": "Writes the data for this segment to the stream in valid JPEG format."}
{"code": "public PatternEveryExpr(){\n}\n", "nl": "Ctor - for use to create a pattern expression tree, without pattern child expression."}
{"code": "private boolean tryQueueCurrentBuffer(long elapsedWaiting){\n  if (currentBuffer.isEmpty())   return true;\n  if (isOpen && neverPubQueue.size() < neverPubCapacity) {\n    neverPubQueue.add(currentBuffer);\n    totalQueuedRecords.addAndGet(currentBuffer.sizeRecords());\n    totalQueuedBuffers.incrementAndGet();\n    onQueueBufferSuccess(currentBuffer,elapsedWaiting);\n    currentBuffer=new RecordBuffer<>(flow);\n    return true;\n  }\n else   if (elapsedWaiting > 0) {\n    onQueueBufferTimeout(currentBuffer,elapsedWaiting);\n    return false;\n  }\n else   return false;\n}\n", "nl": "Keep private. Call only when holding lock."}
{"code": "private void writeKeysWithPrefix(String prefix,String exclude){\n  for (  String key : keys) {\n    if (key.startsWith(prefix) && !key.startsWith(exclude)) {\n      ps.println(key + \"=\" + prop.getProperty(key));\n    }\n  }\n  ps.println();\n}\n", "nl": "writes all keys starting with the specified prefix and not starting with the exclude prefix in alphabetical order."}
{"code": "public ProtocolInfo(String name,Collection<Form> connectionForms,Collection<Form> sharingProfileForms){\n  this.name=name;\n  this.connectionForms=connectionForms;\n  this.sharingProfileForms=sharingProfileForms;\n}\n", "nl": "Creates a new ProtocolInfo having the given name and forms. The given collections of forms are used to describe the parameters for connections and sharing profiles respectively."}
{"code": "public Prepared prepare(String sql){\n  Prepared p=parse(sql);\n  p.prepare();\n  if (currentTokenType != END) {\n    throw getSyntaxError();\n  }\n  return p;\n}\n", "nl": "Parse the statement and prepare it for execution."}
{"code": "void analyze(boolean verbose){\n  if (verbose) {\n    if (traces.length > 1)     System.out.println(\"Combining \" + traces.length + \" traces.\");\n  }\n  final Tree tree0=getTree(0);\n  double[][] changed=new double[tree0.getNodeCount()][tree0.getNodeCount()];\n  double[] rateConditionalOnChange=new double[tree0.getNodeCount()];\n  boolean changesFound=false;\n  cladeSet=new CladeSet(tree0);\n  treeSet=new FrequencySet<String>();\n  treeSet.add(Tree.Utils.uniqueNewick(tree0,tree0.getRoot()));\n  final int reportRate=60;\n  for (  TreeTrace trace : traces) {\n    final int treeCount=trace.getTreeCount(burnin * trace.getStepSize());\n    final double stepSize=treeCount / (double)reportRate;\n    int counter=1;\n    if (verbose) {\n      System.out.println(\"Analyzing \" + treeCount + \" trees...\");\n      System.out.println(\"0              25             50             75            100\");\n      System.out.println(\"|--------------|--------------|--------------|--------------|\");\n      System.out.print(\"*\");\n    }\n    for (int i=1; i < treeCount; i++) {\n      Tree tree=trace.getTree(i,burnin * trace.getStepSize());\n      for (int j=0; j < tree.getNodeCount(); j++) {\n        if (tree.getNode(j) != tree.getRoot() && tree.getNodeAttribute(tree.getNode(j),\"changed\") != null) {\n          changesFound=true;\n          final Object o=tree.getNodeAttribute(tree.getNode(j),\"changed\");\n          if (o != null) {\n            boolean ch=getChanged(tree,j);\n            if (ch) {\n              rateConditionalOnChange[j]+=(Double)tree.getNodeAttribute(tree.getNode(j),\"rate\");\n            }\n            for (int k=0; k < tree.getNodeCount(); k++) {\n              if (tree.getNode(k) != tree.getRoot()) {\n                changed[j][k]+=(ch && getChanged(tree,k)) ? 1 : 0;\n              }\n            }\n          }\n        }\n      }\n      cladeSet.add(tree);\n      treeSet.add(Tree.Utils.uniqueNewick(tree,tree.getRoot()));\n      if (verbose && i >= (int)Math.round(counter * stepSize) && counter <= reportRate) {\n        System.out.print(\"*\");\n        System.out.flush();\n        counter+=1;\n      }\n    }\n    if (verbose) {\n      System.out.println(\"*\");\n    }\n  }\n  if (changesFound) {\n    for (int j=0; j < tree0.getNodeCount(); j++) {\n      System.out.println(j + \"\\t\" + rateConditionalOnChange[j]);\n    }\n    System.out.println();\n    for (int j=0; j < tree0.getNodeCount(); j++) {\n      for (int k=0; k < tree0.getNodeCount(); k++) {\n        System.out.print(changed[j][k] + \"\\t\");\n      }\n      System.out.println();\n    }\n  }\n}\n", "nl": "Actually analyzes the trace given the burnin"}
{"code": "public void logging(String msg1,String msg2,String msg3){\n  System.out.print(msg1);\n  System.out.print(\" \");\n  System.out.print(msg2);\n  System.out.print(\" \");\n  System.out.println(msg3);\n}\n", "nl": "Prints a log message."}
{"code": "public void initQueryStringHandlers(){\n  this.transport=new SimpleTargetedChain();\n  this.transport.setOption(\"qs.list\",\"org.apache.axis.transport.http.QSListHandler\");\n  this.transport.setOption(\"qs.method\",\"org.apache.axis.transport.http.QSMethodHandler\");\n  this.transport.setOption(\"qs.wsdl\",\"org.apache.axis.transport.http.QSWSDLHandler\");\n}\n", "nl": "Initialize a Handler for the transport defined in the Axis server config. This includes optionally filling in query string handlers."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 13:00:42.071 -0500\",hash_original_method=\"236CE70381CAE691CF8D03F3D0A7E2E8\",hash_generated_method=\"34048EFAD324F63AAF648818713681BB\") public static String toUpperCase(String string){\n  boolean changed=false;\n  char[] chars=string.toCharArray();\n  for (int i=0; i != chars.length; i++) {\n    char ch=chars[i];\n    if ('a' <= ch && 'z' >= ch) {\n      changed=true;\n      chars[i]=(char)(ch - 'a' + 'A');\n    }\n  }\n  if (changed) {\n    return new String(chars);\n  }\n  return string;\n}\n", "nl": "A locale independent version of toUpperCase."}
{"code": "HTMLForm(HTMLComponent htmlC,String action,String method,String encType){\n  this.htmlC=htmlC;\n  this.action=htmlC.convertURL(action);\n  this.encType=encType;\n  if (htmlC.getHTMLCallback() != null) {\n    int linkProps=htmlC.getHTMLCallback().getLinkProperties(htmlC,this.action);\n    if ((linkProps & HTMLCallback.LINK_FORBIDDEN) != 0) {\n      this.action=null;\n    }\n  }\n  this.isPostMethod=((method != null) && (method.equalsIgnoreCase(\"post\")));\n}\n", "nl": "Constructs the HTMLForm"}
{"code": "public CurlInterceptor(Loggable logger,long limit){\n  this.logger=logger;\n  this.limit=limit;\n}\n", "nl": "Interceptor responsible for printing curl logs"}
{"code": "@Override public String toString(){\n  return String.valueOf(value);\n}\n", "nl": "Returns the String value of this mutable."}
{"code": "public void unRegisterImpulseConstraint(ImpulseConstraint con){\n  collisionResponseRows-=((ImpulseConstraint)con).GetCollisionResponseRows();\n  collisions.remove(con);\n}\n", "nl": "Un-registers an impulse constraint with the constraint engine"}
{"code": "Index(Node<K,V> node,Index<K,V> down,Index<K,V> right){\n  this.node=node;\n  this.down=down;\n  this.right=right;\n}\n", "nl": "Creates index node with given values."}
{"code": "@Override public void run(){\n  amIActive=true;\n  String rasterHeader=null;\n  String distributionType=null;\n  int numberOfClasses=-1;\n  String statsFileName=null;\n  int numCols, numRows;\n  int col, row;\n  double value;\n  List<Double> values=new ArrayList<>();\n  String str;\n  float progress=0;\n  int index;\n  int h;\n  FileWriter streamWriter=null;\n  if (args.length <= 0) {\n    showFeedback(\"Plugin parameters have not been set.\");\n    return;\n  }\n  for (int i=0; i < args.length; i++) {\n    if (i == 0) {\n      rasterHeader=args[i];\n    }\n else     if (i == 1) {\n      distributionType=args[i].toLowerCase();\n    }\n else     if (i == 2) {\n      if (!args[i].toLowerCase().equals(\"not specified\")) {\n        numberOfClasses=Integer.parseInt(args[i]);\n      }\n    }\n else     if (i == 3) {\n      statsFileName=args[i];\n    }\n  }\n  if ((rasterHeader == null) || (statsFileName == null)) {\n    showFeedback(\"One or more of the input parameters have not been set properly.\");\n    return;\n  }\n  if ((!distributionType.equals(\"complete\")) & (numberOfClasses <= 0)) {\n    showFeedback(\"Specify the number of classes (should be a value larger then 0).\");\n    return;\n  }\n  try {\n    raster=new WhiteboxRaster(rasterHeader,\"r\");\n    numRows=raster.getNumberRows();\n    numCols=raster.getNumberColumns();\n    streamWriter=new FileWriter(statsFileName);\n    str=\"Distribution type: \" + distributionType + System.lineSeparator();\n    streamWriter.write(str);\nswitch (distributionType) {\ncase \"complete\":\n      values=SortGridValues(raster);\n    updateProgress(\"Writing output:\",0);\n  str=\"Value\" + \"\\t\" + \"Cum. Rel. Freq.\"+ System.lineSeparator();\nstreamWriter.write(str);\nfor (int i=0; i < values.size(); i++) {\nstr=values.get(i) + \"\\t\" + (((float)i + 1) / values.size())+ System.lineSeparator();\nstreamWriter.write(str);\nif (cancelOp) {\n  cancelOperation();\n  return;\n}\nprogress=(float)(100f * i / (values.size() - 1));\nupdateProgress(\"Writing output:\",(int)progress);\n}\nbreak;\ncase \"n classes with equal class width\":\nList<Integer> distri=new ArrayList<>();\nList<Double> upper=new ArrayList<>();\nfor (int i=1; i <= numberOfClasses; i++) {\ndistri.add(0);\nupper.add(raster.getMinimumValue() + i * (raster.getMaximumValue() - raster.getMinimumValue()) / numberOfClasses);\n}\nupdateProgress(\"Computing distribution:\",0);\nfor (row=0; row < numRows; row++) {\nfor (col=0; col < numCols; col++) {\nvalue=raster.getValue(row,col);\nif (value != raster.getNoDataValue()) {\nh=0;\nwhile (value > upper.get(h)) {\nh=h + 1;\n}\nif (h <= numberOfClasses) {\ndistri.set(h,distri.get(h) + 1);\n}\n}\n}\nif (cancelOp) {\ncancelOperation();\nreturn;\n}\nprogress=(float)(100f * row / (numRows - 1));\nupdateProgress(\"Computing distribution:\",(int)progress);\n}\nint sum=0;\nfloat cumu;\nfor (int i=0; i < numberOfClasses; i++) {\nsum=sum + distri.get(i);\n}\nupdateProgress(\"Writing output:\",0);\nstr=\"Value\" + \"\\t\" + \"Rel. Freq.\"+ \"\\t\"+ \"Cum. Rel. Freq.\"+ System.lineSeparator();\nstreamWriter.write(str);\nif (sum > 0) {\ncumu=0;\nfor (int i=0; i < numberOfClasses; i++) {\ncumu=cumu + (float)distri.get(i) / sum;\nstr=upper.get(i) + \"\\t\" + (float)distri.get(i) / sum + \"\\t\" + cumu + System.lineSeparator();\nstreamWriter.write(str);\nif (cancelOp) {\ncancelOperation();\nreturn;\n}\nprogress=(float)(100f * i / numberOfClasses);\nupdateProgress(\"Writing output:\",(int)progress);\n}\n}\nbreak;\ncase \"n classes with equal class size\":\nvalues=SortGridValues(raster);\nupdateProgress(\"Writing output:\",0);\nstr=\"Cum. Rel. Freq.\" + \"\\t\" + \"Value\"+ System.lineSeparator();\nstreamWriter.write(str);\nfor (int i=1; i <= numberOfClasses; i++) {\nindex=(int)((float)i / numberOfClasses * values.size()) - 1;\nif (index < 0) {\nindex=0;\n}\nstr=((float)index + 1) / values.size() + \"\\t\" + values.get(index) + System.lineSeparator();\nstreamWriter.write(str);\nprogress=(float)(100f * i / numberOfClasses);\nupdateProgress(\"Writing output:\",(int)progress);\n}\nbreak;\n}\nraster.close();\nstreamWriter.close();\n}\n catch (Exception e) {\nshowFeedback(e.getMessage());\n}\n finally {\nupdateProgress(\"Progress: \",0);\namIActive=false;\nmyHost.pluginComplete();\n}\n}\n", "nl": "Used to execute this plugin tool."}
{"code": "public boolean isInBoundsX(float x){\n  if (isInBoundsLeft(x) && isInBoundsRight(x))   return true;\n else   return false;\n}\n", "nl": "BELOW METHODS FOR BOUNDS CHECK"}
{"code": "public T caseAnonymous_constraint_1_(Anonymous_constraint_1_ object){\n  return null;\n}\n", "nl": "Returns the result of interpreting the object as an instance of '<em>Anonymous constraint 1</em>'. <!-- begin-user-doc --> This implementation returns null; returning a non-null result will terminate the switch. <!-- end-user-doc -->"}
{"code": "public CProjectLoaderReporter(final ListenerProvider<IProjectListener> listeners){\n  m_listeners=listeners;\n}\n", "nl": "Creates a new reporter object."}
{"code": "public String[] queryUniqueIdentifiersForLuns(String arrayUniqueId) throws InvalidArgument, NotFound, InvalidSession, StorageFault, NotImplemented {\n  final String methodName=\"queryUniqueIdentifiersForLuns(): \";\n  log.info(methodName + \"Entry with arrayUniqueId[\" + arrayUniqueId+ \"]\");\n  sslUtil.checkHttpRequest(true,true);\n  SOSManager sosManager=contextManager.getSOSManager();\n  String[] ids=sosManager.queryUniqueIdentifiersForLuns(arrayUniqueId);\n  log.info(methodName + \"Exit returning ids of size[\" + ids.length+ \"]\");\n  return ids;\n}\n", "nl": "Returns unique identifiers for LUNs for the give array Id"}
{"code": "@Override public boolean onCreateOptionsMenu(Menu menu){\n  mOpsOptionsMenu=menu;\n  MenuInflater inflater=getMenuInflater();\n  inflater.inflate(R.menu.ops_options_menu,menu);\n  return true;\n}\n", "nl": "Inflates the Operations (\"Ops\") Option Menu."}
{"code": "protected PackageImpl(){\n  super();\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public void fillAttributeSet(Set attrSet){\n  attrSet.add(\"lang\");\n}\n", "nl": "Fills the given set with the attribute names found in this selector."}
{"code": "public void addColumn(final String columnFamily,final String columnQualifier){\n  Set<String> columns=this.columnFamilies.get(columnFamily);\n  if (columns == null) {\n    columns=new HashSet<String>();\n  }\n  columns.add(columnQualifier);\n  this.columnFamilies.put(columnFamily,columns);\n}\n", "nl": "Add column family and column qualifier to be extracted from tuple"}
{"code": "public static Field<String> ofString(String name,String description){\n  return new Field<>(name,String.class,description);\n}\n", "nl": "Break down metrics by string. <p> Each unique string will allocate a new submetric. <b>Do not use user content as a field value</b> as field values are never reclaimed."}
{"code": "public OMPoint(double lat,double lon,int radius){\n  setRenderType(RENDERTYPE_LATLON);\n  set(lat,lon);\n  this.radius=radius;\n}\n", "nl": "Create an OMPoint at a lat/lon position, with the specified radius."}
{"code": "private void saveMicroAgents(final IScope scope,final IMacroAgent agent) throws GamaRuntimeException {\n  innerPopulations=new THashMap<String,List<SavedAgent>>();\n  for (  final IPopulation<? extends IAgent> microPop : agent.getMicroPopulations()) {\n    final List<SavedAgent> savedAgents=new ArrayList<SavedAgent>();\n    final Iterator<? extends IAgent> it=microPop.iterator();\n    while (it.hasNext()) {\n      savedAgents.add(new SavedAgent(scope,it.next()));\n    }\n    innerPopulations.put(microPop.getSpecies().getName(),savedAgents);\n  }\n}\n", "nl": "Recursively save micro-agents of an agent."}
{"code": "public GenerationResult(Shell parent,int style,IPath location,final IResource target){\n  super(parent,style);\n  this.location=location;\n  this.targetResource=target;\n  setText(\"EvoSuite Result\");\n}\n", "nl": "Create the dialog."}
{"code": "public void run(){\n  ActivationLibrary.deactivate(this,getID());\n}\n", "nl": "Thread to deactivate object. First attempts to make object inactive (via the inactive method).  If that fails (the object may still have pending/executing calls), then unexport the object forcibly."}
{"code": "private static a createImageLink(String AD_Language,String name,String js_command,boolean enabled,boolean pressed){\n  a img=new a(\"#\",createImage(AD_Language,name));\n  if (!pressed || !enabled)   img.setID(\"imgButtonLink\");\n else   img.setID(\"imgButtonPressedLink\");\n  if (js_command == null)   js_command=\"'Submit'\";\n  if (js_command.length() > 0 && enabled) {\n    if (js_command.startsWith(\"startPopup\"))     img.setOnClick(js_command);\n else     img.setOnClick(\"SubmitForm('\" + name + \"', \"+ js_command+ \",'toolbar');return false;\");\n  }\n  img.setClass(\"ToolbarButton\");\n  img.setOnMouseOver(\"window.status='\" + name + \"';return true;\");\n  img.setOnMouseOut(\"window.status='';return true;\");\n  img.setOnBlur(\"this.hideFocus=false\");\n  return img;\n}\n", "nl": "Create Image with name, id of button_name and set P_Command onClick"}
{"code": "public CassandraStatus(CassandraMode mode,boolean joined,boolean rpcRunning,boolean nativeTransportRunning,boolean gossipInitialized,boolean gossipRunning,String hostId,String endpoint,int tokenCount,String dataCenter,String rack,String version){\n  this.mode=mode;\n  this.joined=joined;\n  this.rpcRunning=rpcRunning;\n  this.nativeTransportRunning=nativeTransportRunning;\n  this.gossipInitialized=gossipInitialized;\n  this.gossipRunning=gossipRunning;\n  this.hostId=hostId;\n  this.endpoint=endpoint;\n  this.tokenCount=tokenCount;\n  this.dataCenter=dataCenter;\n  this.rack=rack;\n  this.version=version;\n}\n", "nl": "Constructs a CassandraStatus."}
{"code": "public void checkDataSource(Map<String,ModelEntity> modelEntities,List<String> messages,boolean addMissing) throws GenericEntityException {\n  genericDAO.checkDb(modelEntities,messages,addMissing);\n}\n", "nl": "Check the datasource to make sure the entity definitions are correct, optionally adding missing entities or fields on the server"}
{"code": "public static HashMap<String,String> string2HashMap(String paramString){\n  HashMap<String,String> params=new HashMap<>();\n  for (  String keyValue : paramString.split(\" *& *\")) {\n    String[] pairs=keyValue.split(\" *= *\",2);\n    params.put(pairs[0],pairs.length == 1 ? \"\" : pairs[1]);\n  }\n  return params;\n}\n", "nl": "Convert key=value type String to HashMap<String,String>"}
{"code": "@LargeTest public void testMediaVideoItemRenderingModes() throws Exception {\n  final String videoItemFileName=INPUT_FILE_PATH + \"H263_profile0_176x144_15fps_256kbps_AACLC_32kHz_128kbps_s_0_26.3gp\";\n  final int videoItemRenderingMode=MediaItem.RENDERING_MODE_BLACK_BORDER;\n  boolean flagForException=false;\n  final MediaVideoItem mediaVideoItem1=mVideoEditorHelper.createMediaItem(mVideoEditor,\"mediaVideoItem1\",videoItemFileName,videoItemRenderingMode);\n  mVideoEditor.addMediaItem(mediaVideoItem1);\n  mediaVideoItem1.setRenderingMode(MediaItem.RENDERING_MODE_CROPPING);\n  assertEquals(\"MediaVideo Item rendering Mode\",MediaItem.RENDERING_MODE_CROPPING,mediaVideoItem1.getRenderingMode());\n  try {\n    mediaVideoItem1.setRenderingMode(MediaItem.RENDERING_MODE_CROPPING + 911);\n  }\n catch (  IllegalArgumentException e) {\n    flagForException=true;\n  }\n  assertTrue(\"Media Item Invalid rendering Mode\",flagForException);\n  flagForException=false;\n  try {\n    mediaVideoItem1.setRenderingMode(MediaItem.RENDERING_MODE_BLACK_BORDER - 11);\n  }\n catch (  IllegalArgumentException e) {\n    flagForException=true;\n  }\n  assertTrue(\"Media Item Invalid rendering Mode\",flagForException);\n  assertEquals(\"MediaVideo Item rendering Mode\",MediaItem.RENDERING_MODE_CROPPING,mediaVideoItem1.getRenderingMode());\n  mediaVideoItem1.setRenderingMode(MediaItem.RENDERING_MODE_STRETCH);\n  assertEquals(\"MediaVideo Item rendering Mode\",MediaItem.RENDERING_MODE_STRETCH,mediaVideoItem1.getRenderingMode());\n}\n", "nl": "To test creation of Media Video Item with Set and Get rendering Mode"}
{"code": "public void visitTree(JCTree tree){\n}\n", "nl": "Default member enter visitor method: do nothing"}
{"code": "private EventLogControlPanel createControls(){\n  EventLogControlPanel c=new EventLogControlPanel();\n  c.addHeading(\"connections\");\n  conUpCheck=c.addControl(\"up\");\n  conDownCheck=c.addControl(\"down\");\n  c.addHeading(\"messages\");\n  msgCreateCheck=c.addControl(\"created\");\n  msgTransferStartCheck=c.addControl(\"started relay\");\n  msgRelayCheck=c.addControl(\"relayed\");\n  msgDeliveredCheck=c.addControl(\"delivered\");\n  msgRemoveCheck=c.addControl(\"removed\");\n  msgDropCheck=c.addControl(\"dropped\");\n  msgAbortCheck=c.addControl(\"aborted\");\n  return c;\n}\n", "nl": "Creates a control panel for the log"}
{"code": "@Override public String type(){\n  return type;\n}\n", "nl": "Returns the type of document to get the term vector for."}
{"code": "public void test_getIterator Ljava_text_AttributedCharacterIterator AttributeII(){\n  String test=\"Test string\";\n  try {\n    Map<AttributedCharacterIterator.Attribute,String> hm=new HashMap<AttributedCharacterIterator.Attribute,String>();\n    AttributedCharacterIterator.Attribute[] aci=new AttributedCharacterIterator.Attribute[3];\n    aci[0]=new TestAttributedCharacterIteratorAttribute(\"att1\");\n    aci[1]=new TestAttributedCharacterIteratorAttribute(\"att2\");\n    aci[2]=new TestAttributedCharacterIteratorAttribute(\"att3\");\n    hm.put(aci[0],\"value1\");\n    hm.put(aci[1],\"value2\");\n    AttributedString attrString=new AttributedString(test);\n    attrString.addAttributes(hm,2,4);\n    AttributedCharacterIterator it=attrString.getIterator(aci,1,5);\n    assertTrue(\"Incorrect iteration on AttributedString\",it.getAttribute(aci[0]) == null);\n    assertTrue(\"Incorrect iteration on AttributedString\",it.getAttribute(aci[1]) == null);\n    assertTrue(\"Incorrect iteration on AttributedString\",it.getAttribute(aci[2]) == null);\n    it.next();\n    assertTrue(\"Incorrect iteration on AttributedString\",it.getAttribute(aci[0]).equals(\"value1\"));\n    assertTrue(\"Incorrect iteration on AttributedString\",it.getAttribute(aci[1]).equals(\"value2\"));\n    assertTrue(\"Incorrect iteration on AttributedString\",it.getAttribute(aci[2]) == null);\n    try {\n      attrString.getIterator(aci,-1,5);\n      fail(\"IllegalArgumentException is not thrown.\");\n    }\n catch (    IllegalArgumentException iae) {\n    }\n    try {\n      attrString.getIterator(aci,6,5);\n      fail(\"IllegalArgumentException is not thrown.\");\n    }\n catch (    IllegalArgumentException iae) {\n    }\n    try {\n      attrString.getIterator(aci,3,2);\n      fail(\"IllegalArgumentException is not thrown.\");\n    }\n catch (    IllegalArgumentException iae) {\n    }\n  }\n catch (  Exception e) {\n    fail(\"Unexpected exceptiption \" + e.toString());\n  }\n}\n", "nl": "java.text.AttributedString#getIterator(AttributedCharacterIterator.Attribute[], int, int) Test of method java.text.AttributedString#getIterator(AttributedCharacterIterator.Attribute[], int, int)."}
{"code": "private void newplan(TransformationPlan plan){\n  if (plan.replaces(this.plan)) {\n    this.plan=plan;\n  }\n}\n", "nl": "Install a new plan iff it's more drastic than the existing plan"}
{"code": "private SmallContingencyTables buildSmallContingencyTables(){\n  Set<String> allLabelSet=new TreeSet<String>();\n  for (  SingleOutcome outcome : id2Outcome.getOutcomes()) {\n    allLabelSet.addAll(outcome.getLabels());\n  }\n  List<String> labelList=new ArrayList<String>(allLabelSet);\n  int numberOfLabels=labelList.size();\n  double counterIncreaseValue=1.0;\n  SmallContingencyTables smallContingencyTables=new SmallContingencyTables(labelList);\n  for (int allLabelsClassId=0; allLabelsClassId < numberOfLabels; allLabelsClassId++) {\n    for (    SingleOutcome outcome : id2Outcome.getOutcomes()) {\n      int localClassId=outcome.getReverseLabelMapping(labelList).get(allLabelsClassId);\n      double threshold=outcome.getBipartitionThreshold();\n      double goldValue;\n      double predictionValue;\n      if (localClassId == -1) {\n        goldValue=0.;\n        predictionValue=0.;\n      }\n else {\n        goldValue=outcome.getGoldstandard()[localClassId];\n        predictionValue=outcome.getPrediction()[localClassId];\n      }\n      if (goldValue >= threshold) {\n        if (predictionValue >= threshold) {\n          smallContingencyTables.addTruePositives(allLabelsClassId,counterIncreaseValue);\n        }\n else {\n          smallContingencyTables.addFalseNegatives(allLabelsClassId,counterIncreaseValue);\n        }\n      }\n else {\n        if (predictionValue >= threshold) {\n          smallContingencyTables.addFalsePositives(allLabelsClassId,counterIncreaseValue);\n        }\n else {\n          smallContingencyTables.addTrueNegatives(allLabelsClassId,counterIncreaseValue);\n        }\n      }\n    }\n  }\n  return smallContingencyTables;\n}\n", "nl": "build small contingency tables (a small contingency table for each label) from id2Outcome"}
{"code": "protected String doIt() throws Exception {\n  MRfQ rfq=new MRfQ(getCtx(),p_C_RfQ_ID,get_TrxName());\n  if (rfq.get_ID() == 0)   throw new IllegalArgumentException(\"No RfQ found\");\n  log.info(rfq.toString());\n  MRfQResponse[] responses=rfq.getResponses(true,true);\n  log.config(\"#Responses=\" + responses.length);\n  if (responses.length == 0)   throw new IllegalArgumentException(\"No completed RfQ Responses found\");\n  for (int i=0; i < responses.length; i++) {\n    MRfQResponse response=responses[i];\n    if (!response.isSelectedWinner())     continue;\n    MBPartner bp=new MBPartner(getCtx(),response.getC_BPartner_ID(),get_TrxName());\n    log.config(\"Winner=\" + bp);\n    MOrder order=new MOrder(getCtx(),0,get_TrxName());\n    order.setIsSOTrx(false);\n    if (p_C_DocType_ID != 0)     order.setC_DocTypeTarget_ID(p_C_DocType_ID);\n else     order.setC_DocTypeTarget_ID();\n    order.setBPartner(bp);\n    order.setC_BPartner_Location_ID(response.getC_BPartner_Location_ID());\n    order.setSalesRep_ID(rfq.getSalesRep_ID());\n    if (response.getDateWorkComplete() != null)     order.setDatePromised(response.getDateWorkComplete());\n else     if (rfq.getDateWorkComplete() != null)     order.setDatePromised(rfq.getDateWorkComplete());\n    order.saveEx();\n    MRfQResponseLine[] lines=response.getLines(false);\n    for (int j=0; j < lines.length; j++) {\n      MRfQResponseLine line=lines[j];\n      if (!line.isActive())       continue;\n      MRfQResponseLineQty[] qtys=line.getQtys(false);\n      for (int k=0; k < qtys.length; k++) {\n        MRfQResponseLineQty qty=qtys[k];\n        if (qty.getRfQLineQty().isActive() && qty.getRfQLineQty().isPurchaseQty()) {\n          MOrderLine ol=new MOrderLine(order);\n          ol.setM_Product_ID(line.getRfQLine().getM_Product_ID(),qty.getRfQLineQty().getC_UOM_ID());\n          ol.setDescription(line.getDescription());\n          ol.setQty(qty.getRfQLineQty().getQty());\n          BigDecimal price=qty.getNetAmt();\n          ol.setPrice();\n          ol.setPrice(price);\n          ol.saveEx();\n        }\n      }\n    }\n    response.setC_Order_ID(order.getC_Order_ID());\n    response.saveEx();\n    return order.getDocumentNo();\n  }\n  int noOrders=0;\n  for (int i=0; i < responses.length; i++) {\n    MRfQResponse response=responses[i];\n    MBPartner bp=null;\n    MOrder order=null;\n    MRfQResponseLine[] lines=response.getLines(false);\n    for (int j=0; j < lines.length; j++) {\n      MRfQResponseLine line=lines[j];\n      if (!line.isActive() || !line.isSelectedWinner())       continue;\n      if (bp == null || bp.getC_BPartner_ID() != response.getC_BPartner_ID()) {\n        bp=new MBPartner(getCtx(),response.getC_BPartner_ID(),get_TrxName());\n        order=null;\n      }\n      log.config(\"Line=\" + line + \", Winner=\"+ bp);\n      if (order == null) {\n        order=new MOrder(getCtx(),0,get_TrxName());\n        order.setIsSOTrx(false);\n        order.setC_DocTypeTarget_ID();\n        order.setBPartner(bp);\n        order.setC_BPartner_Location_ID(response.getC_BPartner_Location_ID());\n        order.setSalesRep_ID(rfq.getSalesRep_ID());\n        order.saveEx();\n        noOrders++;\n        addLog(0,null,null,order.getDocumentNo());\n      }\n      MRfQResponseLineQty[] qtys=line.getQtys(false);\n      for (int k=0; k < qtys.length; k++) {\n        MRfQResponseLineQty qty=qtys[k];\n        if (qty.getRfQLineQty().isActive() && qty.getRfQLineQty().isPurchaseQty()) {\n          MOrderLine ol=new MOrderLine(order);\n          ol.setM_Product_ID(line.getRfQLine().getM_Product_ID(),qty.getRfQLineQty().getC_UOM_ID());\n          ol.setDescription(line.getDescription());\n          ol.setQty(qty.getRfQLineQty().getQty());\n          BigDecimal price=qty.getNetAmt();\n          ol.setPrice();\n          ol.setPrice(price);\n          ol.saveEx();\n        }\n      }\n    }\n    if (order != null) {\n      response.setC_Order_ID(order.getC_Order_ID());\n      response.saveEx();\n    }\n  }\n  return \"#\" + noOrders;\n}\n", "nl": "Process. Create purchase order(s) for the resonse(s) and lines marked as  Selected Winner using the selected Purchase Quantity (in RfQ Line Quantity) .  If a Response is marked as Selected Winner, all lines are created  (and Selected Winner of other responses ignored).   If there is no response marked as Selected Winner, the lines are used."}
{"code": "public String commandTopic(String command){\n  if (command == null) {\n    command=\"+\";\n  }\n  return cmdTopic.replace(\"{COMMAND}\",command);\n}\n", "nl": "Get the MQTT topic for a command."}
{"code": "public static boolean hasExtension(String extension){\n  if (TextUtils.isEmpty(extension)) {\n    return false;\n  }\n  return extensionToMimeTypeMap.containsKey(extension);\n}\n", "nl": "Returns true if the given extension has a registered MIME type."}
{"code": "@Before public void onBefore(){\n  tut=new TransportUnitType(\"TUT\");\n  loc1=new Location(new LocationPK(\"AREA\",\"ASL\",\"X\",\"Y\",\"Z\"));\n  loc2=new Location(new LocationPK(\"ARE2\",\"ASL2\",\"X2\",\"Y2\",\"Z2\"));\n  product=new Product(\"tttt\");\n  entityManager.persist(product);\n  entityManager.persist(tut);\n  entityManager.persist(loc1);\n  entityManager.persist(loc2);\n  tu=new TransportUnit(\"TEST\");\n  tu.setTransportUnitType(tut);\n  tu.setActualLocation(loc1);\n  entityManager.persist(tu);\n  entityManager.flush();\n}\n", "nl": "Setup some test data."}
{"code": "public void beforeRerunningIndexCreationQuery(){\n}\n", "nl": "Asif : Called just before IndexManager executes the function rerunIndexCreationQuery. After this function gets invoked, IndexManager will iterate over all the indexes of the region making the data maps null & re running the index creation query on the region. The method of Index Manager gets executed from the clear function of the Region"}
{"code": "public float buffered(){\n  return totalSize > 0 ? Futures.getUnchecked(response).cache.cacheSize() / (float)totalSize : -1;\n}\n", "nl": "Returns the percentage that is buffered, or -1, if unknown"}
{"code": "@Override public boolean accept(File dir,String name){\n  return accept(new File(dir,name));\n}\n", "nl": "Returns true if the file in the given directory with the given name should be accepted."}
{"code": "public static void main(String... a) throws Exception {\n  TestBase.createCaller().init().test();\n}\n", "nl": "Run just this test."}
{"code": "public boolean isFieldPresent(String field){\n  return fields.containsKey(field);\n}\n", "nl": "Checks if the given field is present in this extension because not every field is mandatory (according to scim 2.0 spec)."}
{"code": "public static String mapToStr(Map<? extends Object,? extends Object> map){\n  if (map == null)   return null;\n  StringBuilder buf=new StringBuilder();\n  boolean first=true;\n  for (  Map.Entry<? extends Object,? extends Object> entry : map.entrySet()) {\n    Object key=entry.getKey();\n    Object value=entry.getValue();\n    if (!(key instanceof String) || !(value instanceof String))     continue;\n    String encodedName=null;\n    try {\n      encodedName=URLEncoder.encode((String)key,\"UTF-8\");\n    }\n catch (    UnsupportedEncodingException e) {\n      Debug.logError(e,module);\n    }\n    String encodedValue=null;\n    try {\n      encodedValue=URLEncoder.encode((String)value,\"UTF-8\");\n    }\n catch (    UnsupportedEncodingException e) {\n      Debug.logError(e,module);\n    }\n    if (first)     first=false;\n else     buf.append(\"|\");\n    buf.append(encodedName);\n    buf.append(\"=\");\n    buf.append(encodedValue);\n  }\n  return buf.toString();\n}\n", "nl": "Creates an encoded String from a Map of name/value pairs (MUST BE STRINGS!)"}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 13:00:42.074 -0500\",hash_original_method=\"002C3CFFC816A38E005543BB54E228FD\",hash_generated_method=\"24D6A751F50FC61EC42FBA4D0FC608F4\") public static String toLowerCase(String string){\n  boolean changed=false;\n  char[] chars=string.toCharArray();\n  for (int i=0; i != chars.length; i++) {\n    char ch=chars[i];\n    if ('A' <= ch && 'Z' >= ch) {\n      changed=true;\n      chars[i]=(char)(ch - 'A' + 'a');\n    }\n  }\n  if (changed) {\n    return new String(chars);\n  }\n  return string;\n}\n", "nl": "A locale independent version of toLowerCase."}
{"code": "public String numberToWords(int num){\n  if (num == 0) {\n    return LESS_THAN_TWENTY[0];\n  }\n  int i=0;\n  StringBuilder res=new StringBuilder();\n  while (num > 0) {\n    if (num % 1000 != 0) {\n      res.insert(0,\" \");\n      res.insert(0,THOUSANDS[i]);\n      res.insert(0,helper(num % 1000));\n    }\n    num/=1000;\n    i++;\n  }\n  return res.toString().trim();\n}\n", "nl": "Math, String. Try to find the pattern first. The numbers less than 1000, e.g. xyz, can be x Hundred y\"ty\" z. The numbers larger than 1000, we need to add thousand or million or billion. Given a number num, we pronounce the least significant digits first. Then concat the result to the end to next three least significant digits. So the recurrence relation is: Next result of num = the pronunciation of least three digits + current result of num After that, remove those three digits from number. Stop when number is 0."}
{"code": "public boolean hasLat(){\n  return super.hasAttribute(LAT);\n}\n", "nl": "Returns whether it has the Latitude."}
{"code": "public void test_ConstructorIF(){\n  HashSet hs2=new HashSet(5,(float)0.5);\n  assertEquals(\"Created incorrect HashSet\",0,hs2.size());\n  try {\n    new HashSet(0,0);\n  }\n catch (  IllegalArgumentException e) {\n    return;\n  }\n  fail(\"Failed to throw IllegalArgumentException for initial load factor <= 0\");\n}\n", "nl": "java.util.HashSet#HashSet(int, float)"}
{"code": "private int emitCharMapArray(){\n  CharClasses cl=parser.getCharClasses();\n  if (cl.getMaxCharCode() < 256) {\n    emitCharMapArrayUnPacked();\n    return 0;\n  }\n  intervals=cl.getIntervals();\n  println(\"\");\n  println(\"  /** \");\n  println(\"   * Translates characters to character classes\");\n  println(\"   */\");\n  println(\"  private static final String ZZ_CMAP_PACKED = \");\n  int n=0;\n  print(\"    \\\"\");\n  int i=0, numPairs=0;\n  int count, value;\n  while (i < intervals.length) {\n    count=intervals[i].end - intervals[i].start + 1;\n    value=colMap[intervals[i].charClass];\n    while (count > 0xFFFF) {\n      printUC(0xFFFF);\n      printUC(value);\n      count-=0xFFFF;\n      numPairs++;\n      n++;\n    }\n    numPairs++;\n    printUC(count);\n    printUC(value);\n    if (i < intervals.length - 1) {\n      if (++n >= 10) {\n        println(\"\\\"+\");\n        print(\"    \\\"\");\n        n=0;\n      }\n    }\n    i++;\n  }\n  println(\"\\\";\");\n  println();\n  println(\"  /** \");\n  println(\"   * Translates characters to character classes\");\n  println(\"   */\");\n  println(\"  private static final char [] ZZ_CMAP = zzUnpackCMap(ZZ_CMAP_PACKED);\");\n  println();\n  return numPairs;\n}\n", "nl": "Returns the number of elements in the packed char map array, or zero if the char map array will be not be packed. This will be more than intervals.length if the count for any of the values is more than 0xFFFF, since the number of char map array entries per value is ceil(count / 0xFFFF)"}
{"code": "public int size(){\n  return mSize;\n}\n", "nl": "Returns the number of key-value mappings that this SparseDoubleArray currently stores."}
{"code": "public void depends(int parent,int child){\n  dag.addNode(child);\n  dag.addNode(parent);\n  dag.addEdge(parent,child);\n}\n", "nl": "Adds a dependency relation ship between two variables that will be in the network. The integer value corresponds  the the index of the i'th  categorical variable, where the class target's value is the number of categorical variables."}
{"code": "public DiscreteTransfer(int[] tableValues){\n  this.tableValues=tableValues;\n  this.n=tableValues.length;\n}\n", "nl": "The input is an int array which will be used later to construct the lut data"}
{"code": "public static final float roundTo(float val,float prec){\n  return floor(val / prec + 0.5f) * prec;\n}\n", "nl": "Rounds a single precision value to the given precision."}
{"code": "public static <K,V>List<KeyValue<K,V>> readKeyValues(String topic,Properties consumerConfig,int maxMessages){\n  KafkaConsumer<K,V> consumer=new KafkaConsumer<>(consumerConfig);\n  consumer.subscribe(Collections.singletonList(topic));\n  int pollIntervalMs=100;\n  int maxTotalPollTimeMs=2000;\n  int totalPollTimeMs=0;\n  List<KeyValue<K,V>> consumedValues=new ArrayList<>();\n  while (totalPollTimeMs < maxTotalPollTimeMs && continueConsuming(consumedValues.size(),maxMessages)) {\n    totalPollTimeMs+=pollIntervalMs;\n    ConsumerRecords<K,V> records=consumer.poll(pollIntervalMs);\n    for (    ConsumerRecord<K,V> record : records) {\n      consumedValues.add(new KeyValue<>(record.key(),record.value()));\n    }\n  }\n  consumer.close();\n  return consumedValues;\n}\n", "nl": "Returns up to `maxMessages` by reading via the provided consumer (the topic(s) to read from are already configured in the consumer)."}
{"code": "private int segment(Object key){\n  return Math.abs(key.hashCode() % size);\n}\n", "nl": "This method performs the translation of the key hash code to the segment index within the list. Translation is done by acquiring the modulus of the hash and the list size."}
{"code": "private void handleStateLeaving(InetAddress endpoint){\n  Collection<Token> tokens=getTokensFor(endpoint);\n  if (logger.isDebugEnabled())   logger.debug(\"Node {} state leaving, tokens {}\",endpoint,tokens);\n  if (!tokenMetadata.isMember(endpoint)) {\n    logger.info(\"Node {} state jump to leaving\",endpoint);\n    tokenMetadata.updateNormalTokens(tokens,endpoint);\n  }\n else   if (!tokenMetadata.getTokens(endpoint).containsAll(tokens)) {\n    logger.warn(\"Node {} 'leaving' token mismatch. Long network partition?\",endpoint);\n    tokenMetadata.updateNormalTokens(tokens,endpoint);\n  }\n  tokenMetadata.addLeavingEndpoint(endpoint);\n  PendingRangeCalculatorService.instance.update();\n}\n", "nl": "Handle node preparing to leave the ring"}
{"code": "public MAttributeInstance(Properties ctx,int M_Attribute_ID,int M_AttributeSetInstance_ID,BigDecimal BDValue,String trxName){\n  super(ctx,0,trxName);\n  setM_Attribute_ID(M_Attribute_ID);\n  setM_AttributeSetInstance_ID(M_AttributeSetInstance_ID);\n  setValueNumber(BDValue);\n}\n", "nl": "Number Value Constructior"}
{"code": "@Override public boolean supportsPositionedUpdate(){\n  debugCodeCall(\"supportsPositionedUpdate\");\n  return true;\n}\n", "nl": "Returns whether positioned updates are supported."}
{"code": "@SuppressWarnings(\"unchecked\") private boolean prepareMapping(String index,Map<String,Object> defaultMappings){\n  boolean success=true;\n  for (  Map.Entry<String,Object> stringObjectEntry : defaultMappings.entrySet()) {\n    Map<String,Object> mapping=(Map<String,Object>)stringObjectEntry.getValue();\n    if (mapping == null) {\n      throw new RuntimeException(\"type mapping not defined\");\n    }\n    PutMappingRequestBuilder putMappingRequestBuilder=client.admin().indices().preparePutMapping().setIndices(index);\n    putMappingRequestBuilder.setType(stringObjectEntry.getKey());\n    putMappingRequestBuilder.setSource(mapping);\n    if (log.isLoggable(Level.FINE)) {\n      log.fine(\"Elasticsearch create mapping for index '\" + index + \" and type '\"+ stringObjectEntry.getKey()+ \"': \"+ mapping);\n    }\n    PutMappingResponse resp=putMappingRequestBuilder.execute().actionGet();\n    if (resp.isAcknowledged()) {\n      if (log.isLoggable(Level.FINE)) {\n        log.fine(\"Elasticsearch mapping for index '\" + index + \" and type '\"+ stringObjectEntry.getKey()+ \"' was acknowledged\");\n      }\n    }\n else {\n      success=false;\n      log.warning(\"Elasticsearch mapping creation was not acknowledged for index '\" + index + \" and type '\"+ stringObjectEntry.getKey()+ \"'\");\n    }\n  }\n  return success;\n}\n", "nl": "This method applies the supplied mapping to the index."}
{"code": "public void disableOcr(){\n  if (!ocrDisabled) {\n    excludeParser(TesseractOCRParser.class);\n    ocrDisabled=true;\n    pdfConfig.setExtractInlineImages(false);\n  }\n}\n", "nl": "Disable OCR. This method only has an effect if Tesseract is installed."}
{"code": "@Override public NotificationChain eInverseRemove(InternalEObject otherEnd,int featureID,NotificationChain msgs){\nswitch (featureID) {\ncase DatatypePackage.DICTIONARY_PROPERTY_TYPE__KEY_TYPE:\n    return basicSetKeyType(null,msgs);\ncase DatatypePackage.DICTIONARY_PROPERTY_TYPE__VALUE_TYPE:\n  return basicSetValueType(null,msgs);\n}\nreturn super.eInverseRemove(otherEnd,featureID,msgs);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public static void main(String[] args){\n  (new Am()).run(args);\n}\n", "nl": "Command-line entry point."}
{"code": "public void removeAllHighlights(){\n  TextUI mapper=component.getUI();\n  if (getDrawsLayeredHighlights()) {\n    int len=highlights.size();\n    if (len != 0) {\n      int minX=0;\n      int minY=0;\n      int maxX=0;\n      int maxY=0;\n      int p0=-1;\n      int p1=-1;\n      for (int i=0; i < len; i++) {\n        HighlightInfo hi=highlights.elementAt(i);\n        if (hi instanceof LayeredHighlightInfo) {\n          LayeredHighlightInfo info=(LayeredHighlightInfo)hi;\n          minX=Math.min(minX,info.x);\n          minY=Math.min(minY,info.y);\n          maxX=Math.max(maxX,info.x + info.width);\n          maxY=Math.max(maxY,info.y + info.height);\n        }\n else {\n          if (p0 == -1) {\n            p0=hi.p0.getOffset();\n            p1=hi.p1.getOffset();\n          }\n else {\n            p0=Math.min(p0,hi.p0.getOffset());\n            p1=Math.max(p1,hi.p1.getOffset());\n          }\n        }\n      }\n      if (minX != maxX && minY != maxY) {\n        component.repaint(minX,minY,maxX - minX,maxY - minY);\n      }\n      if (p0 != -1) {\n        try {\n          safeDamageRange(p0,p1);\n        }\n catch (        BadLocationException e) {\n        }\n      }\n      highlights.removeAllElements();\n    }\n  }\n else   if (mapper != null) {\n    int len=highlights.size();\n    if (len != 0) {\n      int p0=Integer.MAX_VALUE;\n      int p1=0;\n      for (int i=0; i < len; i++) {\n        HighlightInfo info=highlights.elementAt(i);\n        p0=Math.min(p0,info.p0.getOffset());\n        p1=Math.max(p1,info.p1.getOffset());\n      }\n      try {\n        safeDamageRange(p0,p1);\n      }\n catch (      BadLocationException e) {\n      }\n      highlights.removeAllElements();\n    }\n  }\n}\n", "nl": "Removes all highlights."}
{"code": "public static void init(){\n  Properties p;\n  try {\n    p=System.getProperties();\n  }\n catch (  java.security.AccessControlException ace) {\n    p=new Properties();\n  }\n  init(p);\n}\n", "nl": "Initialize debugging from the system properties."}
{"code": "public Builder bySecond(Integer... seconds){\n  return bySecond(Arrays.asList(seconds));\n}\n", "nl": "Adds one or more BYSECOND rule parts."}
{"code": "public CakePHP3CustomizerPanel(){\n  initComponents();\n  init();\n}\n", "nl": "Creates new form CakePHP3CustomizerPanel"}
{"code": "private void updateProgress(String progressLabel,int progress){\n  if (myHost != null && ((progress != previousProgress) || (!progressLabel.equals(previousProgressLabel)))) {\n    myHost.updateProgress(progressLabel,progress);\n  }\n  previousProgress=progress;\n  previousProgressLabel=progressLabel;\n}\n", "nl": "Used to communicate a progress update between a plugin tool and the main Whitebox user interface."}
{"code": "public char first(){\n  pos=0;\n  return current();\n}\n", "nl": "Sets the position to getBeginIndex() and returns the character at that position."}
{"code": "@Benchmark public long test4_UsingKeySetAndForEach() throws IOException {\n  long i=0;\n  for (  Integer key : map.keySet()) {\n    i+=key + map.get(key);\n  }\n  return i;\n}\n", "nl": "4. Using keySet and foreach"}
{"code": "@Override public void eUnset(int featureID){\nswitch (featureID) {\ncase N4JSPackage.N4_FIELD_DECLARATION__DECLARED_TYPE_REF:\n    setDeclaredTypeRef((TypeRef)null);\n  return;\ncase N4JSPackage.N4_FIELD_DECLARATION__BOGUS_TYPE_REF:\nsetBogusTypeRef((TypeRef)null);\nreturn;\ncase N4JSPackage.N4_FIELD_DECLARATION__DECLARED_NAME:\nsetDeclaredName((LiteralOrComputedPropertyName)null);\nreturn;\ncase N4JSPackage.N4_FIELD_DECLARATION__DEFINED_FIELD:\nsetDefinedField((TField)null);\nreturn;\ncase N4JSPackage.N4_FIELD_DECLARATION__EXPRESSION:\nsetExpression((Expression)null);\nreturn;\n}\nsuper.eUnset(featureID);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "private StringTextStore(String text){\n  super();\n  fText=text != null ? text : \"\";\n  fCopyLimit=fText.length() > SMALL_TEXT_LIMIT ? fText.length() / 2 : 0;\n}\n", "nl": "Create a text store with initial content."}
{"code": "public static double incompleteGammaP(double a,double x){\n  return incompleteGamma(x,a,lnGamma(a));\n}\n", "nl": "Incomplete Gamma function P(a,x) = 1-Q(a,x) (a cleanroom implementation of Numerical Recipes gammp(a,x); in Mathematica this function is 1-GammaRegularized)"}
{"code": "@Scheduled(fixedDelay=60000) public void controlHerdJmsMessageListener(){\n  try {\n    Boolean jmsMessageListenerEnabled=Boolean.valueOf(configurationHelper.getProperty(ConfigurationValue.JMS_LISTENER_ENABLED));\n    JmsListenerEndpointRegistry registry=ApplicationContextHolder.getApplicationContext().getBean(\"org.springframework.jms.config.internalJmsListenerEndpointRegistry\",JmsListenerEndpointRegistry.class);\n    MessageListenerContainer jmsMessageListenerContainer=registry.getListenerContainer(HerdJmsDestinationResolver.SQS_DESTINATION_HERD_INCOMING);\n    LOGGER.debug(\"controlHerdJmsMessageListener(): {}={} jmsMessageListenerContainer.isRunning()={}\",ConfigurationValue.JMS_LISTENER_ENABLED.getKey(),jmsMessageListenerEnabled,jmsMessageListenerContainer.isRunning());\n    if (!jmsMessageListenerEnabled && jmsMessageListenerContainer.isRunning()) {\n      LOGGER.info(\"controlHerdJmsMessageListener(): Stopping the herd JMS message listener ...\");\n      jmsMessageListenerContainer.stop();\n      LOGGER.info(\"controlHerdJmsMessageListener(): Done\");\n    }\n else     if (jmsMessageListenerEnabled && !jmsMessageListenerContainer.isRunning()) {\n      LOGGER.info(\"controlHerdJmsMessageListener(): Starting the herd JMS message listener ...\");\n      jmsMessageListenerContainer.start();\n      LOGGER.info(\"controlHerdJmsMessageListener(): Done\");\n    }\n  }\n catch (  Exception e) {\n    LOGGER.error(\"controlHerdJmsMessageListener(): Failed to control the herd Jms message listener service.\",e);\n  }\n}\n", "nl": "Periodically check the configuration and apply the action to the herd JMS message listener service, if needed."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2014-08-13 13:14:13.408 -0400\",hash_original_method=\"FC36FCA077BB9356BFDFCA10D99D0311\",hash_generated_method=\"2430FCC224E47ADC0C94FB89530AAC4A\") public AnnotationTypeMismatchException(Method element,String foundType){\n  super(\"The annotation element \" + element + \" doesn't match the type \"+ foundType);\n  this.element=element;\n  this.foundType=foundType;\n}\n", "nl": "Constructs an instance for the given type element and the type found."}
{"code": "public void startDrag(DragGestureEvent trigger,Cursor dragCursor,Transferable transferable,DragSourceListener dsl) throws InvalidDnDOperationException {\n  startDrag(trigger,dragCursor,null,null,transferable,dsl,null);\n}\n", "nl": "Start a drag, given the <code>DragGestureEvent</code> that initiated the drag, the initial <code>Cursor</code> to use, the <code>Transferable</code> subject data of the drag, and the <code>DragSourceListener</code>. <P>"}
{"code": "@SuppressWarnings(\"IfMayBeConditional\") public IgniteInternalFuture<?> dynamicStartCache(@Nullable CacheConfiguration ccfg,String cacheName,@Nullable NearCacheConfiguration nearCfg,CacheType cacheType,boolean failIfExists,boolean failIfNotStarted,boolean checkThreadTx){\n  if (checkThreadTx)   checkEmptyTransactions();\n  DynamicCacheDescriptor desc=registeredCaches.get(maskNull(cacheName));\n  DynamicCacheChangeRequest req=new DynamicCacheChangeRequest(cacheName,ctx.localNodeId());\n  req.failIfExists(failIfExists);\n  if (ccfg != null) {\n    try {\n      cloneCheckSerializable(ccfg);\n    }\n catch (    IgniteCheckedException e) {\n      return new GridFinishedFuture<>(e);\n    }\n    if (desc != null) {\n      if (failIfExists) {\n        return new GridFinishedFuture<>(new CacheExistsException(\"Failed to start cache \" + \"(a cache with the same name is already started): \" + cacheName));\n      }\n else {\n        CacheConfiguration descCfg=desc.cacheConfiguration();\n        if (nearCfg != null) {\n          if (CU.affinityNode(ctx.discovery().localNode(),descCfg.getNodeFilter())) {\n            if (descCfg.getNearConfiguration() != null)             return new GridFinishedFuture<>();\n else             return new GridFinishedFuture<>(new IgniteCheckedException(\"Failed to start near \" + \"cache (local node is an affinity node for cache): \" + cacheName));\n          }\n else           req.clientStartOnly(true);\n        }\n else         req.clientStartOnly(true);\n        req.deploymentId(desc.deploymentId());\n        req.startCacheConfiguration(descCfg);\n      }\n    }\n else {\n      req.deploymentId(IgniteUuid.randomUuid());\n      try {\n        CacheConfiguration cfg=new CacheConfiguration(ccfg);\n        CacheObjectContext cacheObjCtx=ctx.cacheObjects().contextForCache(cfg);\n        initialize(false,cfg,cacheObjCtx);\n        req.startCacheConfiguration(cfg);\n      }\n catch (      IgniteCheckedException e) {\n        return new GridFinishedFuture(e);\n      }\n    }\n  }\n else {\n    req.clientStartOnly(true);\n    if (desc != null)     ccfg=desc.cacheConfiguration();\n    if (ccfg == null) {\n      if (failIfNotStarted)       return new GridFinishedFuture<>(new CacheExistsException(\"Failed to start client cache \" + \"(a cache with the given name is not started): \" + cacheName));\n else       return new GridFinishedFuture<>();\n    }\n    req.deploymentId(desc.deploymentId());\n    req.startCacheConfiguration(ccfg);\n  }\n  if (ccfg.isSwapEnabled())   for (  ClusterNode n : ctx.discovery().allNodes())   if (!GridCacheUtils.clientNode(n) && !GridCacheUtils.isSwapEnabled(n))   return new GridFinishedFuture<>(new IgniteCheckedException(\"Failed to start cache \" + cacheName + \" with swap enabled: Remote Node with ID \"+ n.id().toString().toUpperCase()+ \" has not swap SPI configured\"));\n  if (nearCfg != null)   req.nearCacheConfiguration(nearCfg);\n  req.cacheType(cacheType);\n  return F.first(initiateCacheChanges(F.asList(req),failIfExists));\n}\n", "nl": "Dynamically starts cache."}
{"code": "private HtmlSelectOneMenu createFieldMenu(){\n  HtmlSelectOneMenu field=new HtmlSelectOneMenu();\n  List children=field.getChildren();\n  children.add(createSelectItem(\"Subject\"));\n  children.add(createSelectItem(\"Sender\"));\n  children.add(createSelectItem(\"Date\"));\n  children.add(createSelectItem(\"Priority\"));\n  children.add(createSelectItem(\"Status\"));\n  children.add(createSelectItem(\"To\"));\n  children.add(createSelectItem(\"Cc\"));\n  children.add(createSelectItem(\"To or Cc\"));\n  return field;\n}\n", "nl": "Creates the menu that allows the user to select a field."}
{"code": "public void close(){\nsynchronized (mDiskCacheLock) {\n    if (mDiskLruCache != null) {\n      try {\n        if (!mDiskLruCache.isClosed()) {\n          mDiskLruCache.close();\n        }\n      }\n catch (      Throwable e) {\n        LogUtils.e(e.getMessage(),e);\n      }\n      mDiskLruCache=null;\n    }\n  }\n}\n", "nl": "Closes the disk cache associated with this ImageCache object. Note that this includes disk access so this should not be executed on the main/UI thread."}
{"code": "private void init(){\n  customElements=new CustomElementCollection();\n  this.setExtension(customElements);\n}\n", "nl": "Common initialization code for new list entries."}
{"code": "public _ScheduleDays(){\n  super();\n}\n", "nl": "Constructs a _ScheduleDays with no flags initially set."}
{"code": "public int allocLow(int size,int addrAlignment){\n  for (MemoryChunk memoryChunk=low; memoryChunk != null; memoryChunk=memoryChunk.next) {\n    if (memoryChunk.isAvailable(size,addrAlignment)) {\n      return allocLow(memoryChunk,size,addrAlignment);\n    }\n  }\n  return 0;\n}\n", "nl": "Allocate a memory at the lowest address."}
{"code": "public double heapInit(){\n  return memory.getHeapMemoryUsage().getInit();\n}\n", "nl": "Returns the heap initial memory of the current JVM."}
{"code": "public final long size(){\n  int sum=0;\n  for (int i=0; i < this.sets.length; i++) {\n    sum+=this.sets[i].size();\n  }\n  return sum;\n}\n", "nl": "Returns the number of fingerprints in this set. Warning: The size is only accurate in single-threaded mode."}
{"code": "private static Location initLocation(GlowSession session,PlayerReader reader){\n  if (reader.hasPlayedBefore()) {\n    Location loc=reader.getLocation();\n    if (loc != null) {\n      return loc;\n    }\n  }\n  return session.getServer().getWorlds().get(0).getSpawnLocation();\n}\n", "nl": "Read the location from a PlayerReader for entity initialization. Will fall back to a reasonable default rather than returning null."}
{"code": "public CheckRef createCheckRef(){\n  CheckRefImpl checkRef=new CheckRefImpl();\n  return checkRef;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public static <T1,T2,R>Supplier<R> partial2(final T1 t1,final T2 t2,final BiFunction<T1,T2,R> biFunc){\n  return null;\n}\n", "nl": "Returns a function with 2 arguments applied to the supplied BiFunction"}
{"code": "@Override protected void endBody() throws IOException {\n  PrintStream out=getPrintStream();\n  out.println(endBodyText);\n}\n", "nl": "Extra stuff printed at the end of the &lt;body&gt; element."}
{"code": "private void updateView(){\n  if (!hasEditor()) {\n    return;\n  }\n  ViewEditor editor=getEditor();\n  relationSetEditor.updateTable(editor.getBuiltinAnalysisPlugins());\n  relationSetEditor.selectRelations(editor.getDisplayRelations());\n}\n", "nl": "Update the view after a change in the model."}
{"code": "@Override public NotificationChain eInverseRemove(InternalEObject otherEnd,int featureID,NotificationChain msgs){\nswitch (featureID) {\ncase UmplePackage.CONSTRAINT_BODY___CONSTRAINT_EXPR_1:\n    return ((InternalEList<?>)getConstraintExpr_1()).basicRemove(otherEnd,msgs);\ncase UmplePackage.CONSTRAINT_BODY___ANONYMOUS_CONSTRAINT_BODY_11:\n  return ((InternalEList<?>)getAnonymous_constraintBody_1_1()).basicRemove(otherEnd,msgs);\n}\nreturn super.eInverseRemove(otherEnd,featureID,msgs);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "private void unionRE(Nonterminal nt,RE re){\n  RE old=getRE(nt);\n  try {\n    setRE(nt,old.union(re));\n  }\n catch (  InterruptedException e) {\n    throw new RuntimeException();\n  }\n}\n", "nl": "Union the parameter regular expression with the existing regular expression mapped to the parameter nonterminal."}
{"code": "private void closeConnection(IConnection conn){\n  try {\n    if (conn != null && conn.isOpen())     conn.close();\n  }\n catch (  OdaException e) {\n    e.printStackTrace();\n  }\n}\n", "nl": "Attempts to close given ODA connection."}
{"code": "public DefaultNominator(Agent parentAgent){\n  this.parentAgent=parentAgent;\n  logger=new Logger(classLogger,parentAgent.getLogger());\n  parentAgent.addStateChangeListener(this);\n}\n", "nl": "Creates a new instance of this nominator using <tt>parentAgent</tt> as a reference to the <tt>Agent</tt> instance that we should use to nominate pairs."}
{"code": "private void advance() throws IOException {\n  close();\n  if (it.hasNext()) {\n    current=it.next().getInput();\n  }\n}\n", "nl": "Closes the current reader and opens the next one, if any."}
{"code": "public static int uninstallSilent(Context context,String packageName,boolean isKeepData){\n  if (packageName == null || packageName.length() == 0) {\n    return DELETE_FAILED_INVALID_PACKAGE;\n  }\n  StringBuilder command=new StringBuilder().append(\"LD_LIBRARY_PATH=/vendor/lib:/system/lib pm uninstall\").append(isKeepData ? \" -k \" : \" \").append(packageName.replace(\" \",\"\\\\ \"));\n  ShellUtil.CommandResult commandResult=ShellUtil.execCommand(command.toString(),!isSystemApplication(context),true);\n  if (commandResult.successMsg != null && (commandResult.successMsg.contains(\"Success\") || commandResult.successMsg.contains(\"success\"))) {\n    return DELETE_SUCCEEDED;\n  }\n  Logger.e(new StringBuilder().append(\"uninstallSilent successMsg:\").append(commandResult.successMsg).append(\", ErrorMsg:\").append(commandResult.errorMsg).toString());\n  if (commandResult.errorMsg == null) {\n    return DELETE_FAILED_INTERNAL_ERROR;\n  }\n  if (commandResult.errorMsg.contains(\"Permission denied\")) {\n    return DELETE_FAILED_PERMISSION_DENIED;\n  }\n  return DELETE_FAILED_INTERNAL_ERROR;\n}\n", "nl": "uninstall package silent by root <ul> <strong>Attentions:</strong> <li>Don't call this on the ui thread, it may costs some times.</li> <li>You should add <strong>android.permission.DELETE_PACKAGES</strong> in manifest, so no need to request root permission, if you are system app.</li> </ul>"}
{"code": "@AfterClass public static void teardownAfterClass(){\n  MockStendlRPWorld.reset();\n}\n", "nl": "cleanup after tests"}
{"code": "public final void info(Object message){\n  if (isLevelEnabled(SimpleLog.LOG_LEVEL_INFO)) {\n    log(SimpleLog.LOG_LEVEL_INFO,message,null);\n  }\n}\n", "nl": "Logs a message with  <code>org.apache.commons.logging.impl.SimpleLog.LOG_LEVEL_INFO</code>."}
{"code": "@Override public boolean execute(final Player player,final List<String> args){\n  return load(player,args);\n}\n", "nl": "Executes this script."}
{"code": "public boolean isClosingHtmlTag(){\n  return this.htmlTagIndex != -1 && (this.htmlTagIndex & JAVADOC_CLOSED_TAG) != 0;\n}\n", "nl": "Returns whether the text is a closing html tag or not."}
{"code": "protected void appendMove(Game game,int halfMoveNumber){\n  int currentRow=halfMoveNumber / 2;\n  if (halfMoveNumber % 2 != 0) {\n    movesTable.setText(currentRow,1,GameUtils.convertSanToUseUnicode(game.getMoveList().get(halfMoveNumber).toString(),false));\n  }\n else {\n    int moveNumber=currentRow + 1;\n    movesTable.appendRow(new String[]{String.valueOf(moveNumber) + \") \" + GameUtils.convertSanToUseUnicode(game.getMoveList().get(halfMoveNumber).toString(),true),\"\"});\n  }\n}\n", "nl": "Appends the move at the specified half move number to the movesTable."}
{"code": "public boolean isReversal(){\n  return m_IsReversal;\n}\n", "nl": "Is Reversal"}
{"code": "@Override public byte[] convertIndexToRGB(final byte[] data){\n  final byte[] newdata=new byte[3 * 256];\n  int inpLen=domain.length / 2;\n  int palLen=data.length / inpLen;\n  float[] inputs=new float[inpLen];\n  float[] operand;\n  int p=0, pp=0, tt;\n  for (int i=0, ii=Math.min(256,palLen); i < ii; i++) {\n    for (int j=0; j < inpLen; j++) {\n      inputs[j]=(data[p++] & 0xff) / 255f;\n    }\n    operand=colorMapper.getOperandFloat(inputs);\n    altCS.setColor(operand,operand.length);\n    tt=altCS.getColor().getRGB();\n    newdata[pp++]=(byte)((tt >> 16) & 0xff);\n    newdata[pp++]=(byte)((tt >> 8) & 0xff);\n    newdata[pp++]=(byte)(tt & 0xff);\n  }\n  return newdata;\n}\n", "nl": "create rgb index for color conversion"}
{"code": "private void createECOMConnection(CimConnectionInfo connectionInfo) throws Exception {\n  String hostAndPort=generateConnectionCacheKey(connectionInfo.getHost(),connectionInfo.getPort());\n  s_logger.info(\"Creating connection to ECOM provider on host/port {}\",hostAndPort);\n  try {\n    EcomConnection connection=new EcomConnection(connectionInfo,_listener,_configuration.getIndicationFilterMap());\n    connection.connect(_configuration.getSubscriptionsIdentifier(),_configuration.getDeleteStaleSubscriptionsOnConnect());\n    _connections.put(hostAndPort,connection);\n    connectionLastTouch.put(hostAndPort,System.currentTimeMillis());\n  }\n catch (  Exception e) {\n    throw new Exception(MessageFormatter.format(\"Failed creating connection to ECOM provider on host/port {}\",hostAndPort).getMessage(),e);\n  }\n}\n", "nl": "Creates a connection to an ECOM provider using the passed connection info."}
{"code": "private void updateProgress(int progress){\n  if (myHost != null && progress != previousProgress) {\n    myHost.updateProgress(progress);\n  }\n  previousProgress=progress;\n}\n", "nl": "Used to communicate a progress update between a plugin tool and the main Whitebox user interface."}
{"code": "protected AbstractStoringPageFile(int pageSize){\n  this.emptyPages=new Stack<>();\n  this.nextPageID=0;\n  this.pageSize=pageSize;\n}\n", "nl": "Creates a new PageFile."}
{"code": "public RandomPartition(double proba){\n  this.proba=proba;\n  random=new Random();\n}\n", "nl": "Creates a new vertex filter."}
{"code": "protected NamedNodeMap createAttributes(){\n  return new ExtendedNamedNodeHashMap();\n}\n", "nl": "Creates the attribute list."}
{"code": "public ValidatorITCase(String name){\n  super(name);\n}\n", "nl": "Construct a new instance of this test case."}
{"code": "public Point(Point p){\n  this(p.x,p.y);\n}\n", "nl": "Constructs and initializes a point with the same location as the specified <code>Point</code> object."}
{"code": "public static void initialiseListOfSupportedEbookFormats(){\n  if (EBookFormat.getSupportedFormats() != null) {\n    return;\n  }\n  List<EBookFormat> supportedFormats=new LinkedList<EBookFormat>();\n  InputStream is=ConfigurationManager.getResourceAsStream(Constants.MIMETYPES_FILENAME);\n  assert is != null;\n  Scanner scanner=new Scanner(is);\n  String line;\n  try {\n    while (scanner.hasNextLine()) {\n      line=scanner.nextLine();\n      if (line.length() == 0 || line.charAt(0) == '#') {\n        continue;\n      }\n      Scanner lineScanner=new Scanner(line);\n      String formatType=null;\n      if (lineScanner.hasNext())       formatType=lineScanner.next();\n      String mimeType=null;\n      if (lineScanner.hasNext())       mimeType=lineScanner.next();\n      if (Helper.isNullOrEmpty(formatType) || Helper.isNullOrEmpty(mimeType)) {\n        logger.error(\"Invalid line in Mimetypes file '\" + line + \"'\");\n        continue;\n      }\n      supportedFormats.add(new EBookFormat(formatType,mimeType));\n    }\n    scanner.close();\n    is.close();\n  }\n catch (  Exception e) {\n  }\n  EBookFormat.setSupportedFormats(supportedFormats);\n}\n", "nl": "get the list of supported ebook formats. We use the function that can read from a user configuration file (if present), and if that is not present the default resource file"}
{"code": "public void readRawBinary(BinaryRawReader reader) throws BinaryObjectException {\n  affKey=BinaryUtils.readIgniteUuid(reader);\n  status=reader.readInt();\n  startOff=reader.readLong();\n  endOff=reader.readLong();\n}\n", "nl": "Reads fields from provided reader."}
{"code": "@Override public boolean markSupported(){\n  return false;\n}\n", "nl": "Since we do not support marking just yet, we return false."}
{"code": "@Override public String toString(){\n  return \"Cursor: \" + index;\n}\n", "nl": "Returns the string representation of this cursor."}
{"code": "public void removeThemeRefreshListener(ActionListener l){\n  if (themelisteners == null) {\n    return;\n  }\n  themelisteners.removeListener(l);\n}\n", "nl": "Removes a Theme refresh listener."}
{"code": "public JSONWriter object() throws JSONException {\n  if (this.mode == 'i') {\n    this.mode='o';\n  }\n  if (this.mode == 'o' || this.mode == 'a') {\n    this.append(\"{\");\n    this.push(new JSONObject());\n    this.comma=false;\n    return this;\n  }\n  throw new JSONException(\"Misplaced object.\");\n}\n", "nl": "Begin appending a new object. All keys and values until the balancing <code>endObject</code> will be appended to this object. The <code>endObject</code> method must be called to mark the object's end."}
{"code": "public void fillFieldValues(List<SynapseUpdateRule> ruleList){\n  OjaRule synapseRef=(OjaRule)ruleList.get(0);\n  if (!NetworkUtils.isConsistent(ruleList,OjaRule.class,\"getNormalizationFactor\")) {\n    tfNormalize.setText(SimbrainConstants.NULL_STRING);\n  }\n else {\n    tfNormalize.setText(Double.toString(synapseRef.getNormalizationFactor()));\n  }\n  if (!NetworkUtils.isConsistent(ruleList,OjaRule.class,\"getLearningRate\")) {\n    tfLearningRate.setText(SimbrainConstants.NULL_STRING);\n  }\n else {\n    tfLearningRate.setText(Double.toString(synapseRef.getLearningRate()));\n  }\n}\n", "nl": "Populate fields with current data."}
{"code": "void clear(){\n  zoneInfo.zoneChanged();\n}\n", "nl": "Prepare for zone change."}
{"code": "@SuppressWarnings({\"SimplifiableIfStatement\",\"IfMayBeConditional\"}) public void finish(){\n  boolean sync;\n  if (!F.isEmpty(dhtMap) || !F.isEmpty(nearMap))   sync=finish(dhtMap,nearMap);\n else   if (!commit && !F.isEmpty(tx.lockTransactionNodes()))   sync=rollbackLockTransactions(tx.lockTransactionNodes());\n else   sync=false;\n  markInitialized();\n  if (!sync)   onComplete();\n}\n", "nl": "Initializes future."}
{"code": "public static double pow(double x,double y){\n  final double lns[]=new double[2];\n  if (y == 0.0) {\n    return 1.0;\n  }\n  if (x != x) {\n    return x;\n  }\n  if (x == 0) {\n    long bits=Double.doubleToRawLongBits(x);\n    if ((bits & 0x8000000000000000L) != 0) {\n      long yi=(long)y;\n      if (y < 0 && y == yi && (yi & 1) == 1) {\n        return Double.NEGATIVE_INFINITY;\n      }\n      if (y > 0 && y == yi && (yi & 1) == 1) {\n        return -0.0;\n      }\n    }\n    if (y < 0) {\n      return Double.POSITIVE_INFINITY;\n    }\n    if (y > 0) {\n      return 0.0;\n    }\n    return Double.NaN;\n  }\n  if (x == Double.POSITIVE_INFINITY) {\n    if (y != y) {\n      return y;\n    }\n    if (y < 0.0) {\n      return 0.0;\n    }\n else {\n      return Double.POSITIVE_INFINITY;\n    }\n  }\n  if (y == Double.POSITIVE_INFINITY) {\n    if (x * x == 1.0) {\n      return Double.NaN;\n    }\n    if (x * x > 1.0) {\n      return Double.POSITIVE_INFINITY;\n    }\n else {\n      return 0.0;\n    }\n  }\n  if (x == Double.NEGATIVE_INFINITY) {\n    if (y != y) {\n      return y;\n    }\n    if (y < 0) {\n      long yi=(long)y;\n      if (y == yi && (yi & 1) == 1) {\n        return -0.0;\n      }\n      return 0.0;\n    }\n    if (y > 0) {\n      long yi=(long)y;\n      if (y == yi && (yi & 1) == 1) {\n        return Double.NEGATIVE_INFINITY;\n      }\n      return Double.POSITIVE_INFINITY;\n    }\n  }\n  if (y == Double.NEGATIVE_INFINITY) {\n    if (x * x == 1.0) {\n      return Double.NaN;\n    }\n    if (x * x < 1.0) {\n      return Double.POSITIVE_INFINITY;\n    }\n else {\n      return 0.0;\n    }\n  }\n  if (x < 0) {\n    if (y >= TWO_POWER_53 || y <= -TWO_POWER_53) {\n      return pow(-x,y);\n    }\n    if (y == (long)y) {\n      return ((long)y & 1) == 0 ? pow(-x,y) : -pow(-x,y);\n    }\n else {\n      return Double.NaN;\n    }\n  }\n  double ya;\n  double yb;\n  if (y < 8e298 && y > -8e298) {\n    double tmp1=y * HEX_40000000;\n    ya=y + tmp1 - tmp1;\n    yb=y - ya;\n  }\n else {\n    double tmp1=y * 9.31322574615478515625E-10;\n    double tmp2=tmp1 * 9.31322574615478515625E-10;\n    ya=(tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000;\n    yb=y - ya;\n  }\n  final double lores=log(x,lns);\n  if (Double.isInfinite(lores)) {\n    return lores;\n  }\n  double lna=lns[0];\n  double lnb=lns[1];\n  double tmp1=lna * HEX_40000000;\n  double tmp2=lna + tmp1 - tmp1;\n  lnb+=lna - tmp2;\n  lna=tmp2;\n  final double aa=lna * ya;\n  final double ab=lna * yb + lnb * ya + lnb * yb;\n  lna=aa + ab;\n  lnb=-(lna - aa - ab);\n  double z=1.0 / 120.0;\n  z=z * lnb + (1.0 / 24.0);\n  z=z * lnb + (1.0 / 6.0);\n  z=z * lnb + 0.5;\n  z=z * lnb + 1.0;\n  z*=lnb;\n  final double result=exp(lna,z,null);\n  return result;\n}\n", "nl": "Power function.  Compute x^y."}
{"code": "public static Dcsn cs_qr(Dcs A,Dcss S){\n  double Rx[], Vx[], Ax[], x[], Beta[];\n  int i, k, p, n, vnz, p1, top, m2, len, col, rnz, s[], leftmost[], Ap[], Ai[], parent[], Rp[], Ri[], Vp[], Vi[], w[], pinv[], q[];\n  Dcs R, V;\n  Dcsn N;\n  if (!Dcs_util.CS_CSC(A) || S == null)   return (null);\n  n=A.n;\n  Ap=A.p;\n  Ai=A.i;\n  Ax=A.x;\n  q=S.q;\n  parent=S.parent;\n  pinv=S.pinv;\n  m2=S.m2;\n  vnz=S.lnz;\n  rnz=S.unz;\n  leftmost=S.leftmost;\n  w=new int[m2 + n];\n  x=new double[m2];\n  N=new Dcsn();\n  s=w;\n  int s_offset=m2;\n  for (k=0; k < m2; k++)   x[k]=0;\n  N.L=V=Dcs_util.cs_spalloc(m2,n,vnz,true,false);\n  N.U=R=Dcs_util.cs_spalloc(m2,n,rnz,true,false);\n  N.B=Beta=new double[n];\n  Rp=R.p;\n  Ri=R.i;\n  Rx=R.x;\n  Vp=V.p;\n  Vi=V.i;\n  Vx=V.x;\n  for (i=0; i < m2; i++)   w[i]=-1;\n  rnz=0;\n  vnz=0;\n  for (k=0; k < n; k++) {\n    Rp[k]=rnz;\n    Vp[k]=p1=vnz;\n    w[k]=k;\n    Vi[vnz++]=k;\n    top=n;\n    col=q != null ? q[k] : k;\n    for (p=Ap[col]; p < Ap[col + 1]; p++) {\n      i=leftmost[Ai[p]];\n      for (len=0; w[i] != k; i=parent[i]) {\n        s[s_offset + (len++)]=i;\n        w[i]=k;\n      }\n      while (len > 0)       s[s_offset + (--top)]=s[s_offset + (--len)];\n      i=pinv[Ai[p]];\n      x[i]=Ax[p];\n      if (i > k && w[i] < k) {\n        Vi[vnz++]=i;\n        w[i]=k;\n      }\n    }\n    for (p=top; p < n; p++) {\n      i=s[s_offset + p];\n      Dcs_happly.cs_happly(V,i,Beta[i],x);\n      Ri[rnz]=i;\n      Rx[rnz++]=x[i];\n      x[i]=0;\n      if (parent[i] == k)       vnz=Dcs_scatter.cs_scatter(V,i,0,w,null,k,V,vnz);\n    }\n    for (p=p1; p < vnz; p++) {\n      Vx[p]=x[Vi[p]];\n      x[Vi[p]]=0;\n    }\n    Ri[rnz]=k;\n    double[] beta=new double[1];\n    beta[0]=Beta[k];\n    Rx[rnz++]=Dcs_house.cs_house(Vx,p1,beta,vnz - p1);\n    Beta[k]=beta[0];\n  }\n  Rp[n]=rnz;\n  Vp[n]=vnz;\n  return N;\n}\n", "nl": "Sparse QR factorization of an m-by-n matrix A, A= Q*R"}
{"code": "public boolean isCellEditable(int row,int col){\n  return false;\n}\n", "nl": "Gets the cellEditable attribute of the PropertiesTableModel object"}
{"code": "public JSONArray optJSONArray(String key){\n  Object o=opt(key);\n  return o instanceof JSONArray ? (JSONArray)o : null;\n}\n", "nl": "Get an optional JSONArray associated with a key. It returns null if there is no such key, or if its value is not a JSONArray."}
{"code": "@org.hamcrest.Factory public static org.hamcrest.Matcher<Double> equalTo(final Double value){\n  return equalTo(value,10);\n}\n", "nl": "Creates a rounded equal matcher that checks double (near) equality."}
{"code": "public ChartViewer(JFreeChart chart){\n  this(chart,true);\n}\n", "nl": "Creates a new viewer to display the supplied chart in JavaFX."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2014-02-24 15:47:29.087 -0500\",hash_original_method=\"B33F4935D7EC88037EE2967518A095D3\",hash_generated_method=\"94868AEDB16628F241D8220AA3C50090\") @DSSpec(DSCat.IO) public static String sha512Hex(InputStream data) throws IOException {\n  return Hex.encodeHexString(sha512(data));\n}\n", "nl": "Calculates the SHA-512 digest and returns the value as a hex string. <p> Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0. </p>"}
{"code": "public VirtualMachineError(java.lang.String s){\n  super(s);\n}\n", "nl": "Constructs a VirtualMachineError with the specified detail message. s - the detail message."}
{"code": "public Response onCommand(POP3Session session,Request request){\n  if (session.getHandlerState() == POP3Session.TRANSACTION) {\n    stat(session);\n    return POP3Response.OK;\n  }\n else {\n    return POP3Response.ERR;\n  }\n}\n", "nl": "Handler method called upon receipt of a RSET command. Calls stat() to reset the mailbox."}
{"code": "public int serverDelivery(Object message,Object consumer,int deliveryCount) throws Exception {\n  ProtonServerSenderContext protonSender=serverSenders.get(consumer);\n  if (protonSender != null) {\n    return protonSender.deliverMessage(message,deliveryCount);\n  }\n  return 0;\n}\n", "nl": "The consumer object from the broker or the key used to store the sender"}
{"code": "public static void rollbackConnection(@Nullable Connection rsrc,@Nullable IgniteLogger log){\n  if (rsrc != null)   try {\n    rsrc.rollback();\n  }\n catch (  SQLException e) {\n    warn(log,\"Failed to rollback JDBC connection: \" + e.getMessage());\n  }\n}\n", "nl": "Rollbacks JDBC connection logging possible checked exception."}
{"code": "public void stop(int taskId){\n  this.readTasks.get(taskId).stop();\n}\n", "nl": "Stop the reader for a particular task."}
{"code": "public TypeEraseFilterFactory(Map<String,String> args){\n  super(args);\n  if (!args.isEmpty()) {\n    throw new IllegalArgumentException(\"Unknown parameters: \" + args);\n  }\n}\n", "nl": "Creates a new PorterStemFilterFactory"}
{"code": "protected void makeRegionData(DrawContext dc){\n  this.currentData=(RegionData)this.regionDataCache.getEntry(dc.getGlobe());\n  if (this.currentData == null) {\n    this.currentData=this.createCacheEntry(dc);\n    this.regionDataCache.addEntry(this.currentData);\n  }\n  if (dc.getFrameTimeStamp() != this.getCurrentData().getFrameNumber()) {\n    if (this.mustRegenerateData(dc)) {\n      this.doMakeRegionData(dc);\n      this.getCurrentData().restartTimer(dc);\n      this.getCurrentData().setGlobeStateKey(dc.getGlobe().getGlobeStateKey(dc));\n      this.getCurrentData().setVerticalExaggeration(dc.getVerticalExaggeration());\n    }\n    this.getCurrentData().setFrameNumber(dc.getFrameTimeStamp());\n  }\n}\n", "nl": "Produces the data used to determine whether this Region is active for the specified <code>DrawContext</code>. This attempts to re-use <code>RegionData</code> already been calculated this frame, or previously calculated <code>RegionData</code> that is still valid and has not expired. This method is called by <code>isActive</code> prior to determining if this Region is actually active."}
{"code": "@Override public boolean batchFinished(){\n  if (getInputFormat() == null) {\n    throw new IllegalStateException(\"No input instance format defined\");\n  }\n  if (m_Values == null) {\n    determineValues(getInputFormat());\n    setOutputFormat();\n  }\n  flushInput();\n  m_NewBatch=true;\n  m_FirstBatchDone=true;\n  return (numPendingOutput() != 0);\n}\n", "nl": "Signifies that this batch of input to the filter is finished. If the filter requires all instances prior to filtering, output() may now be called to retrieve the filtered instances."}
{"code": "@Override public T defaultCase(EObject object){\n  return null;\n}\n", "nl": "Returns the result of interpreting the object as an instance of '<em>EObject</em>'. <!-- begin-user-doc --> This implementation returns null; returning a non-null result will terminate the switch, but this is the last case anyway. <!-- end-user-doc -->"}
{"code": "@Override public void environmentConfigure(EnvironmentClassLoader loader) throws ConfigException {\n}\n", "nl": "Handles the case where the environment is configuring and registering beans"}
{"code": "@Override protected void mouseClicked(int par1,int par2,int par3) throws IOException {\n  if (par2 >= 36 && par2 <= height - 57)   if (par1 >= width / 2 + 140 || par1 <= width / 2 - 126)   altList.elementClicked(-1,false,0,0);\n  super.mouseClicked(par1,par2,par3);\n}\n", "nl": "Called when the mouse is clicked."}
{"code": "public void paint(Graphics g,Shape a){\n  Rectangle alloc=(a instanceof Rectangle) ? (Rectangle)a : a.getBounds();\n  tabBase=alloc.x;\n  Graphics2D g2d=(Graphics2D)g;\n  host=(RSyntaxTextArea)getContainer();\n  int ascent=host.getMaxAscent();\n  int fontHeight=host.getLineHeight();\n  int n=getViewCount();\n  int x=alloc.x + getLeftInset();\n  int y=alloc.y + getTopInset();\n  Rectangle clip=g.getClipBounds();\n  for (int i=0; i < n; i++) {\n    tempRect.x=x + getOffset(X_AXIS,i);\n    tempRect.y=y + getOffset(Y_AXIS,i);\n    tempRect.width=getSpan(X_AXIS,i);\n    tempRect.height=getSpan(Y_AXIS,i);\n    if (tempRect.intersects(clip)) {\n      View view=getView(i);\n      drawView(g2d,alloc,view,fontHeight,tempRect.y + ascent);\n    }\n  }\n}\n", "nl": "Paints the word-wrapped text."}
{"code": "@Override public final void wakeUp() throws AdeException {\n  super.wakeUp();\n  createUsageVariables();\n}\n", "nl": "Create variables for this class after deserialization."}
{"code": "public Term(String fld,String text){\n  this(fld,new BytesRef(text));\n}\n", "nl": "Constructs a Term with the given field and text. <p>Note that a null field or null text value results in undefined behavior for most Lucene APIs that accept a Term parameter."}
{"code": "HeapArrayOfDoublesQuickSelectSketch(final int nomEntries,final int lgResizeFactor,final float samplingProbability,final int numValues,final long seed){\n  super(numValues,seed);\n  nomEntries_=ceilingPowerOf2(nomEntries);\n  lgResizeFactor_=lgResizeFactor;\n  samplingProbability_=samplingProbability;\n  theta_=(long)(Long.MAX_VALUE * (double)samplingProbability);\n  final int startingCapacity=1 << startingSubMultiple(Integer.numberOfTrailingZeros(ceilingPowerOf2(nomEntries) * 2),ResizeFactor.getRF(lgResizeFactor),MIN_LG_ARR_LONGS);\n  keys_=new long[startingCapacity];\n  values_=new double[startingCapacity * numValues];\n  lgCurrentCapacity_=Integer.numberOfTrailingZeros(startingCapacity);\n  setRebuildThreshold();\n}\n", "nl": "This is to create an instance of a QuickSelectSketch with custom resize factor and sampling  probability"}
{"code": "public static void main(String[] args){\n  doMain(args);\n}\n", "nl": "Application entry point."}
{"code": "private static Class<?> toJavaType(DbColumn col){\n  boolean nullable=col.nullable();\n  boolean unsigned=col.unsigned();\nswitch (col.type()) {\ncase BIT:\ncase BOOLEAN:\n    return nullable ? Boolean.class : boolean.class;\ncase TINYINT:\n  return unsigned ? (nullable ? Short.class : short.class) : (nullable ? Byte.class : byte.class);\ncase SMALLINT:\nreturn unsigned ? (nullable ? Integer.class : int.class) : (nullable ? Short.class : short.class);\ncase INTEGER:\nreturn unsigned ? (nullable ? Long.class : long.class) : (nullable ? Integer.class : int.class);\ncase BIGINT:\nreturn nullable ? Long.class : long.class;\ncase REAL:\nreturn nullable ? Float.class : float.class;\ncase FLOAT:\ncase DOUBLE:\nreturn nullable ? Double.class : double.class;\ncase NUMERIC:\ncase DECIMAL:\nreturn BigDecimal.class;\ncase CHAR:\ncase VARCHAR:\ncase LONGVARCHAR:\ncase NCHAR:\ncase NVARCHAR:\ncase LONGNVARCHAR:\ncase CLOB:\ncase NCLOB:\ncase SQLXML:\nreturn String.class;\ncase DATE:\nreturn java.sql.Date.class;\ncase TIME:\nreturn java.sql.Time.class;\ncase TIMESTAMP:\nreturn java.sql.Timestamp.class;\ndefault :\nreturn Object.class;\n}\n}\n", "nl": "Convert JDBC data type to java type."}
{"code": "public Token createToken(){\n  Token token=tokenList[currentFreeToken];\n  token.text=null;\n  token.type=Token.NULL;\n  token.offset=-1;\n  token.setNextToken(null);\n  currentFreeToken++;\n  if (currentFreeToken == size)   augmentTokenList();\n  return token;\n}\n", "nl": "Returns a null token."}
{"code": "private static synchronized int increment(){\n  return cyclicCounter++;\n}\n", "nl": "The central method to increment the cyclic counter, synchronized to achieve a unique value for each subsequent call <p> there is no problem if the counter reaches the maximum counter value, defined by N_COUNTERS_CHARS, only the right number of bits are taken into account for generating the output"}
{"code": "public SSHFPRecord(Name name,int dclass,long ttl,int alg,int digestType,byte[] fingerprint){\n  super(name,Type.SSHFP,dclass,ttl);\n  this.alg=checkU8(\"alg\",alg);\n  this.digestType=checkU8(\"digestType\",digestType);\n  this.fingerprint=fingerprint;\n}\n", "nl": "Creates an SSHFP Record from the given data."}
{"code": "protected Control createDialogArea(Composite composite){\n  list=new List(composite,SWT.SINGLE | SWT.V_SCROLL | SWT.RESIZE);\n  setList();\n  list.addSelectionListener(new ShowDeclarationsSelectionListener(EditorUtil.getTLAEditorWithFocus()));\n  list.addKeyListener(new ShowDeclarationsKeyListener(this));\n  list.setSelection(0);\n  return list;\n}\n", "nl": "This is the method that puts the content into the popup's dialog area.  It puts an org.eclipse.swt.widgets.List (note that this isn't an ordinary Java List) there."}
{"code": "public HelloMinecraftLookAndFeel() throws ParseException {\n  this(DEFAULT_SETTINGS);\n}\n", "nl": "Creates a new instance of NimbusLookAndFeel"}
{"code": "private static Schema loadWsTrustSchema(){\n  try {\n    Schema wsTrustSchema=Util.loadXmlSchemaFromResource(ResponseUnmarshaller.class,WS_TRUST_1_3_SCHEMA);\n    return wsTrustSchema;\n  }\n catch (  IllegalArgumentException e) {\n    LoggerFactory.getLogger(SamlTokenImpl.class).error(String.format(\"Schema resource `%s' is missing.\",WS_TRUST_1_3_SCHEMA),e);\n    throw new RuntimeException(String.format(\"Schema resource `%s' is missing.\",WS_TRUST_1_3_SCHEMA),e);\n  }\ncatch (  SAXException e) {\n    LoggerFactory.getLogger(ResponseUnmarshaller.class).error(ERR_LOADING_WS_TRUST_SCHEMA,e);\n    throw new RuntimeException(ERR_LOADING_WS_TRUST_SCHEMA,e);\n  }\n}\n", "nl": "Loads WS-Trust schema file."}
{"code": "public TestProgressBar(Composite parent,int style){\n  super(parent,style);\n  colorSkipped=new Color(Display.getCurrent(),230,232,235);\n  colorPassed=new Color(Display.getCurrent(),198,242,177);\n  colorFailed=new Color(Display.getCurrent(),242,188,177);\n  colorError=new Color(Display.getCurrent(),242,188,177);\n  colorFixme=new Color(Display.getCurrent(),177,231,242);\n  addPaintListener(null);\n  addDisposeListener(null);\n}\n", "nl": "Create instance."}
{"code": "public DigesterOutputStream(MessageDigest md,boolean buffer){\n  this.md=md;\n  this.buffer=buffer;\n  if (buffer) {\n    bos=new UnsyncByteArrayOutputStream();\n  }\n}\n", "nl": "Creates a DigesterOutputStream."}
{"code": "public static String format(double[] v,int w,int d){\n  DecimalFormat format=new DecimalFormat();\n  format.setDecimalFormatSymbols(new DecimalFormatSymbols(Locale.US));\n  format.setMinimumIntegerDigits(1);\n  format.setMaximumFractionDigits(d);\n  format.setMinimumFractionDigits(d);\n  format.setGroupingUsed(false);\n  int width=w + 1;\n  StringBuilder msg=new StringBuilder();\n  msg.append('\\n');\n  for (int i=0; i < v.length; i++) {\n    String s=format.format(v[i]);\n    int padding=Math.max(1,width - s.length());\n    for (int k=0; k < padding; k++) {\n      msg.append(' ');\n    }\n    msg.append(s);\n  }\n  return msg.toString();\n}\n", "nl": "Returns a string representation of this vector."}
{"code": "private void writeQNameAttribute(java.lang.String namespace,java.lang.String attName,javax.xml.namespace.QName qname,javax.xml.stream.XMLStreamWriter xmlWriter) throws javax.xml.stream.XMLStreamException {\n  java.lang.String attributeNamespace=qname.getNamespaceURI();\n  java.lang.String attributePrefix=xmlWriter.getPrefix(attributeNamespace);\n  if (attributePrefix == null) {\n    attributePrefix=registerPrefix(xmlWriter,attributeNamespace);\n  }\n  java.lang.String attributeValue;\n  if (attributePrefix.trim().length() > 0) {\n    attributeValue=attributePrefix + \":\" + qname.getLocalPart();\n  }\n else {\n    attributeValue=qname.getLocalPart();\n  }\n  if (namespace.equals(\"\")) {\n    xmlWriter.writeAttribute(attName,attributeValue);\n  }\n else {\n    registerPrefix(xmlWriter,namespace);\n    xmlWriter.writeAttribute(namespace,attName,attributeValue);\n  }\n}\n", "nl": "Util method to write an attribute without the ns prefix"}
{"code": "@Deprecated public void showDoneButton(boolean showDone){\n  setProgressButtonEnabled(showDone);\n}\n", "nl": "Shows or hides Done button, replaced with setProgressButtonEnabled"}
{"code": "public void onReloadPreferences(){\n  SharedPreferences settings=PreferenceManager.getDefaultSharedPreferences(mContext);\n  boolean enableTapDetection=false;\n  if (!settings.getString(mContext.getString(R.string.pref_shortcut_single_tap_key),mContext.getString(R.string.pref_shortcut_single_tap_default)).equals(mContext.getString(R.string.shortcut_value_unassigned))) {\n    enableTapDetection=true;\n  }\n  if (!settings.getString(mContext.getString(R.string.pref_shortcut_double_tap_key),mContext.getString(R.string.pref_shortcut_double_tap_default)).equals(mContext.getString(R.string.shortcut_value_unassigned))) {\n    enableTapDetection=true;\n    mIntegratedTapDetector.setMaxDoubleTapSpacingNanos(DOUBLE_TAP_SPACING_NANOS);\n  }\n else {\n    mIntegratedTapDetector.setMaxDoubleTapSpacingNanos(0);\n  }\n  if (settings.getString(mContext.getString(R.string.pref_tap_sensitivity_key),mContext.getString(R.string.pref_tap_sensitivity_default)).equals(mContext.getString(R.string.tap_sensitivity_value_lowest))) {\n    mIntegratedTapDetector.setTapDetectionQuality(IntegratedTapDetector.TAP_QUALITY_HIGHEST);\n  }\n  if (settings.getString(mContext.getString(R.string.pref_tap_sensitivity_key),mContext.getString(R.string.pref_tap_sensitivity_default)).equals(mContext.getString(R.string.tap_sensitivity_value_low))) {\n    mIntegratedTapDetector.setTapDetectionQuality(IntegratedTapDetector.TAP_QUALITY_HIGH);\n  }\n  if (settings.getString(mContext.getString(R.string.pref_tap_sensitivity_key),mContext.getString(R.string.pref_tap_sensitivity_default)).equals(mContext.getString(R.string.tap_sensitivity_value_medium))) {\n    mIntegratedTapDetector.setTapDetectionQuality(IntegratedTapDetector.TAP_QUALITY_MEDIUM);\n  }\n  if (settings.getString(mContext.getString(R.string.pref_tap_sensitivity_key),mContext.getString(R.string.pref_tap_sensitivity_default)).equals(mContext.getString(R.string.tap_sensitivity_value_high))) {\n    mIntegratedTapDetector.setTapDetectionQuality(IntegratedTapDetector.TAP_QUALITY_LOW);\n  }\n  mIntegratedTapDetector.setDoubleTapDetectionQuality(IntegratedTapDetector.TAP_QUALITY_LOW);\n  if (enableTapDetection) {\n    mIntegratedTapDetector.start();\n  }\n else {\n    mIntegratedTapDetector.stop();\n  }\n}\n", "nl": "Enables tap detection if appropriate based on preferences."}
{"code": "protected void calcAngularBounds(NodeItem r){\n  if (m_prevRoot == null || !m_prevRoot.isValid() || r == m_prevRoot) {\n    m_prevRoot=r;\n    return;\n  }\n  NodeItem p=m_prevRoot;\n  while (true) {\n    NodeItem pp=(NodeItem)p.getParent();\n    if (pp == r) {\n      break;\n    }\n else     if (pp == null) {\n      m_prevRoot=r;\n      return;\n    }\n    p=pp;\n  }\n  double dt=0;\n  Iterator iter=sortedChildren(r);\n  while (iter.hasNext()) {\n    Node n=(Node)iter.next();\n    if (n == p)     break;\n    dt+=((Params)n.get(PARAMS)).width;\n  }\n  double rw=((Params)r.get(PARAMS)).width;\n  double pw=((Params)p.get(PARAMS)).width;\n  dt=-MathLib.TWO_PI * (dt + pw / 2) / rw;\n  m_theta1=dt + Math.atan2(p.getY() - r.getY(),p.getX() - r.getX());\n  m_theta2=m_theta1 + MathLib.TWO_PI;\n  m_prevRoot=r;\n}\n", "nl": "Calculates the angular bounds of the layout, attempting to preserve the angular orientation of the display across transitions."}
{"code": "public void validateNameString(String name){\n  if (StringUtils.isEmpty(name) || NullColumnValueGetter.getNullStr().equalsIgnoreCase(name)) {\n    throw APIException.badRequests.requiredParameterMissingOrEmpty(\"name\");\n  }\n}\n", "nl": "Fires APIException.badRequests.requiredParameterMissingOrEmpty if the given collection is empty"}
{"code": "private Node tryAppend(Node s,boolean haveData){\n  for (Node t=tail, p=t; ; ) {\n    Node n, u;\n    if (p == null && (p=head) == null) {\n      if (casHead(null,s))       return s;\n    }\n else     if (p.cannotPrecede(haveData))     return null;\n else     if ((n=p.next) != null)     p=p != t && t != (u=tail) ? (t=u) : (p != n) ? n : null;\n else     if (!p.casNext(null,s))     p=p.next;\n else {\n      if (p != t) {\n        while ((tail != t || !casTail(t,s)) && (t=tail) != null && (s=t.next) != null && (s=s.next) != null && s != t)         ;\n      }\n      return p;\n    }\n  }\n}\n", "nl": "Tries to append node s as tail."}
{"code": "public UnconditionalFlowInfo mitigateNullInfoOf(FlowInfo flowInfo){\n  if ((this.tagBits & NULL_FLAG_MASK) == 0) {\n    return flowInfo.unconditionalInits();\n  }\n  long m, m1, nm1, m2, nm2, m3, a2, a3, a4, s1, s2, ns2, s3, ns3, s4, ns4;\n  boolean newCopy=false;\n  UnconditionalFlowInfo source=flowInfo.unconditionalInits();\n  m1=(s1=source.nullBit1) & (s3=source.nullBit3) & (s4=source.nullBit4)& ((a2=this.nullBit2) | (a4=this.nullBit4));\n  m2=s1 & (s2=this.nullBit2) & (s3 ^ s4)& ((a3=this.nullBit3) | a4);\n  m3=s1 & (s2 & (ns3=~s3) & (ns4=~s4)& (a3 | a4) | (ns2=~s2) & s3 & ns4& (a2 | a4) | ns2 & ns3 & s4& (a2 | a3));\n  if ((m=(m1 | m2 | m3)) != 0) {\n    newCopy=true;\n    source=source.unconditionalCopy();\n    source.nullBit1&=~m;\n    source.nullBit2&=(nm1=~m1) & ((nm2=~m2) | a4);\n    source.nullBit3&=(nm1 | a2) & nm2;\n    source.nullBit4&=nm1 & nm2;\n    long x=~this.nullBit1 & a2 & a3& a4;\n    if (x != 0) {\n      source.nullBit1&=~x;\n      source.nullBit2|=x;\n      source.nullBit3|=x;\n      source.nullBit4|=x;\n    }\n  }\n  if (this.extra != null && source.extra != null) {\n    int length=this.extra[2].length, sourceLength=source.extra[0].length;\n    if (sourceLength < length) {\n      length=sourceLength;\n    }\n    for (int i=0; i < length; i++) {\n      m1=(s1=source.extra[1 + 1][i]) & (s3=source.extra[3 + 1][i]) & (s4=source.extra[4 + 1][i])& ((a2=this.extra[2 + 1][i]) | (a4=this.extra[4 + 1][i]));\n      m2=s1 & (s2=this.extra[2 + 1][i]) & (s3 ^ s4)& ((a3=this.extra[3 + 1][i]) | a4);\n      m3=s1 & (s2 & (ns3=~s3) & (ns4=~s4)& (a3 | a4) | (ns2=~s2) & s3 & ns4& (a2 | a4) | ns2 & ns3 & s4& (a2 | a3));\n      if ((m=(m1 | m2 | m3)) != 0) {\n        if (!newCopy) {\n          newCopy=true;\n          source=source.unconditionalCopy();\n        }\n        source.extra[1 + 1][i]&=~m;\n        source.extra[2 + 1][i]&=(nm1=~m1) & ((nm2=~m2) | a4);\n        source.extra[3 + 1][i]&=(nm1 | a2) & nm2;\n        source.extra[4 + 1][i]&=nm1 & nm2;\n      }\n    }\n  }\n  return source;\n}\n", "nl": "Mitigate the definite and protected info of flowInfo, depending on what this null info registry knows about potential assignments and messages sends involving locals. May return flowInfo unchanged, or a modified, fresh copy of flowInfo."}
{"code": "public void testCertificateFactory01() throws CertificateException {\n  if (!X509Support) {\n    fail(NotSupportMsg);\n    return;\n  }\n  for (int i=0; i < validValues.length; i++) {\n    CertificateFactory certF=CertificateFactory.getInstance(validValues[i]);\n    assertEquals(\"Incorrect type: \",validValues[i],certF.getType());\n  }\n}\n", "nl": "Test for <code>getInstance(String type)</code> method Assertion: returns CertificateFactory if type is X.509"}
{"code": "private void applyFonts(Composite composite){\n  Dialog.applyDialogFont(composite);\n  if (titleLabel != null) {\n    Font font=titleLabel.getFont();\n    FontData[] fontDatas=font.getFontData();\n    for (int i=0; i < fontDatas.length; i++) {\n      fontDatas[i].setStyle(SWT.BOLD);\n    }\n    titleFont=new Font(titleLabel.getDisplay(),fontDatas);\n    titleLabel.setFont(titleFont);\n  }\n  if (infoLabel != null) {\n    Font font=infoLabel.getFont();\n    FontData[] fontDatas=font.getFontData();\n    for (int i=0; i < fontDatas.length; i++) {\n      fontDatas[i].setHeight(fontDatas[i].getHeight() * 9 / 10);\n    }\n    infoFont=new Font(infoLabel.getDisplay(),fontDatas);\n    infoLabel.setFont(infoFont);\n  }\n}\n", "nl": "Apply any desired fonts to the specified composite and its children."}
{"code": "public static String toStringPretty(JsonElement jsonElt){\n  return toStringPretty(jsonElt,0);\n}\n", "nl": "Returns a pretty printed string of the given Json element."}
{"code": "protected void deleteLinksOnPort(NodePortTuple npt,String reason){\n  List<Link> eraseList=new ArrayList<Link>();\n  if (this.portLinks.containsKey(npt)) {\n    if (log.isTraceEnabled()) {\n      log.trace(\"handlePortStatus: Switch {} port #{} \" + \"removing links {}\",new Object[]{npt.getNodeId().toString(),npt.getPortId(),this.portLinks.get(npt)});\n    }\n    eraseList.addAll(this.portLinks.get(npt));\n    deleteLinks(eraseList,reason);\n  }\n}\n", "nl": "Delete links incident on a given switch port."}
{"code": "private Token parseSimpleToken(final Token token,int ch) throws IOException {\n  while (true) {\n    if (readEndOfLine(ch)) {\n      token.type=EORECORD;\n      break;\n    }\n else     if (isEndOfFile(ch)) {\n      token.type=EOF;\n      token.isReady=true;\n      break;\n    }\n else     if (isDelimiter(ch)) {\n      token.type=TOKEN;\n      break;\n    }\n else     if (isEscape(ch)) {\n      final int unescaped=readEscape();\n      if (unescaped == Constants.END_OF_STREAM) {\n        token.content.append((char)ch).append((char)in.getLastChar());\n      }\n else {\n        token.content.append((char)unescaped);\n      }\n      ch=in.read();\n    }\n else {\n      token.content.append((char)ch);\n      ch=in.read();\n    }\n  }\n  if (ignoreSurroundingSpaces) {\n    trimTrailingSpaces(token.content);\n  }\n  return token;\n}\n", "nl": "Parses a simple token. <p/> Simple token are tokens which are not surrounded by encapsulators. A simple token might contain escaped delimiters (as \\, or \\;). The token is finished when one of the following conditions become true: <ul> <li>end of line has been reached (EORECORD)</li> <li>end of stream has been reached (EOF)</li> <li>an unescaped delimiter has been reached (TOKEN)</li> </ul>"}
{"code": "public void updateHeader(Header header){\n  if (header == null) {\n    return;\n  }\n  for (int i=0; i < this.headers.size(); i++) {\n    Header current=(Header)this.headers.get(i);\n    if (current.getName().equalsIgnoreCase(header.getName())) {\n      this.headers.set(i,header);\n      return;\n    }\n  }\n  this.headers.add(header);\n}\n", "nl": "Replaces the first occurence of the header with the same name. If no header with  the same name is found the given header is added to the end of the list."}
{"code": "public static <S,A extends Action>Map<S,A> initialPolicyVector(MarkovDecisionProcess<S,A> mdp){\n  Map<S,A> pi=new LinkedHashMap<S,A>();\n  List<A> actions=new ArrayList<A>();\n  for (  S s : mdp.states()) {\n    actions.clear();\n    actions.addAll(mdp.actions(s));\n    if (actions.size() > 0) {\n      pi.put(s,Util.selectRandomlyFromList(actions));\n    }\n  }\n  return pi;\n}\n", "nl": "Create a policy vector indexed by state, initially random."}
{"code": "@Override public void run(){\n  amIActive=true;\n  String inputHeader=null;\n  String outputHeader=null;\n  int row, col, x, y;\n  double z;\n  float progress=0;\n  int a;\n  double slopeX;\n  double slopeY;\n  double val;\n  int[] dX={1,1,1,0,-1,-1,-1,0};\n  int[] dY={-1,0,1,1,1,0,-1,-1};\n  double[] maskX={1,1,1,0,-1,-1,-1,0};\n  double[] maskY={1,0,-1,-1,-1,0,1,1};\n  int numPixelsInFilter;\n  boolean reflectAtBorders=false;\n  if (args.length <= 0) {\n    showFeedback(\"Plugin parameters have not been set.\");\n    return;\n  }\n  for (int i=0; i < args.length; i++) {\n    if (i == 0) {\n      inputHeader=args[i];\n    }\n else     if (i == 1) {\n      outputHeader=args[i];\n    }\n else     if (i == 2) {\n      reflectAtBorders=Boolean.parseBoolean(args[i]);\n    }\n  }\n  if ((inputHeader == null) || (outputHeader == null)) {\n    showFeedback(\"One or more of the input parameters have not been set properly.\");\n    return;\n  }\n  try {\n    WhiteboxRaster inputFile=new WhiteboxRaster(inputHeader,\"r\");\n    inputFile.isReflectedAtEdges=reflectAtBorders;\n    int rows=inputFile.getNumberRows();\n    int cols=inputFile.getNumberColumns();\n    double noData=inputFile.getNoDataValue();\n    WhiteboxRaster outputFile=new WhiteboxRaster(outputHeader,\"rw\",inputHeader,WhiteboxRaster.DataType.FLOAT,noData);\n    outputFile.setPreferredPalette(\"grey.pal\");\n    numPixelsInFilter=8;\n    for (row=0; row < rows; row++) {\n      for (col=0; col < cols; col++) {\n        z=inputFile.getValue(row,col);\n        if (z != noData) {\n          slopeX=0;\n          slopeY=0;\n          for (a=0; a < numPixelsInFilter; a++) {\n            x=col + dX[a];\n            y=row + dY[a];\n            val=inputFile.getValue(y,x);\n            if (val == noData) {\n              val=z;\n            }\n            slopeX+=val * maskX[a];\n            slopeY+=val * maskY[a];\n          }\n          val=Math.sqrt(slopeX * slopeX + slopeY * slopeY);\n          outputFile.setValue(row,col,val);\n        }\n else {\n          outputFile.setValue(row,col,noData);\n        }\n      }\n      if (cancelOp) {\n        cancelOperation();\n        return;\n      }\n      progress=(float)(100f * row / (rows - 1));\n      updateProgress((int)progress);\n    }\n    outputFile.addMetadataEntry(\"Created by the \" + getDescriptiveName() + \" tool.\");\n    outputFile.addMetadataEntry(\"Created on \" + new Date());\n    inputFile.close();\n    outputFile.close();\n    returnData(outputHeader);\n  }\n catch (  OutOfMemoryError oe) {\n    myHost.showFeedback(\"An out-of-memory error has occurred during operation.\");\n  }\ncatch (  Exception e) {\n    myHost.showFeedback(\"An error has occurred during operation. See log file for details.\");\n    myHost.logException(\"Error in \" + getDescriptiveName(),e);\n  }\n finally {\n    updateProgress(\"Progress: \",0);\n    amIActive=false;\n    myHost.pluginComplete();\n  }\n}\n", "nl": "Used to execute this plugin tool."}
{"code": "public BooleanCondition must(Condition... conditions){\n  must=add(must,conditions);\n  return this;\n}\n", "nl": "Returns this with the specified mandatory conditions."}
{"code": "public static final String toBitString(double d[]){\n  StringBuilder sb=new StringBuilder(d.length);\n  for (  double b : d) {\n    sb.append((int)Math.round(b));\n  }\n  return sb.toString();\n}\n", "nl": "ToBitString - returns a String representation of d[]."}
{"code": "public void doStoreFront(HtmlPage storeFront) throws Exception {\n  HtmlSubmitInput button=null;\n  HtmlTableDataCell cell=null;\n  String description=null, moreButton=null;\n  Iterator iter=null;\n  boolean found=false;\n  int i;\n  assertNotNull(storeFront);\n  List cells=getAllElementsOfGivenClass(storeFront,null,HtmlTableDataCell.class), buttons=getAllElementsOfGivenClass(storeFront,null,HtmlSubmitInput.class);\n  for (i=0; i < carBundles.length; i++) {\n    iter=cells.iterator();\n    description=carBundles[i].getString(\"description\").trim();\n    while (iter.hasNext()) {\n      cell=(HtmlTableDataCell)iter.next();\n      if (-1 != cell.asText().indexOf(description)) {\n        if (LOGGER.isLoggable(Level.FINE)) {\n          LOGGER.fine(\"Found description \" + description + \".\");\n        }\n        found=true;\n        break;\n      }\n    }\n  }\n  assertTrue(\"Did not find description: \" + description,found);\n  iter=buttons.iterator();\n  moreButton=resources.getString(\"moreButton\").trim();\n  while (iter.hasNext()) {\n    button=(HtmlSubmitInput)iter.next();\n    assertTrue(-1 != button.asText().indexOf(moreButton));\n    if (LOGGER.isLoggable(Level.FINE)) {\n      LOGGER.fine(\"Button text of \" + moreButton + \" confirmed.\");\n    }\n    doCarDetail((HtmlPage)button.click());\n  }\n}\n", "nl": "<p>Assumptions: there are exactly four buttons on this page, one for each car model.</p> <p/> <p>Verify that all of the expected cars have their descriptions on the page.</p> <p/> <p>Verify that the text of the \"more\" button is properly localized.</p> <p/> <p>Press the button for each model and execute doCarDetail() on the result.</p>"}
{"code": "public void showMessage(String str){\n  ArgumentChecking.notNull(str,\"str\");\n  updateLabel(str,false,MESSAGE_FG_COLOR,MESSAGE_BG_COLOR);\n}\n", "nl": "It shows a message on the status label. The look of the status label is updated accordingly."}
{"code": "SavedState(Parcelable superState){\n  super(superState);\n}\n", "nl": "Called by onSaveInstanceState."}
{"code": "@Override public int hashCode(){\n  if (triple == null) {\n    return getDerivation().hashCode();\n  }\n else {\n    return triple.hashCode();\n  }\n}\n", "nl": "Two statements are the same as long as they represent the same triple. Derivation matters if and only if there is no triple."}
{"code": "public synchronized void store(THLEvent event,boolean commit) throws ReplicatorException, InterruptedException {\n  assertWritable();\n  long maxSeqno=diskLog.getMaxSeqno();\n  long eventSeqno=event.getSeqno();\n  short eventFragno=event.getFragno();\n  if (eventSeqno < maxSeqno) {\n    throw new LogConsistencyException(\"Attempt to write new log record with lower seqno value: current max seqno=\" + maxSeqno + \" attempted new seqno=\"+ eventSeqno);\n  }\n else   if (eventSeqno == maxSeqno && eventFragno <= lastFragno) {\n    throw new LogConsistencyException(\"Attempt to write new log record with equal or lower fragno: seqno=\" + eventSeqno + \" previous stored fragno=\"+ lastFragno+ \" attempted new fragno=\"+ eventFragno);\n  }\n  if (this.cursor == null) {\n    try {\n      LogFile lastFile=diskLog.openLastFile(false);\n      cursor=new LogCursor(lastFile,event.getSeqno());\n      if (logger.isDebugEnabled()) {\n        logger.debug(\"Creating new log cursor: thread=\" + Thread.currentThread() + \" file=\"+ lastFile.getFile().getName()+ \" seqno=\"+ event.getSeqno());\n      }\n    }\n catch (    ReplicatorException e) {\n      throw new THLException(\"Failed to open log last log file\",e);\n    }\n  }\n  LogFile dataFile=cursor.getLogFile();\n  if (logger.isDebugEnabled()) {\n    logger.debug(\"Using log file for writing: \" + dataFile.getFile().getName());\n  }\n  try {\n    if (dataFile.getLength() > logFileSize && event.getFragno() == 0) {\n      dataFile=diskLog.rotate(dataFile,event.getSeqno());\n      cursor.release();\n      cursor=new LogCursor(dataFile,event.getSeqno());\n    }\n    LogEventReplWriter eventWriter=new LogEventReplWriter(event,eventSerializer,doChecksum,dataFile.getFile());\n    LogRecord logRecord=eventWriter.write();\n    dataFile.writeRecord(logRecord,logFileSize);\n    diskLog.setMaxSeqno(event.getSeqno());\n    if (event.getLastFrag())     lastFragno=-1;\n else     lastFragno=event.getFragno();\n    if (commit) {\n      dataFile.flush();\n    }\n  }\n catch (  IOException e) {\n    throw new THLException(\"Error while writing to log file: name=\" + dataFile.getFile().getName(),e);\n  }\n}\n", "nl": "Store a THL event at the end of the log."}
{"code": "private String encodeAttributeValue(final String attributeValue){\n  if (attributeValue == null) {\n    return null;\n  }\n  int len=attributeValue.length();\n  boolean encode=false;\n  for (int pos=0; pos < len; pos++) {\n    char ch=attributeValue.charAt(pos);\n    if (ch == '<') {\n      encode=true;\n      break;\n    }\n else     if (ch == '>') {\n      encode=true;\n      break;\n    }\n else     if (ch == '\\\"') {\n      encode=true;\n      break;\n    }\n else     if (ch == '&') {\n      encode=true;\n      break;\n    }\n  }\n  if (encode) {\n    StringBuilder bf=new StringBuilder();\n    for (int pos=0; pos < len; pos++) {\n      char ch=attributeValue.charAt(pos);\n      if (ch == '<') {\n        bf.append(\"&lt;\");\n      }\n else       if (ch == '>') {\n        bf.append(\"&gt;\");\n      }\n else       if (ch == '\\\"') {\n        bf.append(\"&quot;\");\n      }\n else       if (ch == '&') {\n        bf.append(\"&amp;\");\n      }\n else {\n        bf.append(ch);\n      }\n    }\n    return bf.toString();\n  }\n  return attributeValue;\n}\n", "nl": "Encodes the given string in such a way that it no longer contains characters that have a special meaning in xml."}
{"code": "@Bean public ViewResolver jspViewResolver(){\n  InternalResourceViewResolver resolver=new InternalResourceViewResolver();\n  resolver.setPrefix(\"/WEB-INF/jsp/\");\n  resolver.setSuffix(\".jsp\");\n  return resolver;\n}\n", "nl": "Gets a JSP view resolver."}
{"code": "protected final void endOfInput(boolean streamCancelled) throws IOException {\n  if (cacheRequest != null) {\n    cacheBody.close();\n  }\n  httpEngine.release(streamCancelled);\n}\n", "nl": "Closes the cache entry and makes the socket available for reuse. This should be invoked when the end of the body has been reached."}
{"code": "public RevisionMetadata parseMetadataNodeList(String revId,NodeList nlEntries,ImmutableList<Revision> parents){\n  String author=\"None\";\n  DateTime date=new DateTime(0L);\n  String description=\"None\";\n  for (int i=0; i < nlEntries.getLength(); i++) {\n    Node currNode=nlEntries.item(i);\n    if (currNode.getNodeName().equals(\"author\")) {\n      author=currNode.getTextContent();\n    }\n    if (currNode.getNodeName().equals(\"date\")) {\n      date=ISODateTimeFormat.dateTime().parseDateTime(currNode.getTextContent());\n    }\n    if (currNode.getNodeName().equals(\"msg\")) {\n      description=currNode.getTextContent();\n    }\n  }\n  return RevisionMetadata.builder().id(revId).author(author).date(date).description(description).withParents(parents).build();\n}\n", "nl": "Helper function for parseMetadata"}
{"code": "@SuppressWarnings(\"unchecked\") public Set<S> children(){\n  return children;\n}\n", "nl": "Get the direct childnodes"}
{"code": "public h5 addElement(Element element){\n  addElementToRegistry(element);\n  return (this);\n}\n", "nl": "Adds an Element to the element."}
{"code": "public static long[] convertToLongArray(final byte[] vals){\n  checkSource(vals.length,8);\n  final long[] dest=new long[vals.length / 8];\n  convertToLongArrayInternal(vals,0,vals.length,dest,0);\n  return dest;\n}\n", "nl": "Converts <code>byte[]</code> to <code>long[]</code>, assuming big-endian byte order."}
{"code": "public java.util.ArrayList<TreeNode<E>> path(E e){\n  java.util.ArrayList<TreeNode<E>> list=new java.util.ArrayList<>();\n  TreeNode<E> current=root;\n  while (current != null) {\n    list.add(current);\n    if (e.compareTo(current.element) < 0) {\n      current=current.left;\n    }\n else     if (e.compareTo(current.element) > 0) {\n      current=current.right;\n    }\n else     break;\n  }\n  return list;\n}\n", "nl": "Return a path from the root leadting to the specified element"}
{"code": "private void firePEPListeners(String from,PEPEvent event){\n  PEPListener[] listeners=null;\nsynchronized (pepListeners) {\n    listeners=new PEPListener[pepListeners.size()];\n    pepListeners.toArray(listeners);\n  }\n  for (int i=0; i < listeners.length; i++) {\n    listeners[i].eventReceived(from,event);\n  }\n}\n", "nl": "Fires roster exchange listeners."}
{"code": "public MethodNode popEnclosingMethod(){\n  return enclosingMethods.removeFirst();\n}\n", "nl": "Pops a method from the enclosing methods stack."}
{"code": "private void readParameterAnnotations(final MethodVisitor mv,final Context context,int v,final boolean visible){\n  int i;\n  int n=b[v++] & 0xFF;\n  int synthetics=Type.getArgumentTypes(context.desc).length - n;\n  AnnotationVisitor av;\n  for (i=0; i < synthetics; ++i) {\n    av=mv.visitParameterAnnotation(i,\"Ljava/lang/Synthetic;\",false);\n    if (av != null) {\n      av.visitEnd();\n    }\n  }\n  char[] c=context.buffer;\n  for (; i < n + synthetics; ++i) {\n    int j=readUnsignedShort(v);\n    v+=2;\n    for (; j > 0; --j) {\n      av=mv.visitParameterAnnotation(i,readUTF8(v,c),visible);\n      v=readAnnotationValues(v + 2,c,true,av);\n    }\n  }\n}\n", "nl": "Reads parameter annotations and makes the given visitor visit them."}
{"code": "public StringLiteral createStringLiteral(){\n  StringLiteralImpl stringLiteral=new StringLiteralImpl();\n  return stringLiteral;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public SyntheticMethodBinding(MethodBinding overridenMethodToBridge,MethodBinding targetMethod,SourceTypeBinding declaringClass){\n  this.declaringClass=declaringClass;\n  this.selector=overridenMethodToBridge.selector;\n  this.modifiers=(targetMethod.modifiers | ClassFileConstants.AccBridge | ClassFileConstants.AccSynthetic) & ~(ClassFileConstants.AccSynchronized | ClassFileConstants.AccAbstract | ClassFileConstants.AccNative| ClassFileConstants.AccFinal| ExtraCompilerModifiers.AccGenericSignature);\n  this.tagBits|=(TagBits.AnnotationResolved | TagBits.DeprecatedAnnotationResolved);\n  this.returnType=overridenMethodToBridge.returnType;\n  this.parameters=overridenMethodToBridge.parameters;\n  this.thrownExceptions=overridenMethodToBridge.thrownExceptions;\n  this.targetMethod=targetMethod;\n  this.purpose=SyntheticMethodBinding.BridgeMethod;\n  SyntheticMethodBinding[] knownAccessMethods=declaringClass.syntheticMethods();\n  int methodId=knownAccessMethods == null ? 0 : knownAccessMethods.length;\n  this.index=methodId;\n}\n", "nl": "Construct a bridge method"}
{"code": "public static void start(){\n  start(Thread.currentThread().getContextClassLoader());\n}\n", "nl": "Starts the current environment."}
{"code": "public ConnectionConfig(){\n  super();\n}\n", "nl": "Ctor for a functional Swing object with no prexisting adapter"}
{"code": "public AbstractMRMessage createInitPacket(){\n  return null;\n}\n", "nl": "Public Method to create an Initialization packet (SerialMessage) for this node. There are currently no Oak Tree boards that need an init message, so this returns null."}
{"code": "public Observable<String> exerciseZip(Observable<String> a,Observable<String> b){\n  return Observable.error(new RuntimeException(\"Not Implemented\"));\n}\n", "nl": "Combine 2 streams into pairs using zip. a -> \"one\", \"two\", \"red\", \"blue\" b -> \"fish\", \"fish\", \"fish\", \"fish\" output -> \"one fish\", \"two fish\", \"red fish\", \"blue fish\""}
{"code": "protected void tearDown(){\n}\n", "nl": "Tears down the fixture, for example, close a network connection. This method is called after a test is executed."}
{"code": "static String mapLibraryName(String libname){\n  String libSuffix;\n  if (VM.BuildForLinux || VM.BuildForSolaris) {\n    libSuffix=\".so\";\n  }\n else   if (VM.BuildForOsx) {\n    libSuffix=\".jnilib\";\n  }\n else {\n    libSuffix=\".a\";\n  }\n  return \"lib\" + libname + libSuffix;\n}\n", "nl": "Apply library prefixes and suffixes as necessary to libname to produce a full file name. For example, on linux \"rvm\" would become \"librvm.so\"."}
{"code": "public void removeActionListener(ActionListener a){\n  if (actionListeners == null) {\n    return;\n  }\n  actionListeners.removeListener(a);\n  if (!actionListeners.hasListeners()) {\n    actionListeners=null;\n  }\n}\n", "nl": "Removes an action listener"}
{"code": "@Override protected void onSizeChanged(int w,int h,int oldw,int oldh){\n  updateSize();\n}\n", "nl": "This is called during layout when the size of this view has changed. If you were just added to the view hierarchy, you're called with the old values of 0."}
{"code": "protected void sequence_FunctionFacet(ISerializationContext context,Facet semanticObject){\n  genericSequencer.createSequence(context,semanticObject);\n}\n", "nl": "Contexts: FunctionFacet returns Facet Constraint: ((key='function:' | key='->') expr=Expression)"}
{"code": "public static URL urlFromString(String location){\n  return urlFromString(location,null,true);\n}\n", "nl": "From a string description, attempt to generate a URL object. The string may point to an Internet location (e.g., http:// or ftp:// URL), a resource on the class path (resulting in a resource URL that points into the current classpath), or a file on the local filesystem (resulting in a file:// URL). The String will be checked in that order in an attempt to resolve it to a valid URL."}
{"code": "public static List<? extends Node> evaluateXPath(Document doc,String path) throws XPathExpressionException {\n  XPathFactory factory=XPathFactory.newInstance();\n  XPath xpath=factory.newXPath();\n  xpath.setNamespaceContext(new NamespaceResolver(doc));\n  XPathExpression expr=xpath.compile(path);\n  NodeList nodes=(NodeList)expr.evaluate(doc,XPathConstants.NODESET);\n  List<Node> nodelist=new ArrayList<Node>();\n  for (int i=0; i < nodes.getLength(); ++i) {\n    nodelist.add(nodes.item(i));\n  }\n  LOG.trace(String.format(\"Evaluated XPath: %s and found %s\",path,nodeListToString(nodelist)));\n  return nodelist;\n}\n", "nl": "Takes a Document and evaluates an XPath expression on it. All matching Nodes are returned as a List."}
{"code": "@HLEFunction(nid=0x8DB83FDC,version=150) public int sceNetAdhocctlGetPeerInfo(pspNetMacAddress macAddress,int size,TPointer peerInfoAddr){\n  checkInitialized();\n  int result=SceKernelErrors.ERROR_NET_ADHOC_NO_ENTRY;\n  if (sceNetAdhoc.isMyMacAddress(macAddress.macAddress)) {\n    SceNetAdhocctlPeerInfo peerInfo=new SceNetAdhocctlPeerInfo();\n    peerInfo.nickName=sceUtility.getSystemParamNickname();\n    peerInfo.macAddress=new pspNetMacAddress(Wlan.getMacAddress());\n    peerInfo.timestamp=getCurrentTimestamp();\n    peerInfo.write(peerInfoAddr);\n    if (log.isDebugEnabled()) {\n      log.debug(String.format(\"sceNetAdhocctlGetPeerInfo for own MAC address, returning %s\",peerInfo));\n    }\n    result=0;\n  }\n else {\n    for (    AdhocctlPeer peer : peers) {\n      if (macAddress.equals(peer.macAddress)) {\n        SceNetAdhocctlPeerInfo peerInfo=new SceNetAdhocctlPeerInfo();\n        peerInfo.nickName=peer.nickName;\n        peerInfo.macAddress=new pspNetMacAddress(peer.macAddress);\n        peerInfo.timestamp=peer.timestamp;\n        peerInfo.write(peerInfoAddr);\n        if (log.isDebugEnabled()) {\n          log.debug(String.format(\"sceNetAdhocctlGetPeerInfo returning %s\",peerInfo));\n        }\n        result=0;\n        break;\n      }\n    }\n  }\n  if (result != 0) {\n    if (log.isDebugEnabled()) {\n      log.debug(String.format(\"sceNetAdhocctlGetPeerInfo returning 0x%08X\",result));\n    }\n  }\n  return result;\n}\n", "nl": "Get peer information"}
{"code": "public NodeSet(){\n  m_blocksize=32;\n  m_mapSize=0;\n}\n", "nl": "Create an empty nodelist."}
{"code": "public static void printUsage(final Options options,final OutputStream out){\n  final PrintWriter writer=new PrintWriter(out);\n  final HelpFormatter usageFormatter=new HelpFormatter();\n  usageFormatter.printUsage(writer,80,\"Usage: hadoop jar <jar name> \" + ReplicationJob.class.getName(),options);\n  writer.flush();\n}\n", "nl": "Print usage information to provided OutputStream."}
{"code": "public boolean contains(final int x){\n  int i=d;\n  while (i-- != 0)   if (!bits.getBoolean(hash(x,i)))   return false;\n  return true;\n}\n", "nl": "Checks whether the given integer is in this filter.  <P>Note that this method may return true on an integer that has not been added to the filter. This will happen with probability 2<sup>-<var>d</var></sup>, where <var>d</var> is the number of hash functions specified at creation time, if the number of the elements in the filter is less than <var>n</var>, the number of expected elements specified at creation time."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:54:55.108 -0500\",hash_original_method=\"6B2B571AE4F377CE25FA9B4608683BF5\",hash_generated_method=\"285A23FFDABA1DF6F6F9408346D12FBB\") public String encode(){\n  String retval=headerName + COLON;\n  if (optionTag != null)   retval+=SP + optionTag;\n  retval+=NEWLINE;\n  return retval;\n}\n", "nl": "Return canonical form of the header."}
{"code": "public void minx(int parseInt){\n  minx=parseInt;\n}\n", "nl": "Set the starting x number of the subjar file to create. Depends on the subjar zoom to figure out what that means."}
{"code": "public boolean IsPostPiEmpty(){\n  return this.postPi.isEmpty();\n}\n", "nl": "Checks if the post PI attribute list is empty."}
{"code": "@Override public boolean removeLastOccurrence(Object o){\n  throw new UnsupportedOperationException(ERROR_MSG);\n}\n", "nl": "Guaranteed to throw an exception and leave the table unmodified."}
{"code": "public Builder<KType,VType> putAll(Map<KType,VType> map){\n  for (  Map.Entry<KType,VType> entry : map.entrySet()) {\n    this.map.put(entry.getKey(),entry.getValue());\n  }\n  return this;\n}\n", "nl": "Puts all the entries in the map to the builder."}
{"code": "public static ByteBuffer wrap(byte[] bytes){\n  return ByteBuffer.wrap(bytes).order(DEFAULT_BYTE_ORDER);\n}\n", "nl": "Returns a ByteBuffer wrapping the given bytes and configured with the default byte order."}
{"code": "public void println(){\n  System.err.println(prefix + \":\");\n}\n", "nl": "print a blank line to stderr that is prefixed with the prefix."}
{"code": "public void authorizeComplete(String pin) throws FacebookException {\n  AccessToken token=this.connection.getOAuthAccessToken(pin);\n  setToken(token.getToken());\n  User user=this.connection.getMe();\n  this.userName=user.getId();\n  if (token.getExpires() != null) {\n    this.tokenExpiry=new Date(System.currentTimeMillis() + (token.getExpires() * 1000));\n  }\n  this.profileName=user.getName();\n  try {\n    this.page=\"\";\n    ResponseList<Account> accounts=this.connection.getAccounts();\n    this.pages=new ArrayList<>();\n    if (accounts != null) {\n      for (      Account account : accounts) {\n        this.page=account.getName();\n        this.pages.add(account.getName());\n      }\n    }\n  }\n catch (  Exception exception) {\n    log(exception);\n  }\n}\n", "nl": "Authorise a new account to be accessible by Bot."}
{"code": "public <T>void visit(final Class<? super T> type) throws HandleException {\n  checkArgument(type != null,\"Type to be visited cannot be null\");\n  if (LOGGER.isLoggable(Level.FINER)) {\n    LOGGER.finer(\"  Visit class: \" + type);\n  }\n  if (type.getPackage() != null && type.getPackage().getName().startsWith(JAVA_PACKAGE)) {\n    return;\n  }\n  handle(type);\n  handle(type.getDeclaredFields());\n  handle(type.getDeclaredMethods());\n  visit((Class<? super T>)type.getSuperclass());\n}\n", "nl": "Visits all fields, methods and super classes of the input class."}
{"code": "public static String encode(String str) throws RuntimeException {\n  byte[] bytes=str.getBytes();\n  byte[] encoded=encode(bytes);\n  try {\n    return new String(encoded,\"ASCII\");\n  }\n catch (  UnsupportedEncodingException e) {\n    throw new RuntimeException(\"ASCII is not supported!\",e);\n  }\n}\n", "nl": "<p> Encodes a string. </p> <p> Before the string is encoded in Base64, it is converted in a binary sequence using the system default charset. </p>"}
{"code": "public void clearInputs(){\n  unCache();\n  for (  TransactionInput input : inputs) {\n    input.setParent(null);\n  }\n  inputs.clear();\n  this.length=this.unsafeBitcoinSerialize().length;\n}\n", "nl": "Removes all the inputs from this transaction. Note that this also invalidates the length attribute"}
{"code": "private void determineSyntaxAndEncoding(String absFileName,JarFile jarFile,String jspConfigPageEnc) throws JasperException, IOException {\n  isXml=false;\n  boolean isExternal=false;\n  boolean revert=false;\n  JspConfig jspConfig=ctxt.getOptions().getJspConfig();\n  JspProperty jspProperty=jspConfig.findJspProperty(absFileName);\n  if (jspProperty.isXml() != null) {\n    isXml=JspUtil.booleanValue(jspProperty.isXml());\n    isExternal=true;\n  }\n else   if (absFileName.endsWith(\".jspx\") || absFileName.endsWith(\".tagx\")) {\n    isXml=true;\n    isExternal=true;\n  }\n  if (isExternal && !isXml) {\n    sourceEnc=jspConfigPageEnc;\n    if (sourceEnc != null) {\n      return;\n    }\n    sourceEnc=\"ISO-8859-1\";\n  }\n else {\n    Object[] ret=XMLEncodingDetector.getEncoding(absFileName,jarFile,ctxt,err);\n    sourceEnc=(String)ret[0];\n    if (((Boolean)ret[1]).booleanValue()) {\n      isEncodingSpecifiedInProlog=true;\n    }\n    if (ret[2] != null && ((Boolean)ret[2]).booleanValue()) {\n      hasBom=true;\n    }\n    if (!isXml && sourceEnc.equalsIgnoreCase(\"utf-8\") && !hasBom) {\n      sourceEnc=\"ISO-8859-1\";\n      revert=true;\n    }\n  }\n  if (isXml) {\n    return;\n  }\n  JspReader jspReader=null;\n  try {\n    jspReader=new JspReader(ctxt,absFileName,sourceEnc,jarFile,err);\n  }\n catch (  FileNotFoundException ex) {\n    throw new JasperException(ex);\n  }\n  jspReader.setSingleFile(true);\n  Mark startMark=jspReader.mark();\n  if (!isExternal) {\n    jspReader.reset(startMark);\n    if (hasJspRoot(jspReader)) {\n      isXml=true;\n      if (revert)       sourceEnc=\"UTF-8\";\n      return;\n    }\n else {\n      isXml=false;\n    }\n  }\n  if (!hasBom) {\n    sourceEnc=jspConfigPageEnc;\n  }\n  if (sourceEnc == null) {\n    sourceEnc=getPageEncodingForJspSyntax(jspReader,startMark);\n    if (sourceEnc == null) {\n      sourceEnc=\"ISO-8859-1\";\n      isDefaultPageEncoding=true;\n    }\n  }\n}\n", "nl": "Determines the syntax (standard or XML) and page encoding properties for the given file, and stores them in the 'isXml' and 'sourceEnc' instance variables, respectively."}
{"code": "public FastAdapterDialog<Item> withTitle(@StringRes int titleRes){\n  setTitle(titleRes);\n  return this;\n}\n", "nl": "Set the title text for this dialog's window."}
{"code": "private String buildToolTip(final CTaggedGraphNodesContainerNode node){\n  final StringBuilder tooltip=new StringBuilder(\"<html>\");\n  boolean first=true;\n  for (  final NaviNode graphnode : node.getGraphNodes()) {\n    if (!first) {\n      tooltip.append(\"<br>\");\n    }\n    tooltip.append(CNodesDisplayString.getDisplayString(graphnode));\n    first=false;\n  }\n  return tooltip + \"</html>\";\n}\n", "nl": "Generates the tooltip shown when the cursor hovers over a tag tree node that represents a container of graph nodes."}
{"code": "private void stateData(){\n  Log.d(TAG,\"Santa is online.\");\n  updateNavigation();\n  scheduleUIUpdate();\n  long time=SantaPreferences.getCurrentTime();\n  AbstractLaunch launchSanta=mCardAdapter.getLauncher(CardAdapter.SANTA);\n  if (time > mFirstDeparture && time < OFFLINE_SANTA_FINALARRIVAL) {\n    enableTrackerMode(true);\n    if (mFlagSwitchOff) {\n      launchSanta.setState(AbstractLaunch.STATE_DISABLED);\n    }\n else     if (time > mFinalArrival) {\n      launchSanta.setState(AbstractLaunch.STATE_DISABLED);\n    }\n else {\n      launchSanta.setState(AbstractLaunch.STATE_READY);\n    }\n  }\n else   if (time < mFirstDeparture) {\n    startCountdown(mFirstDeparture);\n    launchSanta.setState(AbstractLaunch.STATE_LOCKED);\n  }\n else {\n    launchSanta.setState(AbstractLaunch.STATE_FINISHED);\n    stopCountdown();\n    enableTrackerMode(false);\n  }\n}\n", "nl": "Move to 'data' (online) state."}
{"code": "public final int type(){\n  return m_Type;\n}\n", "nl": "Returns the attribute's type as an integer."}
{"code": "public ProtomechBay(double space,int doors,int bayNumber){\n  totalSpace=space;\n  currentSpace=space;\n  this.doors=doors;\n  doorsNext=doors;\n  this.bayNumber=bayNumber;\n}\n", "nl": "Create a space for the given tonnage of troops. For this class, only the weight of the troops (and their equipment) are considered; if you'd like to think that they are stacked like lumber, be my guest."}
{"code": "@Override protected EClass eStaticClass(){\n  return GamlPackage.Literals.STATEMENT;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "@RequestMapping(value=\"podcasts_by_frequency\",method=RequestMethod.POST) public String updatePodcastsWithFrequency(@ModelAttribute(\"updatePodcastsByFrequencyForm\") UpdatePodcastsByFrequencyForm updatePodcastsByFrequencyForm,BindingResult bindingResult,ModelMap model){\n  if (bindingResult.hasErrors()) {\n    return \"redirect:/admin\";\n  }\n  LOG.debug(\"------ executing updatePodcastsWithFrequency -----\");\n  Integer podcastsUpdateFrequencyCode=updatePodcastsByFrequencyForm.getUpdateFrequency() != null ? updatePodcastsByFrequencyForm.getUpdateFrequency().getCode() : null;\n  if (podcastsUpdateFrequencyCode == null) {\n    Integer.valueOf(configBean.get(\"PODCAST_FREQUENCY_TYPE_TO_UPDATE\"));\n  }\n  Integer totalNumberOfPodcasts=null;\n  totalNumberOfPodcasts=readService.getNumberOfPodcastsWithUpdateFrequency(podcastsUpdateFrequencyCode);\n  Integer numberOfWorkerThreads=updatePodcastsByFrequencyForm.getNumberOfWorkingThreads();\n  if (numberOfWorkerThreads == null) {\n    numberOfWorkerThreads=Integer.valueOf(configBean.get(\"NO_WORKER_THREADS_FOR_UPDATE_ALL_PODCASTS\"));\n  }\n  if (numberOfWorkerThreads == null) {\n    numberOfWorkerThreads=DEFAULT_NO_WORKER_THREADS_FOR_UPDATE_ALL_PODCASTS;\n  }\n  Integer mod=totalNumberOfPodcasts % numberOfWorkerThreads;\n  Integer chunkSize=totalNumberOfPodcasts / numberOfWorkerThreads;\n  for (int i=0; i < numberOfWorkerThreads; i++) {\n    int startRow=i * chunkSize;\n    if (i == numberOfWorkerThreads - 1) {\n      chunkSize=chunkSize + mod;\n      LOG.debug(\"Thread[\" + i + \"] - [\"+ startRow+ \",\"+ chunkSize+ \"]\");\n      Future<String> future=batchUpdateService.updatePodcastsFromRange(startRow,chunkSize,podcastsUpdateFrequencyCode);\n    }\n else {\n      batchUpdateService.updatePodcastsFromRange(startRow,chunkSize,podcastsUpdateFrequencyCode);\n    }\n  }\n  return \"redirect:/admin/update/batch\";\n}\n", "nl": "UPDATE podcast by id or feed url"}
{"code": "public void removeListener(final SelectionListener listener1){\n  if (this.listener == listener1)   this.listener=null;\n}\n", "nl": "Remove listener."}
{"code": "public CompositePersistence(Persistence<O,A> primaryPersistence,Persistence<O,A> secondaryPersistence,List<? extends Persistence<O,A>> additionalPersistences){\n  validatePersistenceArguments(primaryPersistence,secondaryPersistence,additionalPersistences);\n  this.primaryPersistence=primaryPersistence;\n  this.secondaryPersistence=secondaryPersistence;\n  this.additionalPersistences=additionalPersistences;\n}\n", "nl": "Creates a CompositePersistence wrapping two or more backing persistences. <b>The collection itself will be persisted to the primary persistence.</b>"}
{"code": "public PKCS10 createCSRequest(Device device,KeyPair keyPair) throws KeyStoreException {\n  X500Name x500Name=createX500NameForDevice(device);\n  PKCS10 request=null;\n  try {\n    request=new PKCS10(keyPair.getPublic());\n    Signature signature=Signature.getInstance(\"MD5withRSA\");\n    signature.initSign(keyPair.getPrivate());\n    request.encodeAndSign(x500Name,signature);\n  }\n catch (  Exception e) {\n    throw new KeyStoreException(\"Unable to create CSR request\",e);\n  }\n  return request;\n}\n", "nl": "Creates a Certificate Signing Request and signs it with RSA private key"}
{"code": "public void syncAll(){\n  m_vmasvc.sync(m_nid,0L,0L,true);\n}\n", "nl": "sync. the memory pool to underlying memory device."}
{"code": "private void stripTimings(){\n  long limit=System.currentTimeMillis() - TIMING_TTL_MILLIS;\n  int endIndex=0;\n  for (; endIndex < myTimings.size(); endIndex++) {\n    if (myTimings.get(endIndex) > limit) {\n      break;\n    }\n  }\n  if (endIndex > 0) {\n    myTimings.remove(0,endIndex);\n  }\n}\n", "nl": "Removes old timings."}
{"code": "@Override public FileLock tryLock(long position,long size,boolean shared) throws IOException {\n  throw new IOException(\"Method is unsupported.\");\n}\n", "nl": "Unsupported method."}
{"code": "public UsageException(final String message){\n  super(message);\n}\n", "nl": "Creates a new UsageException."}
{"code": "public BasicEffect ground(Assignment grounding){\n  return this;\n}\n", "nl": "Returns itself."}
{"code": "public UDPMasterTerminal(){\n}\n", "nl": "Create an uninitialized UDP master connection."}
{"code": "public static void cropAll(String[] strings){\n  for (int i=0; i < strings.length; i++) {\n    String string=strings[i];\n    if (string != null) {\n      string=crop(strings[i]);\n    }\n    strings[i]=string;\n  }\n}\n", "nl": "Crops all elements of string array."}
{"code": "public void updateControllerConnections(IOFSwitchBackend sw,OFControllerRole role1,OFBsnControllerConnectionState state1,String uri1,OFControllerRole role2,OFBsnControllerConnectionState state2,String uri2){\n  OFBsnControllerConnection connection1=factory.buildBsnControllerConnection().setAuxiliaryId(OFAuxId.MAIN).setRole(role1).setState(state1).setUri(uri1).build();\n  OFBsnControllerConnection connection2=factory.buildBsnControllerConnection().setAuxiliaryId(OFAuxId.MAIN).setRole(role2).setState(state2).setUri(uri2).build();\n  List<OFBsnControllerConnection> connections=new ArrayList<OFBsnControllerConnection>();\n  connections.add(connection1);\n  connections.add(connection2);\n  OFBsnControllerConnectionsReply reply=factory.buildBsnControllerConnectionsReply().setConnections(connections).build();\n  sw.updateControllerConnections(reply);\n}\n", "nl": "Helper to load controller connection messages into a switch for testing."}
{"code": "@Override public void draw(){\n  background(0);\n  stereoPosition(cameraPositionX,cameraPositionY,cameraPositionZ,0f,0f,-1f,0f,1f,0f);\n}\n", "nl": "Processing draw function. Called before drawLeft and drawRight."}
{"code": "public URI(String scheme,String host,String path,String fragment) throws URISyntaxException {\n  this(scheme,null,host,-1,path,null,fragment);\n}\n", "nl": "Creates a new URI instance of the given unencoded component parts."}
{"code": "public Label(double... c){\n  this(coordToString(c),AbstractDrawer.DEFAULT_COLOR,c);\n}\n", "nl": "show coord itself"}
{"code": "private void scaleStmt(ColumnFormat cf) throws ParserException, IOException {\n  match(SCALE);\n  Token t=matchOne(scaleKeyWords);\n  cf.setScale(Scale.toScale(t.sval));\n  String scaleString=t.sval;\n  log(pdebug,\"Parsed: scale -> \" + scaleString);\n}\n", "nl": "scalestmt -> 'scale' scalespec scalespec -> <see above scaleTerminals array>"}
{"code": "public double predicted(){\n  return m_Predicted;\n}\n", "nl": "Gets the predicted class value."}
{"code": "@DSSafe(DSCat.SAFE_LIST) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:56:47.056 -0500\",hash_original_method=\"61478AA9F56747991020142C67580FB8\",hash_generated_method=\"F44C74B35137AEFCC17E0B0D490721CE\") @Override public synchronized void reset() throws IOException {\n  in.reset();\n}\n", "nl": "Resets this stream to the last marked location. This implementation resets the target stream."}
{"code": "public IteratorSpliterator(Iterator<? extends T> iterator,int characteristics){\n  this.collection=null;\n  this.it=iterator;\n  this.est=Long.MAX_VALUE;\n  this.characteristics=characteristics & ~(Spliterator.SIZED | Spliterator.SUBSIZED);\n}\n", "nl": "Creates a spliterator using the given iterator for traversal, and reporting the given initial size and characteristics."}
{"code": "public static String[] toStringArray(Array array,String defaultValue){\n  String[] arr=new String[array.size()];\n  for (int i=0; i < arr.length; i++) {\n    arr[i]=Caster.toString(array.get(i + 1,defaultValue),defaultValue);\n  }\n  return arr;\n}\n", "nl": "cast a Object Array to a String Array"}
{"code": "protected Texture updateTextureWithSubImage(DrawContext dc,Rectangle rect){\n  Texture texture=this.getTexture(dc);\n  if (texture == null) {\n    String msg=Logging.getMessage(\"nullValue.TextureIsNull\");\n    Logging.logger().warning(msg);\n    return null;\n  }\n  if (!this.isUseMipMaps() || texture.isUsingAutoMipmapGeneration()) {\n    BufferedImage backingImage=(BufferedImage)this.rectPacker.getBackingStore();\n    BufferedImage subImage=backingImage.getSubimage(rect.x,rect.y,rect.width,rect.height);\n    GL gl=dc.getGL();\n    TextureData subTextureData=AWTTextureIO.newTextureData(gl.getGLProfile(),subImage,false);\n    texture.updateSubImage(gl,subTextureData,0,rect.x,rect.y);\n  }\n else {\n    BufferedImage backingImage=(BufferedImage)this.rectPacker.getBackingStore();\n    GL gl=dc.getGL();\n    texture.updateImage(gl,AWTTextureIO.newTextureData(gl.getGLProfile(),backingImage,this.isUseMipMaps()));\n    this.setTextureParameters(dc);\n  }\n  return texture;\n}\n", "nl": "Loads a sub-region of this texture atlas' backing image into its OpenGL texture. This does nothing and returns code <code>null</code> if this texture atlas' does not have an OpenGL texture."}
{"code": "public void rotateY(double degrees){\n  Transform3D other=new Transform3D();\n  other.rotY(degrees * Math.PI / 180);\n  transform(other);\n}\n", "nl": "Modifies the global model transform by rotating along the current Y axis the provided number of degrees."}
{"code": "public static long doubleToLong(double value){\n  return (long)(value / DEGREE_TOLERANCE);\n}\n", "nl": "Function used to convert an angle in degrees to its internal, fixed-precision long representation. Intended for library use only."}
{"code": "public @CheckReturnValue boolean containsProperty(T prop){\n  return map.keySet().contains(prop);\n}\n", "nl": "Return whether or not the set contains the given WarningProperty."}
{"code": "private CGlobalEdgeCommentSynchronizer(){\n}\n", "nl": "You are not supposed to instantiate this class."}
{"code": "protected void assertAsCollection(Object collectionObject,int count){\n  Collection collection=DefaultTypeTransformation.asCollection(collectionObject);\n  assertTrue(\"Collection is not null\",collection != null);\n  assertEquals(\"Collection size\",count,collection.size());\n  assertIterator(\"collections iterator\",collection.iterator(),count);\n  assertIterator(\"InvokerHelper.asIterator\",InvokerHelper.asIterator(collectionObject),count);\n  assertIterator(\"InvokerHelper.asIterator(InvokerHelper.asCollection)\",InvokerHelper.asIterator(collection),count);\n  assertIterator(\"InvokerHelper.asIterator(InvokerHelper.asIterator)\",InvokerHelper.asIterator(InvokerHelper.asIterator(collectionObject)),count);\n}\n", "nl": "Asserts that the given object can be converted into a collection and iterator of the given size"}
{"code": "private void readResponseHeaders(State state,InnerState innerState,HttpResponse response) throws StopRequest {\n  Header header=response.getFirstHeader(\"Content-Disposition\");\n  if (header != null) {\n    innerState.mHeaderContentDisposition=header.getValue();\n  }\n  header=response.getFirstHeader(\"Content-Location\");\n  if (header != null) {\n    innerState.mHeaderContentLocation=header.getValue();\n  }\n  header=response.getFirstHeader(\"ETag\");\n  if (header != null) {\n    innerState.mHeaderETag=header.getValue();\n  }\n  String headerTransferEncoding=null;\n  header=response.getFirstHeader(\"Transfer-Encoding\");\n  if (header != null) {\n    headerTransferEncoding=header.getValue();\n  }\n  String headerContentType=null;\n  header=response.getFirstHeader(\"Content-Type\");\n  if (header != null) {\n    headerContentType=header.getValue();\n    if (!headerContentType.equals(\"application/vnd.android.obb\")) {\n      throw new StopRequest(DownloaderService.STATUS_FILE_DELIVERED_INCORRECTLY,\"file delivered with incorrect Mime type\");\n    }\n  }\n  if (headerTransferEncoding == null) {\n    header=response.getFirstHeader(\"Content-Length\");\n    if (header != null) {\n      innerState.mHeaderContentLength=header.getValue();\n      long contentLength=Long.parseLong(innerState.mHeaderContentLength);\n      if (contentLength != -1 && contentLength != mInfo.mTotalBytes) {\n        Log.e(Constants.TAG,\"Incorrect file size delivered.\");\n      }\n    }\n  }\n else {\n    if (Constants.LOGVV) {\n      Log.v(Constants.TAG,\"ignoring content-length because of xfer-encoding\");\n    }\n  }\n  if (Constants.LOGVV) {\n    Log.v(Constants.TAG,\"Content-Disposition: \" + innerState.mHeaderContentDisposition);\n    Log.v(Constants.TAG,\"Content-Length: \" + innerState.mHeaderContentLength);\n    Log.v(Constants.TAG,\"Content-Location: \" + innerState.mHeaderContentLocation);\n    Log.v(Constants.TAG,\"ETag: \" + innerState.mHeaderETag);\n    Log.v(Constants.TAG,\"Transfer-Encoding: \" + headerTransferEncoding);\n  }\n  boolean noSizeInfo=innerState.mHeaderContentLength == null && (headerTransferEncoding == null || !headerTransferEncoding.equalsIgnoreCase(\"chunked\"));\n  if (noSizeInfo) {\n    throw new StopRequest(DownloaderService.STATUS_HTTP_DATA_ERROR,\"can't know size of download, giving up\");\n  }\n}\n", "nl": "Read headers from the HTTP response and store them into local state."}
{"code": "public String readString(int length) throws IOException {\n  byte[] array=new byte[length];\n  readFully(array);\n  String s=new String(array);\n  return s.trim();\n}\n", "nl": "Constructs a string from the underlying input stream"}
{"code": "public TextOutputCallback(int messageType,String message){\n  if ((messageType != INFORMATION && messageType != WARNING && messageType != ERROR) || message == null || message.length() == 0)   throw new IllegalArgumentException();\n  this.messageType=messageType;\n  this.message=message;\n}\n", "nl": "Construct a TextOutputCallback with a message type and message to be displayed. <p>"}
{"code": "@DSSafe(DSCat.SAFE_OTHERS) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:32:41.939 -0500\",hash_original_method=\"24BC54E57520E50B51FEB9301490242D\",hash_generated_method=\"FAE9CEF2DB2F0021A995BEA229699877\") public JWebCoreJavaBridge(){\n  nativeConstructor();\n}\n", "nl": "Construct a new JWebCoreJavaBridge to interface with WebCore timers and cookies."}
{"code": "public boolean isCallableConstructor(){\n  final EObject parent=this.eContainer();\n  boolean _xifexpression=false;\n  if ((parent instanceof ContainerType<?>)) {\n    TMethod _callableCtor=((ContainerType<?>)parent).getCallableCtor();\n    _xifexpression=(_callableCtor == this);\n  }\n else {\n    _xifexpression=false;\n  }\n  return _xifexpression;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public final double min(){\n  double min=Double.POSITIVE_INFINITY;\n  double[][] fieldx=null;\n  double[] fieldxy=null;\n  final int width=this.width;\n  final int height=this.height;\n  final int length=this.length;\n  for (int x=0; x < width; x++) {\n    fieldx=field[x];\n    for (int y=0; y < height; y++) {\n      fieldxy=fieldx[y];\n      for (int z=0; z < length; z++)       if (min > fieldxy[z])       min=fieldxy[z];\n    }\n  }\n  return min;\n}\n", "nl": "Returns the minimum value stored in the grid"}
{"code": "public static Date round(final Date date,final int field){\n  if (date == null) {\n    throw new IllegalArgumentException(\"The date must not be null\");\n  }\n  final Calendar gval=Calendar.getInstance();\n  gval.setTime(date);\n  modify(gval,field,ModifyType.ROUND);\n  return gval.getTime();\n}\n", "nl": "<p>Rounds a date, leaving the field specified as the most significant field.</p> <p>For example, if you had the date-time of 28 Mar 2002 13:45:01.231, if this was passed with HOUR, it would return 28 Mar 2002 14:00:00.000. If this was passed with MONTH, it would return 1 April 2002 0:00:00.000.</p> <p>For a date in a timezone that handles the change to daylight saving time, rounding to Calendar.HOUR_OF_DAY will behave as follows. Suppose daylight saving time begins at 02:00 on March 30. Rounding a  date that crosses this time would produce the following values: </p> <ul> <li>March 30, 2003 01:10 rounds to March 30, 2003 01:00</li> <li>March 30, 2003 01:40 rounds to March 30, 2003 03:00</li> <li>March 30, 2003 02:10 rounds to March 30, 2003 03:00</li> <li>March 30, 2003 02:40 rounds to March 30, 2003 04:00</li> </ul>"}
{"code": "@Override protected AdminResponse createResponse(DistributionManager dm){\n  return SubRegionResponse.create(dm,this.getSender(),this.getRegion(dm.getSystem()));\n}\n", "nl": "Must return a proper response to this request."}
{"code": "public static void load(final NiFiProperties properties) throws IOException, ClassNotFoundException {\n  if (initialized.getAndSet(true)) {\n    throw new IllegalStateException(\"Extensions class loaders have already been loaded.\");\n  }\n  final ClassLoader systemClassLoader=ClassLoader.getSystemClassLoader();\n  ClassLoader currentContextClassLoader=Thread.currentThread().getContextClassLoader();\n  final Map<String,ClassLoader> extensionDirectoryClassLoaderLookup=new LinkedHashMap<>();\n  final Map<String,ClassLoader> narIdClassLoaderLookup=new HashMap<>();\n  final File frameworkWorkingDirectory=properties.getFrameworkWorkingDirectory();\n  final File extensionsWorkingDirectory=properties.getExtensionsWorkingDirectory();\n  FileUtils.ensureDirectoryExistAndCanAccess(frameworkWorkingDirectory);\n  FileUtils.ensureDirectoryExistAndCanAccess(extensionsWorkingDirectory);\n  final List<File> narWorkingDirContents=new ArrayList<>();\n  final File[] frameworkWorkingDirContents=frameworkWorkingDirectory.listFiles();\n  if (frameworkWorkingDirContents != null) {\n    narWorkingDirContents.addAll(Arrays.asList(frameworkWorkingDirContents));\n  }\n  final File[] extensionsWorkingDirContents=extensionsWorkingDirectory.listFiles();\n  if (extensionsWorkingDirContents != null) {\n    narWorkingDirContents.addAll(Arrays.asList(extensionsWorkingDirContents));\n  }\n  if (!narWorkingDirContents.isEmpty()) {\n    final List<NarDetails> narDetails=new ArrayList<>();\n    for (    final File unpackedNar : narWorkingDirContents) {\n      final NarDetails narDetail=getNarDetails(unpackedNar);\n      if (narDetail.getNarId() == null) {\n        logger.warn(\"No NAR Id found. Skipping: \" + unpackedNar.getAbsolutePath());\n        continue;\n      }\n      narDetails.add(narDetail);\n    }\n    int narCount;\n    do {\n      narCount=narDetails.size();\n      for (final Iterator<NarDetails> narDetailsIter=narDetails.iterator(); narDetailsIter.hasNext(); ) {\n        final NarDetails narDetail=narDetailsIter.next();\n        final String narDependencies=narDetail.getNarDependencyId();\n        ClassLoader narClassLoader=null;\n        if (narDependencies == null) {\n          narClassLoader=createNarClassLoader(narDetail.getNarWorkingDirectory(),currentContextClassLoader);\n        }\n else         if (narIdClassLoaderLookup.containsKey(narDetail.getNarDependencyId())) {\n          narClassLoader=createNarClassLoader(narDetail.getNarWorkingDirectory(),narIdClassLoaderLookup.get(narDetail.getNarDependencyId()));\n        }\n        if (narClassLoader != null) {\n          extensionDirectoryClassLoaderLookup.put(narDetail.getNarWorkingDirectory().getCanonicalPath(),narClassLoader);\n          narIdClassLoaderLookup.put(narDetail.getNarId(),narClassLoader);\n          narDetailsIter.remove();\n        }\n      }\n    }\n while (narCount != narDetails.size());\n    for (    final NarDetails narDetail : narDetails) {\n      logger.warn(String.format(\"Unable to resolve required dependency '%s'. Skipping NAR %s\",narDetail.getNarDependencyId(),narDetail.getNarWorkingDirectory().getAbsolutePath()));\n    }\n  }\n  frameworkClassLoader.set(narIdClassLoaderLookup.get(FRAMEWORK_NAR_ID));\n  extensionClassLoaders.set(new LinkedHashMap<>(extensionDirectoryClassLoaderLookup));\n}\n", "nl": "Loads the extensions class loaders from the specified working directory. Loading is only performed during the initial invocation of load. Subsequent attempts will be ignored."}
{"code": "public CsvInfo(){\n}\n", "nl": "Instantiates a new instance."}
{"code": "public boolean isSummary(){\n  Object oo=get_Value(COLUMNNAME_IsSummary);\n  if (oo != null) {\n    if (oo instanceof Boolean)     return ((Boolean)oo).booleanValue();\n    return \"Y\".equals(oo);\n  }\n  return false;\n}\n", "nl": "Get Summary Level."}
{"code": "public void execute() throws Exception {\n  startUp();\n  generateQueryId();\n  CloseableHttpAsyncClient client=getClient();\n  client.start();\n  Pair<String,InputStream> requestInput=getRequestInput();\n  try (InputStream is=requestInput.getRight()){\n    sentRequest=new Message(is,requestInput.getLeft());\n  }\n   AsyncHttpSender sender=new AsyncHttpSender(client);\n  sender.addHeader(HEADER_HASH_ALGO_ID,DEFAULT_DIGEST_ALGORITHM_ID);\n  requestInput=getRequestInput();\n  try (InputStream is=requestInput.getRight()){\n    for (    Entry<String,String> e : requestHeaders.entrySet()) {\n      sender.addHeader(e.getKey(),e.getValue());\n    }\n    if (\"post\".equalsIgnoreCase(httpMethod)) {\n      sender.doPost(new URI(url),is,CHUNKED_LENGTH,requestInput.getLeft());\n    }\n else {\n      sender.doGet(new URI(url));\n    }\n    sender.waitForResponse(DEFAULT_CLIENT_TIMEOUT);\n  }\n   try {\n    receivedResponse=new Message(sender.getResponseContent(),sender.getResponseContentType());\n    if (sentRequest != null && sentRequest.getSoap() != null && sentRequest.getSoap() instanceof SoapMessageImpl && ((SoapMessageImpl)sentRequest.getSoap()).isAsync() && !requestHeaders.containsKey(SoapUtils.X_IGNORE_ASYNC)) {\n      sentResponse=receivedResponse;\n    }\n  }\n  finally {\n    sender.close();\n    client.close();\n    closeDown();\n  }\n  if (failed) {\n    throw new Exception(\"Test failed in previous stage\");\n  }\n  log.debug(\"Validating SOAP message\\n{}\",receivedResponse.getSoap().getXml());\n  if (receivedResponse.isFault()) {\n    log.debug(\"Validating fault: {}, {}\",((SoapFault)receivedResponse.getSoap()).getCode(),((SoapFault)receivedResponse.getSoap()).getString());\n    validateFaultResponse(receivedResponse);\n    return;\n  }\n  if (!receivedResponse.isResponse()) {\n    throw new Exception(\"Received SOAP message is not a response\");\n  }\n  if (sentResponse != null && !checkConsistency(sentResponse,receivedResponse)) {\n    throw new Exception(\"Received response is not the same as sent response\");\n  }\n  log.debug(\"Validating normal response\");\n  validateNormalResponse(receivedResponse);\n}\n", "nl": "Performs the request and validates the response."}
{"code": "public boolean isInverted(){\n  return lng.isInverted();\n}\n", "nl": "Return true if lng_.lo() > lng_.hi(), i.e. the rectangle crosses the 180 degree latitude line."}
{"code": "private void validateLogicalShardId(final long logicalShardId){\n  if (logicalShardId < MIN_LOGICAL_SHARD_ID || logicalShardId > MAX_LOGICAL_SHARD_ID) {\n    throw new InvalidLogicalShardIdException(\"The logical shard ID set in Redis is less than \" + String.valueOf(MIN_LOGICAL_SHARD_ID) + \" or is greater than the supported maximum of \"+ String.valueOf(MAX_LOGICAL_SHARD_ID));\n  }\n}\n", "nl": "Check that the given logical shard ID is within the bounds that we allow. This is important to check, as otherwise when bit-shifting we may lose digits outside of the bits we care about, introducing possible collisions."}
{"code": "public boolean foo(String x,String y){\n  if (x != null)   return foo_bar0(x);\n else   if (y != null)   return foo_bar1(y);\n else   return false;\n}\n", "nl": "This private method has 4 branches"}
{"code": "public static void ensureOutputDirectory(final File directory){\n  if (!directory.exists()) {\n    if (!directory.mkdirs()) {\n      throw new NoTalkbackSlimException(ErrorType.DIRECTORY_NOT_CREATED,directory.getPath());\n    }\n  }\n else {\n    if (!directory.isDirectory()) {\n      throw new NoTalkbackSlimException(ErrorType.NOT_A_DIRECTORY,directory.getPath());\n    }\n  }\n}\n", "nl": "Test if the supplied directory is valid for the purposes of writing a SLIM result.  This means the directory either exists or does not exist and can be successfully created (which this method will do)."}
{"code": "private static void delete(File f){\n  if (f.isDirectory()) {\n    for (    File c : f.listFiles()) {\n      delete(c);\n    }\n  }\n  if (!f.delete()) {\n    PrintStream err=System.err;\n    err.println(\"Failed to delete file: \" + f);\n  }\n}\n", "nl": "Recursively deletes a file that may represent a directory."}
{"code": "public static void putShortLE(byte[] arr,long off,short val){\n  if (UNALIGNED)   UNSAFE.putShort(arr,off,Short.reverseBytes(val));\n else   putShortByByte(arr,off,val,false);\n}\n", "nl": "Stores short value into byte array assuming that value should be stored in little-endian byte order and native byte order is big-endian. Alignment aware."}
{"code": "public static void incNumWorkers(){\n  incNumWorkers(1);\n}\n", "nl": "Increments the number of workers by 1"}
{"code": "private void buildAddressSelectionPopUp(){\n  final CAddressSelectionDialog dlg=new CAddressSelectionDialog(m_parent,m_modules);\n  dlg.setVisible(true);\n  final INaviModule result=dlg.getSelectionResult();\n  final IAddress address=new CAddress(Long.parseLong(getText(),16));\n  ZyZoomHelpers.zoomToAddress(m_graph,address,result,true);\n}\n", "nl": "In the case of multiple modules zoom to address does not work therefore the user must select in which module to search."}
{"code": "public boolean isFinal(){\n  return ffinal;\n}\n", "nl": "Checks if is final."}
{"code": "protected void writeFormStreamData(OutputStream writer) throws IOException {\n  Set<String> keys=mParamKeyValues.keySet();\n  for (  String key : keys) {\n    List<Object> values=mParamKeyValues.getValues(key);\n    for (    Object value : values) {\n      if (!isCanceled()) {\n        if (value != null && value instanceof String) {\n          if (!(writer instanceof CounterOutputStream))           Logger.i(key + \"=\" + value);\n          writeFormString(writer,key,value.toString());\n        }\n else         if (value != null && value instanceof Binary) {\n          if (!(writer instanceof CounterOutputStream))           Logger.i(key + \" is Binary\");\n          writeFormBinary(writer,key,(Binary)value);\n        }\n        writer.write(\"\\r\\n\".getBytes());\n      }\n    }\n  }\n  writer.write((endBoundary).getBytes());\n}\n", "nl": "Send form data."}
{"code": "public static <E>Set<E> constrainedSet(Set<E> set,Constraint<? super E> constraint){\n  return new ConstrainedSet<E>(set,constraint);\n}\n", "nl": "Returns a constrained view of the specified set, using the specified constraint. Any operations that add new elements to the set will call the provided constraint. However, this method does not verify that existing elements satisfy the constraint. <p>The returned set is not serializable."}
{"code": "private void extractMessages(){\n  Intent lInvokingIntent=getIntent();\n  String lMsgInit=lInvokingIntent.getStringExtra(MSG_INIT);\n  if (lMsgInit != null) {\n    mMsgInit=lMsgInit;\n  }\n  String lMsgDetect=lInvokingIntent.getStringExtra(MSG_DETECT);\n  if (lMsgDetect != null) {\n    mMsgDetect=lMsgDetect;\n  }\n  String lMsgPlaylist=lInvokingIntent.getStringExtra(MSG_PLAYLIST);\n  if (lMsgPlaylist != null) {\n    mMsgPlaylist=lMsgPlaylist;\n  }\n  String lMsgToken=lInvokingIntent.getStringExtra(MSG_TOKEN);\n  if (lMsgToken != null) {\n    mMsgToken=lMsgToken;\n  }\n  String lMsgLoBand=lInvokingIntent.getStringExtra(MSG_LO_BAND);\n  if (lMsgLoBand != null) {\n    mMsgLowBand=lMsgLoBand;\n  }\n  String lMsgHiBand=lInvokingIntent.getStringExtra(MSG_HI_BAND);\n  if (lMsgHiBand != null) {\n    mMsgHiBand=lMsgHiBand;\n  }\n  String lMsgErrTitle=lInvokingIntent.getStringExtra(MSG_ERROR_TITLE);\n  if (lMsgErrTitle != null) {\n    mMsgErrorTitle=lMsgErrTitle;\n  }\n  String lMsgErrMsg=lInvokingIntent.getStringExtra(MSG_ERROR_MSG);\n  if (lMsgErrMsg != null) {\n    mMsgError=lMsgErrMsg;\n  }\n}\n", "nl": "Determine the messages to display during video load and initialization."}
{"code": "private CNameListGenerators(){\n}\n", "nl": "You are not supposed to instantiate this class."}
{"code": "public CCheckBox(Action a){\n  super(a);\n  init();\n}\n", "nl": "Creates a check box where properties are taken from the Action supplied."}
{"code": "public static ZyLabelContent buildContent(final INaviTextNode node){\n  Preconditions.checkNotNull(node,\"IE01700: Node argument can not be null\");\n  final ZyLabelContent content=new ZyLabelContent(null);\n  buildContent(content,node);\n  return content;\n}\n", "nl": "Builds the content of the text node."}
{"code": "protected void layoutSouth(DockWrapper base,int x,int y,int maxwidth,int maxheight){\n  for (Iterator iter=base.getDockedWrappers().iterator(); iter.hasNext(); ) {\n    DockWrapper dw=(DockWrapper)iter.next();\n    Dimension d=dw.getPreferredSize();\n    int w=min(d.width,maxwidth);\n    int h=min(d.height,maxheight);\n    dw.setBounds(x,y - h,w,h);\n    if (!dw.canOcclude()) {\n      updateBottom(backgroundBounds,y - h);\n    }\n    updateBottom(occludingBounds,y - h);\n    layoutSouth(dw,x,y - h,maxwidth,maxheight - h);\n    x+=w;\n    maxwidth-=w;\n  }\n}\n", "nl": "Layout north side."}
{"code": "public void lostOwnership(Clipboard clipboard,Transferable contents){\n}\n", "nl": "Required by the AbstractAction interface; does nothing."}
{"code": "public void cancel(){\n  mCancellationRequested.set(true);\n}\n", "nl": "Cancel operation"}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:59:26.756 -0500\",hash_original_method=\"3F955D64051D380D89135CF7B70C1F05\",hash_generated_method=\"0EC25BC15D68F1E59DA0282A4EDDD537\") public void reqGetReconnectIntent(){\n  Message response=sendMessageSynchronously(REQ_GET_RECONNECT_INTENT);\n  if (DBG)   log(\"reqGetReconnectIntent\");\n}\n", "nl": "Request to get Pending ReconnectIntent to DC. Response RSP_GET_RECONNECT_INTENT when complete."}
{"code": "public void finished(){\n  m_printstream.flush();\n}\n", "nl": "Finalizes output file."}
{"code": "public String encode(){\n  return encode(new StringBuffer()).toString();\n}\n", "nl": "Get the encoded representation of this namevalue object. Added doublequote for encoding doublequoted values. Bug: RFC3261 stipulates that an opaque parameter in authenticate header has to be: opaque              =  \"opaque\" EQUAL quoted-string so returning just the name is not acceptable. (e.g. LinkSys phones are picky about this)"}
{"code": "private void computeSnaps(Collection segStrings,Collection snapPts){\n  for (Iterator i0=segStrings.iterator(); i0.hasNext(); ) {\n    NodedSegmentString ss=(NodedSegmentString)i0.next();\n    computeSnaps(ss,snapPts);\n  }\n}\n", "nl": "Computes nodes introduced as a result of snapping segments to snap points (hot pixels)"}
{"code": "public DotGraph(String graphname){\n  this.graphname=graphname;\n  this.isSubGraph=false;\n  this.nodes=new HashMap<String,DotGraphNode>(100);\n  this.drawElements=new LinkedList<Renderable>();\n  this.attributes=new LinkedList<DotGraphAttribute>();\n}\n", "nl": "Creates a new graph for drawing."}
{"code": "public static LayersBuilder with(Layer... layers){\n  return new LayersBuilder(Arrays.asList(layers));\n}\n", "nl": "Returns a new LayersBuilder with all the provided layers included."}
{"code": "@DSComment(\"Layout info\") @DSSafe(DSCat.DATA_STRUCTURE) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:31:46.937 -0500\",hash_original_method=\"E6336A158C939972C1CFCFE234B123CF\",hash_generated_method=\"77CD180C6E32DEBAEFF64B715469A756\") public void addRule(int verb,int anchor){\n  mRules[verb]=anchor;\n}\n", "nl": "Adds a layout rule to be interpreted by the RelativeLayout. Use this for verbs that take a target, such as a sibling (ALIGN_RIGHT) or a boolean value (VISIBLE)."}
{"code": "private void updateProgress(String progressLabel,int progress){\n  if (myHost != null && ((progress != previousProgress) || (!progressLabel.equals(previousProgressLabel)))) {\n    myHost.updateProgress(progressLabel,progress);\n  }\n  previousProgress=progress;\n  previousProgressLabel=progressLabel;\n}\n", "nl": "Used to communicate a progress update between a plugin tool and the main Whitebox user interface."}
{"code": "private Finalizer(Class<?> finalizableReferenceClass,ReferenceQueue<Object> queue,PhantomReference<Object> frqReference){\n  this.queue=queue;\n  this.finalizableReferenceClassReference=new WeakReference<Class<?>>(finalizableReferenceClass);\n  this.frqReference=frqReference;\n}\n", "nl": "Constructs a new finalizer thread."}
{"code": "void dispose(){\n  stroking=0;\n  if (!USE_CACHE_HARD_REF) {\n    hardRefArrayCaches=null;\n  }\n  if (dirty) {\n    this.nPCPathIterator.dispose();\n    this.nPQPathIterator.dispose();\n    this.dasher.dispose();\n    this.stroker.dispose();\n    dirty=false;\n  }\n}\n", "nl": "Disposes this renderer context: clean up before reusing this context"}
{"code": "@Override public String toString(){\n  StringBuilder result=new StringBuilder();\n  result.append(\"Token[\");\nswitch (ttype) {\ncase TT_EOF:\n    result.append(\"EOF\");\n  break;\ncase TT_EOL:\nresult.append(\"EOL\");\nbreak;\ncase TT_NUMBER:\nresult.append(\"n=\");\nresult.append(nval);\nbreak;\ncase TT_WORD:\nresult.append(sval);\nbreak;\ndefault :\nif (ttype == TT_UNKNOWN || tokenTypes[ttype] == TOKEN_QUOTE) {\nresult.append(sval);\n}\n else {\nresult.append('\\'');\nresult.append((char)ttype);\nresult.append('\\'');\n}\n}\nresult.append(\"], line \");\nresult.append(lineNumber);\nreturn result.toString();\n}\n", "nl": "Returns the state of this tokenizer in a readable format."}
{"code": "public ConstExpConstModel(Parameter N0Parameter,Parameter N1Parameter,Parameter growthRateParameter,Parameter timeParameter,Parameter epochParameter,boolean useNumericalIntegrator,Type units){\n  this(ConstExpConstModelParser.CONST_EXP_CONST_MODEL,N0Parameter,N1Parameter,growthRateParameter,timeParameter,epochParameter,useNumericalIntegrator,units);\n}\n", "nl": "Construct demographic model with default settings"}
{"code": "public void put(String key,File files[]) throws FileNotFoundException {\n  put(key,files,null,null);\n}\n", "nl": "Adds files array to the request."}
{"code": "public void testMoveRenameFileSourceAndDestinationMissingPartially() throws Exception {\n  create(igfsSecondary,paths(DIR,SUBDIR,DIR_NEW,SUBDIR_NEW),paths(FILE));\n  create(igfs,paths(DIR,DIR_NEW),null);\n  igfs.rename(FILE,FILE_NEW);\n  checkExist(igfs,SUBDIR,SUBDIR_NEW);\n  checkExist(igfs,igfsSecondary,FILE_NEW);\n  checkNotExist(igfs,igfsSecondary,FILE);\n}\n", "nl": "Test move and rename in case source and destination exist partially and the path being renamed is a file."}
{"code": "public static int encode(byte[] data,OutputStream out) throws IOException {\n  return encoder.encode(data,0,data.length,out);\n}\n", "nl": "Encode the byte data to base 64 writing it to the given output stream."}
{"code": "protected boolean parseNameTest(PsiBuilder builder){\n  if (builder.getTokenType() == XPathTokenTypes.STAR) {\n    return parseWildcard(builder);\n  }\n else   if (builder.getTokenType() == XPathTokenTypes.NCNAME) {\n    builder.advanceLexer();\n    if (builder.getTokenType() == XPathTokenTypes.COL) {\n      builder.advanceLexer();\n      if (builder.getTokenType() != XPathTokenTypes.STAR) {\n        if (builder.getTokenType() != XPathTokenTypes.NCNAME) {\n          builder.error(\"* or NCName expected\");\n        }\n else {\n          builder.advanceLexer();\n        }\n      }\n else {\n        builder.advanceLexer();\n      }\n    }\n    return true;\n  }\n  return false;\n}\n", "nl": "[37]    NameTest    ::=    '*' | NCName ':' '*' | QName"}
{"code": "private void deleteConfig(HttpServletRequest request,InstructionalOfferingConfigEditForm frm) throws Exception {\n  org.hibernate.Session hibSession=null;\n  Transaction tx=null;\n  try {\n    InstrOfferingConfigDAO iocDao=new InstrOfferingConfigDAO();\n    hibSession=iocDao.getSession();\n    tx=hibSession.beginTransaction();\n    Long configId=frm.getConfigId();\n    InstrOfferingConfig ioc=iocDao.get(configId);\n    InstructionalOffering io=ioc.getInstructionalOffering();\n    deleteSubpart(request,hibSession,ioc,new HashMap());\n    io.removeConfiguration(ioc);\n    io.computeLabels(hibSession);\n    if (!ioc.isUnlimitedEnrollment().booleanValue())     io.setLimit(new Integer(io.getLimit().intValue() - ioc.getLimit().intValue()));\n    ChangeLog.addChange(hibSession,sessionContext,io,io.getCourseName() + \" [\" + ioc.getName()+ \"]\",ChangeLog.Source.INSTR_CFG_EDIT,ChangeLog.Operation.DELETE,io.getControllingCourseOffering().getSubjectArea(),null);\n    Event.deleteFromEvents(hibSession,ioc);\n    Exam.deleteFromExams(hibSession,ioc);\n    hibSession.saveOrUpdate(io);\n    String className=ApplicationProperty.ExternalActionInstrOffrConfigChange.value();\n    ExternalInstrOffrConfigChangeAction configChangeAction=null;\n    if (className != null && className.trim().length() > 0) {\n      configChangeAction=(ExternalInstrOffrConfigChangeAction)(Class.forName(className).newInstance());\n      if (!configChangeAction.validateConfigChangeCanOccur(io,hibSession)) {\n        throw new Exception(\"Configuration change violates rules for Add On, rolling back the change.\");\n      }\n    }\n    hibSession.flush();\n    tx.commit();\n    hibSession.refresh(io);\n    if (configChangeAction != null) {\n      configChangeAction.performExternalInstrOffrConfigChangeAction(io,hibSession);\n    }\n  }\n catch (  Exception e) {\n    try {\n      if (tx != null && tx.isActive())       tx.rollback();\n    }\n catch (    Exception e1) {\n    }\n    Debug.error(e);\n    throw (e);\n  }\n}\n", "nl": "Deletes configuration and associated prefs"}
{"code": "private void loadProfile(String userId,String name){\n  final Intent userProfileIntent=new Intent(getActivity(),UserProfileActivity.class);\n  userProfileIntent.putExtra(AppConstants.Keys.USER_ID,userId);\n  userProfileIntent.putExtra(AppConstants.Keys.USER_NAME,name);\n  userProfileIntent.putExtra(AppConstants.Keys.SERVICE_SCREEN_TYPE,AppConstants.ServiceScreenType.PROFILE);\n  startActivity(userProfileIntent);\n}\n", "nl": "This loads the profile of the user"}
{"code": "int doFinal(byte[] input,int inputOffset,int inputLen,byte[] output,int outputOffset) throws ShortBufferException, IllegalBlockSizeException, BadPaddingException {\n  return cipher.doFinal(input,inputOffset,inputLen,output,outputOffset);\n}\n", "nl": "Encrypts or decrypts data in a single-part operation, or finishes a multiple-part operation. The data is encrypted or decrypted, depending on how this cipher was initialized. <p>The first <code>inputLen</code> bytes in the <code>input</code> buffer, starting at <code>inputOffset</code>, and any input bytes that may have been buffered during a previous <code>update</code> operation, are processed, with padding (if requested) being applied. The result is stored in the <code>output</code> buffer, starting at <code>outputOffset</code>. <p>The cipher is reset to its initial state (uninitialized) after this call."}
{"code": "public boolean isOverwriteMode(){\n  return !isInserting;\n}\n", "nl": "Tells whether the input is in overwrite or insert mode"}
{"code": "private void writeAttribute(java.lang.String prefix,java.lang.String namespace,java.lang.String attName,java.lang.String attValue,javax.xml.stream.XMLStreamWriter xmlWriter) throws javax.xml.stream.XMLStreamException {\n  if (xmlWriter.getPrefix(namespace) == null) {\n    xmlWriter.writeNamespace(prefix,namespace);\n    xmlWriter.setPrefix(prefix,namespace);\n  }\n  xmlWriter.writeAttribute(namespace,attName,attValue);\n}\n", "nl": "Util method to write an attribute with the ns prefix"}
{"code": "public javax.naming.Binding nextElement(){\n  try {\n    return next();\n  }\n catch (  NamingException ne) {\n    throw new NoSuchElementException();\n  }\n}\n", "nl": "Returns the next binding in the list."}
{"code": "public static void i(String tag,String msg,Object... args){\n  if (sLevel > LEVEL_INFO) {\n    return;\n  }\n  if (args.length > 0) {\n    msg=String.format(msg,args);\n  }\n  Log.i(tag,msg);\n}\n", "nl": "Send an INFO log message"}
{"code": "public void cancel(){\n  cancelled=true;\n}\n", "nl": "Since cancel is async, it just means that we will eventually, and rather quickly, stop emitting values. We do this to follow the reactive streams specifications that cancel should mean that the observable eventually stops emitting items."}
{"code": "public void findAndInit(Object someObj){\n  super.findAndInit(someObj);\n  if (someObj instanceof MapBean || someObj instanceof InformationDelegator) {\n    drawingTool.findAndInit(someObj);\n  }\n  if (someObj instanceof MouseDelegator) {\n    setMouseDelegator((MouseDelegator)someObj);\n    drawingTool.findAndInit(someObj);\n  }\n  if (someObj instanceof OMGraphicDeleteTool) {\n    ((OMGraphicDeleteTool)someObj).findAndInit(getDrawingTool());\n  }\n}\n", "nl": "Called by findAndInit(Iterator) so subclasses can find objects, too."}
{"code": "public PaymentGatewayPayPoint(){\n  System.setProperty(\"java.protocol.handler.pkgs\",\"com.sun.net.ssl.internal.www.protocol\");\n  Security.addProvider(new com.sun.net.ssl.internal.ssl.Provider());\n  m_sCommerceID=AppConfig.getInstance().getProperty(\"payment.commerceid\");\n  AltEncrypter cypher=new AltEncrypter(\"cypherkey\" + AppConfig.getInstance().getProperty(\"payment.commerceid\"));\n  this.m_sCommercePassword=cypher.decrypt(AppConfig.getInstance().getProperty(\"payment.commercepassword\").substring(6));\n  m_bTestMode=AppConfig.getInstance().getBoolean(\"payment.testmode\");\n  m_sCurrency=(Locale.getDefault().getCountry().isEmpty()) ? Currency.getInstance(\"EUR\").getCurrencyCode() : Currency.getInstance(Locale.getDefault()).getCurrencyCode();\n}\n", "nl": "Creates a new instance of PaymentGatewaySECPay"}
{"code": "public void init() throws IOException {\n  mailbox.connect();\n  this.initialized=true;\n}\n", "nl": "Connects to Gmail and loads the base information required for the sync."}
{"code": "protected POInfo initPO(Properties ctx){\n  POInfo poi=POInfo.getPOInfo(ctx,Table_ID,get_TrxName());\n  return poi;\n}\n", "nl": "Load Meta Data"}
{"code": "@Override protected EClass eStaticClass(){\n  return TypeRefsPackage.Literals.TYPE_REF;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public final Exercise.Type type(){\n  return type;\n}\n", "nl": "Returns the exercise type"}
{"code": "@Override public void run(){\n  amIActive=true;\n  String inputHeader=null;\n  String outputHeader=null;\n  int row, col;\n  float progress=0;\n  double z, z2, zMin;\n  int x, y, a, b, i;\n  double h=0;\n  int whichCell;\n  double infVal=9999999;\n  int[] dX=new int[]{-1,-1,0,1,1,1,0,-1};\n  int[] dY=new int[]{0,-1,-1,-1,0,1,1,1};\n  int[] Gx=new int[]{1,1,0,1,1,1,0,1};\n  int[] Gy=new int[]{0,1,1,1,0,1,1,1};\n  double gridRes;\n  if (args.length <= 0) {\n    showFeedback(\"Plugin parameters have not been set.\");\n    return;\n  }\n  inputHeader=args[0];\n  outputHeader=args[1];\n  if ((inputHeader == null) || (outputHeader == null)) {\n    showFeedback(\"One or more of the input parameters have not been set properly.\");\n    return;\n  }\n  try {\n    WhiteboxRaster image=new WhiteboxRaster(inputHeader,\"r\");\n    int rows=image.getNumberRows();\n    int cols=image.getNumberColumns();\n    double noData=image.getNoDataValue();\n    gridRes=(image.getCellSizeX() + image.getCellSizeY()) / 2;\n    WhiteboxRaster outputImage=new WhiteboxRaster(outputHeader,\"rw\",inputHeader,WhiteboxRaster.DataType.FLOAT,infVal);\n    outputImage.setPreferredPalette(\"spectrum.pal\");\n    WhiteboxRaster Rx=new WhiteboxRaster(outputHeader.replace(\".dep\",\"_temp1.dep\"),\"rw\",inputHeader,WhiteboxRaster.DataType.FLOAT,0);\n    Rx.isTemporaryFile=true;\n    WhiteboxRaster Ry=new WhiteboxRaster(outputHeader.replace(\".dep\",\"_temp2.dep\"),\"rw\",inputHeader,WhiteboxRaster.DataType.FLOAT,0);\n    Ry.isTemporaryFile=true;\n    double[] data;\n    for (row=0; row < rows; row++) {\n      data=image.getRowValues(row);\n      for (col=0; col < cols; col++) {\n        if (data[col] != 0) {\n          outputImage.setValue(row,col,0);\n        }\n      }\n      if (cancelOp) {\n        cancelOperation();\n        return;\n      }\n      progress=(float)(100f * row / (rows - 1));\n      updateProgress((int)progress);\n    }\n    for (row=0; row < rows; row++) {\n      for (col=0; col < cols; col++) {\n        z=outputImage.getValue(row,col);\n        if (z != 0) {\n          zMin=infVal;\n          whichCell=-1;\n          for (i=0; i <= 3; i++) {\n            x=col + dX[i];\n            y=row + dY[i];\n            z2=outputImage.getValue(y,x);\n            if (z2 != noData) {\nswitch (i) {\ncase 0:\n                h=2 * Rx.getValue(y,x) + 1;\n              break;\ncase 1:\n            h=2 * (Rx.getValue(y,x) + Ry.getValue(y,x) + 1);\n          break;\ncase 2:\n        h=2 * Ry.getValue(y,x) + 1;\n      break;\ncase 3:\n    h=2 * (Rx.getValue(y,x) + Ry.getValue(y,x) + 1);\n  break;\n}\nz2+=h;\nif (z2 < zMin) {\nzMin=z2;\nwhichCell=i;\n}\n}\n}\nif (zMin < z) {\noutputImage.setValue(row,col,zMin);\nx=col + dX[whichCell];\ny=row + dY[whichCell];\nRx.setValue(row,col,Rx.getValue(y,x) + Gx[whichCell]);\nRy.setValue(row,col,Ry.getValue(y,x) + Gy[whichCell]);\n}\n}\n}\nif (cancelOp) {\ncancelOperation();\nreturn;\n}\nprogress=(float)(100f * row / (rows - 1));\nupdateProgress((int)progress);\n}\nfor (row=rows - 1; row >= 0; row--) {\nfor (col=cols - 1; col >= 0; col--) {\nz=outputImage.getValue(row,col);\nif (z != 0) {\nzMin=infVal;\nwhichCell=-1;\nfor (i=4; i <= 7; i++) {\nx=col + dX[i];\ny=row + dY[i];\nz2=outputImage.getValue(y,x);\nif (z2 != noData) {\nswitch (i) {\ncase 5:\nh=2 * (Rx.getValue(y,x) + Ry.getValue(y,x) + 1);\nbreak;\ncase 4:\nh=2 * Rx.getValue(y,x) + 1;\nbreak;\ncase 6:\nh=2 * Ry.getValue(y,x) + 1;\nbreak;\ncase 7:\nh=2 * (Rx.getValue(y,x) + Ry.getValue(y,x) + 1);\nbreak;\n}\nz2+=h;\nif (z2 < zMin) {\nzMin=z2;\nwhichCell=i;\n}\n}\n}\nif (zMin < z) {\noutputImage.setValue(row,col,zMin);\nx=col + dX[whichCell];\ny=row + dY[whichCell];\nRx.setValue(row,col,Rx.getValue(y,x) + Gx[whichCell]);\nRy.setValue(row,col,Ry.getValue(y,x) + Gy[whichCell]);\n}\n}\n}\nif (cancelOp) {\ncancelOperation();\nreturn;\n}\nprogress=(float)(100f * (rows - 1 - row) / (rows - 1));\nupdateProgress((int)progress);\n}\nfor (row=0; row < rows; row++) {\nfor (col=0; col < cols; col++) {\nz=image.getValue(row,col);\nif (z != noData) {\nz=outputImage.getValue(row,col);\noutputImage.setValue(row,col,Math.sqrt(z) * gridRes);\n}\n else {\noutputImage.setValue(row,col,noData);\n}\n}\nif (cancelOp) {\ncancelOperation();\nreturn;\n}\nprogress=(float)(100f * row / (rows - 1));\nupdateProgress((int)progress);\n}\noutputImage.addMetadataEntry(\"Created by the \" + getDescriptiveName() + \" tool.\");\noutputImage.addMetadataEntry(\"Created on \" + new Date());\nimage.close();\noutputImage.close();\nRx.close();\nRy.close();\nreturnData(outputHeader);\n}\n catch (OutOfMemoryError oe) {\nmyHost.showFeedback(\"An out-of-memory error has occurred during operation.\");\n}\ncatch (Exception e) {\nmyHost.showFeedback(\"An error has occurred during operation. See log file for details.\");\nmyHost.logException(\"Error in \" + getDescriptiveName(),e);\n}\n finally {\nupdateProgress(\"Progress: \",0);\namIActive=false;\nmyHost.pluginComplete();\n}\n}\n", "nl": "Used to execute this plugin tool."}
{"code": "public JavaType constructSimpleType(Class<?> rawType,JavaType[] parameterTypes){\n  TypeVariable<?>[] typeVars=rawType.getTypeParameters();\n  if (typeVars.length != parameterTypes.length) {\n    throw new IllegalArgumentException(\"Parameter type mismatch for \" + rawType.getName() + \": expected \"+ typeVars.length+ \" parameters, was given \"+ parameterTypes.length);\n  }\n  String[] names=new String[typeVars.length];\n  for (int i=0, len=typeVars.length; i < len; ++i) {\n    names[i]=typeVars[i].getName();\n  }\n  JavaType resultType=new SimpleType(rawType,names,parameterTypes,null,null);\n  return resultType;\n}\n", "nl": "Method for constructing a type instance with specified parameterization."}
{"code": "@Override public void entityChanged(final Object property){\n  super.entityChanged(property);\n  if (property == Chest.PROP_OPEN) {\n    proceedChangedState(entity);\n    openChanged=true;\n  }\n}\n", "nl": "An entity was changed."}
{"code": "public DragGestureRecognizer createDefaultDragGestureRecognizer(Component c,int actions,DragGestureListener dgl){\n  return Toolkit.getDefaultToolkit().createDragGestureRecognizer(MouseDragGestureRecognizer.class,this,c,actions,dgl);\n}\n", "nl": "Creates a new <code>DragGestureRecognizer</code> that implements the default abstract subclass of <code>DragGestureRecognizer</code> for this <code>DragSource</code>, and sets the specified <code>Component</code> and <code>DragGestureListener</code> on the newly created object. For this <code>DragSource</code> the default is <code>MouseDragGestureRecognizer</code>. <P>"}
{"code": "public PipedReader(PipedWriter src) throws IOException {\n  this(src,DEFAULT_PIPE_SIZE);\n}\n", "nl": "Creates a <code>PipedReader</code> so that it is connected to the piped writer <code>src</code>. Data written to <code>src</code> will then be available as input from this stream."}
{"code": "public static File ensureLogDirectoryExists(){\n  if (mLogDirectory == null) {\n    return null;\n  }\n  if (!mLogDirectory.exists()) {\n    mLogDirectory.mkdirs();\n  }\n  return mLogDirectory;\n}\n", "nl": "Check if the log directory exists. Create it if it s not created"}
{"code": "public String stem(String s){\n  if (stem(s.toCharArray(),s.length()))   return toString();\n else   return s;\n}\n", "nl": "Stem a word provided as a String.  Returns the result as a String."}
{"code": "protected boolean err(){\n  return status != STATUS_OK;\n}\n", "nl": "Returns true if an error was encountered during reading/decoding"}
{"code": "public DeleteRequest parent(String parent){\n  if (routing == null) {\n    routing=parent;\n  }\n  return this;\n}\n", "nl": "Sets the parent id of this document. Will simply set the routing to this value, as it is only used for routing with delete requests."}
{"code": "public AndQueryBuilder add(QueryBuilder filterBuilder){\n  filters.add(filterBuilder);\n  return this;\n}\n", "nl": "Adds a filter to the list of filters to \"and\"."}
{"code": "public static boolean match(String s,String... sa){\n  for (  String st : sa) {\n    if (st.equalsIgnoreCase(s))     return true;\n  }\n  return false;\n}\n", "nl": "Checks if any of the strings from the given array matches the given string"}
{"code": "public static void text(double x,double y,String text){\n  if (text == null)   throw new NullPointerException();\n  offscreen.setFont(font);\n  FontMetrics metrics=offscreen.getFontMetrics();\n  double xs=scaleX(x);\n  double ys=scaleY(y);\n  int ws=metrics.stringWidth(text);\n  int hs=metrics.getDescent();\n  offscreen.drawString(text,(float)(xs - ws / 2.0),(float)(ys + hs));\n  draw();\n}\n", "nl": "Write the given text string in the current font, centered at (<em>x</em>, <em>y</em>)."}
{"code": "static void extractGenericsConnections(Map<String,GenericsType> connections,ClassNode type,ClassNode target){\n  if (target == null || type == target || !isUsingGenericsOrIsArrayUsingGenerics(target))   return;\n  if (type == null || type == UNKNOWN_PARAMETER_TYPE)   return;\n  if (type.isArray() && target.isArray()) {\n    extractGenericsConnections(connections,type.getComponentType(),target.getComponentType());\n  }\n else   if (target.isGenericsPlaceHolder() || type.equals(target) || !implementsInterfaceOrIsSubclassOf(type,target)) {\n    if (target.isGenericsPlaceHolder()) {\n      connections.put(target.getGenericsTypes()[0].getName(),new GenericsType(type));\n    }\n else {\n      extractGenericsConnections(connections,type.getGenericsTypes(),target.getGenericsTypes());\n    }\n  }\n else {\n    Map<String,ClassNode> genSpec=GenericsUtils.createGenericsSpec(type);\n    ClassNode superClass=getNextSuperClass(type,target);\n    if (superClass != null) {\n      ClassNode corrected;\n      if (missesGenericsTypes(type)) {\n        corrected=superClass.getPlainNodeReference();\n      }\n else {\n        corrected=GenericsUtils.correctToGenericsSpecRecurse(genSpec,superClass);\n      }\n      extractGenericsConnections(connections,corrected,target);\n    }\n else {\n      throw new GroovyBugError(\"The type \" + type + \" seems not to normally extend \"+ target+ \". Sorry, I cannot handle this.\");\n    }\n  }\n}\n", "nl": "use supplied type to make a connection from usage to declaration The method operates in two modes. * For type !instanceof target a structural compare will be done (for example Dummy&lt;T&gt; and List&lt;R&gt; to get T=R) * If type equals target, a structural match is done as well (for example Colection&lt;U&gt; and Collection&lt;E&gt; to get U=E) * otherwise we climb the hierarchy to find a case of type equals target to then execute the structural match, while applying possibly existing generics contexts on the way (for example for IntRange and Collection&lt;E&gt; to get E=Integer, since IntRange is an AbstractList&lt;Integer&gt;) Should the target not have any generics this method does nothing."}
{"code": "public FunctionInvocationTargetException(Throwable cause){\n  super(cause);\n}\n", "nl": "Construct an instance of FunctionInvocationTargetException"}
{"code": "private CharSequence formatDuration(long millis){\n  if (millis >= DateUtils.HOUR_IN_MILLIS) {\n    int hours=(int)TimeUnit.MILLISECONDS.toHours(millis + TimeUnit.MINUTES.toMillis(30));\n    return resources.getQuantityString(R.plurals.dl__duration_hours,hours,hours);\n  }\n else   if (millis >= DateUtils.MINUTE_IN_MILLIS) {\n    int minutes=(int)TimeUnit.MILLISECONDS.toMinutes(millis + TimeUnit.SECONDS.toMillis(30));\n    return resources.getQuantityString(R.plurals.dl__duration_minutes,minutes,minutes);\n  }\n else {\n    int seconds=(int)TimeUnit.MILLISECONDS.toSeconds(millis + 500);\n    return resources.getQuantityString(R.plurals.dl__duration_seconds,seconds,seconds);\n  }\n}\n", "nl": "Return given duration in a human-friendly format. For example, \"4 minutes\" or \"1 second\". Returns only largest meaningful unit of time, from seconds up to hours."}
{"code": "public double[][] rankedAttributes() throws Exception {\n  if (m_attributeRanking == null) {\n    throw new Exception(\"Ranking has not been performed\");\n  }\n  return m_attributeRanking;\n}\n", "nl": "get the final ranking of the attributes."}
{"code": "public void endAdding(GL10 gl){\n  checkState(STATE_ADDING,STATE_INITIALIZED);\n  gl.glBindTexture(GL10.GL_TEXTURE_2D,mTextureID);\n  GLUtils.texImage2D(GL10.GL_TEXTURE_2D,0,mBitmap,0);\n  mBitmap.recycle();\n  mBitmap=null;\n  mCanvas=null;\n}\n", "nl": "Call to end adding labels. Must be called before drawing starts."}
{"code": "public static void verifyVirtualPoolChangeForTechRefresh(VirtualPool srcVpool,VirtualPool tgtVpool){\n  String[] exclude=new String[]{PROTOCOLS,PROVISIONING_TYPE,ARRAY_INFO,DRIVE_TYPE,AUTO_TIER_POLICY_NAME,HOST_IO_LIMIT_IOPS,HOST_IO_LIMIT_BANDWIDTH,VMAX_COMPRESSION_ENABLED,MATCHED_POOLS,INVALID_MATCHED_POOLS,ASSIGNED_STORAGE_POOLS,LABEL,DESCRIPTION,STATUS,TAGS,CREATION_TIME,NON_DISRUPTIVE_EXPANSION};\n  if (!VirtualPoolChangeAnalyzer.analyzeChanges(srcVpool,tgtVpool,null,exclude,null).isEmpty()) {\n    throw APIException.badRequests.vPoolChangeNotValid(srcVpool.getId(),tgtVpool.getId());\n  }\n}\n", "nl": "Verifies the Vpool change for a tech refresh of a VPlex virtual volume. The Vpool should only specify a simple change such as the type of disk drive."}
{"code": "public DocumentQuery(URL feedUrl){\n  super(feedUrl);\n}\n", "nl": "Constructs a new query object that targets a feed.  The initial state of the query contains no parameters, meaning all entries in the feed would be returned if the query was executed immediately after construction."}
{"code": "static <T>List<T> cast(Iterable<T> iterable){\n  return (List<T>)iterable;\n}\n", "nl": "Used to avoid http://bugs.sun.com/view_bug.do?bug_id=6558557"}
{"code": "private void addAttributesButtonsTo(JToolBar bar,DrawingEditor editor){\n  JButton b;\n  b=bar.add(new PickAttributesAction(editor));\n  b.setFocusable(false);\n  b=bar.add(new ApplyAttributesAction(editor));\n  b.setFocusable(false);\n  bar.addSeparator();\n  addColorButtonsTo(bar,editor);\n  bar.addSeparator();\n  addStrokeButtonsTo(bar,editor);\n  bar.addSeparator();\n  ButtonFactory.addFontButtonsTo(bar,editor);\n}\n", "nl": "Creates toolbar buttons and adds them to the specified JToolBar"}
{"code": "@Override public boolean equals(Object o){\n  if (o instanceof ChannelInfo) {\n    ChannelInfo other=(ChannelInfo)o;\n    if (this.channelId != null) {\n      if (this.channelId.equals(other.channelId))       return true;\n    }\n else     if (this.channelName != null && this.channelNumber != null) {\n      return this.channelName.equals(other.channelName) && this.channelNumber.equals(other.channelNumber) && this.majorNumber == other.majorNumber && this.minorNumber == other.minorNumber;\n    }\n    Log.d(Util.T,\"Could not compare channel values, no data to compare against\");\n    Log.d(Util.T,\"This channel info: \\n\" + this.rawData.toString());\n    Log.d(Util.T,\"Other channel info: \\n\" + other.rawData.toString());\n    return false;\n  }\n  return super.equals(o);\n}\n", "nl": "Compares two ChannelInfo objects."}
{"code": "static public String format(byte[] p){\n  return jmri.util.StringUtil.hexStringFromBytes(p);\n}\n", "nl": "Convert NMRA packet to a readable form"}
{"code": "private void closeConnectionQuietly(){\n  if (connection != null) {\n    try {\n      connection.disconnect();\n    }\n catch (    Exception e) {\n      Log.e(TAG,\"Unexpected error while disconnecting\",e);\n    }\n    connection=null;\n  }\n}\n", "nl": "Closes the current connection quietly, if there is one."}
{"code": "public void updateEllipse(float latPoint,float lonPoint,float majorAxisSpan,float minorAxisSpan,int units,float rotationAngle,LinkProperties properties,int graphicUpdateMask) throws IOException {\n  writeGraphicGestureHeader(graphicUpdateMask);\n  LinkEllipse.write(latPoint,lonPoint,majorAxisSpan,minorAxisSpan,units,rotationAngle,properties,link.dos);\n}\n", "nl": "Write an ellipse in the response."}
{"code": "@Override public void addTemporaryTopic(final TemporaryTopic temp){\n  if (ActiveMQRASessionFactoryImpl.trace) {\n    ActiveMQRALogger.LOGGER.trace(\"addTemporaryTopic(\" + temp + \")\");\n  }\nsynchronized (tempTopics) {\n    tempTopics.add(temp);\n  }\n}\n", "nl": "Add temporary topic"}
{"code": "@operator(value=ZERO,concept={IConcept.EQUATION,IConcept.MATH},doc=@doc(\"An internal placeholder function\")) public static Double f(final IScope scope,final IExpression var){\n  return Double.NaN;\n}\n", "nl": "Placeholder for zero-order equations. The expression on the right allows to pass the variable directly (maybe useful one day)."}
{"code": "private void exportExcel(){\n  RModel model=table.getRModel();\n  if (model == null) {\n    return;\n  }\n  try {\n    RModelExcelExporter exporter=new RModelExcelExporter((RModel)model);\n    exporter.export(null,null);\n  }\n catch (  Exception e) {\n    ADialog.error(0,this,\"Error\",e.getLocalizedMessage());\n    if (CLogMgt.isLevelFinest())     e.printStackTrace();\n  }\n}\n", "nl": "Export to Excel"}
{"code": "@Override public void onReceivedError(WebView view,int errorCode,String description,String failingUrl){\n  if (!isCurrentlyLoading) {\n    return;\n  }\n  LOG.d(TAG,\"CordovaWebViewClient.onReceivedError: Error code=%s Description=%s URL=%s\",errorCode,description,failingUrl);\n  if (errorCode == WebViewClient.ERROR_UNSUPPORTED_SCHEME) {\n    parentEngine.client.clearLoadTimeoutTimer();\n    if (view.canGoBack()) {\n      view.goBack();\n      return;\n    }\n else {\n      super.onReceivedError(view,errorCode,description,failingUrl);\n    }\n  }\n  parentEngine.client.onReceivedError(errorCode,description,failingUrl);\n}\n", "nl": "Report an error to the host application. These errors are unrecoverable (i.e. the main resource is unavailable). The errorCode parameter corresponds to one of the ERROR_* constants."}
{"code": "static final public boolean parseBoolean(int what){\n  return (what != 0);\n}\n", "nl": "<p>Convert an integer to a boolean. Because of how Java handles upgrading numbers, this will also cover byte and char (as they will upgrade to an int without any sort of explicit cast).</p> <p>The preprocessor will convert boolean(what) to parseBoolean(what).</p>"}
{"code": "public void onSurfaceDestroyed(){\n  if (DEBUG)   Log.v(TAG,\"onSurfaceDestroyed:\");\n  if (mDrawer != null) {\n    mDrawer.release();\n    mDrawer=null;\n  }\n  if (mSTexture != null) {\n    mSTexture.release();\n    mSTexture=null;\n  }\n  release();\n}\n", "nl": "when GLSurface context is soon destroyed"}
{"code": "public SequenceIndex(){\n  mBins=new TreeMap<>();\n  mLinearIndex=new long[5];\n}\n", "nl": "Construct a default SequenceIndex"}
{"code": "private void sequenceCommand(CommandRequest request,ServerSessionContext session,CompletableFuture<CommandResponse> future){\n  if (request.sequence() > session.nextRequestSequence()) {\n    session.registerRequest(request.sequence(),null);\n  }\n else {\n    applyCommand(request,session,future);\n  }\n}\n", "nl": "Sequences the given command to the log."}
{"code": "public cudaChannelFormatDesc(){\n}\n", "nl": "Creates an uninitialized cudaChannelFormatDesc"}
{"code": "public boolean isSelected(ButtonModel m){\n  return (m == selection);\n}\n", "nl": "Returns whether a <code>ButtonModel</code> is selected."}
{"code": "private boolean scheduleNext(){\n  final String tag=\"Scheduled session[\" + taskid + \"]\";\n  try {\n    LOG.finer(tag + \": scheduling next session for \" + delayBeforeNext+ \"ms\");\n    if (cancelled || !notifyStateChange(SCHEDULED,\"scan-scheduled\")) {\n      LOG.finer(tag + \" stopped: do not reschedule\");\n      return false;\n    }\n    final SessionTask nextTask=new SessionTask(delayBeforeNext);\n    if (!scheduleSession(nextTask,delayBeforeNext))     return false;\n    LOG.finer(tag + \": next session successfully scheduled\");\n  }\n catch (  Exception x) {\n    if (LOG.isLoggable(Level.FINEST)) {\n      LOG.log(Level.FINEST,tag + \" failed to schedule next session: \" + x,x);\n    }\n else     if (LOG.isLoggable(Level.FINE)) {\n      LOG.fine(tag + \" failed to schedule next session: \" + x);\n    }\n  }\n  return true;\n}\n", "nl": "Schedule an identical task for next iteration."}
{"code": "public Process exec(String prog,String[] envp) throws java.io.IOException {\n  return exec(prog,envp,null);\n}\n", "nl": "Execute prog in a separate platform process The new process uses the environment provided in envp"}
{"code": "@Override public void put(byte[] tableKey,StreamSource rowSource,Result<Boolean> result){\n  putImpl(tableKey,rowSource,PutType.PUT,result);\n}\n", "nl": "Puts the row for replication. Put is only called for the owning servers. Each owner and its backups get a copy."}
{"code": "public static void changeToTheme(Activity activity){\n  activity.finish();\n  activity.startActivity(new Intent(activity,activity.getClass()));\n}\n", "nl": "Set the theme of the Activity, and restart it by creating a new Activity of the same type."}
{"code": "protected POInfo initPO(Properties ctx){\n  POInfo poi=POInfo.getPOInfo(ctx,Table_ID,get_TrxName());\n  return poi;\n}\n", "nl": "Load Meta Data"}
{"code": "public byte[] serialize(){\n  byte[] payloadData=null;\n  if (payload != null) {\n    payload.setParent(this);\n    payloadData=payload.serialize();\n  }\n  this.length=(short)(8 + ((payloadData == null) ? 0 : payloadData.length));\n  byte[] data=new byte[this.length];\n  ByteBuffer bb=ByteBuffer.wrap(data);\n  bb.putShort((short)this.sourcePort.getPort());\n  bb.putShort((short)this.destinationPort.getPort());\n  bb.putShort(this.length);\n  bb.putShort(this.checksum);\n  if (payloadData != null)   bb.put(payloadData);\n  if (this.parent != null && this.parent instanceof IPv4)   ((IPv4)this.parent).setProtocol(IpProtocol.UDP);\n  if (this.checksum == 0) {\n    bb.rewind();\n    int accumulation=0;\n    if (this.parent != null && this.parent instanceof IPv4) {\n      IPv4 ipv4=(IPv4)this.parent;\n      accumulation+=((ipv4.getSourceAddress().getInt() >> 16) & 0xffff) + (ipv4.getSourceAddress().getInt() & 0xffff);\n      accumulation+=((ipv4.getDestinationAddress().getInt() >> 16) & 0xffff) + (ipv4.getDestinationAddress().getInt() & 0xffff);\n      accumulation+=ipv4.getProtocol().getIpProtocolNumber() & 0xff;\n      accumulation+=this.length & 0xffff;\n    }\n    for (int i=0; i < this.length / 2; ++i) {\n      accumulation+=0xffff & bb.getShort();\n    }\n    if (this.length % 2 > 0) {\n      accumulation+=(bb.get() & 0xff) << 8;\n    }\n    accumulation=((accumulation >> 16) & 0xffff) + (accumulation & 0xffff);\n    this.checksum=(short)(~accumulation & 0xffff);\n    bb.putShort(6,this.checksum);\n  }\n  return data;\n}\n", "nl": "Serializes the packet. Will compute and set the following fields if they are set to specific values at the time serialize is called: -checksum : 0 -length : 0"}
{"code": "public String toString(){\n  StringBuffer buffer=new StringBuffer();\n  buffer.append(toString(getClass()));\n  buffer.append(\"[UseDefault=\");\n  buffer.append(isUseDefault());\n  buffer.append(\", UseLocaleFormat=\");\n  buffer.append(useLocaleFormat);\n  if (pattern != null) {\n    buffer.append(\", Pattern=\");\n    buffer.append(pattern);\n  }\n  if (locale != null) {\n    buffer.append(\", Locale=\");\n    buffer.append(locale);\n  }\n  buffer.append(']');\n  return buffer.toString();\n}\n", "nl": "Provide a String representation of this number converter."}
{"code": "public static boolean isCompleted(Operation op){\n  return (null == op || null == op.getCompletion());\n}\n", "nl": "Returns true if operation still needs to be completed."}
{"code": "public void firePropertyChange(java.beans.PropertyChangeEvent propertyChangeEvent){\n  if (propertyChangeEvent == null) {\n    String msg=Logging.getMessage(\"nullValue.PropertyChangeEventIsNull\");\n    Logging.logger().severe(msg);\n    throw new IllegalArgumentException(msg);\n  }\n  this.getChangeSupport().firePropertyChange(propertyChangeEvent);\n}\n", "nl": "Fire a property change event."}
{"code": "void add(RuleRec rec){\n  list.add(rec);\n}\n", "nl": "Added a RuleRec to the Rule record list."}
{"code": "protected void pack(){\n  Component component=getComponent();\n  if (component instanceof Window) {\n    ((Window)component).pack();\n  }\n}\n", "nl": "Causes the <code>Popup</code> to be sized to fit the preferred size of the <code>Component</code> it contains."}
{"code": "public ManagerServiceImpl(final GenericDAO<Manager,Long> genericDao){\n  super(genericDao);\n}\n", "nl": "Create service to manage the administrative of web shop"}
{"code": "private void updateProgress(int progress){\n  if (myHost != null && progress != previousProgress) {\n    myHost.updateProgress(progress);\n  }\n  previousProgress=progress;\n}\n", "nl": "Used to communicate a progress update between a plugin tool and the main Whitebox user interface."}
{"code": "public Tradingdays findTradingdaysByDateRange(final ZonedDateTime startDate,final ZonedDateTime endDate) throws PersistentModelException {\n  return m_tradingdayHome.findTradingdaysByDateRange(startDate,endDate);\n}\n", "nl": "Method findTradingdaysByDateRange."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:33:43.033 -0500\",hash_original_method=\"ECD2E5721BC163A0054AA741832C3882\",hash_generated_method=\"14A5AF88A2506E99D7DB3789702FBF82\") private static void modifyFieldIfSet(final Field field,final TypedProperties properties,final String propertyName){\n  if (field.getType() == java.lang.String.class) {\n    int stringInfo=properties.getStringInfo(propertyName);\nswitch (stringInfo) {\ncase TypedProperties.STRING_SET:\n      break;\ncase TypedProperties.STRING_NULL:\n    try {\n      field.set(null,null);\n    }\n catch (    IllegalAccessException ex) {\n      throw new IllegalArgumentException(\"Cannot set field for \" + propertyName,ex);\n    }\n  return;\ncase TypedProperties.STRING_NOT_SET:\nreturn;\ncase TypedProperties.STRING_TYPE_MISMATCH:\nthrow new IllegalArgumentException(\"Type of \" + propertyName + \" \"+ \" does not match field type (\"+ field.getType()+ \")\");\ndefault :\nthrow new IllegalStateException(\"Unexpected getStringInfo(\" + propertyName + \") return value \"+ stringInfo);\n}\n}\nObject value=properties.get(propertyName);\nif (value != null) {\nif (!fieldTypeMatches(field,value.getClass())) {\nthrow new IllegalArgumentException(\"Type of \" + propertyName + \" (\"+ value.getClass()+ \") \"+ \" does not match field type (\"+ field.getType()+ \")\");\n}\ntry {\nfield.set(null,value);\n}\n catch (IllegalAccessException ex) {\nthrow new IllegalArgumentException(\"Cannot set field for \" + propertyName,ex);\n}\n}\n}\n", "nl": "Looks up the property that corresponds to the field, and sets the field's value if the types match."}
{"code": "public OptionsBean obtenerTiposInformesCombo(Entidad entidad) throws RPAdminException {\n  MultiEntityContextHolder.setEntity(entidad.getIdentificador());\n  OptionsBean options=new OptionsBean();\n  ResourceBundle rs=ResourceBundle.getBundle(\"ieci.tecdoc.sgm.rpadmin.manager.tipoInforme\");\n  Enumeration keys=rs.getKeys();\n  while (keys.hasMoreElements()) {\n    OptionBean option=new OptionBean();\n    String key=keys.nextElement().toString();\n    String value=rs.getString(key);\n    option.setCodigo(key);\n    option.setDescripcion(value);\n    options.add(option);\n  }\n  return options;\n}\n", "nl": "Obtiene los tipos de perfiles de informes y los devuelve en un bean"}
{"code": "public IteratorSpliterator(Iterator<? extends T> iterator,long size,int characteristics){\n  this.collection=null;\n  this.it=iterator;\n  this.est=size;\n  this.characteristics=(characteristics & Spliterator.CONCURRENT) == 0 ? characteristics | Spliterator.SIZED | Spliterator.SUBSIZED : characteristics;\n}\n", "nl": "Creates a spliterator using the given iterator for traversal, and reporting the given initial size and characteristics."}
{"code": "public KMLPolygonImpl(KMLTraversalContext tc,KMLPlacemark placemark,KMLAbstractGeometry geom){\n  if (tc == null) {\n    String msg=Logging.getMessage(\"nullValue.TraversalContextIsNull\");\n    Logging.logger().severe(msg);\n    throw new IllegalArgumentException(msg);\n  }\n  if (placemark == null) {\n    String msg=Logging.getMessage(\"nullValue.ParentIsNull\");\n    Logging.logger().severe(msg);\n    throw new IllegalArgumentException(msg);\n  }\n  this.parent=placemark;\n  KMLPolygon polygon=(KMLPolygon)geom;\n  this.setAltitudeMode(WorldWind.CLAMP_TO_GROUND);\n  String altMode=polygon.getAltitudeMode();\n  if (!WWUtil.isEmpty(altMode)) {\n    if (\"relativeToGround\".equals(altMode))     this.setAltitudeMode(WorldWind.RELATIVE_TO_GROUND);\n else     if (\"absolute\".equals(altMode))     this.setAltitudeMode(WorldWind.ABSOLUTE);\n  }\n  KMLLinearRing outerBoundary=polygon.getOuterBoundary();\n  if (outerBoundary != null) {\n    Position.PositionList coords=outerBoundary.getCoordinates();\n    if (coords != null && coords.list != null)     this.setOuterBoundary(outerBoundary.getCoordinates().list);\n  }\n  Iterable<? extends KMLLinearRing> innerBoundaries=polygon.getInnerBoundaries();\n  if (innerBoundaries != null) {\n    for (    KMLLinearRing ring : innerBoundaries) {\n      Position.PositionList coords=ring.getCoordinates();\n      if (coords != null && coords.list != null)       this.addInnerBoundary(ring.getCoordinates().list);\n    }\n  }\n  if (placemark.getName() != null)   this.setValue(AVKey.DISPLAY_NAME,placemark.getName());\n  if (placemark.getDescription() != null)   this.setValue(AVKey.DESCRIPTION,placemark.getDescription());\n  if (placemark.getSnippetText() != null)   this.setValue(AVKey.SHORT_DESCRIPTION,placemark.getSnippetText());\n  this.setValue(AVKey.CONTEXT,this.parent);\n}\n", "nl": "Create an instance."}
{"code": "private void fillBuf() throws IOException {\n  int result=in.read(buf,0,buf.length);\n  if (result == -1) {\n    throw new EOFException();\n  }\n  pos=0;\n  end=result;\n}\n", "nl": "Reads new input data into the buffer. Call only with pos == end or end == -1, depending on the desired outcome if the function throws."}
{"code": "public SpecialInvokeExpr newSpecialInvokeExpr(Local base,SootMethodRef method,Value arg){\n  return new JSpecialInvokeExpr(base,method,Arrays.asList(new Value[]{arg}));\n}\n", "nl": "Constructs a NewSpecialInvokeExpr(Local base, SootMethodRef method, List of Immediate) grammar chunk."}
{"code": "public Builder(String headVar){\n  this.headVar=headVar;\n  table=new HashMap<Assignment,CategoricalTable.Builder>();\n}\n", "nl": "Constructs a new conditional categorical table with the given variable name."}
{"code": "@Override public int removeAllByHostHashes(final Set<String> hosthashes){\n  for (  String h : hosthashes) {\n    if (this.hostHash.equals(h)) {\n      int s=this.size();\n      this.clear();\n      return s;\n    }\n  }\n  return 0;\n}\n", "nl": "delete all urls which are stored for given host hashes"}
{"code": "public RESTLoginCommandImpl(final ShoppingCartCommandRegistry registry,final CustomerService customerService,final ShopService shopService,final PriceService priceService,final PricingPolicyProvider pricingPolicyProvider,final ProductService productService,final CartRepository cartRepository){\n  super(registry,customerService,shopService,priceService,pricingPolicyProvider,productService);\n  this.cartRepository=cartRepository;\n}\n", "nl": "Construct command."}
{"code": "public File configFile(String path){\n  return dataFile(CONFIG_DIR + \"/\" + path);\n}\n", "nl": "Constructs an absolute path to a file within the config folder of the data dir."}
{"code": "public ImageCacheParams(File rootDirectory,int maxCacheSizeInBytes){\n  diskCacheDir=rootDirectory;\n  memCacheSize=maxCacheSizeInBytes;\n}\n", "nl": "Create a set of image cache parameters that can be provided to"}
{"code": "public boolean shouldRemoteUiBeVisible(int state,int idleReason) throws TransientNetworkDisconnectionException, NoConnectionException {\nswitch (state) {\ncase MediaStatus.PLAYER_STATE_PLAYING:\ncase MediaStatus.PLAYER_STATE_PAUSED:\ncase MediaStatus.PLAYER_STATE_BUFFERING:\n    return true;\ncase MediaStatus.PLAYER_STATE_IDLE:\n  if (!isRemoteStreamLive()) {\n    return false;\n  }\nreturn idleReason == MediaStatus.IDLE_REASON_CANCELED;\ndefault :\nbreak;\n}\nreturn false;\n}\n", "nl": "A helper method to determine if, given a player state and an idle reason (if the state is idle) will warrant having a UI for remote presentation of the remote content."}
{"code": "@Ignore public void testIngestTemplateThreaded(){\n  File temp=null;\n  try {\n    temp=File.createTempFile(\"testFile2\",\"csv\");\n  }\n catch (  IOException e) {\n    e.printStackTrace();\n    fail();\n  }\n  ByteBuffer data=sourceBuffer.asReadOnlyBuffer();\n  Pipe linesRing=new Pipe(linesRingConfig);\n  Pipe fieldsRing=new Pipe(fieldsRingConfig);\n  Pipe flatFileRing=new Pipe(flatFileRingConfig);\n  GraphManager gm=new GraphManager();\n  LineSplitterByteBufferStage lineSplitter=new LineSplitterByteBufferStage(gm,data,linesRing);\n  FieldSplitterStage fieldSplitter=new FieldSplitterStage(gm,linesRing,fieldsRing);\n  MetaMessagesToCSVStage csvBuilderStage=new MetaMessagesToCSVStage(gm,fieldsRing,flatFileRing);\n  FileChannel outputFileChannel;\n  try {\n    outputFileChannel=new RandomAccessFile(temp,\"rws\").getChannel();\n  }\n catch (  FileNotFoundException e1) {\n    throw new RuntimeException(e1);\n  }\n  FileWriteStage fileWriter=new FileWriteStage(gm,flatFileRing,outputFileChannel);\n  StageScheduler ss=new ThreadPerStageScheduler(gm);\n  ss.startup();\n  boolean ok=ss.awaitTermination(10,TimeUnit.SECONDS);\n  assertEquals(\"File size does not match:\" + temp.getAbsolutePath(),sourceBuffer.remaining(),temp.length());\n  byte[] expected=new byte[sourceBuffer.remaining()];\n  byte[] rebuilt=new byte[sourceBuffer.remaining()];\n  try {\n    InputStream testStream=SmallCSVParseTest.class.getResourceAsStream(TEST_FILE);\n    testStream.read(expected);\n    testStream.close();\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n    fail();\n  }\n  try {\n    InputStream builtStream=new FileInputStream(temp);\n    builtStream.read(rebuilt);\n    builtStream.close();\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n    fail();\n  }\n}\n", "nl": "This is the example you are looking for TODO: AAA, this test is broken and needs to be fixed ASAP, part of the stage migration."}
{"code": "public T caseTClass(TClass object){\n  return null;\n}\n", "nl": "Returns the result of interpreting the object as an instance of '<em>TClass</em>'. <!-- begin-user-doc --> This implementation returns null; returning a non-null result will terminate the switch. <!-- end-user-doc -->"}
{"code": "public static JSONArray toJSONArray(JSONTokener x) throws JSONException {\n  return toJSONArray(rowToJSONArray(x),x);\n}\n", "nl": "Produce a JSONArray of JSONObjects from a comma delimited text string, using the first row as a source of names."}
{"code": "public boolean connect(){\n  try {\n    mService.clientConnect(mClientIf,mDevice.getAddress(),false);\n    return true;\n  }\n catch (  RemoteException e) {\n    Log.e(TAG,\"\",e);\n    return false;\n  }\n}\n", "nl": "Connect back to remote device. <p>This method is used to re-connect to a remote device after the connection has been dropped. If the device is not in range, the re-connection will be triggered once the device is back in range."}
{"code": "public static boolean injectIterationCount(double iterations,boolean condition){\n  return injectBranchProbability(1. - 1. / iterations,condition);\n}\n", "nl": "Injects an average iteration count of a loop into the probability information of a loop exit condition. The iteration count specifies how often the condition is checked, i.e. in for and while loops it is one more than the body iteration count, and in do-while loops it is equal to the body iteration count. The iteration count must be >= 1.0. Example usage (it specifies that the expected iteration count of the loop condition is 500, so the iteration count of the loop body is 499): <code> for (int i = 0; injectIterationCount(500, i < array.length); i++) { // ... } </code>"}
{"code": "public FilterExprIterator(){\n  super(null);\n}\n", "nl": "Create a FilterExprIterator object."}
{"code": "private static String createLibraryPrefix(){\n  OSType osType=calculateOS();\nswitch (osType) {\ncase ANDROID:\ncase APPLE:\ncase LINUX:\ncase SUN:\n    return \"lib\";\ncase WINDOWS:\n  return \"\";\ndefault :\nbreak;\n}\nreturn \"\";\n}\n", "nl": "Returns the prefix for dynamically linked libraries on the current OS. That is, returns <code>\"lib\"</code> on Apple,  Linux and Sun, and the empty String on Windows."}
{"code": "public static void showException(final Throwable exception){\n  final Dialog dialog=new Dialog();\n  dialog.setTitle(ResourceManager.getLabel(ResourceManager.EXCEPTION));\n  final String msg=exception.getMessage();\n  final String className=exception.getClass().getName();\n  final boolean noMessage=msg == null || msg.trim().length() == 0;\n  dialog.getMessageArea().setTitle(noMessage ? className : msg).setText(noMessage ? \"\" : className).setIcon(Display.getCurrent().getSystemImage(SWT.ICON_ERROR)).setException(exception);\n  dialog.getFooterArea().setExpanded(true);\n  dialog.setButtonType(OpalDialogType.CLOSE);\n  dialog.show();\n}\n", "nl": "Display a dialog box with an exception"}
{"code": "public synchronized void flush() throws IOException {\n  checkNotClosed();\n  trimToSize();\n  journalWriter.flush();\n}\n", "nl": "Force buffered operations to the filesystem."}
{"code": "public Graph search(){\n  this.logger.log(\"info\",\"Starting Fast Adjacency Search.\");\n  Graph graph=new EdgeListGraphSingleConnections(test.getVariables());\n  sepsets=new SepsetMap();\n  sepsets.setReturnEmptyIfNotSet(true);\n  int _depth=depth;\n  if (_depth == -1) {\n    _depth=1000;\n  }\n  Map<Node,Set<Node>> adjacencies=new ConcurrentSkipListMap<>();\n  List<Node> nodes=graph.getNodes();\n  for (  Node node : nodes) {\n    adjacencies.put(node,new HashSet<Node>());\n  }\n  double alpha=test.getAlpha();\n  for (double _alpha=0.9; _alpha > alpha; _alpha/=2.0) {\n    System.out.println(\"_alpha = \" + _alpha);\n    searchAtDepth0(nodes,test,adjacencies);\n    test.setAlpha(_alpha);\n    boolean didIt=false;\n    for (int d=didIt ? 1 : 0; d <= _depth; d++) {\n      boolean more;\n      more=searchAtDepth(nodes,test,adjacencies,d);\n      if (!more) {\n        break;\n      }\n    }\n  }\n  test.setAlpha(alpha);\n  if (verbose) {\n    out.println(\"Finished with search, constructing Graph...\");\n  }\n  for (int i=0; i < nodes.size(); i++) {\n    for (int j=i + 1; j < nodes.size(); j++) {\n      Node x=nodes.get(i);\n      Node y=nodes.get(j);\n      if (adjacencies.get(x).contains(y)) {\n        graph.addUndirectedEdge(x,y);\n      }\n    }\n  }\n  if (verbose) {\n    out.println(\"Finished constructing Graph.\");\n  }\n  if (verbose) {\n    this.logger.log(\"info\",\"Finishing Fast Adjacency Search.\");\n  }\n  return graph;\n}\n", "nl": "Discovers all adjacencies in data.  The procedure is to remove edges in the graph which connect pairs of variables which are independent conditional on some other set of variables in the graph (the \"sepset\"). These are removed in tiers.  First, edges which are independent conditional on zero other variables are removed, then edges which are independent conditional on one other variable are removed, then two, then three, and so on, until no more edges can be removed from the graph.  The edges which remain in the graph after this procedure are the adjacencies in the data."}
{"code": "public final ADFContext push(ADFContext obj){\n  if (onStack == stack.length) {\n    ADFContext[] newstack=new ADFContext[stack.length * 2];\n    System.arraycopy(stack,0,newstack,0,stack.length);\n    stack=newstack;\n  }\n  stack[onStack++]=obj;\n  return obj;\n}\n", "nl": "Pushes an ADFContext onto the main stack.  The best way to get an ADFContext to push onto the stack is with get(). Returns obj."}
{"code": "void modCenter(int modulus){\n  mod(modulus);\n  for (int j=0; j < coeffs.length; j++) {\n    while (coeffs[j] < modulus / 2) {\n      coeffs[j]+=modulus;\n    }\n    while (coeffs[j] >= modulus / 2) {\n      coeffs[j]-=modulus;\n    }\n  }\n}\n", "nl": "Reduces all coefficients to the interval [-modulus/2, modulus/2)"}
{"code": "public Gateway createGateway(){\n  GatewayImpl gateway=new GatewayImpl();\n  return gateway;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "private void printStatusMessages(AbstractTestSuiteChromosome<? extends ExecutableChromosome> suite,int coveredBranches,double fitness){\n  if (coveredBranches > maxCoveredBranches) {\n    maxCoveredBranches=coveredBranches;\n    logger.info(\"(Branches) Best individual covers \" + coveredBranches + \"/\"+ (totalBranches * 2)+ \" branches\");\n    logger.info(\"Fitness: \" + fitness + \", size: \"+ suite.size()+ \", length: \"+ suite.totalLengthOfTestCases());\n  }\n  if (fitness < bestFitness) {\n    logger.info(\"(Fitness) Best individual covers \" + coveredBranches + \"/\"+ (totalBranches * 2)+ \" branches\");\n    bestFitness=fitness;\n    logger.info(\"Fitness: \" + fitness + \", size: \"+ suite.size()+ \", length: \"+ suite.totalLengthOfTestCases());\n  }\n}\n", "nl": "Some useful debug information"}
{"code": "public boolean isBuilt(){\n  return _built;\n}\n", "nl": "Used to determine if this train has been built."}
{"code": "public ConditionalRoute createConditionalRoute(){\n  ConditionalRouteImpl conditionalRoute=new ConditionalRouteImpl();\n  return conditionalRoute;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public String toString(){\n  return \"TerminalFactory for type \" + type + \" from provider \"+ provider.getName();\n}\n", "nl": "Returns a string representation of this TerminalFactory."}
{"code": "public UnitName createUnitName(){\n  UnitNameImpl unitName=new UnitNameImpl();\n  return unitName;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "protected String doIt() throws Exception {\n  log.info(\"M_Product_ID=\" + p_M_Product_ID);\n  if (p_M_Product_ID == 0)   throw new AdempiereUserError(\"@NotFound@: @M_Product_ID@ = \" + p_M_Product_ID);\n  MProduct product=MProduct.get(getCtx(),p_M_Product_ID);\n  if (product.get_ID() != p_M_Product_ID)   throw new AdempiereUserError(\"@NotFound@: @M_Product_ID@ = \" + p_M_Product_ID);\n  if (MCostDetail.processProduct(product,get_TrxName()))   return \"@OK@\";\n  return \"@Error@\";\n}\n", "nl": "Perform process."}
{"code": "void visitSubroutine(final Label JSR,final long id,final int nbSubroutines){\n  Label stack=this;\n  while (stack != null) {\n    Label l=stack;\n    stack=l.next;\n    l.next=null;\n    if (JSR != null) {\n      if ((l.status & VISITED2) != 0) {\n        continue;\n      }\n      l.status|=VISITED2;\n      if ((l.status & RET) != 0) {\n        if (!l.inSameSubroutine(JSR)) {\n          Edge e=new Edge();\n          e.info=l.inputStackTop;\n          e.successor=JSR.successors.successor;\n          e.next=l.successors;\n          l.successors=e;\n        }\n      }\n    }\n else {\n      if (l.inSubroutine(id)) {\n        continue;\n      }\n      l.addToSubroutine(id,nbSubroutines);\n    }\n    Edge e=l.successors;\n    while (e != null) {\n      if ((l.status & Label.JSR) == 0 || e != l.successors.next) {\n        if (e.successor.next == null) {\n          e.successor.next=stack;\n          stack=e.successor;\n        }\n      }\n      e=e.next;\n    }\n  }\n}\n", "nl": "Finds the basic blocks that belong to a given subroutine, and marks these blocks as belonging to this subroutine. This method follows the control flow graph to find all the blocks that are reachable from the current block WITHOUT following any JSR target."}
{"code": "public Complex cos(){\n  return new Complex(Math.cos(re) * Math.cosh(im),-Math.sin(re) * Math.sinh(im));\n}\n", "nl": "Returns the complex cosine of this complex number."}
{"code": "public void close() throws SQLException {\n  this.closed=true;\n  for (  Connection c : this.serverConnections.values()) {\n    try {\n      c.close();\n    }\n catch (    SQLException ex) {\n    }\n  }\n}\n", "nl": "Close this connection proxy which entails closing all open connections to MySQL servers."}
{"code": "public String plus(Object value){\n  return this.theString + value;\n}\n", "nl": "Fairly simple method used for the plus (+) base concatenation in Groovy."}
{"code": "public String showAttributes(){\n  DataSortedTableModel model;\n  ListSelectorDialog dialog;\n  int i;\n  JList list;\n  String name;\n  int result;\n  if (!isPanelSelected()) {\n    return null;\n  }\n  list=new JList(getCurrentPanel().getAttributes());\n  dialog=new ListSelectorDialog(getParentFrame(),list);\n  result=dialog.showDialog();\n  if (result == ListSelectorDialog.APPROVE_OPTION) {\n    model=(DataSortedTableModel)getCurrentPanel().getTable().getModel();\n    name=list.getSelectedValue().toString();\n    i=model.getAttributeColumn(name);\n    JTableHelper.scrollToVisible(getCurrentPanel().getTable(),0,i);\n    getCurrentPanel().getTable().setSelectedColumn(i);\n    return name;\n  }\n else {\n    return null;\n  }\n}\n", "nl": "displays all the attributes, returns the selected item or NULL if canceled"}
{"code": "@Override public void mouseReleased(MouseEvent event){\n  if (event.getSource() == getComponentDecreaseSpinnerButton()) {\n    decreaseTimer.stop();\n  }\n else {\n    increaseTimer.stop();\n  }\n}\n", "nl": "mouseReleased, This will be called when the spinner button is released."}
{"code": "private static String thresholdsToString(String[] thresholdArray){\n  String result=null;\n  if (thresholdArray.length > 0) {\n    result=thresholdArray[0];\n    for (int i=1; i < thresholdArray.length; i++) {\n      result+=\"; \";\n      result+=thresholdArray[i];\n    }\n  }\n  return result;\n}\n", "nl": "Converts a given array of strings into a single string with the array elements  separated by a semi-colon."}
{"code": "public boolean willOpenInForeground(TabLaunchType type,boolean isNewTabIncognito){\n  if (type == TabLaunchType.FROM_RESTORE)   return false;\n  return type != TabLaunchType.FROM_LONGPRESS_BACKGROUND || (!mTabModelSelector.isIncognitoSelected() && isNewTabIncognito);\n}\n", "nl": "Determine if a launch type will result in the tab being opened in the foreground."}
{"code": "@Override public void messageSent(final NextFilter nextFilter,final IoSession session,final WriteRequest writeRequest) throws Exception {\n  if (writeRequest.getMessage() != null && writeRequest.getMessage() instanceof ProxyHandshakeIoBuffer) {\n    return;\n  }\n  nextFilter.messageSent(session,writeRequest);\n}\n", "nl": "Filter handshake related messages from reaching the messageSent callbacks of  downstream filters."}
{"code": "protected void writeTableComment(Table table,StringBuilder ddl){\n  printComment(\"-----------------------------------------------------------------------\",ddl);\n  printComment(getFullyQualifiedTableNameShorten(table),ddl);\n  printComment(\"-----------------------------------------------------------------------\",ddl);\n  println(ddl);\n}\n", "nl": "Outputs a comment for the table."}
{"code": "@DSComment(\"constructor\") @DSSafe(DSCat.SAFE_OTHERS) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:33:23.158 -0500\",hash_original_method=\"3CB703BA4BBEFDD58F8198A538C651FA\",hash_generated_method=\"CF855BD0B8B8C8AFFCD8B68DE31A2318\") public SparseIntArray(){\n  this(10);\n}\n", "nl": "Creates a new SparseIntArray containing no mappings."}
{"code": "public void clearUnused(){\n  Log log=getLog();\n  try {\n    if (session == null)     session=new StorageScopeEngine(factory,log,new StorageScopeCleaner[]{new FileStorageScopeCleaner(Scope.SCOPE_SESSION,null),new DatasourceStorageScopeCleaner(Scope.SCOPE_SESSION,null)});\n    if (client == null)     client=new StorageScopeEngine(factory,log,new StorageScopeCleaner[]{new FileStorageScopeCleaner(Scope.SCOPE_CLIENT,null),new DatasourceStorageScopeCleaner(Scope.SCOPE_CLIENT,null)});\n    storeUnusedStorageScope(factory,Scope.SCOPE_CLIENT);\n    storeUnusedStorageScope(factory,Scope.SCOPE_SESSION);\n    clearUnusedMemoryScope(factory,Scope.SCOPE_CLIENT);\n    clearUnusedMemoryScope(factory,Scope.SCOPE_SESSION);\n    session.clean();\n    client.clean();\n    clearUnusedApplications(factory);\n  }\n catch (  Throwable t) {\n    error(t);\n  }\n}\n", "nl": "remove all unused scope objects"}
{"code": "void seed(){\n  for (int j=0; j <= sentLen - 1; j++) {\n    if (pGrammar.hasRuleForSpan(j,j,input.distance(j,j))) {\n      if (null == pGrammar.getTrieRoot()) {\n        throw new RuntimeException(\"trie root is null\");\n      }\n      addDotItem(pGrammar.getTrieRoot(),j,j,null,null,new SourcePath());\n    }\n  }\n}\n", "nl": "Add initial dot items: dot-items pointer to the root of the grammar trie."}
{"code": "@SuppressWarnings(\"unchecked\") public static <T>Matcher<T> any(){\n  return Any.ANY;\n}\n", "nl": "Returns a wildcard matcher."}
{"code": "public static void scaleM(double[] m,int mOffset,double x,double y,double z){\n  for (int i=0; i < 4; i++) {\n    int mi=mOffset + i;\n    m[mi]*=x;\n    m[4 + mi]*=y;\n    m[8 + mi]*=z;\n  }\n}\n", "nl": "Scales matrix m in place by sx, sy, and sz"}
{"code": "private static byte[] readClass(final InputStream is) throws IOException {\n  if (is == null) {\n    throw new IOException(\"Class not found\");\n  }\n  byte[] b=new byte[is.available()];\n  int len=0;\n  while (true) {\n    int n=is.read(b,len,b.length - len);\n    if (n == -1) {\n      if (len < b.length) {\n        byte[] c=new byte[len];\n        System.arraycopy(b,0,c,0,len);\n        b=c;\n      }\n      return b;\n    }\n    len+=n;\n    if (len == b.length) {\n      int last=is.read();\n      if (last < 0) {\n        return b;\n      }\n      byte[] c=new byte[b.length + 1000];\n      System.arraycopy(b,0,c,0,len);\n      c[len++]=(byte)last;\n      b=c;\n    }\n  }\n}\n", "nl": "Reads the bytecode of a class."}
{"code": "public GridCacheVersion mappedVersion(int idx){\n  return mappedVers == null ? null : mappedVers[idx];\n}\n", "nl": "Returns DHT candidate version for acquired near lock on DHT node."}
{"code": "private String addStyleName(String style){\n  if (styleNameMapping == null) {\n    return style;\n  }\n  StringBuilder sb=null;\n  for (int counter=style.length() - 1; counter >= 0; counter--) {\n    if (!isValidCharacter(style.charAt(counter))) {\n      if (sb == null) {\n        sb=new StringBuilder(style);\n      }\n      sb.setCharAt(counter,'a');\n    }\n  }\n  String mappedName=(sb != null) ? sb.toString() : style;\n  while (styleNameMapping.get(mappedName) != null) {\n    mappedName=mappedName + 'x';\n  }\n  styleNameMapping.put(style,mappedName);\n  return mappedName;\n}\n", "nl": "Adds the style named <code>style</code> to the style mapping. This returns the name that should be used when outputting. CSS does not allow the full Unicode set to be used as a style name."}
{"code": "private Organization validateForOnBehalfUserCreation(String organizationId,String password,PlatformUser currentUser) throws ObjectNotFoundException, OperationNotPermittedException {\n  ArgumentValidator.notNull(\"organizationId\",organizationId);\n  ArgumentValidator.notNull(\"password\",password);\n  Organization customer=new Organization();\n  customer.setOrganizationId(organizationId);\n  customer=(Organization)dm.getReferenceByBusinessKey(customer);\n  if (!currentUser.getOrganization().isActingOnBehalf(customer)) {\n    OperationNotPermittedException onpe=new OperationNotPermittedException();\n    logger.logWarn(Log4jLogger.SYSTEM_LOG,onpe,LogMessageIdentifier.WARN_USER_CREATE_CUSTOMER_FAILED,currentUser.getUserId(),currentUser.getOrganization().getOrganizationId(),customer.getOrganizationId());\n    throw onpe;\n  }\n  return customer;\n}\n", "nl": "Validates that the preconditions for the creation of a on-behalf user are met."}
{"code": "public long nextLong(){\n  return org.evosuite.runtime.Random.nextLong();\n}\n", "nl": "Replacement function for nextLong"}
{"code": "public static boolean deleteFileWithBackup(Path file,String datasource){\n  String fn=file.toAbsolutePath().toString();\n  if (!fn.startsWith(datasource)) {\n    LOGGER.warn(\"could not delete file '\" + fn + \"': datasource '\"+ datasource+ \"' does not match\");\n    return false;\n  }\n  if (Files.isDirectory(file)) {\n    LOGGER.warn(\"could not delete file '\" + fn + \"': file is a directory!\");\n    return false;\n  }\n  fn=fn.replace(datasource,datasource + FileSystems.getDefault().getSeparator() + Constants.BACKUP_FOLDER);\n  try {\n    Path backup=Paths.get(fn);\n    if (!Files.exists(backup.getParent())) {\n      Files.createDirectories(backup.getParent());\n    }\n    Files.deleteIfExists(backup);\n    return moveFileSafe(file,backup);\n  }\n catch (  IOException e) {\n    LOGGER.warn(\"Could not delete file: \" + e.getMessage());\n    return false;\n  }\n}\n", "nl": "<b>PHYSICALLY</b> deletes a file by moving it to datasource backup folder<br> DS\\.backup\\&lt;filename&gt;<br> maintaining its originating directory"}
{"code": "public static byte[] internalize(Name name){\n  return internalize(name.getByteArray(),name.getByteOffset(),name.getByteLength());\n}\n", "nl": "Return internal representation of given name, converting '/' to '.'."}
{"code": "@Override public String toString(){\n  if (length == 0) {\n    return \"FacetLabel: []\";\n  }\n  String[] parts=new String[length];\n  System.arraycopy(components,0,parts,0,length);\n  return \"FacetLabel: \" + Arrays.toString(parts);\n}\n", "nl": "Returns a string representation of the path."}
{"code": "protected void init(){\n  if (initialized)   return;\n  Map<String,Class<? extends FXGNode>> elementNodes=new HashMap<String,Class<? extends FXGNode>>(DEFAULT_FXG_1_0_NODES.size() + 4);\n  elementNodes.putAll(DEFAULT_FXG_1_0_NODES);\n  elementNodesByURI=new HashMap<String,Map<String,Class<? extends FXGNode>>>(1);\n  elementNodesByURI.put(FXG_NAMESPACE,elementNodes);\n  HashSet<String> skippedElements=new HashSet<String>(1);\n  skippedElements.add(FXG_PRIVATE_ELEMENT);\n  skippedElementsByURI=new HashMap<String,Set<String>>(1);\n  skippedElementsByURI.put(FXG_NAMESPACE,skippedElements);\n  initialized=true;\n}\n", "nl": "initializes the version handler with FXG 2.0 specific information"}
{"code": "public final double calculateTreeLogLikelihood(Tree tree){\n  int[] n=new int[size];\n  int nTips=tree.getExternalNodeCount();\n  preCalculation(tree);\n  int index=size - 1;\n  double t=t(index);\n  double g=g(index,x0,t);\n  double logP=Math.log(g);\n  for (int i=0; i < tree.getInternalNodeCount(); i++) {\n    double x=tree.getNodeHeight(tree.getInternalNode(i));\n    index=index(x);\n    double contrib=Math.log(birth(birthChanges ? index : 0) * g(index,x,t(index)));\n    logP+=contrib;\n    t=t(index);\n    g=g(index,x,t);\n  }\n  for (int i=0; i < nTips; i++) {\n    double y=tree.getNodeHeight(tree.getExternalNode(i));\n    index=index(y);\n    double contrib=Math.log(psi(samplingChanges ? index : 0)) - Math.log(g(index,y,t(index)));\n    ;\n    logP+=contrib;\n  }\n  for (int j=0; j < size - 1; j++) {\n    double contrib=0;\n    double time=t(j + 1);\n    n[j]=lineageCountAtTime(time,tree);\n    if (n[j] > 0) {\n      contrib+=n[j] * Math.log(g(j,time,t(j)));\n    }\n    logP+=contrib;\n  }\n  return logP;\n}\n", "nl": "Generic likelihood calculation"}
{"code": "public Boolean sismember(final byte[] key,final byte[] member){\n  checkIsInMulti();\n  client.sismember(key,member);\n  return client.getIntegerReply() == 1;\n}\n", "nl": "Return 1 if member is a member of the set stored at key, otherwise 0 is returned. <p> Time complexity O(1)"}
{"code": "Type attribTree(JCTree tree,Env<AttrContext> env,ResultInfo resultInfo){\n  Env<AttrContext> prevEnv=this.env;\n  ResultInfo prevResult=this.resultInfo;\n  try {\n    this.env=env;\n    this.resultInfo=resultInfo;\n    tree.accept(this);\n    if (tree == breakTree && resultInfo.checkContext.deferredAttrContext().mode == AttrMode.CHECK) {\n      throw new BreakAttr(copyEnv(env));\n    }\n    return result;\n  }\n catch (  CompletionFailure ex) {\n    tree.type=syms.errType;\n    return chk.completionError(tree.pos(),ex);\n  }\n finally {\n    this.env=prevEnv;\n    this.resultInfo=prevResult;\n  }\n}\n", "nl": "Visitor method: attribute a tree, catching any completion failure exceptions. Return the tree's type."}
{"code": "@Override public void initialize(){\n  super.initialize();\n  DefaultLookup.setDefaultLookup(new SynthDefaultLookup());\n  setStyleFactory(factory);\n  KeyboardFocusManager.getCurrentKeyboardFocusManager().addPropertyChangeListener(_handler);\n}\n", "nl": "Called by UIManager when this look and feel is installed."}
{"code": "private float spacing(WrapMotionEvent event){\n  float x=event.getX(0) - event.getX(1);\n  float y=event.getY(0) - event.getY(1);\n  return FloatMath.sqrt(x * x + y * y);\n}\n", "nl": "Determine the space between the first two fingers"}
{"code": "protected void parseHeaderLine(String line) throws IOException {\n  int len=2;\n  int n=line.indexOf(\": \");\n  if (n == -1) {\n    len=1;\n    n=line.indexOf(':');\n    if (n == -1)     return;\n  }\n  String key=line.substring(0,n);\n  String val=line.substring(n + len);\n  List<String> list=headers.get(key);\n  if (list != null) {\n    list.add(val);\n  }\n else {\n    list=new ArrayList<String>();\n    list.add(val);\n    headers.put(key,list);\n  }\n}\n", "nl": "Reads one response header line and adds it to the headers map."}
{"code": "public MediaSize(float x,float y,int units){\n  super(x,y,units);\n  if (x > y) {\n    throw new IllegalArgumentException(\"X dimension > Y dimension\");\n  }\n  sizeVector.add(this);\n}\n", "nl": "Construct a new media size attribute from the given floating-point values."}
{"code": "public void fill(int rgb){\n  g.fill(rgb);\n}\n", "nl": "Set the fill to either a grayscale value or an ARGB int."}
{"code": "public boolean equals(Object obj){\n  if (obj == this) {\n    return true;\n  }\n  if (obj instanceof AnnotationMember) {\n    AnnotationMember that=(AnnotationMember)obj;\n    if (name.equals(that.name) && tag == that.tag) {\n      if (tag == ARRAY) {\n        return equalArrayValue(that.value);\n      }\n else       if (tag == ERROR) {\n        return false;\n      }\n else {\n        return value.equals(that.value);\n      }\n    }\n  }\n  return false;\n}\n", "nl": "Returns true if the specified object represents equal element (equivalent name-value pair). <br> A special case is the contained Throwable value; it is considered transcendent so no other element would be equal."}
{"code": "private void init(final AttributeSet attrs,final int defStyleAttr,final int defStyleRes){\n  final TypedArray attributes=getContext().obtainStyledAttributes(attrs,R.styleable.DotIndicator,defStyleAttr,defStyleRes);\n  final int defaultSelectedDotDiameterPx=DimensionHelper.dpToPx(getContext(),DEFAULT_SELECTED_DOT_DIAMETER_DP);\n  final int defaultUnselectedDotDiameterPx=DimensionHelper.dpToPx(getContext(),DEFAULT_UNSELECTED_DOT_DIAMETER_DP);\n  final int defaultSpacingBetweenDotsPx=DimensionHelper.dpToPx(getContext(),DEFAULT_SPACING_BETWEEN_DOTS_DP);\n  numberOfDots=attributes.getInt(R.styleable.DotIndicator_numberOfDots,DEFAULT_NUMBER_OF_DOTS);\n  selectedDotIndex=attributes.getInt(R.styleable.DotIndicator_selectedDotIndex,DEFAULT_SELECTED_DOT_INDEX);\n  unselectedDotDiameterPx=attributes.getDimensionPixelSize(R.styleable.DotIndicator_unselectedDotDiameter,defaultUnselectedDotDiameterPx);\n  selectedDotDiameterPx=attributes.getDimensionPixelSize(R.styleable.DotIndicator_selectedDotDiameter,defaultSelectedDotDiameterPx);\n  unselectedDotColor=attributes.getColor(R.styleable.DotIndicator_unselectedDotColor,DEFAULT_UNSELECTED_DOT_COLOR);\n  selectedDotColor=attributes.getColor(R.styleable.DotIndicator_selectedDotColor,DEFAULT_SELECTED_DOT_COLOR);\n  spacingBetweenDotsPx=attributes.getDimensionPixelSize(R.styleable.DotIndicator_spacingBetweenDots,defaultSpacingBetweenDotsPx);\n  dotTransitionDuration=attributes.getDimensionPixelSize(R.styleable.DotIndicator_dotTransitionDuration,DEFAULT_DOT_TRANSITION_DURATION_MS);\n  attributes.recycle();\n  setLayoutParams(new LayoutParams(MATCH_PARENT,MATCH_PARENT));\n  setGravity(Gravity.CENTER);\n  reflectParametersInView();\n}\n", "nl": "Initialises the member variables of this DotIndicator and creates the UI. This method should only be invoked during construction."}
{"code": "public void block(){\n  lock.writeLock();\n}\n", "nl": "Blocks current thread till all activities left \"busy\" state and prevents them from further entering to \"busy\" state."}
{"code": "@Override public boolean appendTasks(ImageToProcess img,Set<TaskImageContainer> tasks){\n  int countImageRefs=numPropagatedImageReferences(img,tasks);\n  if (img != null) {\n    incrementSemaphoreReferenceCount(img,countImageRefs);\n  }\n  incrementTaskDone(tasks);\n  scheduleTasks(tasks);\n  return true;\n}\n", "nl": "Spawns dependent tasks from internal implementation of a set of tasks. If a dependent task does NOT require the image reference, it should be passed a null pointer as an image reference. In general, this method should be called after the task has completed its own computations, but before it has released its own image reference (via the releaseSemaphoreReference call)."}
{"code": "Account(){\n  id=0;\n  balance=0;\n  annualInterestRate=0;\n  dateCreated=new Date();\n}\n", "nl": "Creates a default account"}
{"code": "private void createLogoutEvent(Session session){\n  if (session.getUserToken() != null && session.getUserToken().length() == 0) {\n    GatheredEvent event=new GatheredEvent();\n    event.setActor(session.getPlatformUserId());\n    event.setType(EventType.PLATFORM_EVENT);\n    event.setEventId(PlatformEventIdentifier.USER_LOGOUT_FROM_SERVICE);\n    event.setOccurrenceTime(System.currentTimeMillis());\n    event.setSubscriptionTKey(session.getSubscriptionTKey().longValue());\n    try {\n      evtMgmt.recordEvent(event);\n    }\n catch (    DuplicateEventException e) {\n      logger.logDebug(e.getMessage());\n    }\n  }\n}\n", "nl": "Creates a logout event for the given session. A logout event is only generated in case the user token is not set anymore, what means that the user has really logged in earlier"}
{"code": "public void clear(){\n  ref.length=0;\n}\n", "nl": "Reset this builder to the empty state."}
{"code": "public static TupleSchema of(String name,TupleSlot... slots){\n  checkNotNull(name,\"name must not be null\");\n  checkNotNull(slots,\"slots must not be null\");\n  Map<String,Integer> slotLookup=IntStream.range(0,slots.length).collect(null,null,null);\n  checkArgument(slots.length == slotLookup.size(),\"Slot names are not unique\");\n  return new TupleSchema(name,slots,slotLookup);\n}\n", "nl": "Create a TupleSchema having the supplied TupleSlots."}
{"code": "boolean isPrivileged(){\n  return isPrivileged;\n}\n", "nl": "Returns true if this context is privileged."}
{"code": "public Iterable<FunctionImport> build(FactoryLookup lookup){\n  List<FunctionImport> builder=new ArrayList<>();\n  for (  FunctionImportImpl.Builder functionImportBuilder : functionImportBuilders) {\n    EntitySet entitySet=lookup.getEntitySet(functionImportBuilder.getEntitySetName());\n    Function function=lookup.getFunction(functionImportBuilder.getFunctionName());\n    if (entitySet == null && function.isBound()) {\n      throw new IllegalArgumentException(\"Could not find EntitySet with name: \" + functionImportBuilder.getEntitySetName());\n    }\n    functionImportBuilder.setEntitySet(entitySet);\n    functionImportBuilder.setFunction(function);\n    builder.add(functionImportBuilder.build());\n  }\n  return Collections.unmodifiableList(builder);\n}\n", "nl": "Returns built function imports using passed lookup for searching entity sets and functions for appropriate function import."}
{"code": "public boolean isEnabled(){\n  if (source instanceof Component) {\n    return ((Component)source).isEnabled();\n  }\n else   if (source instanceof MenuItem) {\n    return ((MenuItem)source).isEnabled();\n  }\n else {\n    return true;\n  }\n}\n", "nl": "Determine if the object is enabled."}
{"code": "@SuppressWarnings(\"unchecked\") public ClusterUpdateSettingsRequest transientSettings(Map source){\n  try {\n    XContentBuilder builder=XContentFactory.contentBuilder(XContentType.JSON);\n    builder.map(source);\n    transientSettings(builder.string());\n  }\n catch (  IOException e) {\n    throw new ElasticsearchGenerationException(\"Failed to generate [\" + source + \"]\",e);\n  }\n  return this;\n}\n", "nl": "Sets the transient settings to be updated. They will not survive a full cluster restart"}
{"code": "private void layoutComponents(){\n  setLayout(new GridBagLayout());\n  setBorder(new CompoundBorder(new TitledBorder(DISPLAY_NAME),new EmptyBorder(6,6,6,6)));\n  setToolTipText(DESCRIPTION);\n  GridBagConstraints c=new GridBagConstraints();\n  c.anchor=GridBagConstraints.WEST;\n  c.fill=GridBagConstraints.HORIZONTAL;\n  c.gridheight=1;\n  c.gridwidth=GridBagConstraints.RELATIVE;\n  c.insets=LABEL_INSETS;\n  c.gridx=0;\n  c.gridy=0;\n  c.weightx=0.33f;\n  c.weighty=0;\n  add(new JLabel(\"Minimum value\"),c);\n  c.insets=FIELD_INSETS;\n  c.gridx=1;\n  c.weightx=0.66f;\n  add(minimumValue,c);\n  c.insets=LABEL_INSETS;\n  c.gridx=0;\n  c.gridy++;\n  c.weightx=0.33f;\n  add(new JLabel(\"Maximum value\"),c);\n  c.insets=FIELD_INSETS;\n  c.gridx=1;\n  c.weightx=0.66f;\n  add(maximumValue,c);\n  c.anchor=GridBagConstraints.NORTHWEST;\n  c.fill=GridBagConstraints.BOTH;\n  c.gridwidth=GridBagConstraints.REMAINDER;\n  c.insets=EMPTY_INSETS;\n  c.gridx=0;\n  c.gridy++;\n  c.weightx=1.0f;\n  c.weighty=1.0f;\n  add(Box.createGlue(),c);\n}\n", "nl": "Layout components."}
{"code": "public int addMultiNewarray(CtClass clazz,int[] dimensions){\n  int len=dimensions.length;\n  for (int i=0; i < len; ++i)   addIconst(dimensions[i]);\n  growStack(len);\n  return addMultiNewarray(clazz,len);\n}\n", "nl": "Appends MULTINEWARRAY."}
{"code": "public int transcribe(IPoint[] hull,int offset){\n  int idx=offset;\n  int sz=points.size();\n  for (int i=0; i < sz; i++) {\n    hull[idx++]=points.get(i);\n  }\n  return idx;\n}\n", "nl": "Fill array with points starting at given offset."}
{"code": "public void editTracks(){\n  List<Track> trackSelection=getRootController().getSelectedTracks();\n  if (!trackSelection.isEmpty()) {\n    boolean[] edit={true};\n    if (trackSelection.size() > 1) {\n      String alertHeader=\"Are you sure you want to edit multiple files?\";\n      Alert alert=createAlert(\"\",alertHeader,\"\",AlertType.CONFIRMATION);\n      Optional<ButtonType> result=alert.showAndWait();\n      result.ifPresent(null);\n    }\n    if (edit[0]) {\n      if (editStage == null) {\n        editStage=initStage(EDIT_LAYOUT,\"Edit\");\n        ((EditController)controllers.get(EDIT_LAYOUT)).setStage(editStage);\n      }\n      showStage(editStage);\n      LOG.debug(\"Showing edit stage\");\n    }\n  }\n}\n", "nl": "Shows the edit window. If the size of track selection is greater than 1, an <tt>Alert</tt> is opened asking for a confirmation of the user."}
{"code": "public ReadMemoryReply(final int packetId,final int errorCode,final IAddress address,final byte[] data){\n  super(packetId,errorCode);\n  if (success()) {\n    Preconditions.checkNotNull(address,\"IE01066: Address argument can not be null\");\n    Preconditions.checkNotNull(data,\"IE01067: Data argument can not be null\");\n  }\n else {\n    if (address != null) {\n      throw new IllegalArgumentException(\"IE01068: Address argument must be null\");\n    }\n    if (data != null) {\n      throw new IllegalArgumentException(\"IE01069: Data argument must be null\");\n    }\n  }\n  startAddress=address;\n  memoryData=data == null ? null : data.clone();\n}\n", "nl": "Creates a new Read Memory reply."}
{"code": "public static CompileStates instance(Context context){\n  CompileStates instance=context.get(compileStatesKey);\n  if (instance == null) {\n    instance=new CompileStates(context);\n  }\n  return instance;\n}\n", "nl": "Get the CompileStates instance for this context."}
{"code": "@Override public void stateChanged(ChangeEvent e){\n  if (e.getSource() == this.acceptCheckBox) {\n    this.acceptButton.setEnabled(this.acceptCheckBox.isSelected());\n  }\n}\n", "nl": "Listens to changes of the check box, enables the accept button when the check box is active."}
{"code": "public void addPoint(Vector3 point1,Vector3 controlPoint,Vector3 point2){\n  mPoint1=point1;\n  mControlPoint=controlPoint;\n  mPoint2=point2;\n}\n", "nl": "Add a Curve"}
{"code": "@Override public void sendErrorStatus(String errorStatus) throws IOException {\n  this.sendMessage(OPERATIONS + \": \" + errorStatus+ \"\\n\");\n}\n", "nl": "constructs an error message and sends it to the client. The error message will be <ul> <li> OPERATIONS: </li> <li> the error string </li> <li> \"\\n\" </li> </ul>"}
{"code": "private boolean selectID(int nodeID,boolean show){\n  if (m_root == null)   return false;\n  log.config(\"NodeID=\" + nodeID + \", Show=\"+ show+ \", root=\"+ m_root);\n  MTreeNode node=m_root.findNode(nodeID);\n  if (node != null) {\n    TreePath treePath=new TreePath(node.getPath());\n    log.config(\"Node=\" + node + \", Path=\"+ treePath.toString());\n    tree.setSelectionPath(treePath);\n    if (show) {\n      tree.makeVisible(treePath);\n      tree.scrollPathToVisible(treePath);\n    }\n    return true;\n  }\n  log.info(\"Node not found; ID=\" + nodeID);\n  return false;\n}\n", "nl": "Select ID in Tree"}
{"code": "public ProductTypeServiceImpl(final GenericDAO<ProductType,Long> productTypeDao){\n  super(productTypeDao);\n}\n", "nl": "Construct service."}
{"code": "public int size(){\n  return data.size();\n}\n", "nl": "Returns the number of observations used in this test."}
{"code": "@Override public void createUntamperedRequest(){\n  CollisionDJBX33A DJBX33A=new CollisionDJBX33A();\n  String untampered=UtilHashDoS.generateUntampered(DJBX33A,optionNumberAttributes.getValue(),optionUseNamespaces.isOn());\n  String soapMessage=this.getOptionTextAreaSoapMessage().getValue();\n  String soapMessageFinal=this.getOptionTextAreaSoapMessage().replacePlaceholderWithPayload(soapMessage,untampered);\n  Map<String,String> httpHeaderMap=new HashMap<String,String>();\n  for (  Map.Entry<String,String> entry : getOriginalRequestHeaderFields().entrySet()) {\n    httpHeaderMap.put(entry.getKey(),entry.getValue());\n  }\n  this.setUntamperedRequestObject(httpHeaderMap,getOriginalRequest().getEndpoint(),soapMessageFinal);\n}\n", "nl": "custom untampered request needed for prevention of false positives based on effect of XML Attribute Count Attack"}
{"code": "@Override public void onCreate(Bundle savedInstanceState){\n  super.onCreate(savedInstanceState);\n  requestWindowFeature(Window.FEATURE_NO_TITLE);\n  setContentView(R.layout.main);\n  mHanler=new Handler();\n  setVolumeControlStream(AudioManager.STREAM_VOICE_CALL);\n  if (!Engine.getInstance().isStarted()) {\n    startActivityForResult(new Intent(this,ScreenSplash.class),Main.RC_SPLASH);\n    return;\n  }\n  Bundle bundle=savedInstanceState;\n  if (bundle == null) {\n    Intent intent=getIntent();\n    bundle=intent == null ? null : intent.getExtras();\n  }\n  if (bundle != null && bundle.getInt(\"action\",Main.ACTION_NONE) != Main.ACTION_NONE) {\n    handleAction(bundle);\n  }\n else   if (mScreenService != null) {\n    mScreenService.show(ScreenHome.class);\n  }\n}\n", "nl": "Called when the activity is first created."}
{"code": "public static String readInputStream(InputStream in) throws IOException {\n  BufferedReader br=new BufferedReader(new InputStreamReader(in));\n  char[] buffer=new char[INITIAL_READ_BUFFER_SIZE];\n  StringBuilder sb=new StringBuilder();\n  int readCount;\n  while ((readCount=br.read(buffer)) != -1) {\n    sb.append(buffer,0,readCount);\n  }\n  return sb.toString();\n}\n", "nl": "Read a string from an input stream."}
{"code": "@Override public ClusterSearchShardsRequest indices(String... indices){\n  if (indices == null) {\n    throw new IllegalArgumentException(\"indices must not be null\");\n  }\n else {\n    for (int i=0; i < indices.length; i++) {\n      if (indices[i] == null) {\n        throw new IllegalArgumentException(\"indices[\" + i + \"] must not be null\");\n      }\n    }\n  }\n  this.indices=indices;\n  return this;\n}\n", "nl": "Sets the indices the search will be executed on."}
{"code": "@Override protected DeLiCluEntry createRootEntry(){\n  return new DeLiCluDirectoryEntry(0,null,false,true);\n}\n", "nl": "Creates an entry representing the root node."}
{"code": "public final void close(){\n  try {\n    this.dataOut.flush();\n    if (this.trace) {\n      this.traceDataOut.flush();\n    }\n  }\n catch (  IOException ignore) {\n  }\n  try {\n    outStream.close();\n    if (this.trace) {\n      this.traceOutStream.close();\n    }\n  }\n catch (  IOException ex) {\n    throw new GemFireIOException(LocalizedStrings.StatArchiveWriter_COULD_NOT_CLOSE_STATARCHIVER_FILE.toLocalizedString(),ex);\n  }\n  if (getSampleCount() == 0) {\n    deleteFileIfPossible(new File(getArchiveName()));\n  }\n}\n", "nl": "Closes the statArchiver by flushing its data to disk a closing its output stream."}
{"code": "public static void createAllTables(SQLiteDatabase db,boolean ifNotExists){\n  RecommendEntityDao.createTable(db,ifNotExists);\n}\n", "nl": "Creates underlying database table using DAOs."}
{"code": "public ContentDispositionHeader createContentDispositionHeader(String contentDisposition) throws ParseException {\n  if (contentDisposition == null)   throw new NullPointerException(\"null arg contentDisposition\");\n  ContentDisposition c=new ContentDisposition();\n  c.setDispositionType(contentDisposition);\n  return c;\n}\n", "nl": "Creates a new ContentDispositionHeader based on the newly supplied contentDisposition value."}
{"code": "public int encodeBase64Partial(int bits,int outputBytes,byte[] buffer,int outPtr){\n  buffer[outPtr++]=_base64ToAsciiB[(bits >> 18) & 0x3F];\n  buffer[outPtr++]=_base64ToAsciiB[(bits >> 12) & 0x3F];\n  if (_usesPadding) {\n    byte pb=(byte)_paddingChar;\n    buffer[outPtr++]=(outputBytes == 2) ? _base64ToAsciiB[(bits >> 6) & 0x3F] : pb;\n    buffer[outPtr++]=pb;\n  }\n else {\n    if (outputBytes == 2) {\n      buffer[outPtr++]=_base64ToAsciiB[(bits >> 6) & 0x3F];\n    }\n  }\n  return outPtr;\n}\n", "nl": "Method that outputs partial chunk (which only encodes one or two bytes of data). Data given is still aligned same as if it as full data; that is, missing data is at the \"right end\" (LSB) of int."}
{"code": "public final boolean isProxy(){\n  return flags[PROXY_TICKET_FLAG];\n}\n", "nl": "Determines is this ticket is a proxy-ticket."}
{"code": "public OracleException(String message,Throwable cause,int errorCode){\n  super(message,cause);\n  this.errorCode=errorCode;\n}\n", "nl": "Constructs an <code>OracleException</code> with a given message, cause, error code, and error prefix."}
{"code": "public HandlerSubscriber(EventExecutor executor){\n  this(executor,DEFAULT_LOW_WATERMARK,DEFAULT_HIGH_WATERMARK);\n}\n", "nl": "Create a new handler subscriber with the default low and high watermarks. The supplied executor must be the same event loop as the event loop that this handler is eventually registered with, if not, an exception will be thrown when the handler is registered."}
{"code": "protected Intersection findClosestIntersection(LatLonPoint latLon){\n  Intersection inter=(Intersection)interQuadTree.get(latLon.getY(),latLon.getX());\n  if (inter == null)   logger.warning(\"no intersection at \" + latLon);\n  return inter;\n}\n", "nl": "Look in intersection Quad Tree for closest intersection to point at specified latitude and longitude. <p>"}
{"code": "public void addSpokenFlag(int flag){\n  final int flags=mMetadata.getInt(KEY_METADATA_SPEECH_FLAGS,0);\n  mMetadata.putInt(KEY_METADATA_SPEECH_FLAGS,flags | flag);\n}\n", "nl": "Adds a spoken feedback flag to this utterance's metadata."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:55:20.434 -0500\",hash_original_method=\"A949ED7F371D2CEC2724714D98F74A81\",hash_generated_method=\"A35FEC8DECEC7FCDFB70A09E65B2BE34\") protected SIPTransactionStack(StackMessageFactory messageFactory){\n  this();\n  this.sipMessageFactory=messageFactory;\n}\n", "nl": "Construcor for the stack. Registers the request and response factories for the stack."}
{"code": "private static Result<?> decodeVariableHeader(ByteBuf buffer,MqttFixedHeader mqttFixedHeader){\nswitch (mqttFixedHeader.messageType()) {\ncase CONNECT:\n    return decodeConnectionVariableHeader(buffer);\ncase CONNACK:\n  return decodeConnAckVariableHeader(buffer);\ncase SUBSCRIBE:\ncase UNSUBSCRIBE:\ncase SUBACK:\ncase UNSUBACK:\ncase PUBACK:\ncase PUBREC:\ncase PUBCOMP:\ncase PUBREL:\nreturn decodePacketIdVariableHeader(buffer);\ncase PUBLISH:\nreturn decodePublishVariableHeader(buffer,mqttFixedHeader);\ndefault :\nreturn new Result<>(null,0);\n}\n}\n", "nl": "Decodes the variable header (if any)"}
{"code": "public String multivalEncode(String value){\n  return value.replaceAll(\"\\\\\\\\\",\"\\\\\\\\\\\\\\\\\").replaceAll(\",\",\"\\\\\\\\,\");\n}\n", "nl": "Encodes a string value according to the conventions for supporting multiple values for a parameter (commas and backslashes are escaped)."}
{"code": "public UrlModuleSourceProvider(Iterable<URI> privilegedUris,Iterable<URI> fallbackUris,UrlConnectionExpiryCalculator urlConnectionExpiryCalculator,UrlConnectionSecurityDomainProvider urlConnectionSecurityDomainProvider){\n  this.privilegedUris=privilegedUris;\n  this.fallbackUris=fallbackUris;\n  this.urlConnectionExpiryCalculator=urlConnectionExpiryCalculator;\n  this.urlConnectionSecurityDomainProvider=urlConnectionSecurityDomainProvider;\n}\n", "nl": "Creates a new module script provider that loads modules against a set of privileged and fallback URIs. It will use the specified heuristic cache expiry calculator and security domain provider."}
{"code": "public void test_getInstanceLjava_lang_StringLjava_lang_String() throws NoSuchAlgorithmException, NoSuchProviderException, IllegalArgumentException, KeyManagementException {\n  try {\n    SSLContext.getInstance(null,mProv.getName());\n    fail(\"NoSuchAlgorithmException or NullPointerException should be thrown \" + \"(protocol is null)\");\n  }\n catch (  NoSuchAlgorithmException e) {\n  }\ncatch (  NullPointerException e) {\n  }\n  for (int i=0; i < invalidValues.length; i++) {\n    try {\n      SSLContext.getInstance(invalidValues[i],mProv.getName());\n      fail(\"NoSuchAlgorithmException must be thrown (protocol: \".concat(invalidValues[i]).concat(\")\"));\n    }\n catch (    NoSuchAlgorithmException e) {\n    }\n  }\n  String prov=null;\n  for (int i=0; i < validValues.length; i++) {\n    try {\n      SSLContext.getInstance(validValues[i],prov);\n      fail(\"IllegalArgumentException must be thrown when provider is null (protocol: \".concat(invalidValues[i]).concat(\")\"));\n    }\n catch (    IllegalArgumentException e) {\n    }\n    try {\n      SSLContext.getInstance(validValues[i],\"\");\n      fail(\"IllegalArgumentException must be thrown when provider is empty (protocol: \".concat(invalidValues[i]).concat(\")\"));\n    }\n catch (    IllegalArgumentException e) {\n    }\n  }\n  for (int i=0; i < validValues.length; i++) {\n    for (int j=1; j < invalidValues.length; j++) {\n      try {\n        SSLContext.getInstance(validValues[i],invalidValues[j]);\n        fail(\"NoSuchProviderException must be thrown (protocol: \".concat(invalidValues[i]).concat(\" provider: \").concat(invalidValues[j]).concat(\")\"));\n      }\n catch (      NoSuchProviderException e) {\n      }\n    }\n  }\n  SSLContext sslC;\n  for (int i=0; i < validValues.length; i++) {\n    sslC=SSLContext.getInstance(validValues[i],mProv.getName());\n    assertTrue(\"Not instanceof SSLContext object\",sslC instanceof SSLContext);\n    assertEquals(\"Incorrect protocol\",sslC.getProtocol(),validValues[i]);\n    assertEquals(\"Incorrect provider\",sslC.getProvider().getName(),mProv.getName());\n    checkSSLContext(sslC);\n  }\n}\n", "nl": "Test for <code>getInstance(String protocol, String provider)</code> method Assertions: throws NullPointerException when protocol is null; throws NoSuchAlgorithmException when protocol is not correct; throws IllegalArgumentException when provider is null or empty; throws NoSuchProviderException when provider is available; returns SSLContext object"}
{"code": "public WrappedByteBuffer putLong(long v){\n  _autoExpand(8);\n  _buf.putLong(v);\n  return this;\n}\n", "nl": "Puts an eight-byte long into the buffer at the current position."}
{"code": "private void verifyMigrationDone(String version){\n  CoordinatorClient coordinator=getCoordinator();\n  Assert.assertEquals(MigrationStatus.DONE,coordinator.getMigrationStatus());\n  String checkpoint=getCheckpoint(version);\n  Assert.assertNull(checkpoint);\n}\n", "nl": "Verify if migration checkpoint information is cleared after migration done"}
{"code": "public RepaintManager(ImageRenderer r){\n  renderer=r;\n}\n", "nl": "Creates a new repaint manager."}
{"code": "public void testMaxNegZero(){\n  byte aBytes[]={45,91,3,-15,35,26,3,91};\n  int aSign=-1;\n  byte rBytes[]={0};\n  BigInteger aNumber=new BigInteger(aSign,aBytes);\n  BigInteger bNumber=BigInteger.ZERO;\n  BigInteger result=aNumber.max(bNumber);\n  byte resBytes[]=new byte[rBytes.length];\n  resBytes=result.toByteArray();\n  for (int i=0; i < resBytes.length; i++) {\n    assertTrue(resBytes[i] == rBytes[i]);\n  }\n  assertTrue(\"incorrect sign\",result.signum() == 0);\n}\n", "nl": "max(BigInteger val). max of negative and ZERO."}
{"code": "static int[] convertMidTerms(int[] k){\n  int[] res=new int[3];\n  if (k.length == 1) {\n    res[0]=k[0];\n  }\n else {\n    if (k.length != 3) {\n      throw new IllegalArgumentException(\"Only Trinomials and pentanomials supported\");\n    }\n    if (k[0] < k[1] && k[0] < k[2]) {\n      res[0]=k[0];\n      if (k[1] < k[2]) {\n        res[1]=k[1];\n        res[2]=k[2];\n      }\n else {\n        res[1]=k[2];\n        res[2]=k[1];\n      }\n    }\n else     if (k[1] < k[2]) {\n      res[0]=k[1];\n      if (k[0] < k[2]) {\n        res[1]=k[0];\n        res[2]=k[2];\n      }\n else {\n        res[1]=k[2];\n        res[2]=k[0];\n      }\n    }\n else {\n      res[0]=k[2];\n      if (k[0] < k[1]) {\n        res[1]=k[0];\n        res[2]=k[1];\n      }\n else {\n        res[1]=k[1];\n        res[2]=k[0];\n      }\n    }\n  }\n  return res;\n}\n", "nl": "Returns a sorted array of middle terms of the reduction polynomial."}
{"code": "public boolean isBufferDirty(){\n  return true;\n}\n", "nl": "Checks whether the image buffer should be repainted."}
{"code": "public int fetchInteger(int tag) throws BerException {\n  int result=0;\n  final int backup=next;\n  try {\n    if (fetchTag() != tag) {\n      throw new BerException();\n    }\n    result=fetchIntegerValue();\n  }\n catch (  BerException e) {\n    next=backup;\n    throw e;\n  }\n  return result;\n}\n", "nl": "Fetch an integer with the specified tag."}
{"code": "protected void drawImage(int x,int y,int w,int h,String image){\n  Image img=loadImage(image);\n  if (img != null) {\n    g.drawImage(img,x,y,w,h,null);\n  }\n}\n", "nl": "Draws an image for the given parameters."}
{"code": "@UnpreemptibleNoWarn(\"The caller is prepared to lose control when it allocates a lock\") static void growLocks(int id){\n  int spineId=id >> LOG_LOCK_CHUNK_SIZE;\n  if (spineId >= LOCK_SPINE_SIZE) {\n    VM.sysFail(\"Cannot grow lock array greater than maximum possible index\");\n  }\n  for (int i=chunksAllocated; i <= spineId; i++) {\n    if (locks[i] != null) {\n      continue;\n    }\n    Lock[] newChunk=new Lock[LOCK_CHUNK_SIZE];\n    lockAllocationMutex.lock();\n    if (locks[i] == null) {\n      locks[i]=newChunk;\n      chunksAllocated++;\n    }\n    lockAllocationMutex.unlock();\n  }\n}\n", "nl": "Grow the locks table by allocating a new spine chunk."}
{"code": "public PLCubicPanorama(){\n  super();\n}\n", "nl": "init methods"}
{"code": "public GetResponseMessage(GetResponseMessage other){\n  if (other.isSetHeader()) {\n    this.header=new AsyncMessageHeader(other.header);\n  }\n  if (other.isSetValues()) {\n    List<VersionedValue> __this__values=new ArrayList<VersionedValue>();\n    for (    VersionedValue other_element : other.values) {\n      __this__values.add(new VersionedValue(other_element));\n    }\n    this.values=__this__values;\n  }\n  if (other.isSetError()) {\n    this.error=new SyncError(other.error);\n  }\n}\n", "nl": "Performs a deep copy on <i>other</i>."}
{"code": "public static String printDateTime(LocalDateTime datetime){\n  return dfISO8601.print(datetime);\n}\n", "nl": "Prints the given datetime as a string."}
{"code": "@Override public SignatureLibraryRelease parse() throws IOException {\n  final SignatureLibraryRelease release=new SignatureLibraryRelease(this.getSignatureLibrary(),this.getReleaseVersionNumber());\n  final Model model1=new Model(SIGNALP_SIGNATURE_NAME1,SIGNALP_SIGNATURE_NAME1,null,null);\n  final Signature.Builder builder1=new Signature.Builder(SIGNALP_SIGNATURE_NAME1);\n  final Signature signature1=builder1.name(SIGNALP_SIGNATURE_NAME1).model(model1).signatureLibraryRelease(release).build();\n  release.addSignature(signature1);\n  final Model model2=new Model(SIGNALP_SIGNATURE_NAME2,SIGNALP_SIGNATURE_NAME2,null,null);\n  final Signature.Builder builder2=new Signature.Builder(SIGNALP_SIGNATURE_NAME2);\n  final Signature signature2=builder2.name(SIGNALP_SIGNATURE_NAME2).model(model2).signatureLibraryRelease(release).build();\n  release.addSignature(signature2);\n  return release;\n}\n", "nl": "This is rather badly named as there is nothing to parse... <p/> However, the point is that it returns a SignatureLibraryRelease for SignalP, containing two Signature objects called \"SignalP-TM\" and \"SignalP-noTM\"."}
{"code": "public Frame(int locals,int stack){\n  this.locals=new Type[locals];\n  this.stack=new Type[stack];\n}\n", "nl": "Create a new frame with the specified local variable table size, and max stack size"}
{"code": "public void enlarge(double scale){\n  double latMargin=scale * (lat2 - lat1);\n  double lngMargin=scale * (lng2 - lng1);\n  lat1-=latMargin;\n  lat2+=latMargin;\n  lng1-=lngMargin;\n  lng2+=lngMargin;\n}\n", "nl": "e.g. scale=0.1 means increase the size by 10% on all sides."}
{"code": "public void exportCode(JavaClass source,JavaClass target) throws Exception {\n  ExportAnalyzer analyzer=new ExportAnalyzer(source,target);\n  CodeEnhancer visitor=new CodeEnhancer(source,this);\n  visitor.analyze(analyzer,false);\n  visitor.update();\n}\n", "nl": "Exports code."}
{"code": "protected void drawFollow(Graphics g,Point2D[] pts,boolean reverse){\n  LinkedList points=new LinkedList();\n  if (reverse) {\n    for (int i=pts.length - 1; i >= 0; i--)     points.add(pts[i]);\n  }\n else {\n    for (int i=0; i < pts.length; i++)     points.add(pts[i]);\n  }\n  LinkedList polysegment=new LinkedList();\n  int l, x1, y1, x2, y2;\n  String c;\n  Point2D p1, p2;\n  double angle;\n  for (int i=0; i < text.length(); i++) {\n    c=text.substring(i,i + 1);\n    l=metrics.stringWidth(c);\n    if (points.isEmpty())     break;\n    LineUtil.retrievePoints(l,points,polysegment);\n    p1=(Point2D)polysegment.getFirst();\n    x1=(int)p1.getX();\n    y1=(int)p1.getY();\n    p2=(Point2D)polysegment.getLast();\n    x2=(int)p2.getX();\n    y2=(int)p2.getY();\n    angle=Math.atan2(y2 - y1,x2 - x1);\n    drawAngledString(g,c,x1,y1,angle);\n  }\n}\n", "nl": "Draws the text character per character to follow the polyline"}
{"code": "public TacticalGraphicSymbol(String sidc){\n  super();\n  init(sidc);\n}\n", "nl": "Constructs a new symbol with no position."}
{"code": "public static TestDiagnosticLine fromDiagnosticFileLine(String diagnosticLine){\n  final String trimmedLine=diagnosticLine.trim();\n  if (trimmedLine.startsWith(\"#\") || trimmedLine.isEmpty()) {\n    return new TestDiagnosticLine(\"\",-1,diagnosticLine,EMPTY);\n  }\n  TestDiagnostic diagnostic=fromDiagnosticFileString(diagnosticLine);\n  return new TestDiagnosticLine(\"\",diagnostic.getLineNumber(),diagnosticLine,Arrays.asList(diagnostic));\n}\n", "nl": "Convert a line in a DiagnosticFile to a TestDiagnosticLine"}
{"code": "public void appendTextString(byte[] textString){\n  if (null == textString) {\n    throw new NullPointerException(\"Text-string is null.\");\n  }\n  if (null == mData) {\n    mData=new byte[textString.length];\n    System.arraycopy(textString,0,mData,0,textString.length);\n  }\n else {\n    ByteArrayOutputStream newTextString=new ByteArrayOutputStream();\n    try {\n      newTextString.write(mData);\n      newTextString.write(textString);\n    }\n catch (    IOException e) {\n      e.printStackTrace();\n      throw new NullPointerException(\"appendTextString: failed when write a new Text-string\");\n    }\n    mData=newTextString.toByteArray();\n  }\n}\n", "nl": "Append to Text-string."}
{"code": "public PoolingByteArrayOutputStream(ByteArrayPool pool){\n  this(pool,DEFAULT_SIZE);\n}\n", "nl": "Constructs a new PoolingByteArrayOutputStream with a default size. If more bytes are written to this instance, the underlying byte array will expand."}
{"code": "private void updateAlias(JLabel label,Alias alias){\n  if (alias != null) {\n    label.setText(alias.getName());\n    String icon=alias.getIconName();\n    if (icon != null) {\n      label.setIcon(mSettingsManager.getImageIcon(icon,SettingsManager.DEFAULT_ICON_SIZE));\n    }\n else {\n      label.setIcon(null);\n    }\n  }\n else {\n    label.setText(\"\");\n    label.setIcon(null);\n  }\n}\n", "nl": "Updates the alias label with text and icon from the alias.  Note: this  does not occur on the Swing event thread -- wrap any calls to this method with an event thread call."}
{"code": "public boolean verifyReader(){\n  return this.verifyReader;\n}\n", "nl": "<p> Returns if the CSVReader will verify the reader before each read. </p> <p> By default the value is true which is the functionality for version 3.0. If set to false the reader is always assumed ready to read - this is the functionality for version 2.4 and before. </p> <p> The reason this method was needed was that certain types of Readers would return false for its ready() method until a read was done (namely readers created using Channels). This caused opencsv not to read from those readers. </p>"}
{"code": "private static void launchDebugger(String dmlScriptStr,String fnameOptConfig,Map<String,String> argVals,boolean parsePyDML) throws ParseException, IOException, DMLRuntimeException, DMLDebuggerException, LanguageException, HopsException, LopsException {\n  DMLDebuggerProgramInfo dbprog=new DMLDebuggerProgramInfo();\n  DMLConfig conf=DMLConfig.readConfigurationFile(fnameOptConfig);\n  ConfigurationManager.setGlobalConfig(conf);\n  AParserWrapper parser=AParserWrapper.createParser(parsePyDML);\n  DMLProgram prog=parser.parse(DML_FILE_PATH_ANTLR_PARSER,dmlScriptStr,argVals);\n  DMLTranslator dmlt=new DMLTranslator(prog);\n  dmlt.liveVariableAnalysis(prog);\n  dmlt.validateParseTree(prog);\n  dmlt.constructHops(prog);\n  dmlt.rewriteHopsDAG(prog);\n  dmlt.constructLops(prog);\n  dbprog.rtprog=prog.getRuntimeProgram(conf);\n  try {\n    initHadoopExecution(conf);\n    DMLDebugger SystemMLdb=new DMLDebugger(dbprog,dmlScriptStr);\n    SystemMLdb.runSystemMLDebugger();\n  }\n  finally {\n    cleanupHadoopExecution(conf);\n  }\n}\n", "nl": "launchDebugger: Launcher for DML debugger. This method should be called after  execution and debug properties have been correctly set, and customized parameters  have been put into _argVals"}
{"code": "public static VMRequest highFraction(float frac){\n  if (VM.HEAP_LAYOUT_64BIT) {\n    return common64Bit(true);\n  }\n  return new VMRequest(REQUEST_FRACTION,Address.zero(),Extent.zero(),frac,true);\n}\n", "nl": "A request for a fraction of available memory, optionally requesting the highest available."}
{"code": "@Override public String toString(){\n  StringBuffer text=new StringBuffer();\n  if (m_trainInstances == null) {\n    text.append(\"CFS subset evaluator has not been built yet\\n\");\n  }\n else {\n    text.append(\"\\tCFS Subset Evaluator\\n\");\n    if (m_missingSeparate) {\n      text.append(\"\\tTreating missing values as a separate value\\n\");\n    }\n    if (m_locallyPredictive) {\n      text.append(\"\\tIncluding locally predictive attributes\\n\");\n    }\n  }\n  return text.toString();\n}\n", "nl": "returns a string describing CFS"}
{"code": "private void unwrapData() throws IgniteCheckedException, SSLException {\n  if (log.isDebugEnabled())   log.debug(\"Unwrapping received data: \" + ses);\n  inNetBuf.flip();\n  SSLEngineResult res=unwrap0();\n  inNetBuf.compact();\n  checkStatus(res);\n  renegotiateIfNeeded(res);\n}\n", "nl": "Unwraps user data to the application buffer."}
{"code": "public static ceylon.language.meta.declaration.Module findLoadedModule(String name,String version){\n  com.redhat.ceylon.model.typechecker.model.Module module=moduleManager.findLoadedModule(name,version);\n  return module != null ? getOrCreateMetamodel(null,module,null,true) : null;\n}\n", "nl": "Used by c.l.meta.modules.find, which accepts null"}
{"code": "public void endBoolean(boolean value){\n}\n", "nl": "Indicates the end of a boolean literal (<code>true</code> or <code>false</code>) in the JSON input. This method will be called after reading the last character of the literal."}
{"code": "public static Organization toVendor(VOOrganization voOrganization) throws ValidationException {\n  validateVendorMandatoryFields(voOrganization);\n  return toCustomer(voOrganization);\n}\n", "nl": "Updates the fields in the Supplier or Technology Provider Organization object to reflect the changes performed in the value object. Creates a new Vendor Organization (Supplier or Technology Provider) object and fills the fields with the corresponding fields from the given value object. For vendors, email contact, phone, url, name and address are mandatory; for customers not."}
{"code": "public UnaryOperator createUnaryOperatorFromString(EDataType eDataType,String initialValue){\n  UnaryOperator result=UnaryOperator.get(initialValue);\n  if (result == null)   throw new IllegalArgumentException(\"The value '\" + initialValue + \"' is not a valid enumerator of '\"+ eDataType.getName()+ \"'\");\n  return result;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "@Override public final void updateCursorBoxOnScreen(final int[] rectParams,final int outlineColor){\n  if (options.getDisplayView() != Display.SINGLE_PAGE) {\n    return;\n  }\n  pages.updateCursorBoxOnScreen(rectParams,outlineColor,getPageNumber(),x_size,y_size);\n}\n", "nl": "update rectangle we draw to highlight an area - See Viewer example for example code showing current usage. This method takes an int array containing the x,y,w,h params of  the rectangle we wish to update. It also takes an int outLineColor which is the rgb value of a Color object."}
{"code": "public boolean isCritical(){\n  return criticality;\n}\n", "nl": "Determines the control's criticality."}
{"code": "public JCTree.JCCompilationUnit parse(JavaFileObject filename){\n  JavaFileObject prev=log.useSource(filename);\n  try {\n    JCTree.JCCompilationUnit t=parse(filename,readSource(filename));\n    if (t.endPositions != null)     log.setEndPosTable(filename,t.endPositions);\n    return t;\n  }\n  finally {\n    log.useSource(prev);\n  }\n}\n", "nl": "Parse contents of file."}
{"code": "public static double[] toDoubleArray(final long[] array){\n  double[] values=new double[array.length];\n  for (int i=0; i < array.length; i++)   values[i]=array[i];\n  return values;\n}\n", "nl": "Converts an array of long primitives to an array of doubles."}
{"code": "@Override public String convertToString(EDataType eDataType,Object instanceValue){\nswitch (eDataType.getClassifierID()) {\ncase DomPackage.TAG_DEFINITION:\n    return convertTagDefinitionToString(eDataType,instanceValue);\ndefault :\n  throw new IllegalArgumentException(\"The datatype '\" + eDataType.getName() + \"' is not a valid classifier\");\n}\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public CSVWriter(Writer writer,char separator,char quotechar){\n  this(writer,separator,quotechar,DEFAULT_ESCAPE_CHARACTER);\n}\n", "nl": "Constructs CSVWriter with supplied separator and quote char."}
{"code": "String formatRomanDigit(int level,int digit){\n  String result=\"\";\n  if (digit == 9) {\n    result=result + romanChars[level][0];\n    result=result + romanChars[level + 1][0];\n    return result;\n  }\n else   if (digit == 4) {\n    result=result + romanChars[level][0];\n    result=result + romanChars[level][1];\n    return result;\n  }\n else   if (digit >= 5) {\n    result=result + romanChars[level][1];\n    digit-=5;\n  }\n  for (int i=0; i < digit; i++) {\n    result=result + romanChars[level][0];\n  }\n  return result;\n}\n", "nl": "Converts the item number into a roman numeral"}
{"code": "public CProjectContainer(final IDatabase database,final INaviProject project){\n  m_database=Preconditions.checkNotNull(database,\"IE01785: database argument can not be null\");\n  m_project=Preconditions.checkNotNull(project,\"IE01786: project argument can not be null\");\n  m_addressSpace=null;\n  m_provider=new ProjectTraceProvider(m_project);\n  m_debuggerProvider=new DebuggerProvider(new ProjectTargetSettings(m_project));\n  if (m_project.isLoaded()) {\n    updateProjectDebuggers();\n  }\n  m_project.addListener(m_listener);\n  if (m_project.isLoaded()) {\n    for (    final INaviAddressSpace addressSpace : m_project.getContent().getAddressSpaces()) {\n      initializeAddressSpaceListeners(addressSpace);\n    }\n  }\n}\n", "nl": "Creates a new project container object."}
{"code": "public VNXeCommandResult createConsistencyGroup(ConsistencyGroupCreateParam createParam){\n  _url=URL_CREATE;\n  return postRequestSync(createParam);\n}\n", "nl": "Create consistency group"}
{"code": "public static String doThrustCheck(MovePath md,Client client){\n  StringBuffer nagReport=new StringBuffer();\n  List<TargetRoll> psrList=new ArrayList<TargetRoll>();\n  if (client.getGame().useVectorMove()) {\n    return nagReport.toString();\n  }\n  final Entity entity=md.getEntity();\n  if (!(entity instanceof Aero)) {\n    return nagReport.toString();\n  }\n  EntityMovementType overallMoveType=EntityMovementType.MOVE_NONE;\n  Aero a=(Aero)entity;\n  PilotingRollData rollTarget;\n  overallMoveType=md.getLastStepMovementType();\n  int thrustUsed=0;\n  int j=0;\n  for (final Enumeration<MoveStep> i=md.getSteps(); i.hasMoreElements(); ) {\n    final MoveStep step=i.nextElement();\n    j++;\n    if ((step.getDistance() == 0) && (md.length() != j)) {\n      thrustUsed+=step.getMp();\n    }\n else {\n      if ((step.getDistance() == 0) && (md.length() == j)) {\n        thrustUsed+=step.getMp();\n      }\n      rollTarget=a.checkThrustSI(thrustUsed,overallMoveType);\n      checkNag(rollTarget,nagReport,psrList);\n      int hits=entity.getCrew().getHits();\n      int health=6 - hits;\n      if (thrustUsed > (2 * health)) {\n        int targetroll=2 + (thrustUsed - (2 * health)) + (2 * hits);\n        nagReport.append(Messages.getString(\"MovementDisplay.addNag\",new Object[]{Integer.toString(targetroll),\"Thrust exceeded twice pilot's health in single hex\"}));\n      }\n      thrustUsed=0;\n    }\n  }\n  return nagReport.toString();\n}\n", "nl": "Checks to see if piloting skill rolls are needed for excessive use of thrust."}
{"code": "public IterationWrapper(Iteration<? extends E,? extends X> iter){\n  assert iter != null;\n  wrappedIter=iter;\n}\n", "nl": "Creates a new IterationWrapper that operates on the supplied Iteration."}
{"code": "public void testReservePassiveAvailabilityChange() throws Throwable {\n  createServers(3);\n  CopycatServer passive=createServer(nextMember(Member.Type.PASSIVE));\n  passive.join(members.stream().map(null).collect(Collectors.toList())).thenRun(null);\n  CopycatServer reserve=createServer(nextMember(Member.Type.RESERVE));\n  reserve.join(members.stream().map(null).collect(Collectors.toList())).thenRun(null);\n  await(10000,2);\n  reserve.cluster().member(passive.cluster().member().address()).onStatusChange(null);\n  passive.shutdown().thenRun(null);\n  await(10000,2);\n}\n", "nl": "Tests detecting an availability change of a passive member on a reserve member."}
{"code": "public void stop(){\n  if (isRunning()) {\n    unscheduleSelf(this);\n  }\n}\n", "nl": "<p>Stops the animation. This method has no effect if the animation is not running.</p>"}
{"code": "public double slopeStdErr(){\n  return Math.sqrt(svar1);\n}\n", "nl": "Returns the standard error of the estimate for the slope."}
{"code": "private static XYDataset createDataset(){\n  TimeSeries s1=new TimeSeries(\"L&G European Index Trust\");\n  s1.add(new Month(2,2001),181.8);\n  s1.add(new Month(3,2001),167.3);\n  s1.add(new Month(4,2001),153.8);\n  s1.add(new Month(5,2001),167.6);\n  s1.add(new Month(6,2001),158.8);\n  s1.add(new Month(7,2001),148.3);\n  s1.add(new Month(8,2001),153.9);\n  s1.add(new Month(9,2001),142.7);\n  s1.add(new Month(10,2001),123.2);\n  s1.add(new Month(11,2001),131.8);\n  s1.add(new Month(12,2001),139.6);\n  s1.add(new Month(1,2002),142.9);\n  s1.add(new Month(2,2002),138.7);\n  s1.add(new Month(3,2002),137.3);\n  s1.add(new Month(4,2002),143.9);\n  s1.add(new Month(5,2002),139.8);\n  s1.add(new Month(6,2002),137.0);\n  s1.add(new Month(7,2002),132.8);\n  TimeSeries s2=new TimeSeries(\"L&G UK Index Trust\");\n  s2.add(new Month(2,2001),129.6);\n  s2.add(new Month(3,2001),123.2);\n  s2.add(new Month(4,2001),117.2);\n  s2.add(new Month(5,2001),124.1);\n  s2.add(new Month(6,2001),122.6);\n  s2.add(new Month(7,2001),119.2);\n  s2.add(new Month(8,2001),116.5);\n  s2.add(new Month(9,2001),112.7);\n  s2.add(new Month(10,2001),101.5);\n  s2.add(new Month(11,2001),106.1);\n  s2.add(new Month(12,2001),110.3);\n  s2.add(new Month(1,2002),111.7);\n  s2.add(new Month(2,2002),111.0);\n  s2.add(new Month(3,2002),109.6);\n  s2.add(new Month(4,2002),113.2);\n  s2.add(new Month(5,2002),111.6);\n  s2.add(new Month(6,2002),108.8);\n  s2.add(new Month(7,2002),101.6);\n  TimeSeriesCollection dataset=new TimeSeriesCollection();\n  dataset.addSeries(s1);\n  dataset.addSeries(s2);\n  return dataset;\n}\n", "nl": "Creates a dataset, consisting of two series of monthly data."}
{"code": "public void globalInit() throws Exception {\n  computeRotationTime();\n  InterProcessLock lock=null;\n  try {\n    lock=_coordinator.getLock(DISTRIBUTED_KEY_TOKEN_LOCK);\n    lock.acquire();\n    if (!doesConfigExist()) {\n      TokenKeysBundle bundle=TokenKeysBundle.createNewTokenKeysBundle();\n      createOrUpdateBundle(bundle);\n      updateCachedTokenKeys(bundle);\n    }\n else {\n      updateCachedKeys();\n      _log.debug(\"Token keys configuration exists, loaded keys\");\n      _log.debug(\"Current token key {}\",_cachedTokenKeysBundle.getCurrentKeyEntry());\n    }\n    keyRotationExecutor.scheduleWithFixedDelay(new KeyRotationThread(),0,_keyRotationIntervalInMsecs,TimeUnit.MILLISECONDS);\n  }\n catch (  Exception ex) {\n    _log.error(\"Exception during initialization of TokenKeyGenerator\",ex);\n  }\n finally {\n    try {\n      if (lock != null) {\n        lock.release();\n      }\n    }\n catch (    Exception ex) {\n      _log.error(\"Could not release the lock during TokenKeyGenerator.init()\");\n      throw ex;\n    }\n  }\n}\n", "nl": "Initialization method to be called by authsvc. It will create the key configuration if it doesn't exist on first startup. Else it will just load the cache."}
{"code": "public Builder addInClause(String fieldName,Collection<String> itemNames,Occurance occurance){\n  if (itemNames.size() == 1) {\n    return addFieldClause(fieldName,itemNames.iterator().next(),occurance);\n  }\n  Query.Builder inClause=Query.Builder.create(occurance);\n  for (  String itemName : itemNames) {\n    inClause.addFieldClause(fieldName,itemName,Occurance.SHOULD_OCCUR);\n  }\n  return addClause(inClause.build());\n}\n", "nl": "Add a clause with the given occurance which matches a property with at least one of several specified values (analogous to a SQL \"IN\" or \"NOT IN\" statements)."}
{"code": "private void injectForBroadcastReceiver(SootField brField,SootField intentField){\n  SootMethod onReceive=Scene.v().getMethod(\"<android.content.BroadcastReceiver: void onReceive(android.content.Context,android.content.Intent)>\");\n  logger.info(\"Adding onReceive call in Harness for Field {}\",brField);\n  Local compLocal=Jimple.v().newLocal(\"_ injectinterapp_comp_local_\" + localID++,brField.getType());\n  Harness.v().addLocalToMain(compLocal);\n  Local intentLocal=Jimple.v().newLocal(\"_ injectinterapp_intent_local_\" + localID++,intentField.getType());\n  Harness.v().addLocalToMain(intentLocal);\n  Stmt compLocalAssign=Jimple.v().newAssignStmt(compLocal,Jimple.v().newStaticFieldRef(brField.makeRef()));\n  Harness.v().addStmtToEndOfMainLoop(compLocalAssign);\n  Stmt intentAssign=Jimple.v().newAssignStmt(intentLocal,Jimple.v().newStaticFieldRef(intentField.makeRef()));\n  Harness.v().addStmtToEndOfMainLoop(intentAssign);\n  Local contextLocal=Jimple.v().newLocal(\"_ injectinterapp_content_local_\" + localID++,intentField.getType());\n  Harness.v().addLocalToMain(contextLocal);\n  SootField contextField=Scene.v().getSootClass(\"droidsafe.runtime.DroidSafeAndroidRuntime\").getFieldByName(\"context\");\n  Stmt contextAssign=Jimple.v().newAssignStmt(contextLocal,Jimple.v().newStaticFieldRef(contextField.makeRef()));\n  Harness.v().addStmtToEndOfMainLoop(contextAssign);\n  List<Value> args=new LinkedList<Value>();\n  args.add(contextLocal);\n  args.add(intentLocal);\n  Stmt onReceiveCall=Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(compLocal,onReceive.makeRef(),args));\n  Harness.v().addStmtToEndOfMainLoop(onReceiveCall);\n  RCFG.v().ignoreInvokeForOutputEvents(onReceiveCall);\n}\n", "nl": "Inject source flow into broadcast receiver field by injecting a call to onReceiver with the created Intent."}
{"code": "public boolean hasActiveEvent(){\n  return activeEvent;\n}\n", "nl": "Returns true if there is an active event"}
{"code": "private static boolean caselessCompare(char a,char b){\n  return Character.toLowerCase(a) == Character.toLowerCase(b);\n}\n", "nl": "Compares two characters whilst ignoring case."}
{"code": "public static void clickToolbarCollapseButton(){\n  onView(withContentDescription(\"Collapse\")).perform(click());\n}\n", "nl": "Clicks the arrow button in the toolbar when its function is collapsing a view. For instance, collapse the search view in the toolbar."}
{"code": "public static JsonValue parse(Reader reader) throws IOException {\n  if (reader == null) {\n    throw new NullPointerException(\"reader is null\");\n  }\n  return new JsonParser(reader).parse();\n}\n", "nl": "Reads the entire input stream from the given reader and parses it as JSON. The input must contain a valid JSON value, optionally padded with whitespace. <p> Characters are read in chunks and buffered internally, therefore wrapping an existing reader in an additional <code>BufferedReader</code> does <strong>not</strong> improve reading performance. </p>"}
{"code": "public static Map<String,Object> sendMail(DispatchContext ctx,Map<String,? extends Object> context){\n  Delegator delegator=ctx.getDelegator();\n  String communicationEventId=(String)context.get(\"communicationEventId\");\n  String orderId=(String)context.get(\"orderId\");\n  Locale locale=(Locale)context.get(\"locale\");\n  if (communicationEventId != null) {\n    Debug.logInfo(\"SendMail Running, for communicationEventId : \" + communicationEventId,module);\n  }\n  Map<String,Object> results=ServiceUtil.returnSuccess();\n  String subject=(String)context.get(\"subject\");\n  subject=FlexibleStringExpander.expandString(subject,context);\n  String partyId=(String)context.get(\"partyId\");\n  String body=(String)context.get(\"body\");\n  List<Map<String,Object>> bodyParts=UtilGenerics.checkList(context.get(\"bodyParts\"));\n  GenericValue userLogin=(GenericValue)context.get(\"userLogin\");\n  results.put(\"communicationEventId\",communicationEventId);\n  results.put(\"partyId\",partyId);\n  results.put(\"subject\",subject);\n  if (UtilValidate.isNotEmpty(orderId)) {\n    results.put(\"orderId\",orderId);\n  }\n  if (UtilValidate.isNotEmpty(body)) {\n    body=FlexibleStringExpander.expandString(body,context);\n    results.put(\"body\",body);\n  }\n  if (UtilValidate.isNotEmpty(bodyParts)) {\n    results.put(\"bodyParts\",bodyParts);\n  }\n  results.put(\"userLogin\",userLogin);\n  String sendTo=(String)context.get(\"sendTo\");\n  String sendCc=(String)context.get(\"sendCc\");\n  String sendBcc=(String)context.get(\"sendBcc\");\n  String redirectAddress=EntityUtilProperties.getPropertyValue(\"general.properties\",\"mail.notifications.redirectTo\",delegator);\n  if (UtilValidate.isNotEmpty(redirectAddress)) {\n    String originalRecipients=\" [To: \" + sendTo + \", Cc: \"+ sendCc+ \", Bcc: \"+ sendBcc+ \"]\";\n    subject+=originalRecipients;\n    sendTo=redirectAddress;\n    sendCc=null;\n    sendBcc=null;\n    if (subject.length() > 255) {\n      subject=subject.substring(0,255);\n    }\n  }\n  String sendFrom=(String)context.get(\"sendFrom\");\n  String sendType=(String)context.get(\"sendType\");\n  String port=(String)context.get(\"port\");\n  String socketFactoryClass=(String)context.get(\"socketFactoryClass\");\n  String socketFactoryPort=(String)context.get(\"socketFactoryPort\");\n  String socketFactoryFallback=(String)context.get(\"socketFactoryFallback\");\n  String sendVia=(String)context.get(\"sendVia\");\n  String authUser=(String)context.get(\"authUser\");\n  String authPass=(String)context.get(\"authPass\");\n  String messageId=(String)context.get(\"messageId\");\n  String contentType=(String)context.get(\"contentType\");\n  Boolean sendPartial=(Boolean)context.get(\"sendPartial\");\n  Boolean isStartTLSEnabled=(Boolean)context.get(\"startTLSEnabled\");\n  boolean useSmtpAuth=false;\n  if (sendType == null || sendType.equals(\"mail.smtp.host\")) {\n    sendType=\"mail.smtp.host\";\n    if (UtilValidate.isEmpty(sendVia)) {\n      sendVia=EntityUtilProperties.getPropertyValue(\"general.properties\",\"mail.smtp.relay.host\",\"localhost\",delegator);\n    }\n    if (UtilValidate.isEmpty(authUser)) {\n      authUser=EntityUtilProperties.getPropertyValue(\"general.properties\",\"mail.smtp.auth.user\",delegator);\n    }\n    if (UtilValidate.isEmpty(authPass)) {\n      authPass=EntityUtilProperties.getPropertyValue(\"general.properties\",\"mail.smtp.auth.password\",delegator);\n    }\n    if (UtilValidate.isNotEmpty(authUser)) {\n      useSmtpAuth=true;\n    }\n    if (UtilValidate.isEmpty(port)) {\n      port=EntityUtilProperties.getPropertyValue(\"general.properties\",\"mail.smtp.port\",delegator);\n    }\n    if (UtilValidate.isEmpty(socketFactoryPort)) {\n      socketFactoryPort=EntityUtilProperties.getPropertyValue(\"general.properties\",\"mail.smtp.socketFactory.port\",delegator);\n    }\n    if (UtilValidate.isEmpty(socketFactoryClass)) {\n      socketFactoryClass=EntityUtilProperties.getPropertyValue(\"general.properties\",\"mail.smtp.socketFactory.class\",delegator);\n    }\n    if (UtilValidate.isEmpty(socketFactoryFallback)) {\n      socketFactoryFallback=EntityUtilProperties.getPropertyValue(\"general.properties\",\"mail.smtp.socketFactory.fallback\",\"false\",delegator);\n    }\n    if (sendPartial == null) {\n      sendPartial=EntityUtilProperties.propertyValueEqualsIgnoreCase(\"general.properties\",\"mail.smtp.sendpartial\",\"true\",delegator) ? true : false;\n    }\n    if (isStartTLSEnabled == null) {\n      isStartTLSEnabled=EntityUtilProperties.propertyValueEqualsIgnoreCase(\"general.properties\",\"mail.smtp.starttls.enable\",\"true\",delegator);\n    }\n  }\n else   if (sendVia == null) {\n    return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"CommonEmailSendMissingParameterSendVia\",locale));\n  }\n  if (contentType == null) {\n    contentType=\"text/html\";\n  }\n  if (UtilValidate.isNotEmpty(bodyParts)) {\n    contentType=\"multipart/mixed\";\n  }\n  results.put(\"contentType\",contentType);\n  Session session;\n  MimeMessage mail;\n  try {\n    Properties props=System.getProperties();\n    props.put(sendType,sendVia);\n    if (UtilValidate.isNotEmpty(port)) {\n      props.put(\"mail.smtp.port\",port);\n    }\n    if (UtilValidate.isNotEmpty(socketFactoryPort)) {\n      props.put(\"mail.smtp.socketFactory.port\",socketFactoryPort);\n    }\n    if (UtilValidate.isNotEmpty(socketFactoryClass)) {\n      props.put(\"mail.smtp.socketFactory.class\",socketFactoryClass);\n      Security.addProvider(new com.sun.net.ssl.internal.ssl.Provider());\n    }\n    if (UtilValidate.isNotEmpty(socketFactoryFallback)) {\n      props.put(\"mail.smtp.socketFactory.fallback\",socketFactoryFallback);\n    }\n    if (useSmtpAuth) {\n      props.put(\"mail.smtp.auth\",\"true\");\n    }\n    if (sendPartial != null) {\n      props.put(\"mail.smtp.sendpartial\",sendPartial ? \"true\" : \"false\");\n    }\n    if (isStartTLSEnabled) {\n      props.put(\"mail.smtp.starttls.enable\",\"true\");\n    }\n    session=Session.getInstance(props);\n    boolean debug=EntityUtilProperties.propertyValueEqualsIgnoreCase(\"general.properties\",\"mail.debug.on\",\"Y\",delegator);\n    session.setDebug(debug);\n    mail=new MimeMessage(session);\n    if (messageId != null) {\n      mail.setHeader(\"In-Reply-To\",messageId);\n      mail.setHeader(\"References\",messageId);\n    }\n    mail.setFrom(new InternetAddress(sendFrom));\n    mail.setSubject(subject,\"UTF-8\");\n    mail.setHeader(\"X-Mailer\",\"Apache OFBiz, The Apache Open For Business Project\");\n    mail.setSentDate(new Date());\n    mail.addRecipients(Message.RecipientType.TO,sendTo);\n    if (UtilValidate.isNotEmpty(sendCc)) {\n      mail.addRecipients(Message.RecipientType.CC,sendCc);\n    }\n    if (UtilValidate.isNotEmpty(sendBcc)) {\n      mail.addRecipients(Message.RecipientType.BCC,sendBcc);\n    }\n    if (UtilValidate.isNotEmpty(bodyParts)) {\n      MimeMultipart mp=new MimeMultipart();\n      Debug.logInfo(bodyParts.size() + \" multiparts found\",module);\n      for (      Map<String,Object> bodyPart : bodyParts) {\n        Object bodyPartContent=bodyPart.get(\"content\");\n        MimeBodyPart mbp=new MimeBodyPart();\n        if (bodyPartContent instanceof String) {\n          Debug.logInfo(\"part of type: \" + bodyPart.get(\"type\") + \" and size: \"+ bodyPart.get(\"content\").toString().length(),module);\n          mbp.setText((String)bodyPartContent,\"UTF-8\",((String)bodyPart.get(\"type\")).substring(5));\n        }\n else         if (bodyPartContent instanceof byte[]) {\n          ByteArrayDataSource bads=new ByteArrayDataSource((byte[])bodyPartContent,(String)bodyPart.get(\"type\"));\n          Debug.logInfo(\"part of type: \" + bodyPart.get(\"type\") + \" and size: \"+ ((byte[])bodyPartContent).length,module);\n          mbp.setDataHandler(new DataHandler(bads));\n        }\n else         if (bodyPartContent instanceof DataHandler) {\n          mbp.setDataHandler((DataHandler)bodyPartContent);\n        }\n else {\n          mbp.setDataHandler(new DataHandler(bodyPartContent,(String)bodyPart.get(\"type\")));\n        }\n        String fileName=(String)bodyPart.get(\"filename\");\n        if (fileName != null) {\n          mbp.setFileName(fileName);\n        }\n        mp.addBodyPart(mbp);\n      }\n      mail.setContent(mp);\n      mail.saveChanges();\n    }\n else {\n      if (contentType.startsWith(\"text\")) {\n        mail.setText(body,\"UTF-8\",contentType.substring(5));\n      }\n else {\n        mail.setContent(body,contentType);\n      }\n      mail.saveChanges();\n    }\n  }\n catch (  MessagingException e) {\n    Debug.logError(e,\"MessagingException when creating message to [\" + sendTo + \"] from [\"+ sendFrom+ \"] cc [\"+ sendCc+ \"] bcc [\"+ sendBcc+ \"] subject [\"+ subject+ \"]\",module);\n    Debug.logError(\"Email message that could not be created to [\" + sendTo + \"] had context: \"+ context,module);\n    return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"CommonEmailSendMessagingException\",UtilMisc.toMap(\"sendTo\",sendTo,\"sendFrom\",sendFrom,\"sendCc\",sendCc,\"sendBcc\",sendBcc,\"subject\",subject),locale));\n  }\ncatch (  IOException e) {\n    Debug.logError(e,\"IOExcepton when creating message to [\" + sendTo + \"] from [\"+ sendFrom+ \"] cc [\"+ sendCc+ \"] bcc [\"+ sendBcc+ \"] subject [\"+ subject+ \"]\",module);\n    Debug.logError(\"Email message that could not be created to [\" + sendTo + \"] had context: \"+ context,module);\n    return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"CommonEmailSendIOException\",UtilMisc.toMap(\"sendTo\",sendTo,\"sendFrom\",sendFrom,\"sendCc\",sendCc,\"sendBcc\",sendBcc,\"subject\",subject),locale));\n  }\n  String mailEnabled=EntityUtilProperties.getPropertyValue(\"general.properties\",\"mail.notifications.enabled\",\"N\",delegator);\n  if (!\"Y\".equalsIgnoreCase(mailEnabled)) {\n    Debug.logImportant(\"Mail notifications disabled in general.properties; mail with subject [\" + subject + \"] not sent to addressee [\"+ sendTo+ \"]\",module);\n    Debug.logVerbose(\"What would have been sent, the addressee: \" + sendTo + \" subject: \"+ subject+ \" context: \"+ context,module);\n    results.put(\"messageWrapper\",new MimeMessageWrapper(session,mail));\n    return results;\n  }\n  Transport trans=null;\n  try {\n    trans=session.getTransport(\"smtp\");\n    if (!useSmtpAuth) {\n      trans.connect();\n    }\n else {\n      trans.connect(sendVia,authUser,authPass);\n    }\n    trans.sendMessage(mail,mail.getAllRecipients());\n    results.put(\"messageWrapper\",new MimeMessageWrapper(session,mail));\n    results.put(\"messageId\",mail.getMessageID());\n    trans.close();\n  }\n catch (  SendFailedException e) {\n    Debug.logError(e,\"[ADDRERR] Address error when sending message to [\" + sendTo + \"] from [\"+ sendFrom+ \"] cc [\"+ sendCc+ \"] bcc [\"+ sendBcc+ \"] subject [\"+ subject+ \"]\",module);\n    List<SMTPAddressFailedException> failedAddresses=new LinkedList<SMTPAddressFailedException>();\n    Exception nestedException=null;\n    while ((nestedException=e.getNextException()) != null && nestedException instanceof MessagingException) {\n      if (nestedException instanceof SMTPAddressFailedException) {\n        SMTPAddressFailedException safe=(SMTPAddressFailedException)nestedException;\n        Debug.logError(\"Failed to send message to [\" + safe.getAddress() + \"], return code [\"+ safe.getReturnCode()+ \"], return message [\"+ safe.getMessage()+ \"]\",module);\n        failedAddresses.add(safe);\n        break;\n      }\n    }\n    Boolean sendFailureNotification=(Boolean)context.get(\"sendFailureNotification\");\n    if (sendFailureNotification == null || sendFailureNotification) {\n      sendFailureNotification(ctx,context,mail,failedAddresses);\n      results.put(\"messageWrapper\",new MimeMessageWrapper(session,mail));\n      try {\n        results.put(\"messageId\",mail.getMessageID());\n        trans.close();\n      }\n catch (      MessagingException e1) {\n        Debug.logError(e1,module);\n      }\n    }\n else {\n      return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"CommonEmailSendAddressError\",UtilMisc.toMap(\"sendTo\",sendTo,\"sendFrom\",sendFrom,\"sendCc\",sendCc,\"sendBcc\",sendBcc,\"subject\",subject),locale));\n    }\n  }\ncatch (  MessagingException e) {\n    Debug.logError(e,\"[CON] Connection error when sending message to [\" + sendTo + \"] from [\"+ sendFrom+ \"] cc [\"+ sendCc+ \"] bcc [\"+ sendBcc+ \"] subject [\"+ subject+ \"]\",module);\n    Debug.logError(\"Email message that could not be sent to [\" + sendTo + \"] had context: \"+ context,module);\n    return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"CommonEmailSendConnectionError\",UtilMisc.toMap(\"sendTo\",sendTo,\"sendFrom\",sendFrom,\"sendCc\",sendCc,\"sendBcc\",sendBcc,\"subject\",subject),locale));\n  }\n  return results;\n}\n", "nl": "Basic JavaMail Service"}
{"code": "public void appendBytes(byte[] bs,int start,int len){\n  elems=ArrayUtils.ensureCapacity(elems,length + len);\n  System.arraycopy(bs,start,elems,length,len);\n  length+=len;\n}\n", "nl": "Append `len' bytes from byte array, starting at given `start' offset."}
{"code": "private void startScrolling(){\n  if (!isScrollingPerformed) {\n    isScrollingPerformed=true;\n    notifyScrollingListenersAboutStart();\n  }\n}\n", "nl": "Starts scrolling"}
{"code": "public void onProgressData(byte[] responseBody){\n  Log.d(LOG_TAG,\"onProgressData(byte[]) was not overriden, but callback was received\");\n}\n", "nl": "Fired when the request progress, override to handle in your own code"}
{"code": "public void writeAttribute(String name,String value,String prefix) throws Exception {\n  if (last != Tag.START) {\n    throw new NodeException(\"Start element required\");\n  }\n  write(' ');\n  write(name,prefix);\n  write('=');\n  write('\"');\n  escape(value);\n  write('\"');\n}\n", "nl": "This is used to write a name value attribute pair. If the last tag written was not a start tag then this throws an exception. All attribute values written are enclosed in double quotes."}
{"code": "private Border createNonRolloverToggleBorder(){\n  UIDefaults table=UIManager.getLookAndFeelDefaults();\n  return new CompoundBorder(new BasicBorders.RadioButtonBorder(table.getColor(\"ToggleButton.shadow\"),table.getColor(\"ToggleButton.darkShadow\"),table.getColor(\"ToggleButton.light\"),table.getColor(\"ToggleButton.highlight\")),new BasicBorders.RolloverMarginBorder());\n}\n", "nl": "Creates a non rollover border for Toggle buttons in the toolbar."}
{"code": "public int toReal(){\n  return _real;\n}\n", "nl": "Returns the real value."}
{"code": "private void addParsedAsAnnotations(final JCas jCas,final int offset,final Parse parsed){\n  final String type=parsed.getType();\n  if (OpenNLPParser.PHRASE_TYPES.contains(type)) {\n    final Span span=parsed.getSpan();\n    final PhraseChunk phraseChunk=new PhraseChunk(jCas);\n    phraseChunk.setBegin(offset + span.getStart());\n    phraseChunk.setEnd(offset + span.getEnd());\n    phraseChunk.setChunkType(parsed.getType());\n    addToJCasIndex(phraseChunk);\n  }\n  Arrays.stream(parsed.getChildren()).forEach(null);\n}\n", "nl": "Adds the parsed as annotations."}
{"code": "public static boolean isLocalContentUri(Uri uri){\n  final String scheme=getSchemeOrNull(uri);\n  return FrescoUri.LOCAL_CONTENT_SCHEME.equals(scheme);\n}\n", "nl": "Check if uri represents local content"}
{"code": "public XPathSubsetContentSelector(ContentManager cm,XBLOMContentElement content,Element bound,String selector){\n  super(cm,content,bound);\n  parseSelector(selector);\n}\n", "nl": "Creates a new XPathSubsetContentSelector object."}
{"code": "protected RestClient newPortalClient(){\n  URI baseUri=URI.create(String.format(\"%s://%s:%s\",protocol,host,portalPort));\n  return new RestClient(baseUri,this);\n}\n", "nl": "Creates the RestClient for the portal. This is provided here so Testcases are able to override the base implementation."}
{"code": "public int mainInit(final String[] args,final OutputStream out,final PrintStream err){\n  if (mCli == null) {\n    throw new RuntimeException(\"Incorrectly configured module\");\n  }\n  return mCli.mainInit(args,out,err);\n}\n", "nl": "Main init for running this module"}
{"code": "public Matrix sample_X(Matrix Z){\n  Matrix P_X=prob_X(Z);\n  return MatrixUtils.sample(P_X,m_R);\n}\n", "nl": "Sample Visible - returns X ~ P(X|Z). A bias column is assumed to be included."}
{"code": "public void reportTable(HSSFWorkbook book,LinkedList<ReportTO> data,HSSFSheet sheet,int fila){\n  HSSFRow row;\n  HSSFFont font=book.createFont();\n  font.setFontHeightInPoints((short)10);\n  font.setFontName(HSSFFont.FONT_ARIAL);\n  HSSFRichTextString text;\n  Iterator<ReportTO> itRep=data.iterator();\n  Boolean newRow=false;\n  sheet.setColumnWidth((short)0,(short)(13 * 256));\n  sheet.setColumnWidth((short)1,(short)(60 * 256));\n  for (int i=2; i < (cols); i++) {\n    sheet.setColumnWidth((short)i,(short)(15 * 256));\n  }\n  HSSFCellStyle cellStyle=book.createCellStyle();\n  HSSFCellStyle cellStyleD=book.createCellStyle();\n  HSSFCellStyle cellStyleN=book.createCellStyle();\n  while (itRep.hasNext()) {\n    short col=0;\n    ReportTO rpt=itRep.next();\n    if (!newRow) {\n      cellStyle=book.createCellStyle();\n      cellStyleD=book.createCellStyle();\n      cellStyleN=book.createCellStyle();\n    }\n    newRow=false;\n    if (rpt.getReportlinestyle() != null && rpt.getReportlinestyle().equals(\"T\")) {\n      row=sheet.createRow(fila++);\n      HSSFFont fontT=book.createFont();\n      fontT.setFontHeightInPoints((short)12);\n      fontT.setFontName(HSSFFont.FONT_ARIAL);\n      fontT.setBoldweight(HSSFFont.BOLDWEIGHT_BOLD);\n      HSSFCellStyle cellStyleT=book.createCellStyle();\n      cellStyleT.setWrapText(true);\n      cellStyleT.setAlignment(HSSFCellStyle.ALIGN_CENTER);\n      cellStyleT.setVerticalAlignment(HSSFCellStyle.VERTICAL_TOP);\n      cellStyleT.setFont(fontT);\n      Region region=new Region(fila - 1,(short)0,fila - 1,endRegion);\n      sheet.addMergedRegion(region);\n      text=new HSSFRichTextString(rpt.getDescription());\n      HSSFCell cellT=row.createCell(col);\n      cellT.setCellStyle(cellStyleT);\n      cellT.setCellValue(text);\n      newRow=true;\n    }\n else     if (rpt.getReportlinestyle() != null && rpt.getReportlinestyle().equals(\"L\")) {\n      cellStyle.setWrapText(true);\n      cellStyle.setBorderTop(HSSFCellStyle.BORDER_MEDIUM);\n      cellStyle.setBottomBorderColor((short)8);\n      cellStyleD.setWrapText(true);\n      cellStyleD.setBorderTop(HSSFCellStyle.BORDER_MEDIUM);\n      cellStyleD.setBottomBorderColor((short)8);\n      cellStyleN.setWrapText(true);\n      cellStyleN.setBorderTop(HSSFCellStyle.BORDER_MEDIUM);\n      cellStyleN.setBottomBorderColor((short)8);\n      newRow=true;\n    }\n else     if (rpt.getReportlinestyle() != null && rpt.getReportlinestyle().equals(\"X\")) {\n      cellStyle.setWrapText(true);\n      cellStyle.setVerticalAlignment(HSSFCellStyle.VERTICAL_TOP);\n      cellStyle.setBorderTop(HSSFCellStyle.BORDER_MEDIUM);\n      cellStyle.setBottomBorderColor((short)8);\n      newRow=true;\n    }\n else     if (rpt.getReportlinestyle() != null && rpt.getReportlinestyle().equals(\"Z\")) {\n      cellStyle.setWrapText(true);\n      cellStyle.setVerticalAlignment(HSSFCellStyle.VERTICAL_TOP);\n      cellStyle.setBorderTop(HSSFCellStyle.BORDER_DOUBLE);\n      cellStyle.setBottomBorderColor((short)8);\n      row=sheet.createRow(fila++);\n      ReportTO rptD=new ReportTO();\n      putRow(cellStyle,cellStyleD,cellStyleN,sheet,row,fila,rptD);\n      cellStyle=book.createCellStyle();\n      newRow=true;\n    }\n else     if (rpt.getReportlinestyle() != null && rpt.getReportlinestyle().equals(\"D\")) {\n      cellStyleD.setWrapText(true);\n      cellStyleD.setVerticalAlignment(HSSFCellStyle.VERTICAL_TOP);\n      cellStyleD.setBorderTop(HSSFCellStyle.BORDER_MEDIUM);\n      cellStyleD.setBottomBorderColor((short)8);\n      newRow=true;\n    }\n else     if (rpt.getReportlinestyle() != null && rpt.getReportlinestyle().equals(\"S\")) {\n      row=sheet.createRow(fila++);\n      newRow=true;\n    }\n else     if (rpt.getTablevel() != null && rpt.getTablevel() > 0) {\n      row=sheet.createRow(fila++);\n      String jerarchy=\"\";\n      for (int i=1; i <= rpt.getTablevel(); i++) {\n        jerarchy=jerarchy + \"   \";\n      }\n      Region region=new Region(fila - 1,(short)0,fila - 1,endRegion);\n      sheet.addMergedRegion(region);\n      text=new HSSFRichTextString(jerarchy + rpt.getDescription());\n      HSSFCell cellJ=row.createCell(col);\n      cellJ.setCellValue(text);\n      newRow=true;\n    }\n else {\n      row=sheet.createRow(fila++);\n      putRow(cellStyle,cellStyleD,cellStyleN,sheet,row,fila,rpt);\n    }\n  }\n}\n", "nl": "llena los datos del reporte - fill report data"}
{"code": "public static Bitmap drawableToBitmap(Drawable drawable){\n  int width=drawable.getIntrinsicWidth();\n  int height=drawable.getIntrinsicHeight();\n  Bitmap bitmap=Bitmap.createBitmap(width,height,drawable.getOpacity() != PixelFormat.OPAQUE ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565);\n  Canvas canvas=new Canvas(bitmap);\n  drawable.setBounds(0,0,width,height);\n  drawable.draw(canvas);\n  return bitmap;\n}\n", "nl": "convert drawable to bitmap"}
{"code": "public XObject operate(XObject left,XObject right) throws javax.xml.transform.TransformerException {\n  return new XNumber(left.num() % right.num());\n}\n", "nl": "Apply the operation to two operands, and return the result."}
{"code": "public static void isTrue(boolean val){\n  if (!val)   throw new IllegalArgumentException(\"Must be true\");\n}\n", "nl": "Validates that the value is true"}
{"code": "private String pad(int n){\n  return n < 10 ? \"0\" + n : n + \"\";\n}\n", "nl": "Return n as padded string"}
{"code": "public static String toJSONString(Collection collection){\n  final StringWriter writer=new StringWriter();\n  try {\n    writeJSONString(collection,writer);\n    return writer.toString();\n  }\n catch (  IOException e) {\n    throw new RuntimeException(e);\n  }\n}\n", "nl": "Convert a list to JSON text. The result is a JSON array.  If this list is also a JSONAware, JSONAware specific behaviours will be omitted at this top level."}
{"code": "protected Map<String,Object> itemToEntityResponse(String root_url){\n  return super.toEntityResponse(root_url);\n}\n", "nl": "Calls the superclass entity response not aggregated to this response."}
{"code": "private void drawDiscete(DiscreteUncertainObject uo,MarkerLibrary ml,int cnum,double size){\n  final int e=uo.getNumberSamples();\n  final double ssize=size * Math.sqrt(e);\n  for (int i=0; i < e; i++) {\n    final NumberVector s=uo.getSample(i);\n    if (s == null) {\n      continue;\n    }\n    double[] v=proj.fastProjectDataToRenderSpace(s);\n    if (v[0] != v[0] || v[1] != v[1]) {\n      continue;\n    }\n    ml.useMarker(svgp,layer,v[0],v[1],cnum,uo.getWeight(i) * ssize);\n  }\n}\n", "nl": "Visualize a discrete uncertain object"}
{"code": "private void checkSetup(){\nsynchronized (TransactionManagerImp.class) {\n    txmgr_=TransactionManagerImp.getTransactionManager();\n    if (txmgr_ == null) {\n      UserTransactionService uts=new UserTransactionServiceImp();\n      uts.init();\n      txmgr_=TransactionManagerImp.getTransactionManager();\n    }\n  }\n}\n", "nl": "Referenceable mechanism requires later setup of txmgr_, otherwise binding into JNDI already requires that TM is running."}
{"code": "public void writeExif(Bitmap bmap,String exifOutFileName) throws FileNotFoundException, IOException {\n  if (bmap == null || exifOutFileName == null) {\n    throw new IllegalArgumentException(NULL_ARGUMENT_STRING);\n  }\n  OutputStream s=null;\n  try {\n    s=getExifWriterStream(exifOutFileName);\n    bmap.compress(Bitmap.CompressFormat.JPEG,90,s);\n    s.flush();\n  }\n catch (  IOException e) {\n    closeSilently(s);\n    throw e;\n  }\n  s.close();\n}\n", "nl": "Writes the tags from this ExifInterface object into a jpeg compressed bitmap, removing prior exif tags."}
{"code": "protected void sendPrepare(final String statementText) throws SQLException, IOException {\n  final XdrOutputStream xdrOut=getXdrOut();\n  xdrOut.writeInt(WireProtocolConstants.op_prepare_statement);\n  xdrOut.writeInt(getTransaction().getHandle());\n  xdrOut.writeInt(getHandle());\n  xdrOut.writeInt(getDatabase().getConnectionDialect());\n  xdrOut.writeString(statementText,getDatabase().getEncoding());\n  xdrOut.writeBuffer(getStatementInfoRequestItems());\n  xdrOut.writeInt(getDefaultSqlInfoSize());\n}\n", "nl": "Sends the statement prepare to the connection."}
{"code": "private void writeNetBuffer() throws IgniteCheckedException {\n  try {\n    ch.write(outNetBuf);\n  }\n catch (  IOException e) {\n    throw new IgniteCheckedException(\"Failed to write byte to socket.\",e);\n  }\n}\n", "nl": "Copies data from out net buffer and passes it to the underlying chain."}
{"code": "public Vector2f interpolate(Vector2f finalVec,float changeAmnt){\n  this.x=(1 - changeAmnt) * this.x + changeAmnt * finalVec.x;\n  this.y=(1 - changeAmnt) * this.y + changeAmnt * finalVec.y;\n  return this;\n}\n", "nl": "Sets this vector to the interpolation by changeAmnt from this to the finalVec this=(1-changeAmnt)*this + changeAmnt * finalVec"}
{"code": "public Compactor minorIndex(long index){\n  this.minorIndex=Math.max(this.minorIndex,index);\n  Segment segment=segments.segment(minorIndex);\n  if (segment != null) {\n    compactIndex=segment.firstIndex();\n  }\n  return this;\n}\n", "nl": "Sets the maximum compaction index for minor compaction."}
{"code": "public static BatchStatus createCreatedStatus(){\n  BatchStatus retval=new BatchStatus();\n  retval.setCode(HttpURLConnection.HTTP_CREATED);\n  retval.setReason(\"Created\");\n  return retval;\n}\n", "nl": "Creates a Success status object."}
{"code": "public final static NameValuePair parseNameValuePair(final String value,HeaderValueParser parser) throws ParseException {\n  if (value == null) {\n    throw new IllegalArgumentException(\"Value to parse may not be null\");\n  }\n  if (parser == null)   parser=BasicHeaderValueParser.DEFAULT;\n  CharArrayBuffer buffer=new CharArrayBuffer(value.length());\n  buffer.append(value);\n  ParserCursor cursor=new ParserCursor(0,value.length());\n  return parser.parseNameValuePair(buffer,cursor);\n}\n", "nl": "Parses a name-value-pair with the given parser."}
{"code": "public void dismissSuggestions(){\n  if (mSuggestionsListView.getVisibility() == VISIBLE) {\n    mSuggestionsListView.setVisibility(GONE);\n  }\n}\n", "nl": "Dismiss the suggestions list."}
{"code": "private static boolean tagExists(final String tagTitle,final List<JSONObject> tags) throws JSONException {\n  for (  final JSONObject tag : tags) {\n    if (tag.getString(Tag.TAG_TITLE).equals(tagTitle)) {\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "Determines whether the specified tag title exists in the specified tags."}
{"code": "public Second(){\n  this(new Date());\n}\n", "nl": "Constructs a new Second, based on the system date/time."}
{"code": "private void launchReport(KeyNamePair pp){\n  MPrintFormat pf=MPrintFormat.get(Env.getCtx(),pp.getKey(),false);\n  launchReport(pf);\n}\n", "nl": "Launch Report"}
{"code": "public static Class<?> loadClassWithout(ClassLoader loader,String className) throws ClassNotFoundException {\n  MBEANSERVER_LOGGER.logp(Level.FINEST,DefaultLoaderRepository.class.getName(),\"loadClassWithout\",className);\n  return load(loader,className);\n}\n", "nl": "Go through the list of class loaders but exclude the given class loader, then try to load the requested class. The method will stop as soon as the class is found. If the class is not found the method will throw a <CODE>ClassNotFoundException</CODE> exception."}
{"code": "@Override public void mark(int readlimit){\n}\n", "nl": "Marks the current position in this stream. Setting a mark is not supported in this class; this implementation does nothing."}
{"code": "public void removeGenClass(SootClass clz){\n  genClasses.remove(clz.getName());\n}\n", "nl": "Remove a class from the list of gen classes."}
{"code": "public boolean isMultipleAssignmentDeclaration(){\n  return getLeftExpression() instanceof TupleExpression;\n}\n", "nl": "This method tells you if this declaration is a multiple assignment declaration, which  has the form \"def (x, y) = ...\" in Groovy. If this method returns true, then the left hand side is an ArgumentListExpression. Do not call \"getVariableExpression()\" on this  object if this method returns true, instead use \"getLeftExpression()\"."}
{"code": "public Bindings addOptComponent(String property,Class<? extends IValidatable> clazz,JToggleButton c){\n  return addOptComponent(property,clazz,c,false);\n}\n", "nl": "Add an optional (nullable) Java Bean component of type clazz."}
{"code": "public LUDecomposition lu(){\n  return new LUDecomposition(this);\n}\n", "nl": "LU Decomposition"}
{"code": "public static void addCombinerRecipe(ItemStack input,ItemStack output){\n  try {\n    Class recipeClass=Class.forName(\"mekanism.common.recipe.RecipeHandler\");\n    Method m=recipeClass.getMethod(\"addCombinerRecipe\",ItemStack.class,ItemStack.class);\n    m.invoke(null,input,output);\n  }\n catch (  Exception e) {\n    System.err.println(\"Error while adding recipe: \" + e.getMessage());\n  }\n}\n", "nl": "Add a Combiner recipe."}
{"code": "static void forceSetFactory2(LayoutInflater inflater,LayoutInflater.Factory2 factory){\n  if (!sCheckedField) {\n    try {\n      sLayoutInflaterFactory2Field=LayoutInflater.class.getDeclaredField(\"mFactory2\");\n      sLayoutInflaterFactory2Field.setAccessible(true);\n    }\n catch (    NoSuchFieldException e) {\n      Log.e(TAG,\"forceSetFactory2 Could not find field 'mFactory2' on class \" + LayoutInflater.class.getName() + \"; inflation may have unexpected results.\",e);\n    }\n    sCheckedField=true;\n  }\n  if (sLayoutInflaterFactory2Field != null) {\n    try {\n      sLayoutInflaterFactory2Field.set(inflater,factory);\n    }\n catch (    IllegalAccessException e) {\n      Log.e(TAG,\"forceSetFactory2 could not set the Factory2 on LayoutInflater \" + inflater + \"; inflation may have unexpected results.\",e);\n    }\n  }\n}\n", "nl": "For APIs >= 11 && < 21, there was a framework bug that prevented a LayoutInflater's Factory2 from being merged properly if set after a cloneInContext from a LayoutInflater that already had a Factory2 registered. We work around that bug here. If we can't we log an error."}
{"code": "public static XmlJmapper readAtRuntime(String xmlPath) throws MalformedURLException, IOException {\n  return toXmlJmapper(xmlPath,loadResource(xmlPath));\n}\n", "nl": "This method loads the xml file relative to xmlPath parameter. Read method is used for the xml manipulation at runtime."}
{"code": "protected double computeEyeDistance(DrawContext dc,ShapeData shapeData){\n  double minDistance=Double.MAX_VALUE;\n  Vec4 eyePoint=dc.getView().getEyePoint();\n  for (  Vec4 point : shapeData.getOuterBoundaryInfo().capVertices) {\n    double d=point.add3(shapeData.getReferencePoint()).distanceTo3(eyePoint);\n    if (d < minDistance)     minDistance=d;\n  }\n  return minDistance;\n}\n", "nl": "Computes the minimum distance between this shape and the eye point."}
{"code": "private <T extends DataObject>void updateInactiveField(Class<T> clazz,List<URI> keyList){\n  DbClient dbClient=getDbClient();\n  log.info(\"update inactive field for class: {}\",clazz.getSimpleName());\n  T object;\n  for (  URI key : keyList) {\n    try {\n      object=clazz.newInstance();\n      object.setId(key);\n      object.setInactive(false);\n    }\n catch (    Exception e) {\n      log.error(\"create new object of class({}) failed. e=\",clazz.getSimpleName(),e);\n      throw new IllegalStateException(e);\n    }\n    dbClient.updateAndReindexObject(object);\n    log.info(\"Update the inactive field of object(cf={}, id={}) to false\",object.getClass().getName(),object.getId());\n  }\n}\n", "nl": "Update the missed setting of \"inactive field\" for all data object"}
{"code": "public int compareTo(Object other){\n  if (!(other instanceof Resource)) {\n    throw new SwcException.NotAResource(other.getClass().getName());\n  }\n  Resource r=(Resource)other;\n  return getName().compareTo(r.getName());\n}\n", "nl": "delegates to a comparison of names."}
{"code": "public static void main(String[] args) throws InterruptedException {\n  Counter counter;\n  final int total=10000;\n  Thread[] threads=new Thread[total];\n  for (  Method method : Method.values()) {\n    counter=new Counter();\n    for (int i=0; i < threads.length; i++) {\n      threads[i]=new Thread(new Incrementer(counter,method));\n      threads[i].start();\n    }\n    for (int i=0; i < threads.length; i++) {\n      threads[i].join();\n    }\nswitch (method) {\ncase TwoStatements:\ncase OneStatement:\n      if (counter.total >= total) {\n        System.out.format(\"unlikely event: method %s: total: %d%n\",method,counter.total);\n      }\n    break;\ncase SynchronizedMethod:\ncase SynchronizedBlock:\ncase Semaphore:\ncase SemaphoreTry:\ncase Lock:\n  assert counter.total == total;\nbreak;\ncase AtomicInteger:\nassert counter.atomicTotal.get() == total;\nbreak;\n}\n}\nCounter.reentrantOuter();\nCounter.reentrantOuterBlock();\nCounter.reentrantOuterLock();\n}\n", "nl": "Increments a counter `total` times with different methods in multiple threads and checks if the result is correct (shoul equal `total`)."}
{"code": "public void reset(ActionMapping mapping,HttpServletRequest request){\n  puid=null;\n  op=null;\n  name=null;\n  canLookup=false;\n}\n", "nl": "Method reset"}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:58:53.642 -0500\",hash_original_method=\"8F0255C2E086694196AF7CFC36B7EF43\",hash_generated_method=\"7E35C8E7189C135682BC48CACE7EFA68\") public boolean isMinInfoReady(){\n  return mIsMinInfoReady;\n}\n", "nl": "Check if subscription data has been assigned to mMin return true if MIN info is ready; false otherwise."}
{"code": "public Name(byte[] encoding) throws IOException {\n  DerInputStream in=new DerInputStream(encoding);\n  if (in.getEndOffset() != encoding.length) {\n    throw new IOException(\"Wrong content length\");\n  }\n  ASN1.decode(in);\n  this.rdn=(List<List<AttributeTypeAndValue>>)in.content;\n}\n", "nl": "Creates new <code>Name</code> instance from its DER encoding"}
{"code": "public double[][] distributionsForInstances(Instances insts) throws Exception {\n  if (getClassifier() instanceof BatchPredictor) {\n    Instances filteredInsts=Filter.useFilter(insts,m_Filter);\n    if (filteredInsts.numInstances() != insts.numInstances()) {\n      throw new WekaException(\"FilteredClassifier: filter has returned more/less instances than required.\");\n    }\n    return ((BatchPredictor)getClassifier()).distributionsForInstances(filteredInsts);\n  }\n else {\n    double[][] result=new double[insts.numInstances()][insts.numClasses()];\n    for (int i=0; i < insts.numInstances(); i++) {\n      result[i]=distributionForInstance(insts.instance(i));\n    }\n    return result;\n  }\n}\n", "nl": "Batch scoring method. Calls the appropriate method for the base learner if it implements BatchPredictor. Otherwise it simply calls the distributionForInstance() method repeatedly."}
{"code": "@Override public UserProjectObject copy(){\n  return new UserProjectObject(this);\n}\n", "nl": "This method was generated by MyBatis Generator. This method corresponds to the database table user_project"}
{"code": "public void addLogListener(LogListener l){\n  super.addLogListener(l);\n  for (  DatasetProvider provider : m_Providers)   provider.addLogListener(l);\n}\n", "nl": "Adds the log listener to use."}
{"code": "public static void closeSilently(Closeable out){\n  if (out != null) {\n    try {\n      trace(\"closeSilently\",null,out);\n      out.close();\n    }\n catch (    Exception e) {\n    }\n  }\n}\n", "nl": "Close an output stream without throwing an exception."}
{"code": "BitMatrix buildFunctionPattern(){\n  int dimension=getDimensionForVersion();\n  BitMatrix bitMatrix=new BitMatrix(dimension);\n  bitMatrix.setRegion(0,0,9,9);\n  bitMatrix.setRegion(dimension - 8,0,8,9);\n  bitMatrix.setRegion(0,dimension - 8,9,8);\n  int max=alignmentPatternCenters.length;\n  for (int x=0; x < max; x++) {\n    int i=alignmentPatternCenters[x] - 2;\n    for (int y=0; y < max; y++) {\n      if ((x == 0 && (y == 0 || y == max - 1)) || (x == max - 1 && y == 0)) {\n        continue;\n      }\n      bitMatrix.setRegion(alignmentPatternCenters[y] - 2,i,5,5);\n    }\n  }\n  bitMatrix.setRegion(6,9,1,dimension - 17);\n  bitMatrix.setRegion(9,6,dimension - 17,1);\n  if (versionNumber > 6) {\n    bitMatrix.setRegion(dimension - 11,0,3,6);\n    bitMatrix.setRegion(0,dimension - 11,6,3);\n  }\n  return bitMatrix;\n}\n", "nl": "See ISO 18004:2006 Annex E"}
{"code": "public boolean equals(Object obj){\n  if (obj == this) {\n    return true;\n  }\n  if (!(obj instanceof VolumeDataset)) {\n    return false;\n  }\n  VolumeDataset that=(VolumeDataset)obj;\n  if (!this.xPosition.equals(that.xPosition)) {\n    return false;\n  }\n  return ObjectUtilities.equal(this.data,that.data);\n}\n", "nl": "Tests this instance for equality with an arbitrary object."}
{"code": "public void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {\n  doGet(request,response);\n}\n", "nl": "Process the HTTP Post request to simplify we reuse the doGet functionality"}
{"code": "public static <U extends Key<?>>KeyMatcher<U> keyEquals(U compareTo){\n  return new KeyMatcher<U>(compareTo);\n}\n", "nl": "Create a KeyMatcher that matches Keys that equal the given key."}
{"code": "public OverScroller(Context context,Interpolator interpolator,float bounceCoefficientX,float bounceCoefficientY){\n  this(context,interpolator,true);\n}\n", "nl": "Creates an OverScroller with flywheel enabled."}
{"code": "@Override public void execute() throws MojoExecutionException {\n  getLog().debug(\"Creating output directory \\\"\" + outputDirectory + \"\\\".\");\n  java.nio.file.Path outputDirectoryPath=Paths.get(outputDirectory.toURI());\n  if (!Files.exists(outputDirectoryPath)) {\n    try {\n      Files.createDirectories(outputDirectoryPath);\n    }\n catch (    IOException e) {\n      throw new MojoExecutionException(\"Unable to create directory for output path \\\"\" + outputDirectoryPath + \"\\\".\",e);\n    }\n  }\n  Swagger swagger=getSwagger();\n  ModelClassFinder modelClassFinder=new ModelClassFinder(getLog(),modelJavaPackage,modelErrorClassName);\n  RestControllerProcessor restControllerProcessor=new RestControllerProcessor(getLog(),swagger,restJavaPackage,tagPatternParameter,modelClassFinder.getModelErrorClass());\n  XsdParser xsdParser=null;\n  if (xsdName != null) {\n    xsdParser=new XsdParser(xsdName);\n  }\n  new DefinitionGenerator(getLog(),swagger,restControllerProcessor.getExampleClassNames(),modelClassFinder.getModelClasses(),xsdParser);\n  createYamlFile(swagger);\n}\n", "nl": "The main execution method for this Mojo."}
{"code": "public ActionErrors validate(ActionMapping mapping,HttpServletRequest request){\n  ActionErrors errors=new ActionErrors();\n  if (nivelAcceso < 0) {\n    errors.add(ActionErrors.GLOBAL_MESSAGE,new ActionError(Constants.ERROR_REQUIRED,Messages.getString(Constants.ETIQUETA_NIVEL_ACCESO,request.getLocale())));\n  }\n  if ((nivelAcceso == NivelAcceso.RESTRINGIDO) && StringUtils.isBlank(idLCA)) {\n    errors.add(ActionErrors.GLOBAL_MESSAGE,new ActionError(Constants.ERROR_REQUIRED,Messages.getString(Constants.ETIQUETA_LISTA_CONTROL_ACCESO,request.getLocale())));\n  }\n  return errors;\n}\n", "nl": "Valida el formulario"}
{"code": "@Override public Object readReply(Class expectedClass) throws Throwable {\n  int tag=read();\n  if (tag == 'R')   return readObject(expectedClass);\n else   if (tag == 'F') {\n    HashMap map=(HashMap)readObject(HashMap.class);\n    throw prepareFault(map);\n  }\n else {\n    StringBuilder sb=new StringBuilder();\n    sb.append((char)tag);\n    try {\n      int ch;\n      while ((ch=read()) >= 0) {\n        sb.append((char)ch);\n      }\n    }\n catch (    IOException e) {\n      log.log(Level.FINE,e.toString(),e);\n    }\n    throw error(\"expected hessian reply at \" + codeName(tag) + \"\\n\"+ sb);\n  }\n}\n", "nl": "Reads a reply as an object. If the reply has a fault, throws the exception."}
{"code": "@POST @Path(\"send\") @Consumes(MediaType.APPLICATION_JSON) public Response sendMail(EmailBeanDto emailBean){\n  File tempDir=null;\n  try {\n    MimeMessage message=new MimeMessage(sessionHolder.getMailSession());\n    Multipart contentPart=new MimeMultipart();\n    MimeBodyPart bodyPart=new MimeBodyPart();\n    bodyPart.setText(emailBean.getBody(),\"UTF-8\",getSubType(emailBean.getMimeType()));\n    contentPart.addBodyPart(bodyPart);\n    if (emailBean.getAttachments() != null) {\n      tempDir=Files.createTempDir();\n      for (      AttachmentDto attachmentDto : emailBean.getAttachments()) {\n        byte[] attachmentContent=Base64.getDecoder().decode(attachmentDto.getContent());\n        File attachmentFile=new File(tempDir,attachmentDto.getFileName());\n        Files.write(attachmentContent,attachmentFile);\n        MimeBodyPart attachmentPart=new MimeBodyPart();\n        attachmentPart.attachFile(attachmentFile);\n        attachmentPart.setContentID(\"<\" + attachmentDto.getContentId() + \">\");\n        contentPart.addBodyPart(attachmentPart);\n      }\n    }\n    message.setContent(contentPart);\n    message.setSubject(emailBean.getSubject(),\"UTF-8\");\n    message.setFrom(new InternetAddress(emailBean.getFrom(),true));\n    message.addRecipients(Message.RecipientType.TO,InternetAddress.parse(emailBean.getTo()));\n    if (emailBean.getReplyTo() != null) {\n      message.setReplyTo(InternetAddress.parse(emailBean.getReplyTo()));\n    }\n    LOG.info(\"Sending from {} to {} with subject {}\",emailBean.getFrom(),emailBean.getTo(),emailBean.getSubject());\n    Transport.send(message);\n    LOG.debug(\"Mail send\");\n  }\n catch (  MessagingException|IOException e) {\n    LOG.error(e.getLocalizedMessage());\n    throw new WebApplicationException(e);\n  }\n finally {\n    if (tempDir != null) {\n      try {\n        FileUtils.deleteDirectory(tempDir);\n      }\n catch (      IOException exception) {\n        LOG.error(exception.getMessage());\n      }\n    }\n  }\n  return Response.ok().build();\n}\n", "nl": "Send mail message. If you need to send more than one copy of email, then write needed receivers to EmailBean using setTo() method."}
{"code": "@Override public boolean isActive(){\n  return amIActive;\n}\n", "nl": "Used by the Whitebox GUI to tell if this plugin is still running."}
{"code": "static String checkNotNullOrBlank(String value,String errorMessage,Object... args){\n  checkNotNull(value,errorMessage,args);\n  String trimmed=value.trim();\n  if (trimmed.isEmpty()) {\n    throw new IllegalArgumentException(String.format(errorMessage,args));\n  }\n  return trimmed;\n}\n", "nl": "Ensures that a String is not null and contains at least one non-whitespace char."}
{"code": "public boolean hasTrait(String ns,String ln){\n  return false;\n}\n", "nl": "Returns whether the given trait is available on this element."}
{"code": "@Override public synchronized void acceptTrainingSet(TrainingSetEvent e){\n  try {\n    m_Saver=makeCopy();\n  }\n catch (  Exception ex) {\n    if (m_logger != null) {\n      m_logger.statusMessage(statusMessagePrefix() + \"ERROR (See log for details)\");\n      m_logger.logMessage(\"[Saver] \" + statusMessagePrefix() + \" unable to copy saver. \"+ ex.getMessage());\n    }\n  }\n  passEnvOnToSaver();\n  m_fileName=sanitizeFilename(e.getTrainingSet().relationName());\n  m_dataSet=e.getTrainingSet();\n  if (e.isStructureOnly() && m_isDBSaver && ((DatabaseSaver)m_SaverTemplate).getRelationForTableName()) {\n    ((DatabaseSaver)m_Saver).setTableName(m_fileName);\n  }\n  if (!e.isStructureOnly()) {\n    if (!m_isDBSaver) {\n      try {\n        m_Saver.setDirAndPrefix(m_fileName,\"_training_\" + e.getSetNumber() + \"_of_\"+ e.getMaxSetNumber());\n      }\n catch (      Exception ex) {\n        System.out.println(ex);\n      }\n    }\n else {\n      ((DatabaseSaver)m_Saver).setRelationForTableName(false);\n      String setName=((DatabaseSaver)m_Saver).getTableName();\n      setName=setName.replaceFirst(\"_[tT][rR][aA][iI][nN][iI][nN][gG]_[0-9]+_[oO][fF]_[0-9]+\",\"\");\n      ((DatabaseSaver)m_Saver).setTableName(setName + \"_training_\" + e.getSetNumber()+ \"_of_\"+ e.getMaxSetNumber());\n    }\n    saveBatch();\n    System.out.println(\"... training set \" + e.getSetNumber() + \" of \"+ e.getMaxSetNumber()+ \" for relation \"+ m_fileName+ \" saved.\");\n  }\n}\n", "nl": "Method reacts to a training set event and starts the writing process in batch mode"}
{"code": "public boolean contains(final short[] a){\n  int i=d, l=a.length;\n  long bits[]=this.bits;\n  while (i-- != 0)   if (!get(bits,hash(a,l,i)))   return false;\n  return true;\n}\n", "nl": "Checks whether the given short array is in this filter."}
{"code": "public int hashCode(){\n  return 83 + start + 7 * end + (negated ? 1 : 0);\n}\n", "nl": "<p>Gets a hashCode compatible with the equals method.</p>"}
{"code": "@BeforeClass public static void beforeClass(){\n  PlayerTestHelper.generateNPCRPClasses();\n  MockStendlRPWorld.get();\n}\n", "nl": "Setup before running tests in this test class"}
{"code": "public void requestDestroyed(ServletRequestEvent event){\n  try {\n    ServletRequest request=event.getServletRequest();\n    for (Enumeration e=request.getAttributeNames(); e.hasMoreElements(); ) {\n      String beanName=(String)e.nextElement();\n      handleAttributeEvent(beanName,request.getAttribute(beanName),ELUtils.Scope.REQUEST);\n    }\n    WebConfiguration config=WebConfiguration.getInstance(event.getServletContext());\n    if (config.isOptionEnabled(WebConfiguration.BooleanWebContextInitParameter.EnableAgressiveSessionDirtying)) {\n      syncSessionScopedBeans(request);\n    }\n    boolean distributable=config.isOptionEnabled(EnableDistributable);\n    if (distributable) {\n      HttpSession session=((HttpServletRequest)request).getSession(false);\n      if (session != null && session.getAttribute(ACTIVE_VIEW_MAPS) != null) {\n        session.setAttribute(ACTIVE_VIEW_MAPS,session.getAttribute(ACTIVE_VIEW_MAPS));\n      }\n    }\n  }\n catch (  Throwable t) {\n    FacesContext context=new InitFacesContext(event.getServletContext());\n    ExceptionQueuedEventContext eventContext=new ExceptionQueuedEventContext(context,t);\n    context.getApplication().publishEvent(context,ExceptionQueuedEvent.class,eventContext);\n    context.getExceptionHandler().handle();\n  }\n finally {\n    ApplicationAssociate.setCurrentInstance(null);\n  }\n}\n", "nl": "The request is about to go out of scope of the web application."}
{"code": "public void testFailoverAutoFallBack() throws Exception {\n  Set<String> downedHosts=new HashSet<String>();\n  downedHosts.add(HOST_1);\n  downedHosts.add(HOST_3);\n  Properties props=new Properties();\n  props.setProperty(\"retriesAllDown\",\"2\");\n  props.setProperty(\"queriesBeforeRetryMaster\",\"10\");\n  props.setProperty(\"secondsBeforeRetryMaster\",\"1\");\n  for (  boolean autoCommit : new boolean[]{true,false}) {\n    Connection testConn=getUnreliableFailoverConnection(new String[]{HOST_1,HOST_2,HOST_3},props,downedHosts);\n    Statement testStmt=null;\n    try {\n      testConn.setAutoCommit(autoCommit);\n      assertEquals(HOST_2_OK,UnreliableSocketFactory.getHostFromLastConnection());\n      testStmt=testConn.createStatement();\n      assertSingleValueQuery(testStmt,\"SELECT 1\",1L);\n      UnreliableSocketFactory.dontDownHost(HOST_1);\n      UnreliableSocketFactory.dontDownHost(HOST_3);\n      long startTime=System.currentTimeMillis();\n      boolean hostSwitched=false;\n      do {\n        assertSingleValueQuery(testStmt,\"SELECT 1\",1L);\n        if (autoCommit) {\n          if (!hostSwitched && UnreliableSocketFactory.getHostFromLastConnection().equals(HOST_1_OK)) {\n            hostSwitched=true;\n          }\n          if (hostSwitched) {\n            assertEquals(HOST_1_OK,UnreliableSocketFactory.getHostFromLastConnection());\n          }\n else {\n            assertEquals(HOST_2_OK,UnreliableSocketFactory.getHostFromLastConnection());\n          }\n        }\n else {\n          assertEquals(HOST_2_OK,UnreliableSocketFactory.getHostFromLastConnection());\n        }\n        try {\n          Thread.sleep(100);\n        }\n catch (        InterruptedException e) {\n        }\n      }\n while (System.currentTimeMillis() - startTime < 2000);\n      UnreliableSocketFactory.downHost(HOST_2);\n      if (autoCommit) {\n        assertEquals(HOST_1_OK,UnreliableSocketFactory.getHostFromLastConnection());\n      }\n else {\n        assertEquals(HOST_2_OK,UnreliableSocketFactory.getHostFromLastConnection());\n        assertSQLException(testStmt,\"SELECT 1\",COMM_LINK_ERR_PATTERN);\n        assertEquals(HOST_1_OK,UnreliableSocketFactory.getHostFromLastConnection());\n      }\n      assertConnectionsHistory(HOST_2_OK,HOST_1_OK);\n    }\n  finally {\n      if (testStmt != null) {\n        testStmt.close();\n      }\n      if (testConn != null) {\n        testConn.close();\n      }\n    }\n  }\n  props.setProperty(\"queriesBeforeRetryMaster\",\"0\");\n  props.setProperty(\"secondsBeforeRetryMaster\",\"0\");\n  for (  boolean autoCommit : new boolean[]{true,false}) {\n    Connection testConn=getUnreliableFailoverConnection(new String[]{HOST_1,HOST_2,HOST_3},props,downedHosts);\n    Statement testStmt=null;\n    try {\n      testConn.setAutoCommit(autoCommit);\n      assertEquals(HOST_2_OK,UnreliableSocketFactory.getHostFromLastConnection());\n      testStmt=testConn.createStatement();\n      assertSingleValueQuery(testStmt,\"SELECT 1\",1L);\n      UnreliableSocketFactory.dontDownHost(HOST_1);\n      UnreliableSocketFactory.dontDownHost(HOST_3);\n      for (int i=0; i < 55; i++) {\n        assertSingleValueQuery(testStmt,\"SELECT 1\",1L);\n        assertEquals(HOST_2_OK,UnreliableSocketFactory.getHostFromLastConnection());\n      }\n      UnreliableSocketFactory.downHost(HOST_2);\n      assertEquals(HOST_2_OK,UnreliableSocketFactory.getHostFromLastConnection());\n      assertSQLException(testStmt,\"SELECT 1\",COMM_LINK_ERR_PATTERN);\n      assertEquals(HOST_3_OK,UnreliableSocketFactory.getHostFromLastConnection());\n      testStmt=testConn.createStatement();\n      assertSingleValueQuery(testStmt,\"SELECT 1\",1L);\n      UnreliableSocketFactory.dontDownHost(HOST_2);\n      UnreliableSocketFactory.downHost(HOST_3);\n      assertEquals(HOST_3_OK,UnreliableSocketFactory.getHostFromLastConnection());\n      assertSQLException(testStmt,\"SELECT 1\",COMM_LINK_ERR_PATTERN);\n      assertEquals(HOST_1_OK,UnreliableSocketFactory.getHostFromLastConnection());\n      assertConnectionsHistory(HOST_2_OK,HOST_3_OK,HOST_1_OK);\n    }\n  finally {\n      if (testStmt != null) {\n        testStmt.close();\n      }\n      if (testConn != null) {\n        testConn.close();\n      }\n    }\n  }\n}\n", "nl": "Tests the automatic fall back to primary host in a failover connection using three hosts and the following sequence of events: + 1.st part: - [\\HOST_1 : /HOST_2 : \\HOST_3] --> HOST_2 - [/HOST_1 : /HOST_2 : /HOST_3] --> no_change vs HOST_1 (auto fall back) - [/HOST_1 : \\HOST_2 : /HOST_3] --> HOST_1 vs no_change + 2.nd part: - [\\HOST_1 : /HOST_2 : \\HOST_3] --> HOST_2 - [/HOST_1 : /HOST_2 : /HOST_3] --> no_change - [/HOST_1 : \\HOST_2 : /HOST_3] --> HOST_3 - [/HOST_1 : /HOST_2 : \\HOST_3] --> HOST_1 - /HOST_2 & \\HOST_3 The automatic fall back only happens at transaction boundaries and at least 'queriesBeforeRetryMaster' or 'secondsBeforeRetryMaster' is greater than 0. [Legend: \"/HOST_n\" --> HOST_n up; \"\\HOST_n\" --> HOST_n down]"}
{"code": "@Deprecated public static GamaRuntimeException error(final String s){\n  return error(s,GAMA.getRuntimeScope());\n}\n", "nl": "This method is deprecated. Use the equivalent method that passes the scope"}
{"code": "public Class load(String type) throws Exception {\n  ClassLoader loader=getClassLoader();\n  if (loader == null) {\n    loader=getCallerClassLoader();\n  }\n  return loader.loadClass(type);\n}\n", "nl": "This method is used to acquire the class of the specified name. Loading is performed by the thread context class loader as this will ensure that the class loading strategy can be changed as requirements dictate. Typically the thread context class loader can handle all serialization requirements."}
{"code": "private double euclideanDistance(DoubleArrayListWritable v1,DoubleArrayListWritable v2,int dim){\n  double distance=0.0;\n  for (int i=0; i < dim; i++) {\n    distance+=math.pow(v1.get(i).get() - v2.get(i).get(),2);\n  }\n  return math.sqrt(distance);\n}\n", "nl": "Calculates the Euclidean distance between two vectors of doubles"}
{"code": "private List<FacetResult> facetsWithSearch() throws IOException {\n  DirectoryReader indexReader=DirectoryReader.open(indexDir);\n  IndexSearcher searcher=new IndexSearcher(indexReader);\n  TaxonomyReader taxoReader=new DirectoryTaxonomyReader(taxoDir);\n  FacetsCollector fc=new FacetsCollector();\n  FacetsCollector.search(searcher,new MatchAllDocsQuery(),10,fc);\n  List<FacetResult> results=new ArrayList<>();\n  Facets facets=new FastTaxonomyFacetCounts(taxoReader,config,fc);\n  results.add(facets.getTopChildren(10,\"Author\"));\n  results.add(facets.getTopChildren(10,\"Publish Date\"));\n  indexReader.close();\n  taxoReader.close();\n  return results;\n}\n", "nl": "User runs a query and counts facets."}
{"code": "public boolean wasAtRest(){\n  return mWasAtRest;\n}\n", "nl": "Check if the spring was at rest in the prior iteration. This is used for ensuring the ending callbacks are fired as the spring comes to a rest."}
{"code": "protected CIMObjectPath createSubscription(CimFilterInfo filterInfo) throws WBEMException, ConnectionManagerException {\n  CIMObjectPath filterPath;\n  if (filterInfo instanceof CimManagedFilterInfo) {\n    filterPath=createFilter((CimManagedFilterInfo)filterInfo);\n  }\n else {\n    filterPath=getInstance(CimConstants.CIM_FILTER_NAME,filterInfo.getName()).getObjectPath();\n  }\n  s_logger.trace(\"filterPath :{}\",filterPath);\n  CIMProperty<?> filterProp=new CIMProperty<CIMObjectPath>(CimConstants.SUBSCRIPTION_PROP_FILTER,new CIMDataType(CimConstants.CIM_FILTER_NAME),filterPath);\n  CIMProperty<?> handlerProp=new CIMProperty<CIMObjectPath>(CimConstants.SUBSCRIPTION_PROP_HANDLER,new CIMDataType(CimConstants.CIM_HANDLER_NAME),getHandler());\n  s_logger.trace(\"filterProp :{}\",filterProp);\n  s_logger.trace(\"handlerProp :{}\",handlerProp);\n  CIMProperty<?>[] subscriptionProperties=new CIMProperty[]{filterProp,handlerProp};\n  CIMObjectPath subscriptionPath=createInstance(CimConstants.CIM_SUBSCRIPTION_NAME,subscriptionProperties);\n  _subscriptionPaths.add(subscriptionPath);\n  s_logger.trace(\"subscriptionPath :{}\",subscriptionPath);\n  return subscriptionPath;\n}\n", "nl": "Creates an indication subscription in the CIMOM for the given filter."}
{"code": "private void updatePopulation(int[] ids){\n  List<Integer> archivedIds=new ArrayList<Integer>();\n  for (  int id : ids) {\n    archivedIds.add(id);\n  }\n  solutions.keySet().retainAll(archivedIds);\n}\n", "nl": "Updates the population, retaining only those solutions with the specified identifiers."}
{"code": "private void updateProgress(String progressLabel,int progress){\n  if (myHost != null && ((progress != previousProgress) || (!progressLabel.equals(previousProgressLabel)))) {\n    myHost.updateProgress(progressLabel,progress);\n  }\n  previousProgress=progress;\n  previousProgressLabel=progressLabel;\n}\n", "nl": "Used to communicate a progress update between a plugin tool and the main Whitebox user interface."}
{"code": "private void initializeSparseSlider(){\n  sparsitySlider.setMajorTickSpacing(10);\n  sparsitySlider.setMinorTickSpacing(2);\n  sparsitySlider.setPaintTicks(true);\n  Hashtable<Integer,JLabel> labelTable2=new Hashtable<Integer,JLabel>();\n  labelTable2.put(new Integer(0),new JLabel(\"0%\"));\n  labelTable2.put(new Integer(100),new JLabel(\"100%\"));\n  sparsitySlider.setLabelTable(labelTable2);\n  sparsitySlider.setPaintLabels(true);\n}\n", "nl": "Initializes the sparse slider."}
{"code": "public boolean isStereo(){\n  return (channelMode != 3);\n}\n", "nl": "Whether stereo playback mode is used"}
{"code": "@Override public Overlay buildOverlay(MapView map,Style defaultStyle,Styler styler,KmlPlacemark kmlPlacemark,KmlDocument kmlDocument){\n  Marker marker=new Marker(map);\n  marker.setTitle(kmlPlacemark.mName);\n  marker.setSnippet(kmlPlacemark.mDescription);\n  marker.setSubDescription(kmlPlacemark.getExtendedDataAsText());\n  marker.setPosition(getPosition());\n  marker.setRelatedObject(this);\n  if (styler == null) {\n    applyDefaultStyling(marker,defaultStyle,kmlPlacemark,kmlDocument,map);\n  }\n else   styler.onPoint(marker,kmlPlacemark,this);\n  return marker;\n}\n", "nl": "Build the corresponding Marker overlay"}
{"code": "public static boolean startsWithIgnoreCase(String searchIn,String searchFor){\n  return startsWithIgnoreCase(searchIn,0,searchFor);\n}\n", "nl": "Determines whether or not the string 'searchIn' contains the string 'searchFor', dis-regarding case. Shorthand for a String.regionMatch(...)"}
{"code": "public void removeListener(ColorMapListener listener){\n  if (listener == null)   return;\n  listeners.remove(listener);\n}\n", "nl": "Remove a color map listener"}
{"code": "public T adwordsId(String value){\n  setString(ADWORDS_ID,value);\n  return (T)this;\n}\n", "nl": "<div class=\"ind\"> <p> Optional. </p> <p>Specifies the Google AdWords Id.</p> <table border=\"1\"> <tbody> <tr> <th>Parameter</th> <th>Value Type</th> <th>Default Value</th> <th>Max Length</th> <th>Supported Hit Types</th> </tr> <tr> <td><code>gclid</code></td> <td>text</td> <td><span class=\"none\">None</span> </td> <td><span class=\"none\">None</span> </td> <td>all</td> </tr> </tbody> </table> <div> Example value: <code>CL6Q-OXyqKUCFcgK2goddQuoHg</code><br> Example usage: <code>gclid=CL6Q-OXyqKUCFcgK2goddQuoHg</code> </div> </div>"}
{"code": "@HLEUnimplemented @HLEFunction(nid=0x9E8AAF8D,version=271) public int sceUsbCamGetZoom(TPointer32 zoomAddr){\n  zoomAddr.setValue(zoom);\n  return 0;\n}\n", "nl": "Gets the current zoom."}
{"code": "@Override public Object eGet(int featureID,boolean resolve,boolean coreType){\nswitch (featureID) {\ncase MappingPackage.OPERATION_SOURCE__OPERATION:\n    if (resolve)     return getOperation();\n  return basicGetOperation();\n}\nreturn super.eGet(featureID,resolve,coreType);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public static boolean screenshot(Activity activity,String filePath){\n  View decorView=activity.getWindow().getDecorView();\n  decorView.setDrawingCacheEnabled(true);\n  decorView.buildDrawingCache();\n  Bitmap bitmap=decorView.getDrawingCache();\n  File imagePath=new File(filePath);\n  FileOutputStream fos=null;\n  try {\n    fos=new FileOutputStream(imagePath);\n    bitmap.compress(Bitmap.CompressFormat.JPEG,100,fos);\n    fos.flush();\n    return true;\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n  }\n finally {\n    try {\n      fos.close();\n      if (null != bitmap) {\n        bitmap.recycle();\n        bitmap=null;\n      }\n    }\n catch (    Exception e) {\n    }\n    decorView.destroyDrawingCache();\n    decorView.setDrawingCacheEnabled(false);\n  }\n  return false;\n}\n", "nl": "take a screenshot"}
{"code": "private Counter<String> computeGradient(List<Datum> dataset,Counter<String> weights,int batchSize){\n  Counter<String> gradient=new ClassicCounter<String>(weights.keySet().size());\n  for (  Datum datum : dataset) {\n    double sum=0;\n    for (    String feature : datum.vX.keySet()) {\n      sum+=weights.getCount(feature) * datum.vX.getCount(feature);\n    }\n    double expSum, derivativeIncrement;\n    if (datum.label == Label.NEGATIVE) {\n      expSum=Math.exp(sum);\n      derivativeIncrement=1.0 / (1.0 + (1.0 / expSum));\n    }\n else {\n      expSum=Math.exp(-sum);\n      derivativeIncrement=-1.0 / (1.0 + (1.0 / expSum));\n    }\n    for (    String feature : datum.vX.keySet()) {\n      double g=datum.vX.getCount(feature) * derivativeIncrement;\n      gradient.incrementCount(feature,g);\n    }\n  }\n  if (this.l2Regularization && dataset.size() > 0) {\n    final Set<String> features=new HashSet<String>(weights.keySet());\n    features.addAll(gradient.keySet());\n    final double dataFraction=dataset.size() / ((double)2 * xi * tuneSetSize);\n    final double scaledSigmaSquared=sigmaSq / dataFraction;\n    for (    String key : features) {\n      double x=weights.getCount(key);\n      gradient.incrementCount(key,x / scaledSigmaSquared);\n    }\n  }\n  return gradient;\n}\n", "nl": "Compute the gradient for the specified set of PRO samples."}
{"code": "public void testSizingWithWidthConstraint(){\n  RectangleConstraint constraint=new RectangleConstraint(10.0,new Range(10.0,10.0),LengthConstraintType.FIXED,0.0,new Range(0.0,0.0),LengthConstraintType.NONE);\n  BlockContainer container=new BlockContainer(new BorderArrangement());\n  BufferedImage image=new BufferedImage(200,100,BufferedImage.TYPE_INT_RGB);\n  Graphics2D g2=image.createGraphics();\n  container.add(new EmptyBlock(5.0,6.0));\n  Size2D size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(6.0,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(15.0,16.0));\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(16.0,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(12.3,45.6),RectangleEdge.RIGHT);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(45.6,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(7.0,20.0));\n  container.add(new EmptyBlock(8.0,45.6),RectangleEdge.RIGHT);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(45.6,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(12.3,45.6),RectangleEdge.LEFT);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(45.6,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(10.0,20.0));\n  container.add(new EmptyBlock(12.3,45.6),RectangleEdge.LEFT);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(45.6,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(10.0,20.0),RectangleEdge.RIGHT);\n  container.add(new EmptyBlock(12.3,45.6),RectangleEdge.LEFT);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(45.6,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(10.0,20.0));\n  container.add(new EmptyBlock(12.3,45.6),RectangleEdge.LEFT);\n  container.add(new EmptyBlock(5.4,3.2),RectangleEdge.RIGHT);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(45.6,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(12.3,45.6),RectangleEdge.BOTTOM);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(45.6,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(10.0,20.0));\n  container.add(new EmptyBlock(12.3,45.6),RectangleEdge.BOTTOM);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(65.6,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(10.0,20.0),RectangleEdge.RIGHT);\n  container.add(new EmptyBlock(12.3,45.6),RectangleEdge.BOTTOM);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(65.6,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(21.0,12.3));\n  container.add(new EmptyBlock(10.0,20.0),RectangleEdge.RIGHT);\n  container.add(new EmptyBlock(12.3,45.6),RectangleEdge.BOTTOM);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(65.6,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(10.0,20.0),RectangleEdge.LEFT);\n  container.add(new EmptyBlock(12.3,45.6),RectangleEdge.BOTTOM);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(65.6,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(21.0,12.3));\n  container.add(new EmptyBlock(10.0,20.0),RectangleEdge.LEFT);\n  container.add(new EmptyBlock(12.3,45.6),RectangleEdge.BOTTOM);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(65.6,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(21.0,12.3),RectangleEdge.RIGHT);\n  container.add(new EmptyBlock(10.0,20.0),RectangleEdge.LEFT);\n  container.add(new EmptyBlock(12.3,45.6),RectangleEdge.BOTTOM);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(65.6,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(3.0,4.0),RectangleEdge.BOTTOM);\n  container.add(new EmptyBlock(5.0,6.0),RectangleEdge.LEFT);\n  container.add(new EmptyBlock(7.0,8.0),RectangleEdge.RIGHT);\n  container.add(new EmptyBlock(9.0,10.0));\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(14.0,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(12.3,45.6),RectangleEdge.TOP);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(45.6,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(10.0,20.0));\n  container.add(new EmptyBlock(12.3,45.6),RectangleEdge.TOP);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(65.6,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(10.0,20.0),RectangleEdge.RIGHT);\n  container.add(new EmptyBlock(12.3,45.6),RectangleEdge.TOP);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(65.6,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(21.0,12.3));\n  container.add(new EmptyBlock(10.0,20.0),RectangleEdge.TOP);\n  container.add(new EmptyBlock(12.3,45.6),RectangleEdge.RIGHT);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(65.6,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(10.0,20.0),RectangleEdge.LEFT);\n  container.add(new EmptyBlock(12.3,45.6),RectangleEdge.TOP);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(65.6,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(21.0,12.3));\n  container.add(new EmptyBlock(10.0,20.0),RectangleEdge.TOP);\n  container.add(new EmptyBlock(12.3,45.6),RectangleEdge.LEFT);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(65.6,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(21.0,12.3),RectangleEdge.RIGHT);\n  container.add(new EmptyBlock(10.0,20.0),RectangleEdge.TOP);\n  container.add(new EmptyBlock(12.3,45.6),RectangleEdge.LEFT);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(65.6,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(1.0,2.0),RectangleEdge.TOP);\n  container.add(new EmptyBlock(5.0,6.0),RectangleEdge.LEFT);\n  container.add(new EmptyBlock(7.0,8.0),RectangleEdge.RIGHT);\n  container.add(new EmptyBlock(9.0,10.0));\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(12.0,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(10.0,20.0),RectangleEdge.TOP);\n  container.add(new EmptyBlock(12.3,45.6),RectangleEdge.BOTTOM);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(65.6,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(21.0,12.3));\n  container.add(new EmptyBlock(10.0,20.0),RectangleEdge.TOP);\n  container.add(new EmptyBlock(12.3,45.6),RectangleEdge.BOTTOM);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(77.9,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(21.0,12.3),RectangleEdge.RIGHT);\n  container.add(new EmptyBlock(10.0,20.0),RectangleEdge.TOP);\n  container.add(new EmptyBlock(12.3,45.6),RectangleEdge.BOTTOM);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(77.9,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(1.0,2.0),RectangleEdge.TOP);\n  container.add(new EmptyBlock(3.0,4.0),RectangleEdge.BOTTOM);\n  container.add(new EmptyBlock(7.0,8.0),RectangleEdge.RIGHT);\n  container.add(new EmptyBlock(9.0,10.0));\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(16.0,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(21.0,12.3),RectangleEdge.LEFT);\n  container.add(new EmptyBlock(10.0,20.0),RectangleEdge.TOP);\n  container.add(new EmptyBlock(12.3,45.6),RectangleEdge.BOTTOM);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(77.9,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(1.0,2.0),RectangleEdge.TOP);\n  container.add(new EmptyBlock(3.0,4.0),RectangleEdge.BOTTOM);\n  container.add(new EmptyBlock(5.0,6.0),RectangleEdge.LEFT);\n  container.add(new EmptyBlock(9.0,10.0));\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(16.0,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(1.0,2.0),RectangleEdge.TOP);\n  container.add(new EmptyBlock(3.0,4.0),RectangleEdge.BOTTOM);\n  container.add(new EmptyBlock(5.0,6.0),RectangleEdge.LEFT);\n  container.add(new EmptyBlock(7.0,8.0),RectangleEdge.RIGHT);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(14.0,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(1.0,2.0),RectangleEdge.TOP);\n  container.add(new EmptyBlock(3.0,4.0),RectangleEdge.BOTTOM);\n  container.add(new EmptyBlock(5.0,6.0),RectangleEdge.LEFT);\n  container.add(new EmptyBlock(7.0,8.0),RectangleEdge.RIGHT);\n  container.add(new EmptyBlock(9.0,10.0));\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(16.0,size.height,EPSILON);\n  container.clear();\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(0.0,size.height,EPSILON);\n}\n", "nl": "Run some checks on sizing when there is a fixed width constraint."}
{"code": "private void receivedFollowerOrSubscriberCount(FollowerInfo followerInfo){\n  if (followerInfo.requestError) {\n    return;\n  }\n  StreamInfo streamInfo=api.getStreamInfo(followerInfo.stream,null);\n  boolean changed=false;\n  if (followerInfo.type == Follower.Type.SUBSCRIBER) {\n    changed=streamInfo.setSubscriberCount(followerInfo.total);\n  }\n else   if (followerInfo.type == Follower.Type.FOLLOWER) {\n    changed=streamInfo.setFollowerCount(followerInfo.total);\n  }\n  if (changed && streamInfo.isValid()) {\n    streamStatusWriter.streamStatus(streamInfo);\n  }\n}\n", "nl": "Set follower/subscriber count in StreamInfo and send to Stream Status Writer."}
{"code": "public FrameSlot findOrAddFrameSlot(Object identifier,FrameSlotKind kind){\n  FrameSlot result=findFrameSlot(identifier);\n  if (result != null) {\n    return result;\n  }\n  return addFrameSlot(identifier,kind);\n}\n", "nl": "Finds an existing slot or creates new one. This is a slow operation."}
{"code": "private static boolean isValidVersionNumber(final String version){\n  if (version == null) {\n    return false;\n  }\n  final String[] parts=version.split(\"\\\\.\");\n  if (parts.length != 3) {\n    return false;\n  }\n  for (  final String part : parts) {\n    if (!Convert.isDecString(part)) {\n      return false;\n    }\n  }\n  return true;\n}\n", "nl": "Checks whether a given version string is a valid version string."}
{"code": "@ObjectiveCName(\"isInAppNotificationsEnabled\") public boolean isInAppNotificationsEnabled(){\n  return modules.getSettingsModule().isInAppEnabled();\n}\n", "nl": "Is in-app notifications enabled"}
{"code": "@Override public void intervalAdded(ListDataEvent event){\n  calculatePositionArray();\n  setPreferredSize(calculatePreferredSize());\n}\n", "nl": "Listen for items being added to the model."}
{"code": "public static MaterialColor fromInt(@ColorInt int color){\n  return new MaterialColor(color);\n}\n", "nl": "Create a MaterialColor from the provided color value."}
{"code": "public void shouldHandleThrowingFutureCallable(){\n  assertThrows(null,ExecutionException.class,IllegalArgumentException.class);\n  assertThrows(null,ExecutionException.class,IllegalArgumentException.class);\n  assertThrows(null,ExecutionException.class,IllegalArgumentException.class);\n}\n", "nl": "Assert handles a callable that throws instead of returning a future."}
{"code": "public CategoricalColumn(){\n  super(ColumnType.CATEGORICAL);\n}\n", "nl": "Instantiates a new categorical column."}
{"code": "@MethodDesc(description=\"Starts the replicator service\",usage=\"start\") public void start(boolean forceOffline) throws Exception {\n  try {\n    handleEventSynchronous(new StartEvent());\n    if (sm.getState().getName().equals(\"OFFLINE:NORMAL\")) {\n      boolean autoEnabled=new Boolean(properties.getBoolean(ReplicatorConf.AUTO_ENABLE));\n      if (!forceOffline && autoEnabled) {\n        logger.info(\"Replicator auto-enabling is engaged; going online automatically\");\n        online();\n      }\n    }\n  }\n catch (  Exception e) {\n    logger.error(\"Start operation failed\",e);\n    throw new Exception(\"Start operation failed: \" + e.getMessage());\n  }\n  this.doneLatch=new CountDownLatch(1);\n}\n", "nl": "Start Replicator Node Manager JMX service."}
{"code": "Alerter(AlertService service,int timeout,AtomicInteger jobCounter){\n  this.service=service;\n  this.timeout=timeout;\n  this.jobCounter=jobCounter;\n}\n", "nl": "Creates a new Alerter object."}
{"code": "private void removeAnyCallbacks(){\n  if (mPerformSearchRunnable != null) {\n    mHandler.removeCallbacks(mPerformSearchRunnable);\n  }\n}\n", "nl": "Removes any pending callbacks(if any) from the handler"}
{"code": "@Override public Object eGet(int featureID,boolean resolve,boolean coreType){\nswitch (featureID) {\ncase EipPackage.GATEWAY__NAME:\n    return getName();\ncase EipPackage.GATEWAY__TO_CHANNELS:\n  return getToChannels();\ncase EipPackage.GATEWAY__FROM_CHANNELS:\nreturn getFromChannels();\n}\nreturn super.eGet(featureID,resolve,coreType);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "static void appendDate(StringBuilder buff,long dateValue){\n  int y=DateTimeUtils.yearFromDateValue(dateValue);\n  int m=DateTimeUtils.monthFromDateValue(dateValue);\n  int d=DateTimeUtils.dayFromDateValue(dateValue);\n  if (y > 0 && y < 10000) {\n    StringUtils.appendZeroPadded(buff,4,y);\n  }\n else {\n    buff.append(y);\n  }\n  buff.append('-');\n  StringUtils.appendZeroPadded(buff,2,m);\n  buff.append('-');\n  StringUtils.appendZeroPadded(buff,2,d);\n}\n", "nl": "Append a date to the string builder."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2014-09-03 14:59:54.006 -0400\",hash_original_method=\"FFD73B06BFF281953B16F54803697DC3\",hash_generated_method=\"9914BD0B75BD9C1F8FA2F0E0462B401B\") protected FalseFileFilter(){\n}\n", "nl": "Restrictive consructor."}
{"code": "@Inline public static boolean fits(Word val,int bits){\n  Word o=val.rsha(bits - 1);\n  return (o.isZero() || o.isMax());\n}\n", "nl": "Finds out whether a given signed value can be represented in a given number of bits."}
{"code": "public static Map<String,Object> removeDuplicateScrumRevision(DispatchContext ctx,Map<String,? extends Object> context){\n  Delegator delegator=ctx.getDelegator();\n  LocalDispatcher dispatcher=ctx.getDispatcher();\n  String repositoryRoot=(String)context.get(\"repositoryRoot\");\n  Map<String,Object> result=ServiceUtil.returnSuccess();\n  try {\n    List<EntityCondition> exprsAnd=FastList.newInstance();\n    String revisionLink=repositoryRoot.substring(repositoryRoot.lastIndexOf(\"svn/\") + 4,repositoryRoot.length()) + \"&revision=\";\n    exprsAnd.add(EntityCondition.makeCondition(\"workEffortContentTypeId\",EntityOperator.EQUALS,\"TASK_SUB_INFO\"));\n    exprsAnd.add(EntityCondition.makeCondition(\"contentTypeId\",EntityOperator.EQUALS,\"DOCUMENT\"));\n    exprsAnd.add(EntityCondition.makeCondition(\"drObjectInfo\",EntityOperator.LIKE,revisionLink + \"%\"));\n    List<GenericValue> workEffortDataResourceList=EntityQuery.use(delegator).from(\"WorkEffortAndContentDataResource\").where(exprsAnd).queryList();\n    if (UtilValidate.isNotEmpty(workEffortDataResourceList)) {\n      Debug.logInfo(\"Total Content Size ============== >>>>>>>>>>> \" + workEffortDataResourceList.size(),module);\n      Set<String> keys=FastSet.newInstance();\n      Set<GenericValue> exclusions=FastSet.newInstance();\n      for (      GenericValue workEffort : workEffortDataResourceList) {\n        String drObjectInfo=workEffort.getString(\"drObjectInfo\");\n        if (keys.contains(drObjectInfo)) {\n          exclusions.add(workEffort);\n        }\n else {\n          keys.add(drObjectInfo);\n        }\n      }\n      Debug.logInfo(\"Remove size ============== >>>>>>>>>>> \" + exclusions.size(),module);\n      if (UtilValidate.isNotEmpty(exclusions)) {\n        for (        GenericValue contentResourceMap : exclusions) {\n          Debug.logInfo(\"Remove contentId ============== >>>>>>>>>>> \" + contentResourceMap.getString(\"contentId\"),module);\n          GenericValue dataResourceMap=EntityQuery.use(delegator).from(\"DataResource\").where(\"dataResourceId\",contentResourceMap.getString(\"dataResourceId\")).queryOne();\n          GenericValue contentMap=EntityQuery.use(delegator).from(\"Content\").where(\"contentId\",contentResourceMap.getString(\"contentId\")).queryOne();\n          contentMap.removeRelated(\"WorkEffortContent\");\n          contentMap.removeRelated(\"ContentRole\");\n          contentMap.remove();\n          dataResourceMap.removeRelated(\"DataResourceRole\");\n          dataResourceMap.remove();\n        }\n      }\n    }\n  }\n catch (  GenericEntityException entityEx) {\n    entityEx.printStackTrace();\n    return ServiceUtil.returnError(entityEx.getMessage());\n  }\n  return result;\n}\n", "nl": "removeDuplicateScrumRevision <p> Use for remove duplicate scrum revision"}
{"code": "private void updateProgress(String progressLabel,int progress){\n  if (myHost != null && ((progress != previousProgress) || (!progressLabel.equals(previousProgressLabel)))) {\n    myHost.updateProgress(progressLabel,progress);\n  }\n  previousProgress=progress;\n  previousProgressLabel=progressLabel;\n}\n", "nl": "Used to communicate a progress update between a plugin tool and the main Whitebox user interface."}
{"code": "private void checkCapture(GenericClassType genericClassType,ReferenceType paramType,ReferenceType actualArgType,List<TypedOperation> genericOperations){\n  InstantiatedType finalType=genericClassType.instantiate(actualArgType);\n  InstantiatedType instantiatedType=sourceType.instantiate(paramType);\n  Substitution<ReferenceType> substitution=instantiatedType.getTypeSubstitution();\n  for (  TypedOperation op : genericOperations) {\n    InstantiatedType argumentType=getArgumentType(op).apply(substitution);\n    InstantiatedType convertedArgumentType=argumentType.applyCaptureConversion();\n    List<TypeVariable> arguments=convertedArgumentType.getTypeParameters();\n    if (arguments.size() > 0) {\n      Substitution<ReferenceType> wcSubst=Substitution.forArgs(arguments,actualArgType);\n      convertedArgumentType=convertedArgumentType.apply(wcSubst);\n    }\n    if (op.hasWildcardTypes()) {\n      assertEquals(\"should be instantiated type for method \" + op.getName() + \" argument.\",finalType,convertedArgumentType);\n    }\n else {\n      assertEquals(\"should not be converted \" + op.getName(),argumentType,convertedArgumentType);\n    }\n  }\n}\n", "nl": "Checks the capture conversion over a set of types with wildcard (given as the input types to operations). Checks that the conversion followed by the substitution for the capture variable result in the class type instantiated by the actual argument type."}
{"code": "public static synchronized LogStream switchLog(final File newLog){\n  if (sLogStream != null) {\n    userLog(\"Switching logfile to:\" + newLog.getAbsolutePath());\n    final File file=sLogStream.file();\n    if (newLog.equals(file)) {\n      return sLogStream;\n    }\n    sLogStream.removeLog();\n  }\n  if (!newLog.getParentFile().exists()) {\n    if (!newLog.getParentFile().mkdirs()) {\n      throw new RuntimeException(\"Unable to create directory for log file.\");\n    }\n  }\n  sLogStream=new LogFile(newLog);\n  sLogClosed=false;\n  logEnvironment();\n  return sLogStream;\n}\n", "nl": "Switch the log to a (usually) different output file."}
{"code": "protected SimState(MersenneTwisterFast random,Schedule schedule){\n  this(0,random,schedule);\n}\n", "nl": "Creates a SimState with the given random number generator and schedule, and sets the seed to a bogus value (0).  This should only be used by SimState  subclasses which need to use an existing random number generator and schedule."}
{"code": "public void addEditor(){\n  removeEditor();\n  editor=comboBox.getEditor().getEditorComponent();\n  if (editor != null) {\n    configureEditor();\n    comboBox.add(editor);\n    if (comboBox.isFocusOwner()) {\n      editor.requestFocusInWindow();\n    }\n  }\n}\n", "nl": "This public method is implementation specific and should be private. do not call or override. To implement a specific editor create a custom <code>ComboBoxEditor</code>"}
{"code": "public void init(int value){\n  if (value == -1) {\n    throw new IllegalArgumentException(\"IntConstant cannot be initialized with a value of -1\");\n  }\nsynchronized (this) {\n    if (this.value != -1) {\n      throw new IllegalStateException(\"IntConstant already initialized!\");\n    }\n    this.value=value;\n  }\n}\n", "nl": "Initializes the constant. This method can only be called once."}
{"code": "public StAndrewsSimulation(long seed){\n  super(seed);\n}\n", "nl": "Create a new StAndrewsSimulation with the given randomization seed."}
{"code": "public AuthenticationNotSupportedException(){\n  super();\n}\n", "nl": "Constructs a new instance of AuthenticationNotSupportedException all name resolution fields and explanation initialized to null."}
{"code": "public synchronized void addMemberAsync(Contact contact){\n  notifyMemberJoined(contact);\n}\n", "nl": "Adds a member to this group. TODO: more docs on async callbacks."}
{"code": "public Record(){\n  super();\n  setEntity(new Entity(TYPE_ID));\n  getEntity().initDefaultValues(getTypeFactory());\n}\n", "nl": "Creates an empty asset"}
{"code": "@Override protected void makeCastlingMove(Move move){\n  FischerRandomUtils.makeCastlingMove(this,move,initialKingFile,initialShortRookFile,initialLongRookFile);\n}\n", "nl": "Overridden to handle special FR castling rules."}
{"code": "@DSComment(\"Package priviledge\") @DSBan(DSCat.DEFAULT_MODIFIER) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:29:52.081 -0500\",hash_original_method=\"0309B89A8A5C20FB439CB65AA9DE3FAA\",hash_generated_method=\"0309B89A8A5C20FB439CB65AA9DE3FAA\") void enforceSealed(){\n  if (!isSealed()) {\n    throw new IllegalStateException(\"Cannot perform this \" + \"action on a not sealed instance.\");\n  }\n}\n", "nl": "Enforces that this instance is sealed."}
{"code": "public void unload(){\n  GLES20.glDeleteShader(mVShaderHandle);\n  GLES20.glDeleteShader(mFShaderHandle);\n  GLES20.glDeleteProgram(mProgram);\n}\n", "nl": "Unloads and deletes references to the shader program"}
{"code": "default <T>T newInstance(Class<T> concreteClass){\n  try {\n    return concreteClass.newInstance();\n  }\n catch (  Exception ex) {\n    throw new UncheckedException(ex);\n  }\n}\n", "nl": "Called to construct actor."}
{"code": "@Override public boolean createFrom(final IScope scope,final List<Map<String,Object>> inits,final Integer max,final Object input,final Arguments init,final CreateStatement statement){\n  final GamaGridFile file=(GamaGridFile)input;\n  final int num=max == null ? file.length(scope) : CmnFastMath.min(file.length(scope),max);\n  for (int i=0; i < num; i++) {\n    final IShape g=file.get(scope,i);\n    final Map map=g.getOrCreateAttributes();\n    map.put(IKeyword.SHAPE,g);\n    statement.fillWithUserInit(scope,map);\n    inits.add(map);\n  }\n  return true;\n}\n", "nl": "Method createFrom() Method used to read initial values and attributes from a GRID file."}
{"code": "protected void processFiles(String ext,boolean recursive,File outDir,serverObjects post,File[] inFiles,List<File> processedFiles,Map<String,Throwable> failures) throws IOException {\n  for (  File inFile : inFiles) {\n    if (inFile.isDirectory()) {\n      if (recursive) {\n        File subDir=new File(outDir,inFile.getName());\n        subDir.mkdirs();\n        processFiles(ext,recursive,subDir,post,inFile.listFiles(),processedFiles,failures);\n      }\n    }\n else {\n      processedFiles.add(inFile);\n      processFile(ext,outDir,post,failures,inFile);\n    }\n  }\n}\n", "nl": "Process inFiles and update processedFiles list and failures map. All parameters must not be null."}
{"code": "private void languageComboChanged(){\n  String langName=(String)languageCombo.getSelectedItem();\n  Language language=Language.getLanguage(langName);\n  Language.setLoginLanguage(language);\n  Env.setContext(m_ctx,Env.LANGUAGE,language.getAD_Language());\n  Locale loc=language.getLocale();\n  Locale.setDefault(loc);\n  this.setLocale(loc);\n  res=ResourceBundle.getBundle(RESOURCE,loc);\n  this.setTitle(res.getString(\"Login\"));\n  hostLabel.setText(res.getString(\"Host\"));\n  userLabel.setText(res.getString(\"User\"));\n  userLabel.setToolTipText(res.getString(\"EnterUser\"));\n  passwordLabel.setText(res.getString(\"Password\"));\n  passwordLabel.setToolTipText(res.getString(\"EnterPassword\"));\n  languageLabel.setText(res.getString(\"Language\"));\n  languageLabel.setToolTipText(res.getString(\"SelectLanguage\"));\n  roleLabel.setText(res.getString(\"Role\"));\n  clientLabel.setText(res.getString(\"Client\"));\n  orgLabel.setText(res.getString(\"Organization\"));\n  dateLabel.setText(res.getString(\"Date\"));\n  warehouseLabel.setText(res.getString(\"Warehouse\"));\n  printerLabel.setText(res.getString(\"Printer\"));\n  defaultPanel.setToolTipText(res.getString(\"Defaults\"));\n  connectionPanel.setToolTipText(res.getString(\"Connection\"));\n  txt_NotConnected=res.getString(\"NotConnected\");\n  txt_NoDatabase=res.getString(\"DatabaseNotFound\");\n  txt_UserPwdError=res.getString(\"UserPwdError\");\n  txt_RoleError=res.getString(\"RoleNotFound\");\n  txt_LoggedIn=res.getString(\"Authorized\");\n  loginTabPane.setTitleAt(0,res.getString(\"Connection\"));\n  loginTabPane.setTitleAt(1,res.getString(\"Defaults\"));\n  confirmPanel.getOKButton().setToolTipText(res.getString(\"Ok\"));\n  confirmPanel.getCancelButton().setToolTipText(res.getString(\"Cancel\"));\n  dateField.setFormat();\n  dateField.setValue(new Timestamp(System.currentTimeMillis()));\n  if (m_connectionOK) {\n    this.setTitle(hostField.getDisplay());\n    statusBar.setStatusLine(txt_LoggedIn);\n  }\n else {\n    this.setTitle(res.getString(\"Login\"));\n    statusBar.setStatusLine(txt_NotConnected,true);\n  }\n}\n", "nl": "Change Language"}
{"code": "@Override protected void prepare(){\n  AD_User_ID=Env.getAD_User_ID(getCtx());\n  p_Record_ID=getRecord_ID();\n  for (  ProcessInfoParameter para : getParameter()) {\n    String name=para.getParameterName();\n    if (para.getParameter() == null)     ;\n else     if (name.equals(\"WM_Area_Type_ID\")) {\n      p_WM_Area_Type_ID=para.getParameterAsInt();\n    }\n else     if (name.equals(\"WM_Section_Type_ID\")) {\n      p_WM_Section_Type_ID=para.getParameterAsInt();\n    }\n else     if (name.equals(\"DeliveryRule\")) {\n      p_DeliveryRule=(String)para.getParameter();\n    }\n else     if (name.equals(\"DocAction\")) {\n      p_DocAction=(String)para.getParameter();\n    }\n else     if (name.equals(\"C_DocType_ID\")) {\n      p_C_DocType_ID=para.getParameterAsInt();\n    }\n else     if (name.equals(\"M_Locator_ID\")) {\n      p_M_Locator_ID=para.getParameterAsInt();\n      m_locator=new MLocator(getCtx(),p_M_Locator_ID,get_TrxName());\n    }\n else     if (name.equals(\"IsPrintPickList\")) {\n      p_IsPrintPickList=\"Y\".equals(para.getParameter());\n    }\n else     if (name.equals(\"IsCreateSupply\")) {\n      p_IsCreateSupply=\"Y\".equals(para.getParameter());\n    }\n else     log.log(Level.SEVERE,\"Unknown Parameter: \" + name);\n  }\n}\n", "nl": "Get Parameters"}
{"code": "private void buildSpellTables(){\n  try {\n    final SpellGroupsXMLLoader loader=new SpellGroupsXMLLoader(new URI(\"/data/conf/spells.xml\"));\n    List<DefaultSpell> loadedDefaultSpells=loader.load();\n    for (    DefaultSpell defaultSpell : loadedDefaultSpells) {\n      addSpell(defaultSpell);\n    }\n  }\n catch (  Exception e) {\n    LOGGER.error(\"spells.xml could not be loaded\",e);\n  }\n}\n", "nl": "builds the spell tables"}
{"code": "public LogEventReplReader(LogRecord logRecord,Serializer serializer,boolean checkCRC) throws ReplicatorException {\n  this.logRecord=logRecord;\n  this.serializer=serializer;\n  this.checkCRC=checkCRC;\n  try {\n    load();\n  }\n catch (  IOException e) {\n    throw new THLException(\"I/O error while loading log record header: offset=\" + logRecord.getOffset(),e);\n  }\n}\n", "nl": "Instantiate the reader and load header information."}
{"code": "public static IndexKeyRange bounded(IndexRowType indexRowType,IndexBound lo,boolean loInclusive,IndexBound hi,boolean hiInclusive){\n  if (lo == null || hi == null) {\n    throw new IllegalArgumentException(\"IndexBound arguments must not be null\");\n  }\n  return new IndexKeyRange(indexRowType,lo,loInclusive,hi,hiInclusive,IndexKind.CONVENTIONAL);\n}\n", "nl": "Describes a range of keys between lo and hi. The bounds are inclusive or not depending on loInclusive and hiInclusive. lo and hi must both be non-null. There are constraints on the bounds: - The ColumnSelectors for lo and hi must select for the same columns. - The selected columns must be leading columns of the index."}
{"code": "@Override public void updateRef(int columnIndex,Ref x) throws SQLException {\n  throw unsupported(\"ref\");\n}\n", "nl": "[Not supported]"}
{"code": "public NavigationModel(String id){\n  super(id);\n}\n", "nl": "Construct a new emtpy NavigationModel with the specified ID."}
{"code": "@NotNull default B append(double d) throws BufferOverflowException {\n  BytesInternal.append((StreamingDataOutput)this,d);\n  return (B)this;\n}\n", "nl": "Append a double in decimal notation"}
{"code": "@Entrypoint @UnpreemptibleNoWarn static void deliverHardwareException(int trapCode,Word trapInfo){\n  if (VM.verboseSignalHandling)   VM.sysWriteln(\"delivering hardware exception\");\n  RVMThread myThread=RVMThread.getCurrentThread();\n  if (VM.verboseSignalHandling)   VM.sysWriteln(\"we have a thread = \",Magic.objectAsAddress(myThread));\n  if (VM.verboseSignalHandling)   VM.sysWriteln(\"it's in state = \",myThread.getExecStatus());\n  AbstractRegisters exceptionRegisters=myThread.getExceptionRegisters();\n  if (VM.verboseSignalHandling)   VM.sysWriteln(\"we have exception registers = \",Magic.objectAsAddress(exceptionRegisters));\n  if ((trapCode == TRAP_STACK_OVERFLOW || trapCode == TRAP_JNI_STACK) && myThread.getStack().length < (StackFrameLayout.getMaxStackSize() >> LOG_BYTES_IN_ADDRESS) && !myThread.hasNativeStackFrame()) {\n    if (trapCode == TRAP_JNI_STACK) {\n      RVMThread.resizeCurrentStack(myThread.getStackLength() + StackFrameLayout.getJNIStackGrowthSize(),exceptionRegisters);\n    }\n else {\n      RVMThread.resizeCurrentStack(myThread.getStackLength() + StackFrameLayout.getStackGrowthSize(),exceptionRegisters);\n    }\n    if (VM.VerifyAssertions)     VM._assert(exceptionRegisters.getInUse());\n    exceptionRegisters.setInUse(false);\n    Magic.restoreHardwareExceptionState(exceptionRegisters);\n    if (VM.VerifyAssertions)     VM._assert(NOT_REACHED);\n  }\n  if (canForceGC()) {\n    System.gc();\n  }\n  if (!VM.sysFailInProgress()) {\n    Address fp=exceptionRegisters.getInnermostFramePointer();\n    int compiledMethodId=Magic.getCompiledMethodID(fp);\n    if (compiledMethodId != StackFrameLayout.getInvisibleMethodID()) {\n      CompiledMethod compiledMethod=CompiledMethods.getCompiledMethod(compiledMethodId);\n      Address ip=exceptionRegisters.getInnermostInstructionAddress();\n      Offset instructionOffset=compiledMethod.getInstructionOffset(ip);\n      if (compiledMethod.isWithinUninterruptibleCode(instructionOffset)) {\nswitch (trapCode) {\ncase TRAP_NULL_POINTER:\n          VM.sysWriteln(\"\\nFatal error: NullPointerException within uninterruptible region.\");\n        break;\ncase TRAP_ARRAY_BOUNDS:\n      VM.sysWriteln(\"\\nFatal error: ArrayIndexOutOfBoundsException within uninterruptible region (index was \",trapInfo.toInt(),\").\");\n    break;\ncase TRAP_DIVIDE_BY_ZERO:\n  VM.sysWriteln(\"\\nFatal error: DivideByZero within uninterruptible region.\");\nbreak;\ncase TRAP_STACK_OVERFLOW:\ncase TRAP_JNI_STACK:\nVM.sysWriteln(\"\\nFatal error: StackOverflowError within uninterruptible region.\");\nbreak;\ncase TRAP_CHECKCAST:\nVM.sysWriteln(\"\\nFatal error: ClassCastException within uninterruptible region.\");\nbreak;\ncase TRAP_MUST_IMPLEMENT:\nVM.sysWriteln(\"\\nFatal error: IncompatibleClassChangeError within uninterruptible region.\");\nbreak;\ncase TRAP_STORE_CHECK:\nVM.sysWriteln(\"\\nFatal error: ArrayStoreException within uninterruptible region.\");\nbreak;\ncase TRAP_UNREACHABLE_BYTECODE:\nVM.sysWriteln(\"\\nFatal error: Reached a bytecode that was determined to be unreachable within uninterruptible region.\");\nbreak;\ndefault :\nVM.sysWriteln(\"\\nFatal error: Unknown hardware trap within uninterruptible region.\");\nbreak;\n}\nVM.sysWriteln(\"trapCode = \",trapCode);\nVM.sysWriteln(\"trapInfo = \",trapInfo.toAddress());\nVM.sysFail(\"Exiting virtual machine due to uninterruptibility violation.\");\n}\n}\n}\nThrowable exceptionObject;\nswitch (trapCode) {\ncase TRAP_NULL_POINTER:\nexceptionObject=new java.lang.NullPointerException();\nbreak;\ncase TRAP_ARRAY_BOUNDS:\nexceptionObject=new java.lang.ArrayIndexOutOfBoundsException(trapInfo.toInt());\nbreak;\ncase TRAP_DIVIDE_BY_ZERO:\nexceptionObject=new java.lang.ArithmeticException();\nbreak;\ncase TRAP_STACK_OVERFLOW:\ncase TRAP_JNI_STACK:\nexceptionObject=new java.lang.StackOverflowError();\nbreak;\ncase TRAP_CHECKCAST:\nexceptionObject=new java.lang.ClassCastException();\nbreak;\ncase TRAP_MUST_IMPLEMENT:\nexceptionObject=new java.lang.IncompatibleClassChangeError();\nbreak;\ncase TRAP_STORE_CHECK:\nexceptionObject=new java.lang.ArrayStoreException();\nbreak;\ncase TRAP_UNREACHABLE_BYTECODE:\nexceptionObject=new java.lang.InternalError(UNREACHABLE_BC_MESSAGE);\nbreak;\ndefault :\nexceptionObject=new java.lang.UnknownError();\nRVMThread.traceback(\"UNKNOWN ERROR\");\nbreak;\n}\nVM.disableGC();\ndeliverException(exceptionObject,exceptionRegisters);\n}\n", "nl": "Deliver a hardware exception to current java thread. <p> Does not return. (stack is unwound, starting at trap site, and execution resumes in a catch block somewhere up the stack) /or/  execution resumes at instruction following trap (for TRAP_STACK_OVERFLOW) <p> Note:     Control reaches here by the actions of an external \"C\" signal handler which saves the register state of the trap site into the \"exceptionRegisters\" field of the current Thread object. The signal handler also inserts a &lt;hardware trap&gt; frame onto the stack immediately above this frame, for use by HardwareTrapGCMapIterator during garbage collection."}
{"code": "public static BigInteger[] transformRawSignature(byte[] raw) throws IOException {\n  BigInteger[] output=new BigInteger[2];\n  output[0]=new BigInteger(1,Arrays.copyOfRange(raw,0,32));\n  output[1]=new BigInteger(1,Arrays.copyOfRange(raw,32,64));\n  return output;\n}\n", "nl": "From byte[] to Big Integers r,s UAF_ALG_SIGN_SECP256K1_ECDSA_SHA256_RAW 0x05 An ECDSA signature on the secp256k1 curve which must have raw R and S buffers, encoded in big-endian order. I.e.[R (32 bytes), S (32 bytes)]"}
{"code": "public static void println(Object self,Object value){\n  if (self instanceof Writer) {\n    final PrintWriter pw=new GroovyPrintWriter((Writer)self);\n    pw.println(value);\n  }\n else {\n    System.out.println(InvokerHelper.toString(value));\n  }\n}\n", "nl": "Print a value formatted Groovy style (followed by a newline) to self if it is a Writer, otherwise to the standard output stream."}
{"code": "protected void checkProcessorVersion(Hashtable h){\n  if (null == h)   h=new Hashtable();\n  try {\n    final String XALAN1_VERSION_CLASS=\"org.apache.xalan.xslt.XSLProcessorVersion\";\n    Class clazz=ObjectFactory.findProviderClass(XALAN1_VERSION_CLASS,ObjectFactory.findClassLoader(),true);\n    StringBuffer buf=new StringBuffer();\n    Field f=clazz.getField(\"PRODUCT\");\n    buf.append(f.get(null));\n    buf.append(';');\n    f=clazz.getField(\"LANGUAGE\");\n    buf.append(f.get(null));\n    buf.append(';');\n    f=clazz.getField(\"S_VERSION\");\n    buf.append(f.get(null));\n    buf.append(';');\n    h.put(VERSION + \"xalan1\",buf.toString());\n  }\n catch (  Exception e1) {\n    h.put(VERSION + \"xalan1\",CLASS_NOTPRESENT);\n  }\n  try {\n    final String XALAN2_VERSION_CLASS=\"org.apache.xalan.processor.XSLProcessorVersion\";\n    Class clazz=ObjectFactory.findProviderClass(XALAN2_VERSION_CLASS,ObjectFactory.findClassLoader(),true);\n    StringBuffer buf=new StringBuffer();\n    Field f=clazz.getField(\"S_VERSION\");\n    buf.append(f.get(null));\n    h.put(VERSION + \"xalan2x\",buf.toString());\n  }\n catch (  Exception e2) {\n    h.put(VERSION + \"xalan2x\",CLASS_NOTPRESENT);\n  }\n  try {\n    final String XALAN2_2_VERSION_CLASS=\"org.apache.xalan.Version\";\n    final String XALAN2_2_VERSION_METHOD=\"getVersion\";\n    final Class noArgs[]=new Class[0];\n    Class clazz=ObjectFactory.findProviderClass(XALAN2_2_VERSION_CLASS,ObjectFactory.findClassLoader(),true);\n    Method method=clazz.getMethod(XALAN2_2_VERSION_METHOD,noArgs);\n    Object returnValue=method.invoke(null,new Object[0]);\n    h.put(VERSION + \"xalan2_2\",(String)returnValue);\n  }\n catch (  Exception e2) {\n    h.put(VERSION + \"xalan2_2\",CLASS_NOTPRESENT);\n  }\n}\n", "nl": "Report product version information from Xalan-J. Looks for version info in xalan.jar from Xalan-J products."}
{"code": "public void deinstall(JEditorPane c){\n  c.removeCaretListener(inputAttributeUpdater);\n  c.removePropertyChangeListener(inputAttributeUpdater);\n  currentRun=null;\n  currentParagraph=null;\n}\n", "nl": "Called when the kit is being removed from the JEditorPane.  This is used to unregister any listeners that were attached."}
{"code": "public void dismissAndSwitch(){\n  final int numIcons=mIcons.length;\n  RecentTag tag=null;\n  for (int i=0; i < numIcons; i++) {\n    if (mIcons[i].getVisibility() != View.VISIBLE) {\n      break;\n    }\n    if (i == 0 || mIcons[i].hasFocus()) {\n      tag=(RecentTag)mIcons[i].getTag();\n      if (mIcons[i].hasFocus()) {\n        break;\n      }\n    }\n  }\n  if (tag != null) {\n    switchTo(tag);\n  }\n  dismiss();\n}\n", "nl": "Dismiss the dialog and switch to the selected application."}
{"code": "public byte toReal(){\n  return _real;\n}\n", "nl": "Returns the real value."}
{"code": "public void updateParameterInfo(@NotNull final PyArgumentList arglist,@NotNull final UpdateParameterInfoContext context){\n  if (context.getParameterOwner() != arglist) {\n    context.removeHint();\n    return;\n  }\n  List<PyExpression> flat_args=PyUtil.flattenedParensAndLists(arglist.getArguments());\n  int alleged_cursor_offset=context.getOffset();\n  final TextRange argListTextRange=arglist.getTextRange();\n  if (!argListTextRange.contains(alleged_cursor_offset) && arglist.getText().endsWith(\")\")) {\n    context.removeHint();\n    return;\n  }\n  PsiFile file=context.getFile();\n  CharSequence chars=file.getViewProvider().getContents();\n  int offset=-1;\n  for (  PyExpression arg : flat_args) {\n    TextRange range=arg.getTextRange();\n    int left=CharArrayUtil.shiftBackward(chars,range.getStartOffset() - 1,\" \\t\\r\\n\");\n    int right=CharArrayUtil.shiftForwardCarefully(chars,range.getEndOffset(),\" \\t\\r\\n\");\n    if (arg.getParent() instanceof PyListLiteralExpression || arg.getParent() instanceof PyTupleExpression) {\n      right=CharArrayUtil.shiftForward(chars,range.getEndOffset(),\" \\t\\r\\n])\");\n    }\n    if (left <= alleged_cursor_offset && right >= alleged_cursor_offset) {\n      offset=range.getStartOffset();\n      break;\n    }\n  }\n  context.setCurrentParameter(offset);\n}\n", "nl": "<b>Note: instead of parameter index, we directly store parameter's offset for later use.</b><br/> We cannot store an index since we cannot determine what is an argument until we actually map arguments to parameters. This is because a tuple in arguments may be a whole argument or map to a tuple parameter."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:36:13.915 -0500\",hash_original_method=\"E54E1790034E06C2564EA8F8D322C604\",hash_generated_method=\"4A4D6596F1AA464E59CD29757B0A54BF\") @Deprecated public SslError(int error,SslCertificate certificate){\n  this(error,certificate,\"\");\n}\n", "nl": "Creates a new SslError object using the supplied error and certificate. The URL will be set to the empty string."}
{"code": "private static boolean hasXMPHeader(byte[] data){\n  if (data.length < XMP_HEADER_SIZE) {\n    return false;\n  }\n  try {\n    byte[] header=new byte[XMP_HEADER_SIZE];\n    System.arraycopy(data,0,header,0,XMP_HEADER_SIZE);\n    if (new String(header,\"UTF-8\").equals(XMP_HEADER)) {\n      return true;\n    }\n  }\n catch (  UnsupportedEncodingException e) {\n    return false;\n  }\n  return false;\n}\n", "nl": "Checks whether the byte array has XMP header. The XMP section contains a fixed length header XMP_HEADER."}
{"code": "public ButtonFactory(ResourceBundle rb,ActionMap am){\n  super(rb);\n  actions=am;\n}\n", "nl": "Creates a new button factory"}
{"code": "private void updateRangesFields(){\n  fRanges=(mask & ~(1 << 31));\n  fContextual=((mask & (1 << 31)) != 0);\n  if (fContextual) {\n    fRanges=(mask & ~(1 << 31));\n    fDefaultContextIndex=key;\n  }\n else {\n    fRanges=mask;\n    fSingleRangeIndex=key;\n  }\n}\n", "nl": "Updates all private serialized fields for object to be correctly serialized according to the serialized form of this class mentioned in the documentation."}
{"code": "public void startCountdown(int sec){\n  mCountdownView.startCountDown(sec);\n}\n", "nl": "Starts the countdown timer."}
{"code": "public long readLongFromXML(Element node) throws Exception {\n  if (DEBUG) {\n    trace(new Throwable(),node.getAttribute(ATT_NAME));\n  }\n  m_CurrentNode=node;\n  return ((Long)getPrimitive(node)).longValue();\n}\n", "nl": "builds the primitive from the given DOM node."}
{"code": "public static ZeroConfService create(String type,String name,int port,int weight,int priority,HashMap<String,String> properties){\n  ZeroConfService s;\n  if (ZeroConfService.services().containsKey(ZeroConfService.key(type,name))) {\n    s=ZeroConfService.services().get(ZeroConfService.key(type,name));\n    log.debug(\"Using existing ZeroConfService {}\",s.key());\n  }\n else {\n    properties.put(\"version\",jmri.Version.name());\n    properties.put(\"jmri\",jmri.Version.getCanonicalVersion());\n    properties.put(\"node\",NodeIdentity.identity());\n    s=new ZeroConfService(ServiceInfo.create(type,name,port,weight,priority,properties));\n    log.debug(\"Creating new ZeroConfService {} with properties {}\",s.key(),properties);\n  }\n  return s;\n}\n", "nl": "Create a ZeroConfService. The property <i>version</i> is added or replaced with the current JMRI version as its value. The property <i>jmri</i> is added or replaced with the JMRI major.minor.test version string as its value. <p> If a service with the same key as the new service is already published, the original service is returned unmodified."}
{"code": "public void cancelChallanReceiptOnCreation(final ReceiptHeader receiptHeader){\n  final ReceiptHeader receiptHeaderToBeCancelled=receiptHeaderService.findById(receiptHeader.getReceiptHeader().getId(),false);\n  receiptHeaderToBeCancelled.setStatus(collectionsUtil.getStatusForModuleAndCode(CollectionConstants.MODULE_NAME_RECEIPTHEADER,CollectionConstants.RECEIPT_STATUS_CODE_CANCELLED));\n  receiptHeaderService.persist(receiptHeaderToBeCancelled);\n}\n", "nl": "This method cancels the receipt against a challan. The reason for cancellation is set and the staus is changed to CANCELLED."}
{"code": "public static double nextDouble(double value,boolean increment){\n  return increment ? nextDouble(value) : previousDouble(value);\n}\n", "nl": "Returns the double value which is closest to the specified double but either larger or smaller as specified."}
{"code": "private void checkSourceVersionCompatibility(Source source,Log log){\n  SourceVersion procSourceVersion=processor.getSupportedSourceVersion();\n  if (procSourceVersion.compareTo(Source.toSourceVersion(source)) < 0) {\n    log.warning(\"proc.processor.incompatible.source.version\",procSourceVersion,Wrappers.unwrapProcessorClass(processor).getName(),source.name);\n  }\n}\n", "nl": "Checks whether or not a processor's source version is compatible with the compilation source version.  The processor's source version needs to be greater than or equal to the source version of the compile."}
{"code": "void openPolicy(String filename) throws FileNotFoundException, PolicyParser.ParsingException, KeyStoreException, CertificateException, InstantiationException, MalformedURLException, IOException, NoSuchAlgorithmException, IllegalAccessException, NoSuchMethodException, UnrecoverableKeyException, NoSuchProviderException, ClassNotFoundException, PropertyExpander.ExpandException, InvocationTargetException {\n  newWarning=false;\n  policyEntries=new Vector<PolicyEntry>();\n  parser=new PolicyParser();\n  warnings=new Vector<String>();\n  setPolicyFileName(null);\n  clearKeyStoreInfo();\n  if (filename == null) {\n    modified=false;\n    return;\n  }\n  setPolicyFileName(filename);\n  parser.read(new FileReader(filename));\n  openKeyStore(parser.getKeyStoreUrl(),parser.getKeyStoreType(),parser.getKeyStoreProvider(),parser.getStorePassURL());\n  Enumeration<PolicyParser.GrantEntry> enum_=parser.grantElements();\n  while (enum_.hasMoreElements()) {\n    PolicyParser.GrantEntry ge=enum_.nextElement();\n    if (ge.signedBy != null) {\n      String signers[]=parseSigners(ge.signedBy);\n      for (int i=0; i < signers.length; i++) {\n        PublicKey pubKey=getPublicKeyAlias(signers[i]);\n        if (pubKey == null) {\n          newWarning=true;\n          MessageFormat form=new MessageFormat(getMessage(\"Warning.A.public.key.for.alias.signers.i.does.not.exist.Make.sure.a.KeyStore.is.properly.configured.\"));\n          Object[] source={signers[i]};\n          warnings.addElement(form.format(source));\n        }\n      }\n    }\n    ListIterator<PolicyParser.PrincipalEntry> prinList=ge.principals.listIterator(0);\n    while (prinList.hasNext()) {\n      PolicyParser.PrincipalEntry pe=prinList.next();\n      try {\n        verifyPrincipal(pe.getPrincipalClass(),pe.getPrincipalName());\n      }\n catch (      ClassNotFoundException fnfe) {\n        newWarning=true;\n        MessageFormat form=new MessageFormat(getMessage(\"Warning.Class.not.found.class\"));\n        Object[] source={pe.getPrincipalClass()};\n        warnings.addElement(form.format(source));\n      }\n    }\n    Enumeration<PolicyParser.PermissionEntry> perms=ge.permissionElements();\n    while (perms.hasMoreElements()) {\n      PolicyParser.PermissionEntry pe=perms.nextElement();\n      try {\n        verifyPermission(pe.permission,pe.name,pe.action);\n      }\n catch (      ClassNotFoundException fnfe) {\n        newWarning=true;\n        MessageFormat form=new MessageFormat(getMessage(\"Warning.Class.not.found.class\"));\n        Object[] source={pe.permission};\n        warnings.addElement(form.format(source));\n      }\ncatch (      InvocationTargetException ite) {\n        newWarning=true;\n        MessageFormat form=new MessageFormat(getMessage(\"Warning.Invalid.argument.s.for.constructor.arg\"));\n        Object[] source={pe.permission};\n        warnings.addElement(form.format(source));\n      }\n      if (pe.signedBy != null) {\n        String signers[]=parseSigners(pe.signedBy);\n        for (int i=0; i < signers.length; i++) {\n          PublicKey pubKey=getPublicKeyAlias(signers[i]);\n          if (pubKey == null) {\n            newWarning=true;\n            MessageFormat form=new MessageFormat(getMessage(\"Warning.A.public.key.for.alias.signers.i.does.not.exist.Make.sure.a.KeyStore.is.properly.configured.\"));\n            Object[] source={signers[i]};\n            warnings.addElement(form.format(source));\n          }\n        }\n      }\n    }\n    PolicyEntry pEntry=new PolicyEntry(this,ge);\n    policyEntries.addElement(pEntry);\n  }\n  modified=false;\n}\n", "nl": "Open and read a policy file"}
{"code": "private T[] ensureCapacity(int minCapacity){\n  if (tmp.length < minCapacity) {\n    int newSize=minCapacity;\n    newSize|=newSize >> 1;\n    newSize|=newSize >> 2;\n    newSize|=newSize >> 4;\n    newSize|=newSize >> 8;\n    newSize|=newSize >> 16;\n    newSize++;\n    if (newSize < 0)     newSize=minCapacity;\n else     newSize=Math.min(newSize,a.length >>> 1);\n    @SuppressWarnings({\"unchecked\",\"UnnecessaryLocalVariable\"}) T[] newArray=(T[])new Object[newSize];\n    tmp=newArray;\n  }\n  return tmp;\n}\n", "nl": "Ensures that the external array tmp has at least the specified number of elements, increasing its size if necessary.  The size increases exponentially to ensure amortized linear time complexity."}
{"code": "public static short[] toShortArray(int[] array){\n  short[] result=new short[array.length];\n  for (int i=0; i < array.length; i++) {\n    result[i]=(short)array[i];\n  }\n  return result;\n}\n", "nl": "Coverts given ints array to array of shorts."}
{"code": "public void deleteThreadVars() throws IOException {\n  print(\"deleteThreadVars\",null);\n}\n", "nl": "Description of the Method"}
{"code": "public static void main(String[] args){\n  try {\n    File testF=new File(new File(System.getProperty(\"user.dir\")),\"testOut.zip\");\n    OutputZipper oz=new OutputZipper(testF);\n    oz.zipit(\"Here is some test text to be zipped\",\"testzip\");\n    oz.zipit(\"Here is a second entry to be zipped\",\"testzip2\");\n    oz.finished();\n  }\n catch (  Exception ex) {\n    ex.printStackTrace();\n    System.err.println(ex.getMessage());\n  }\n}\n", "nl": "Main method for testing this class"}
{"code": "public void createOffspring(Turkanian parent){\n  if (parent.energy <= birthEnergy) {\n    return;\n  }\n  Turkanian offspring=new Turkanian(this,parent.x,parent.y);\n  parent.energy-=birthEnergy;\n  offspring.energy=0;\n  agents.add(offspring);\n  agentGrid.setObjectLocation(offspring,offspring.x,offspring.y);\n  schedule.scheduleOnce(offspring);\n}\n", "nl": "Create offspring of the current agent and add them to the grid in the same cell."}
{"code": "public static <T>Supplier<T> prevNoDupSupplier(final Cursor cursor,ByteArrayConverter<T> converter){\n  DatabaseEntry key=new DatabaseEntry();\n  DatabaseEntry data=new DatabaseEntry();\n  return null;\n}\n", "nl": "Supplies previous key, ignore duplicates, produce the key value, NOT the associated data."}
{"code": "private static void enableObjectAddressRemapper(){\n  Magic.setObjectAddressRemapper(BootImageObjectAddressRemapper.getInstance());\n}\n", "nl": "Begin recording objects referenced by RVM classes during loading/resolution/instantiation.  These references will be converted to bootimage addresses when those objects are copied into bootimage."}
{"code": "public void transformNode(int node) throws TransformerException {\n  setExtensionsTable(getStylesheet());\nsynchronized (m_serializationHandler) {\n    m_hasBeenReset=false;\n    XPathContext xctxt=getXPathContext();\n    DTM dtm=xctxt.getDTM(node);\n    try {\n      pushGlobalVars(node);\n      StylesheetRoot stylesheet=this.getStylesheet();\n      int n=stylesheet.getGlobalImportCount();\n      for (int i=0; i < n; i++) {\n        StylesheetComposed imported=stylesheet.getGlobalImport(i);\n        int includedCount=imported.getIncludeCountComposed();\n        for (int j=-1; j < includedCount; j++) {\n          Stylesheet included=imported.getIncludeComposed(j);\n          included.runtimeInit(this);\n          for (ElemTemplateElement child=included.getFirstChildElem(); child != null; child=child.getNextSiblingElem()) {\n            child.runtimeInit(this);\n          }\n        }\n      }\n      DTMIterator dtmIter=new org.apache.xpath.axes.SelfIteratorNoPredicate();\n      dtmIter.setRoot(node,xctxt);\n      xctxt.pushContextNodeList(dtmIter);\n      try {\n        this.applyTemplateToNode(null,null,node);\n      }\n  finally {\n        xctxt.popContextNodeList();\n      }\n      if (null != m_serializationHandler) {\n        m_serializationHandler.endDocument();\n      }\n    }\n catch (    Exception se) {\n      while (se instanceof org.apache.xml.utils.WrappedRuntimeException) {\n        Exception e=((org.apache.xml.utils.WrappedRuntimeException)se).getException();\n        if (null != e)         se=e;\n      }\n      if (null != m_serializationHandler) {\n        try {\n          if (se instanceof org.xml.sax.SAXParseException)           m_serializationHandler.fatalError((org.xml.sax.SAXParseException)se);\n else           if (se instanceof TransformerException) {\n            TransformerException te=((TransformerException)se);\n            SAXSourceLocator sl=new SAXSourceLocator(te.getLocator());\n            m_serializationHandler.fatalError(new org.xml.sax.SAXParseException(te.getMessage(),sl,te));\n          }\n else {\n            m_serializationHandler.fatalError(new org.xml.sax.SAXParseException(se.getMessage(),new SAXSourceLocator(),se));\n          }\n        }\n catch (        Exception e) {\n        }\n      }\n      if (se instanceof TransformerException) {\n        m_errorHandler.fatalError((TransformerException)se);\n      }\n else       if (se instanceof org.xml.sax.SAXParseException) {\n        m_errorHandler.fatalError(new TransformerException(se.getMessage(),new SAXSourceLocator((org.xml.sax.SAXParseException)se),se));\n      }\n else {\n        m_errorHandler.fatalError(new TransformerException(se));\n      }\n    }\n finally {\n      this.reset();\n    }\n  }\n}\n", "nl": "Process the source node to the output result, if the processor supports the \"http://xml.org/trax/features/dom/input\" feature. %REVIEW% Do we need a Node version of this?"}
{"code": "@Override protected RdKNNEntry createRootEntry(){\n  return new RdKNNDirectoryEntry(0,null,Double.NaN);\n}\n", "nl": "Creates an entry representing the root node."}
{"code": "public static byte[] readBytes(Path self) throws IOException {\n  return Files.readAllBytes(self);\n}\n", "nl": "Reads the content of the file into a byte array."}
{"code": "public void showURLInBrowser(final URL url){\n  try {\n    if (Desktop.isDesktopSupported())     try {\n      Desktop.getDesktop().browse(url.toURI());\n      return;\n    }\n catch (    final Exception e) {\n    }\n    String[] cmdArray=null;\n    if (LEnv.OS == OpSys.WINDOWS) {\n      cmdArray=new String[]{\"rundll32\",\"url.dll,FileProtocolHandler\",url.toString()};\n    }\n else {\n      final String[] browsers={\"firefox\",\"google-chrome\",\"opera\",\"konqueror\",\"epiphany\",\"mozilla\",\"netscape\"};\n      for (      final String browser : browsers)       if (Runtime.getRuntime().exec(new String[]{\"which\",browser}).waitFor() == 0) {\n        cmdArray=new String[]{browser,url.toString()};\n        break;\n      }\n    }\n    if (cmdArray != null)     Runtime.getRuntime().exec(cmdArray);\n  }\n catch (  final Exception e) {\n    LEnv.LOGGER.info(\"Failed to open URL: \" + url,e);\n  }\n}\n", "nl": "Opens the web page specified by the URL in the system's default browser."}
{"code": "private void updateProgress(String progressLabel,int progress){\n  if (myHost != null && ((progress != previousProgress) || (!progressLabel.equals(previousProgressLabel)))) {\n    myHost.updateProgress(progressLabel,progress);\n  }\n  previousProgress=progress;\n  previousProgressLabel=progressLabel;\n}\n", "nl": "Used to communicate a progress update between a plugin tool and the main Whitebox user interface."}
{"code": "public void addInputProducer(PValue expandedInput,TransformTreeNode producer){\n  checkState(!finishedSpecifying);\n  inputs.put(expandedInput,producer);\n}\n", "nl": "Adds an input to the transform node."}
{"code": "public Clustering<Model> run(Relation<Model> relation){\n  HashMap<Model,ModifiableDBIDs> modelMap=new HashMap<>();\n  for (DBIDIter iditer=relation.iterDBIDs(); iditer.valid(); iditer.advance()) {\n    Model model=relation.get(iditer);\n    ModifiableDBIDs modelids=modelMap.get(model);\n    if (modelids == null) {\n      modelids=DBIDUtil.newHashSet();\n      modelMap.put(model,modelids);\n    }\n    modelids.add(iditer);\n  }\n  Clustering<Model> result=new Clustering<>(\"By Model Clustering\",\"bymodel-clustering\");\n  for (  Entry<Model,ModifiableDBIDs> entry : modelMap.entrySet()) {\n    final Model model=entry.getKey();\n    final ModifiableDBIDs ids=entry.getValue();\n    final String name=(model instanceof GeneratorInterface) ? ((GeneratorInterface)model).getName() : model.toString();\n    Cluster<Model> c=new Cluster<>(name,ids,model);\n    if (noisepattern != null && noisepattern.matcher(name).find()) {\n      c.setNoise(true);\n    }\n    result.addToplevelCluster(c);\n  }\n  return result;\n}\n", "nl": "Run the actual clustering algorithm."}
{"code": "String rrToString(){\n  StringBuffer sb=new StringBuffer();\n  sb.append(Type.string(covered));\n  sb.append(\" \");\n  sb.append(alg);\n  sb.append(\" \");\n  sb.append(labels);\n  sb.append(\" \");\n  sb.append(origttl);\n  sb.append(\" \");\n  if (Options.check(\"multiline\"))   sb.append(\"(\\n\\t\");\n  sb.append(FormattedTime.format(expire));\n  sb.append(\" \");\n  sb.append(FormattedTime.format(timeSigned));\n  sb.append(\" \");\n  sb.append(footprint);\n  sb.append(\" \");\n  sb.append(signer);\n  if (Options.check(\"multiline\")) {\n    sb.append(\"\\n\");\n    sb.append(base64.formatString(signature,64,\"\\t\",true));\n  }\n else {\n    sb.append(\" \");\n    sb.append(base64.toString(signature));\n  }\n  return sb.toString();\n}\n", "nl": "Converts the RRSIG/SIG Record to a String"}
{"code": "private boolean isModel(JavaContext context,Node classDeclaration){\n  String classFilePackage=PackageManager.getPackage(context,classDeclaration);\n  return classFilePackage.contains(\".models.\");\n}\n", "nl": "Check if a class is a Model (is inside a package called 'models')."}
{"code": "public void addPlugin(final IPlugin<IPluginInterface> plugin){\n  Preconditions.checkNotNull(plugin,\"Error: Plugin argument can not be null\");\n  m_registry.addPlugin(plugin);\n}\n", "nl": "Add a new plugin to the list of registered plugins."}
{"code": "private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException {\n  s.defaultWriteObject();\n  s.writeInt(table.length);\n  s.writeInt(count);\n  for (int index=table.length - 1; index >= 0; index--) {\n    Entry entry=table[index];\n    while (entry != null) {\n      s.writeObject(entry.key);\n      s.writeObject(entry.value);\n      entry=entry.next;\n    }\n  }\n}\n", "nl": "Save the state of the <tt>IdentityHashMap</tt> instance to a stream (i.e., serialize it)."}
{"code": "@Override protected void mouseClicked(int par1,int par2,int par3) throws IOException {\n  super.mouseClicked(par1,par2,par3);\n  tokenBox.mouseClicked(par1,par2,par3);\n  if (tokenBox.isFocused()) {\n    errorText=\"\";\n    helpText=\"\";\n  }\n}\n", "nl": "Called when the mouse is clicked."}
{"code": "public Object call(Object object,String name,Object[] args) throws BSFException {\n  if (object == null) {\n    try {\n      object=interpreter.get(\"global\");\n    }\n catch (    EvalError e) {\n      throw new BSFException(\"bsh internal error: \" + e.toString());\n    }\n  }\n  if (object instanceof bsh.This) {\n    try {\n      return ((bsh.This)object).invokeMethod(name,args);\n    }\n catch (    InterpreterError e) {\n      throw new BSFException(\"BeanShell interpreter internal error: \" + e);\n    }\ncatch (    TargetError e2) {\n      throw new BSFException(\"The application script threw an exception: \" + e2.getTarget());\n    }\ncatch (    EvalError e3) {\n      throw new BSFException(\"BeanShell script error: \" + e3);\n    }\n  }\n else {\n    throw new BSFException(\"Cannot invoke method: \" + name + \". Object: \"+ object+ \" is not a BeanShell scripted object.\");\n  }\n}\n", "nl": "Invoke method name on the specified bsh scripted object. The object may be null to indicate the global namespace of the interpreter."}
{"code": "@DSComment(\"Private Method\") @DSBan(DSCat.PRIVATE_METHOD) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:31:30.536 -0500\",hash_original_method=\"55F676D436FF1EC67ECC1C028E81ED27\",hash_generated_method=\"AC9FD73229CF68305BF944740C6C29B7\") private View moveSelection(int delta,int childrenTop,int childrenBottom){\n  final int fadingEdgeLength=getVerticalFadingEdgeLength();\n  final int selectedPosition=mSelectedPosition;\n  final int numColumns=mNumColumns;\n  final int verticalSpacing=mVerticalSpacing;\n  int oldRowStart;\n  int rowStart;\n  int rowEnd=-1;\n  if (!mStackFromBottom) {\n    oldRowStart=(selectedPosition - delta) - ((selectedPosition - delta) % numColumns);\n    rowStart=selectedPosition - (selectedPosition % numColumns);\n  }\n else {\n    int invertedSelection=mItemCount - 1 - selectedPosition;\n    rowEnd=mItemCount - 1 - (invertedSelection - (invertedSelection % numColumns));\n    rowStart=Math.max(0,rowEnd - numColumns + 1);\n    invertedSelection=mItemCount - 1 - (selectedPosition - delta);\n    oldRowStart=mItemCount - 1 - (invertedSelection - (invertedSelection % numColumns));\n    oldRowStart=Math.max(0,oldRowStart - numColumns + 1);\n  }\n  final int rowDelta=rowStart - oldRowStart;\n  final int topSelectionPixel=getTopSelectionPixel(childrenTop,fadingEdgeLength,rowStart);\n  final int bottomSelectionPixel=getBottomSelectionPixel(childrenBottom,fadingEdgeLength,numColumns,rowStart);\n  mFirstPosition=rowStart;\n  View sel;\n  View referenceView;\n  if (rowDelta > 0) {\n    final int oldBottom=mReferenceViewInSelectedRow == null ? 0 : mReferenceViewInSelectedRow.getBottom();\n    sel=makeRow(mStackFromBottom ? rowEnd : rowStart,oldBottom + verticalSpacing,true);\n    referenceView=mReferenceView;\n    adjustForBottomFadingEdge(referenceView,topSelectionPixel,bottomSelectionPixel);\n  }\n else   if (rowDelta < 0) {\n    final int oldTop=mReferenceViewInSelectedRow == null ? 0 : mReferenceViewInSelectedRow.getTop();\n    sel=makeRow(mStackFromBottom ? rowEnd : rowStart,oldTop - verticalSpacing,false);\n    referenceView=mReferenceView;\n    adjustForTopFadingEdge(referenceView,topSelectionPixel,bottomSelectionPixel);\n  }\n else {\n    final int oldTop=mReferenceViewInSelectedRow == null ? 0 : mReferenceViewInSelectedRow.getTop();\n    sel=makeRow(mStackFromBottom ? rowEnd : rowStart,oldTop,true);\n    referenceView=mReferenceView;\n  }\n  if (!mStackFromBottom) {\n    fillUp(rowStart - numColumns,referenceView.getTop() - verticalSpacing);\n    adjustViewsUpOrDown();\n    fillDown(rowStart + numColumns,referenceView.getBottom() + verticalSpacing);\n  }\n else {\n    fillDown(rowEnd + numColumns,referenceView.getBottom() + verticalSpacing);\n    adjustViewsUpOrDown();\n    fillUp(rowStart - 1,referenceView.getTop() - verticalSpacing);\n  }\n  return sel;\n}\n", "nl": "Fills the grid based on positioning the new selection relative to the old selection. The new selection will be placed at, above, or below the location of the new selection depending on how the selection is moving. The selection will then be pinned to the visible part of the screen, excluding the edges that are faded. The grid is then filled upwards and downwards from there."}
{"code": "public synchronized void clear(){\n  super.clear();\n  mValue.clear();\n  initRange();\n}\n", "nl": "Removes all the values from the series."}
{"code": "public static void fill(int[][][] matrix,int value){\n  int rows=matrix.length;\n  for (int r=0; r < rows; r++) {\n    int cols=matrix[r].length;\n    for (int c=0; c < cols; c++) {\n      int height=matrix[r][c].length;\n      for (int h=0; h < height; h++) {\n        matrix[r][c][h]=value;\n      }\n    }\n  }\n}\n", "nl": "Initialises all values in the matrix to the given value"}
{"code": "@Override public int hashCode(){\n  if (m_RecalcHashCode) {\n    m_HashCode=toString().hashCode();\n    m_RecalcHashCode=false;\n  }\n  return m_HashCode;\n}\n", "nl": "Returns the hash code value for this collection."}
{"code": "@Override public int intValue(){\n  return value;\n}\n", "nl": "Returns the value of this MutableInt as an int."}
{"code": "public DefaultDeployableFactory(ClassLoader classLoader){\n  registerDeployable(DEFAULT_CONTAINER_ID,DeployableType.WAR,WAR.class);\n  registerDeployable(DEFAULT_CONTAINER_ID,DeployableType.EJB,EJB.class);\n  registerDeployable(DEFAULT_CONTAINER_ID,DeployableType.EAR,EAR.class);\n  registerDeployable(DEFAULT_CONTAINER_ID,DeployableType.SAR,SAR.class);\n  registerDeployable(DEFAULT_CONTAINER_ID,DeployableType.RAR,RAR.class);\n  registerDeployable(DEFAULT_CONTAINER_ID,DeployableType.FILE,File.class);\n  registerDeployable(DEFAULT_CONTAINER_ID,DeployableType.BUNDLE,Bundle.class);\n  registerDeployable(DEFAULT_CONTAINER_ID,DeployableType.HAR,HAR.class);\n  registerDeployable(DEFAULT_CONTAINER_ID,DeployableType.AOP,AOP.class);\n  AbstractFactoryRegistry.register(classLoader,this);\n}\n", "nl": "Register deployable classes mappings."}
{"code": "public VarInt(long value){\n  this.value=value;\n  originallyEncodedSize=getSizeInBytes();\n}\n", "nl": "Constructs a new VarInt with the given unsigned long value."}
{"code": "public void makeClass(Vector v,boolean caseless){\n  makeClass(new IntCharSet(v),caseless);\n}\n", "nl": "Updates the current partition, so that the specified set of characters gets a new character class. Characters that are elements of the set <code>v</code> are not in the same equivalence class with characters that are not elements of the set <code>v</code>."}
{"code": "@POST @Produces({MediaType.APPLICATION_XML,MediaType.APPLICATION_JSON}) @Path(\"/{id}/deactivate\") @CheckPermission(roles={Role.TENANT_ADMIN},acls={ACL.ANY}) public TaskList deactivateSnapshot(@PathParam(\"id\") URI id,@DefaultValue(\"FULL\") @QueryParam(\"type\") String type){\n  _log.info(\"Executing {} snapshot delete for snapshot {}\",type,id);\n  String opStage=null;\n  boolean successStatus=true;\n  String taskId=UUID.randomUUID().toString();\n  TaskList response=new TaskList();\n  BlockSnapshot snap=(BlockSnapshot)queryResource(id);\n  List<Class<? extends DataObject>> excludeTypes=new ArrayList<Class<? extends DataObject>>();\n  excludeTypes.add(BlockSnapshotSession.class);\n  if (VolumeDeleteTypeEnum.VIPR_ONLY.name().equals(type)) {\n    excludeTypes.add(ExportGroup.class);\n    excludeTypes.add(ExportMask.class);\n  }\n  ArgValidator.checkReference(BlockSnapshot.class,id,checkForDelete(snap,excludeTypes));\n  if (!VolumeDeleteTypeEnum.VIPR_ONLY.name().equals(type)) {\n    opStage=AuditLogManager.AUDITOP_BEGIN;\n    URIQueryResultList snapSessionURIs=new URIQueryResultList();\n    _dbClient.queryByConstraint(ContainmentConstraint.Factory.getLinkedTargetSnapshotSessionConstraint(id),snapSessionURIs);\n    Iterator<URI> snapSessionURIsIter=snapSessionURIs.iterator();\n    if (snapSessionURIsIter.hasNext()) {\n      _log.info(\"Snapshot is linked target for a snapshot session\");\n      SnapshotSessionUnlinkTargetsParam param=new SnapshotSessionUnlinkTargetsParam();\n      List<SnapshotSessionUnlinkTargetParam> targetInfoList=new ArrayList<SnapshotSessionUnlinkTargetParam>();\n      SnapshotSessionUnlinkTargetParam targetInfo=new SnapshotSessionUnlinkTargetParam(id,Boolean.TRUE);\n      targetInfoList.add(targetInfo);\n      param.setLinkedTargets(targetInfoList);\n      response.getTaskList().add(getSnapshotSessionManager().unlinkTargetVolumesFromSnapshotSession(snapSessionURIsIter.next(),param,OperationTypeEnum.DELETE_VOLUME_SNAPSHOT));\n      return response;\n    }\n    if (snap.getInactive()) {\n      _log.info(\"Snapshot is already inactive\");\n      Operation op=new Operation();\n      op.ready(\"The snapshot has already been deleted\");\n      op.setResourceType(ResourceOperationTypeEnum.DELETE_VOLUME_SNAPSHOT);\n      _dbClient.createTaskOpStatus(BlockSnapshot.class,snap.getId(),taskId,op);\n      response.getTaskList().add(toTask(snap,taskId,op));\n      return response;\n    }\n  }\n  StorageSystem device=_dbClient.queryObject(StorageSystem.class,snap.getStorageController());\n  List<BlockSnapshot> snapshots=new ArrayList<BlockSnapshot>();\n  final URI cgId=snap.getConsistencyGroup();\n  if (!NullColumnValueGetter.isNullURI(cgId) && !NullColumnValueGetter.isNullValue(snap.getReplicationGroupInstance())) {\n    snapshots=ControllerUtils.getSnapshotsPartOfReplicationGroup(snap,_dbClient);\n  }\n else {\n    snapshots.add(snap);\n  }\n  Volume parentVolume=_permissionsHelper.getObjectById(snap.getParent(),Volume.class);\n  checkForPendingTasks(Arrays.asList(parentVolume.getTenant().getURI()),snapshots);\n  for (  BlockSnapshot snapshot : snapshots) {\n    Operation snapOp=_dbClient.createTaskOpStatus(BlockSnapshot.class,snapshot.getId(),taskId,ResourceOperationTypeEnum.DELETE_VOLUME_SNAPSHOT);\n    response.getTaskList().add(toTask(snapshot,taskId,snapOp));\n  }\n  try {\n    BlockServiceApi blockServiceApiImpl=BlockService.getBlockServiceImpl(parentVolume,_dbClient);\n    blockServiceApiImpl.deleteSnapshot(snap,snapshots,taskId,type);\n  }\n catch (  APIException|InternalException e) {\n    successStatus=false;\n    String errorMsg=String.format(\"Exception attempting to delete snapshot %s: %s\",snap.getId(),e.getMessage());\n    _log.error(errorMsg);\n    for (    TaskResourceRep taskResourceRep : response.getTaskList()) {\n      taskResourceRep.setState(Operation.Status.error.name());\n      taskResourceRep.setMessage(errorMsg);\n      _dbClient.error(BlockSnapshot.class,taskResourceRep.getResource().getId(),taskId,e);\n    }\n  }\ncatch (  Exception e) {\n    successStatus=false;\n    String errorMsg=String.format(\"Exception attempting to delete snapshot %s: %s\",snap.getId(),e.getMessage());\n    _log.error(errorMsg);\n    ServiceCoded sc=APIException.internalServerErrors.genericApisvcError(errorMsg,e);\n    for (    TaskResourceRep taskResourceRep : response.getTaskList()) {\n      taskResourceRep.setState(Operation.Status.error.name());\n      taskResourceRep.setMessage(sc.getMessage());\n      _dbClient.error(BlockSnapshot.class,taskResourceRep.getResource().getId(),taskId,sc);\n    }\n  }\n  auditOp(OperationTypeEnum.DELETE_VOLUME_SNAPSHOT,successStatus,opStage,id.toString(),snap.getLabel(),snap.getParent().getName(),device.getId().toString());\n  return response;\n}\n", "nl": "Deactivate volume snapshot, this will move the snapshot to a \"marked-for-delete\" state. It will be deleted by the garbage collector on a subsequent iteration If this snapshot was created from a volume that is part of a consistency group, then all the related snapshots will be deactivated, as well."}
{"code": "public static List propertyDescriptors(int apiLevel){\n  return PROPERTY_DESCRIPTORS;\n}\n", "nl": "Returns a list of structural property descriptors for this node type. Clients must not modify the result."}
{"code": "public CataclysmicDemographicModel(Parameter N0Parameter,Parameter N1Parameter,Parameter growthRateParameter,Parameter timeParameter,Type units,boolean useSpike){\n  this(CataclysmicDemographicModelParser.CATACLYSM_MODEL,N0Parameter,N1Parameter,growthRateParameter,timeParameter,units,useSpike);\n}\n", "nl": "Construct demographic model with default settings"}
{"code": "public <T extends SuperModel>boolean insert(T model){\n  Object[] objects=model.getInsertSql();\n  return execSQL(objects[0].toString(),Arrays.copyOfRange(objects,1,objects.length));\n}\n", "nl": "Insert a model."}
{"code": "public void update(byte[] in,int off,int len){\n  contentDigest.update(in,off,len);\n}\n", "nl": "update the internal digest with the byte array in"}
{"code": "PostscriptGraphics(PostscriptGraphics copy){\n  m_extent=new Rectangle(copy.m_extent);\n  m_printstream=copy.m_printstream;\n  m_localGraphicsState=new GraphicsState(copy.m_localGraphicsState);\n  m_psGraphicsState=copy.m_psGraphicsState;\n}\n", "nl": "Creates a new cloned PostscriptGraphics object."}
{"code": "public boolean isParameterized(){\n  EList<TypeRef> _typeArgs=this.getTypeArgs();\n  boolean _isEmpty=_typeArgs.isEmpty();\n  return (!_isEmpty);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public ConstraintIntervalType createConstraintIntervalTypeFromString(EDataType eDataType,String initialValue){\n  ConstraintIntervalType result=ConstraintIntervalType.get(initialValue);\n  if (result == null)   throw new IllegalArgumentException(\"The value '\" + initialValue + \"' is not a valid enumerator of '\"+ eDataType.getName()+ \"'\");\n  return result;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "private Optional<FeedItem> findLastVisibleFeedItem(Set<ContentType> contentType){\n  List<FeedItem> items=feedAdapter.getFeed().getItems();\n  return getRecyclerViewLayoutManager().<Optional<FeedItem>>transform(null).get();\n}\n", "nl": "Finds the first item in the proxy, that is visible and of one of the given content type."}
{"code": "public TaskBuilder single(){\n  this.type=TaskType.SINGLE;\n  return this;\n}\n", "nl": "<b>This is default value/state of builder.</b> <br> Change task type to single, so it will be only executed once."}
{"code": "public static double mean(Iterator tuples,String field){\n  try {\n    int count=0;\n    double sum=0;\n    while (tuples.hasNext()) {\n      sum+=((Tuple)tuples.next()).getDouble(field);\n      ++count;\n    }\n    return sum / count;\n  }\n catch (  Exception e) {\n    return Double.NaN;\n  }\n}\n", "nl": "Get the mean value of a tuple data value. If any tuple does not have the named field or the field is not a numeric data type, NaN will be returned."}
{"code": "@Override public void onPageScrollStateChanged(int page){\n}\n", "nl": "On scroll state of page changed."}
{"code": "public static boolean exitableTerrain(int terrType){\n  boolean exitableTerrainType=false;\n  for (int i=0; i < Terrains.exitableTerrains.length; i++) {\n    exitableTerrainType|=terrType == Terrains.exitableTerrains[i];\n  }\n  return exitableTerrainType;\n}\n", "nl": "Checks to see if the given terrain type can have exits."}
{"code": "private static CTutorial loadTutorial(final File file) throws ParserConfigurationException, SAXException, IOException {\n  String name=\"\";\n  String description=\"\";\n  final List<CTutorialStep> steps=new ArrayList<CTutorialStep>();\n  final DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();\n  final DocumentBuilder builder=factory.newDocumentBuilder();\n  final Document document=builder.parse(file);\n  final NodeList nodes=document.getFirstChild().getChildNodes();\n  for (int i=0; i < nodes.getLength(); ++i) {\n    final Node node=nodes.item(i);\n    final String nodeName=node.getNodeName();\n    if (\"name\".equals(nodeName)) {\n      name=node.getTextContent();\n    }\n else     if (\"description\".equals(nodeName)) {\n      description=node.getTextContent();\n    }\n else     if (\"steps\".equals(nodeName)) {\n      steps.addAll(readSteps(node));\n    }\n  }\n  return new CTutorial(name,description,steps);\n}\n", "nl": "Loads a single tutorial from a file."}
{"code": "public void readFromNBT(NBTTagCompound nbt){\n  this.cheese=EnumCheeseType.loadFromNBT(nbt);\n  this.cheeseStage=EnumCheeseStage.loadFromNBT(nbt);\n  if (nbt.hasKey(\"age\")) {\n    this.age=nbt.getInteger(\"age\");\n  }\n  if (nbt.hasKey(\"slices\")) {\n    this.slices=nbt.getInteger(\"slices\");\n  }\n  if (nbt.hasKey(\"slices_max\")) {\n    this.slicesMax=nbt.getInteger(\"slices_max\");\n  }\n}\n", "nl": "When the tileentity is reloaded from an ItemStack"}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:32:00.390 -0500\",hash_original_method=\"344907C67A02819CC7A230367AD45761\",hash_generated_method=\"4B06F00DE2D9425181B65C93B3228913\") @Override protected int computeHorizontalScrollRange(){\n  final int count=getChildCount();\n  final int contentWidth=getWidth() - mPaddingLeft - mPaddingRight;\n  if (count == 0) {\n    return contentWidth;\n  }\n  int scrollRange=getChildAt(0).getRight();\n  final int scrollX=mScrollX;\n  final int overscrollRight=Math.max(0,scrollRange - contentWidth);\n  if (scrollX < 0) {\n    scrollRange-=scrollX;\n  }\n else   if (scrollX > overscrollRight) {\n    scrollRange+=scrollX - overscrollRight;\n  }\n  return scrollRange;\n}\n", "nl": "<p>The scroll range of a scroll view is the overall width of all of its children.</p>"}
{"code": "public DateBuilder inLocale(Locale locale){\n  this.lc=locale;\n  return this;\n}\n", "nl": "Set the Locale for the Date that will be built by this builder (if \"null\", system default will be used)"}
{"code": "public IgniteThread(GridWorker worker){\n  this(DFLT_GRP,worker.gridName(),worker.name(),worker,GRP_IDX_UNASSIGNED);\n}\n", "nl": "Creates thread with given worker."}
{"code": "void convertRequireToImportStatements(Node n,String fullLocalName,String requiredNamespace){\n  if (!namespaceToModule.containsKey(requiredNamespace)) {\n    compiler.report(JSError.make(n,GentsErrorManager.GENTS_MODULE_PASS_ERROR,String.format(\"Module %s does not exist.\",requiredNamespace)));\n    return;\n  }\n  String localName=nameUtil.lastStepOfName(fullLocalName);\n  FileModule module=namespaceToModule.get(requiredNamespace);\n  String moduleSuffix=nameUtil.lastStepOfName(requiredNamespace);\n  String backupName=moduleSuffix.equals(localName) ? moduleSuffix + \"Exports\" : moduleSuffix;\n  if (module.shouldUseOldSyntax()) {\n    Node importNode=new Node(Token.IMPORT,IR.empty(),Node.newString(Token.NAME,localName),Node.newString(\"goog:\" + requiredNamespace));\n    nodeComments.replaceWithComment(n,importNode);\n    compiler.reportCodeChange();\n    registerLocalSymbol(n.getSourceFileName(),fullLocalName,requiredNamespace,localName);\n    return;\n  }\n  String referencedFile=pathUtil.getImportPath(n.getSourceFileName(),module.file);\n  boolean imported=false;\n  if (module.importedNamespacesToSymbols.containsKey(requiredNamespace)) {\n    Node importSpec=new Node(Token.IMPORT_SPEC,IR.name(moduleSuffix));\n    if (!moduleSuffix.equals(localName)) {\n      importSpec.addChildToBack(IR.name(localName));\n    }\n    Node importNode=new Node(Token.IMPORT,IR.empty(),new Node(Token.IMPORT_SPECS,importSpec),Node.newString(referencedFile));\n    n.getParent().addChildBefore(importNode,n);\n    nodeComments.moveComment(n,importNode);\n    imported=true;\n    registerLocalSymbol(n.getSourceFileName(),fullLocalName,requiredNamespace,localName);\n    localName=backupName;\n  }\n  if (module.providesObjectChildren.get(requiredNamespace).size() > 0) {\n    Node importNode=new Node(Token.IMPORT,IR.empty(),Node.newString(Token.IMPORT_STAR,localName),Node.newString(referencedFile));\n    n.getParent().addChildBefore(importNode,n);\n    nodeComments.moveComment(n,importNode);\n    imported=true;\n    for (    String child : module.providesObjectChildren.get(requiredNamespace)) {\n      if (!valueRewrite.contains(n.getSourceFileName(),child)) {\n        String fileName=n.getSourceFileName();\n        registerLocalSymbol(fileName,fullLocalName + '.' + child,requiredNamespace + '.' + child,localName + '.' + child);\n      }\n    }\n  }\n  if (!imported) {\n    Node importNode=new Node(Token.IMPORT,IR.empty(),IR.empty(),Node.newString(referencedFile));\n    n.getParent().addChildBefore(importNode,n);\n    nodeComments.moveComment(n,importNode);\n  }\n  n.getParent().removeChild(n);\n  compiler.reportCodeChange();\n}\n", "nl": "Converts a Closure goog.require call into a TypeScript import statement. The resulting node is dependent on the exports by the module being imported: import localName from \"goog:old.namespace.syntax\"; import {A as localName} from \"./valueExports\"; import * as localName from \"./objectExports\"; import \"./sideEffectsOnly\""}
{"code": "@VisibleForTesting public void clearPendingInvalidations(Context context){\n  SharedPreferences.Editor editor=PreferenceManager.getDefaultSharedPreferences(context).edit();\n  editor.putString(DELAYED_ACCOUNT_NAME,null);\n  editor.putStringSet(DELAYED_INVALIDATIONS,null);\n  editor.apply();\n}\n", "nl": "If there are any pending invalidations, they will be cleared."}
{"code": "public static int parseCodePoint(String s) throws NumberFormatException {\n  return Integer.parseInt(s,16);\n}\n", "nl": "Parse the codePoint attribute for a Unicode character.  If the parse succeeds, the codePoint field of this UnicodeSpec object is updated and false is returned. The codePoint attribute should be a four to six digit hexadecimal integer."}
{"code": "public final boolean hasIndex(){\n  return (index >= 0);\n}\n", "nl": "Gets whether or not this instance has been assigned an index."}
{"code": "public static String encodeLines(byte[] in,int iOff,int iLen,int lineLen,String lineSeparator){\n  final int blockLen=lineLen * 3 / 4;\n  if (blockLen <= 0) {\n    throw new IllegalArgumentException();\n  }\n  final int lines=(iLen + blockLen - 1) / blockLen;\n  final int bufLen=(iLen + 2) / 3 * 4 + lines * lineSeparator.length();\n  final StringBuilder buf=new StringBuilder(bufLen);\n  int ip=0;\n  while (ip < iLen) {\n    final int l=Math.min(iLen - ip,blockLen);\n    buf.append(encode(in,iOff + ip,l));\n    buf.append(lineSeparator);\n    ip+=l;\n  }\n  return buf.toString();\n}\n", "nl": "Encodes a byte array into Base 64 format and breaks the output into lines."}
{"code": "@SuppressWarnings(\"unchecked\") @Override public void eSet(int featureID,Object newValue){\nswitch (featureID) {\ncase EipPackage.ROUTE__OWNED_ENDPOINTS:\n    getOwnedEndpoints().clear();\n  getOwnedEndpoints().addAll((Collection<? extends Endpoint>)newValue);\nreturn;\ncase EipPackage.ROUTE__OWNED_CHANNELS:\ngetOwnedChannels().clear();\ngetOwnedChannels().addAll((Collection<? extends Channel>)newValue);\nreturn;\ncase EipPackage.ROUTE__NAME:\nsetName((String)newValue);\nreturn;\ncase EipPackage.ROUTE__EXCHANGE_TYPE:\nsetExchangeType((ExchangeType)newValue);\nreturn;\n}\nsuper.eSet(featureID,newValue);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public void write(int c){\n  buf.append((char)c);\n}\n", "nl": "Write a single character."}
{"code": "public void initialize(EngineStatusCallback engineStatusCallback){\n  this.statusEventHandler.initialize(engineStatusCallback);\n  this.outputEventHandler.initialize(engineStatusCallback);\n}\n", "nl": "Initialize some callbacks"}
{"code": "public String encode(String pString) throws EncoderException {\n  if (pString == null) {\n    return null;\n  }\n  try {\n    return encode(pString,getDefaultCharset());\n  }\n catch (  UnsupportedEncodingException e) {\n    throw new EncoderException(e.getMessage());\n  }\n}\n", "nl": "Encodes a string into its quoted-printable form using the default string charset. Unsafe characters are escaped. <p> This function implements a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in RFC 1521 and is suitable for encoding binary data. </p>"}
{"code": "public DiskBasedCache(File rootDirectory){\n  this(rootDirectory,DEFAULT_DISK_USAGE_BYTES);\n}\n", "nl": "Constructs an instance of the DiskBasedCache at the specified directory using the default maximum cache size of 5MB."}
{"code": "public static OutputLimitClause create(OutputLimitSelector selector,double frequency){\n  return new OutputLimitClause(selector,frequency);\n}\n", "nl": "Creates an output limit clause."}
{"code": "public static boolean isHeadMissing(final VcsException e){\n  @NonNls final String errorText=\"fatal: bad revision 'HEAD'\\n\";\n  return e.getMessage().equals(errorText);\n}\n", "nl": "Check if the exception means that HEAD is missing for the current repository."}
{"code": "private String compute(String left,Boolean right){\n  if (left == null && right == null) {\n    return null;\n  }\n  return (left == null ? \"\" : left) + (right == null ? \"\" : right);\n}\n", "nl": "Adds a String and a Boolean. If both are missing, then the result is missing; if one is missing, it is ignored."}
{"code": "public boolean isNamespaceAware(){\n  return _isNamespaceAware;\n}\n", "nl": "Gets Namespace aware flag."}
{"code": "public void remove(int fieldNumber){\n  int i=binarySearch(fieldNumber);\n  if (i >= 0 && mData[i] != DELETED) {\n    mData[i]=DELETED;\n    mGarbage=true;\n  }\n}\n", "nl": "Removes the data from the specified fieldNumber, if there was any."}
{"code": "protected void sequence_IntersectionTypeExpressionOLD_TypeRef_TypeRefWithModifiers(ISerializationContext context,IntersectionTypeExpression semanticObject){\n  genericSequencer.createSequence(context,semanticObject);\n}\n", "nl": "Contexts: IntersectionTypeExpression.IntersectionTypeExpression_1_0 returns IntersectionTypeExpression PrimaryTypeExpression returns IntersectionTypeExpression Constraint: ( typeRefs+=TypeRefWithoutModifiers  typeRefs+=TypeRefWithoutModifiers*  ((undefModifier=UndefModifierToken? nullModifier=NullModifierToken?) | undefModifier=UndefModifierToken)? )"}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:28:44.149 -0500\",hash_original_method=\"A22563797EE8B98D8D2C96F4FC0F2C77\",hash_generated_method=\"EB9D53584F352AD6AC60DCC4EDA82399\") public Cursor query(SQLiteDatabase db,String[] projectionIn,String selection,String[] selectionArgs,String groupBy,String having,String sortOrder,String limit){\n  Cursor ret=new DSCursor(DSOnlyType.NOT_USED);\n  ret.addTaint(db.getTaint());\n  ret.addTaint(projectionIn.getTaint());\n  ret.addTaint(projectionIn[0].getTaint());\n  ret.addTaint(selection.getTaint());\n  ret.addTaint(selectionArgs.getTaint());\n  ret.addTaint(selectionArgs[0].getTaint());\n  ret.addTaint(groupBy.getTaint());\n  ret.addTaint(having.getTaint());\n  ret.addTaint(sortOrder.getTaint());\n  ret.addTaint(limit.getTaint());\n  return ret;\n}\n", "nl": "Perform a query by combining all current settings and the information passed into this method."}
{"code": "public PayloadItem(E payloadExt){\n  super();\n  if (payloadExt == null)   throw new IllegalArgumentException(\"payload cannot be 'null'\");\n  payload=payloadExt;\n}\n", "nl": "Create an <tt>Item</tt> with no id and a payload  The id will be set by the server. "}
{"code": "public void testNegPos(){\n  String numA=\"-27384627835298756289327365\";\n  String numB=\"0\";\n  String res=\"-27384627835298756289327365\";\n  BigInteger aNumber=new BigInteger(numA);\n  BigInteger bNumber=new BigInteger(numB);\n  BigInteger result=aNumber.xor(bNumber);\n  assertTrue(res.equals(result.toString()));\n}\n", "nl": "Xor for a negative number and zero "}
{"code": "public void initializeTrie(Context context,int fileResource){\n  TrieNode startInsertionNode=mRoot;\n  InputStream stream=context.getResources().openRawResource(fileResource);\n  BufferedReader reader=null;\n  try {\n    reader=new BufferedReader(new InputStreamReader(stream,\"UTF-8\"));\n    String input;\n    while ((input=reader.readLine()) != null) {\n      for (int i=0; i < input.length(); i++) {\n        startInsertionNode=insertSymbol(startInsertionNode,input.charAt(i));\n      }\n    }\n  }\n catch (  IOException e) {\n    LogUtils.log(this,Log.ERROR,\"Unable to read PPMTrie input file: %1 s\",e.toString());\n  }\n finally {\n    try {\n      if (reader != null) {\n        reader.close();\n      }\n    }\n catch (    IOException e) {\n      LogUtils.log(this,Log.ERROR,\"Unable to close input file: %1 s\",e.toString());\n    }\n  }\n}\n", "nl": "Uses the text in a training file to form a ppm model and store it in a trie. The file is a .txt file that contains plain unicode text."}
{"code": "@DSComment(\"Package priviledge\") @DSBan(DSCat.DEFAULT_MODIFIER) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:56:50.891 -0500\",hash_original_method=\"7045B1DBF21073AA43E994CE221E4094\",hash_generated_method=\"7045B1DBF21073AA43E994CE221E4094\") ObjectStreamField(String signature,String name){\n  if (name == null) {\n    throw new NullPointerException();\n  }\n  this.name=name;\n  this.typeString=signature.replace('.','/').intern();\n  defaultResolve();\n  this.isDeserialized=true;\n}\n", "nl": "Constructs an ObjectStreamField with the given name and the given type. The type may be null."}
{"code": "@Override protected final int nextIndex(){\n  if (_expectedSize != _hash.size()) {\n    throw new ConcurrentModificationException();\n  }\n  Object[] set=_map._set;\n  int i=_index;\n  while (i-- > 0 && (set[i] == null || set[i] == TObjectHash.REMOVED))   ;\n  return i;\n}\n", "nl": "Returns the index of the next value in the data structure or a negative value if the iterator is exhausted."}
{"code": "public static ArrayList<BaseQuestion> returnChatList(String jsonFile){\n  ArrayList<BaseQuestion> questions=new ArrayList<BaseQuestion>();\n  RestAPI api=RestAPI.getAPI();\n  questions=api.getChatQuestions(jsonFile);\n  return questions;\n}\n", "nl": "Get list of chat questions"}
{"code": "public int numElements() throws Exception {\n  if (m_Classifier instanceof PartitionGenerator)   return ((PartitionGenerator)m_Classifier).numElements();\n else   throw new Exception(\"Classifier: \" + getClassifierSpec() + \" cannot generate a partition\");\n}\n", "nl": "Returns the number of elements in the partition. (If the base classifier supports this.)"}
{"code": "@Override protected Instance process(Instance instance) throws Exception {\n  m_Remove.input(instance);\n  return m_Remove.output();\n}\n", "nl": "processes the given instance (may change the provided instance) and returns the modified version."}
{"code": "public static void main(String[] args) throws Exception {\n  if (args.length > 1) {\n    BufferedImage firstImage=ImageIO.read(new File(args[0]));\n    ImageOutputStream output=new FileImageOutputStream(new File(args[args.length - 1]));\n    GifSequenceWriter writer=new GifSequenceWriter(output,firstImage.getType(),1,false);\n    writer.writeToSequence(firstImage);\n    for (int i=1; i < args.length - 1; i++) {\n      BufferedImage nextImage=ImageIO.read(new File(args[i]));\n      writer.writeToSequence(nextImage);\n    }\n    writer.close();\n    output.close();\n  }\n else {\n    System.out.println(\"Usage: java GifSequenceWriter [list of gif files] [output file]\");\n  }\n}\n", "nl": "public GifSequenceWriter( BufferedOutputStream outputStream, int imageType, int timeBetweenFramesMS, boolean loopContinuously) {"}
{"code": "private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {\n  s.defaultReadObject();\n  if (index < 0) {\n    throw new IllegalStateException();\n  }\n  if (lag < 0) {\n    throw new IllegalStateException();\n  }\n}\n", "nl": "Adds semantic checks to the default deserialization method. This method must have the standard signature for a readObject method, and the body of the method must begin with \"s.defaultReadObject();\". Other than that, any semantic checks can be specified and do not need to stay the same from version to version. A readObject method of this form may be added to any class, even if Tetrad sessions were previously saved out using a version of the class that didn't include it. (That's what the \"s.defaultReadObject();\" is for. See J. Bloch, Effective Java, for help."}
{"code": "public boolean markAsRead(String smsNumber){\n  try {\n    ContentResolver cr=_context.getContentResolver();\n    ContentValues values=new ContentValues();\n    values.put(\"read\",\"1\");\n    cr.update(SMS_INBOX_CONTENT_URI,values,\" address='\" + smsNumber + \"'\",null);\n    return true;\n  }\n catch (  Exception e) {\n    Log.w(\"markAsRead() exception:\",e);\n    return false;\n  }\n}\n", "nl": "Not supported in Android 5 Marks all SMS from a given phone number as read"}
{"code": "public CategoryAxis3D(String label){\n  super(label);\n}\n", "nl": "Creates a new axis using default attribute values."}
{"code": "@Override public int compare(Triplet<byte[],UserLeafNode,Operation> p1,Triplet<byte[],UserLeafNode,Operation> p2){\n  byte[] buf1=p1.getValue0();\n  byte[] buf2=p2.getValue0();\n  if (buf1.length < 3 || buf2.length < 3) {\n    throw new RuntimeException(\"bad byte array length\");\n  }\n  for (int i=0; i < 3; i++) {\n    if (buf1[i] > buf2[i]) {\n      return 1;\n    }\n else     if (buf1[i] < buf2[i]) {\n      return -1;\n    }\n  }\n  Operation op1=p1.getValue2();\n  Operation op2=p2.getValue2();\n  if (op1 instanceof Register) {\n    return 1;\n  }\n  if (op2 instanceof Register) {\n    return -1;\n  }\n  if (op1 instanceof KeyChange && op2 instanceof KeyChange) {\n    return (((KeyChange)op1).getCounter() > ((KeyChange)op2).getCounter()) ? 1 : -1;\n  }\n  return 0;\n}\n", "nl": "Compares the first 24 bits of two data binding lookup indeces."}
{"code": "private void parsePublicUserIdentity(Node node){\n  String publicUserIdentity=null;\n  if (node == null) {\n    return;\n  }\n  Node childnode=node.getFirstChild();\n  if (childnode != null) {\n    do {\n      if (publicUserIdentity == null) {\n        if ((publicUserIdentity=getValueByParamName(\"Public_User_Identity\",childnode,TYPE_TXT)) != null) {\n          String username=extractUserNamePart(publicUserIdentity.trim());\n          PhoneNumber number=ContactUtil.getValidPhoneNumberFromUri(username);\n          if (number == null) {\n            if (sLogger.isActivated()) {\n              sLogger.error(\"Invalid public user identity '\" + username + \"'\");\n            }\n            mRcsSettings.setUserProfileImsUserName(null);\n          }\n else {\n            ContactId contact=ContactUtil.createContactIdFromValidatedData(number);\n            mRcsSettings.setUserProfileImsUserName(contact);\n          }\n        }\n      }\n    }\n while ((childnode=childnode.getNextSibling()) != null);\n  }\n}\n", "nl": "Parse public user identity"}
{"code": "@Override public void clearUndo(){\n  ((DataSortedTableModel)m_TableData.getModel()).clearUndo();\n}\n", "nl": "removes the undo history"}
{"code": "public static List<org.oscm.internal.vo.VOParameterOption> convertToUpVOParameterOption(List<org.oscm.vo.VOParameterOption> oldVO){\n  if (oldVO == null) {\n    return null;\n  }\n  List<org.oscm.internal.vo.VOParameterOption> newVO=new ArrayList<org.oscm.internal.vo.VOParameterOption>();\n  for (  org.oscm.vo.VOParameterOption tmp : oldVO) {\n    newVO.add(convertToUp(tmp));\n  }\n  return newVO;\n}\n", "nl": "Convert list of VOParameterOption."}
{"code": "public void traceFieldNotStaticInHostJdk(){\n  traceNulledWord(\": field not static in host jdk\");\n}\n", "nl": "Report a field that is an instance field in the host JDK but a static field in ours. "}
{"code": "public SwitchPreference(Context context){\n  super(context,null);\n}\n", "nl": "Construct a new SwitchPreference with default style options."}
{"code": "private void publishTextRecord(final LogRecord record){\n  try {\n    logpane.publish(record);\n  }\n catch (  Exception e) {\n    throw new RuntimeException(\"Error writing a log-like message.\",e);\n  }\n}\n", "nl": "Publish a text record to the pane"}
{"code": "public static final List<String> combine(Collection<String> list,String... args){\n  List<String> ret=new ArrayList<String>(list);\n  for (  String s : args) {\n    ret.add(s);\n  }\n  return ret;\n}\n", "nl": "Combine a string collection (list) with additional strings."}
{"code": "public void clear(){\n  try {\n    skip(size);\n  }\n catch (  EOFException e) {\n    throw new AssertionError(e);\n  }\n}\n", "nl": "Discards all bytes in this buffer. Calling this method when you're done with a buffer will return its segments to the pool."}
{"code": "public static String fromUTF8(byte[] bytes){\n  try {\n    return new String(bytes,ENCODING_UTF8);\n  }\n catch (  UnsupportedEncodingException e) {\n    throw new AssertionError(e);\n  }\n}\n", "nl": "Decodes the given binary data with UTF-8."}
{"code": "private void analyzeFiles(Set<String> fileNames) throws CLIArgumentParserException, IOException {\n  ColorSettings colorSettings=new ColorSettings(configuration.shouldColorOutput(),configuration.shouldInvertColorOutput());\n  Formatter formatter=configuration.getFormatter(colorSettings);\n  Severity maxSeverity=configuration.getMaxSeverity();\n  ConstructLengths constructLengths=configuration.parseConstructLengths();\n  Set<Rules> enabledRules=configuration.getEnabledRules();\n  numberOfFilesBeforePurge=configuration.numberOfFilesBeforePurge();\n  List<File> files=fileNames.parallelStream().map(null).collect(Collectors.toList());\n  formatter.printProgressInfo(String.format(\"Analyzing %s:%n\",Formatter.pluralize(fileNames.size(),\"file\",\"files\")));\n  files.parallelStream().forEach(null);\n  formatter.printProgressInfo(String.format(\"%n\"));\n  printersForAllFiles.forEach(null);\n  formatter.displaySummary(fileNames.size(),numSkippedFiles.get(),numErrors.get(),numWarnings.get());\n  handleErrorViolations(formatter,numErrors.get());\n}\n", "nl": "Analyze files with SwiftLexer, SwiftParser and Listeners."}
{"code": "@Override public void eUnset(int featureID){\nswitch (featureID) {\ncase UmplePackage.ENUM___NAME_1:\n    setName_1(NAME_1_EDEFAULT);\n  return;\ncase UmplePackage.ENUM___STATE_NAME_1:\nsetStateName_1(STATE_NAME_1_EDEFAULT);\nreturn;\ncase UmplePackage.ENUM___ANONYMOUS_ENUM_11:\ngetAnonymous_enum_1_1().clear();\nreturn;\n}\nsuper.eUnset(featureID);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "private synchronized boolean isSelectedTrackRecording(){\n  return trackDataHub != null && trackDataHub.isSelectedTrackRecording();\n}\n", "nl": "Returns true if the selected track is recording. Needs to be synchronized because the trackDataHub can be accessed by multiple threads."}
{"code": "public byte[] filter(byte[] buffer,int offset,int len){\n  byte[] slices=getSlices(buffer,offset,len);\n  if (null == slices) {\n    return null;\n  }\n  int insertionPoint=findInsertionPoint(slices);\n  if (insertionPoint >= 0) {\n    return buffer;\n  }\n  if (-1 == insertionPoint) {\n    if (hasHinting) {\n      return Arrays.copyOf(this.rangekeys,this.bounds[1]);\n    }\n else {\n      return null;\n    }\n  }\n  if (-nranges - 1 == insertionPoint) {\n    if (hasHinting) {\n      return EMPTY_BYTE_ARRAY;\n    }\n else {\n      return null;\n    }\n  }\n  if (-(insertionPoint + 1) % 2 == 0) {\n    if (hasHinting) {\n      int hintOffset=this.slicesLength * (-(insertionPoint + 1));\n      return Arrays.copyOfRange(this.rangekeys,hintOffset,this.bounds[1]);\n    }\n else {\n      return null;\n    }\n  }\n  return buffer;\n}\n", "nl": "Determine if a key should be filtered or not. This method returns a byte array which indicates how the key should be dealt with. If the return value is 'buffer', the key should be include. If the return value is null, the key should be skipped and no next key hint is available If the return value is a non empty byte array (different from 'buffer'), the key should be skipped and the return value used as the next key hint. If the return value is an empty byte array, the key is passed the last range and scanning should end"}
{"code": "private JPanel createPhotoframe(){\n  JPanel pf=NPComponentUtils.createPanel_root(NPIconFactory.getInstance().getPhotoframeBg(),new Insets(13,15,15,15));\n  pf.setLayout(new BorderLayout());\n  pf.setOpaque(false);\n  return pf;\n}\n", "nl": "Create and return a new photo frame pane object. Its background is NinePatch pictrue."}
{"code": "@SuppressWarnings(\"deprecation\") void insertIntoHoveringConnection(final Operator operator){\n  OutputPort hoveringConnectionSource=model.getHoveringConnectionSource();\n  if (hoveringConnectionSource == null) {\n    return;\n  }\n  InputPort oldDest=hoveringConnectionSource.getDestination();\n  oldDest.lock();\n  hoveringConnectionSource.lock();\n  try {\n    InputPort bestInputPort=null;\n    MetaData md=hoveringConnectionSource.getMetaData();\n    if (md != null) {\n      for (      InputPort inCandidate : operator.getInputPorts().getAllPorts()) {\n        if (!inCandidate.isConnected() && inCandidate.isInputCompatible(md,CompatibilityLevel.PRE_VERSION_5)) {\n          bestInputPort=inCandidate;\n          break;\n        }\n      }\n    }\n else {\n      for (      InputPort inCandidate : operator.getInputPorts().getAllPorts()) {\n        if (!inCandidate.isConnected()) {\n          bestInputPort=inCandidate;\n          break;\n        }\n      }\n    }\n    if (bestInputPort != null) {\n      hoveringConnectionSource.disconnect();\n      connect(hoveringConnectionSource,bestInputPort);\n      if (RapidMinerGUI.getMainFrame().VALIDATE_AUTOMATICALLY_ACTION.isSelected()) {\n        hoveringConnectionSource.getPorts().getOwner().getOperator().transformMetaData();\n        operator.transformMetaData();\n      }\n      OutputPort bestOutput=null;\n      for (      OutputPort outCandidate : operator.getOutputPorts().getAllPorts()) {\n        if (!outCandidate.isConnected()) {\n          md=outCandidate.getMetaData();\n          if (md != null && oldDest.isInputCompatible(md,CompatibilityLevel.PRE_VERSION_5)) {\n            bestOutput=outCandidate;\n            break;\n          }\n        }\n      }\n      if (bestOutput == null) {\n        for (        OutputPort outCandidate : operator.getOutputPorts().getAllPorts()) {\n          if (!outCandidate.isConnected()) {\n            bestOutput=outCandidate;\n            break;\n          }\n        }\n      }\n      if (bestOutput != null) {\n        connect(bestOutput,oldDest);\n      }\n    }\n  }\n  finally {\n    oldDest.unlock();\n    hoveringConnectionSource.unlock();\n    model.setHoveringConnectionSource(null);\n  }\n}\n", "nl": "Insert the specified operator into the currently hovered connection."}
{"code": "protected void unhandledMessageReceived(OFMessage m){\n  switchManagerCounters.unhandledMessage.increment();\n  if (log.isDebugEnabled()) {\n    String msg=getSwitchStateMessage(m,\"Ignoring unexpected message\");\n    log.debug(msg);\n  }\n}\n", "nl": "We have an OFMessage we didn't expect given the current state and we want to ignore the message"}
{"code": "public static int sanitizeInt(int flags){\n  if (((flags & OFMatch.OFPFW_NW_SRC_MASK) >> OFMatch.OFPFW_NW_SRC_SHIFT) > 32) {\n    flags=(flags & ~OFMatch.OFPFW_NW_SRC_MASK) | OFMatch.OFPFW_NW_SRC_ALL;\n  }\n  if (((flags & OFMatch.OFPFW_NW_DST_MASK) >> OFMatch.OFPFW_NW_DST_SHIFT) > 32) {\n    flags=(flags & ~OFMatch.OFPFW_NW_DST_MASK) | OFMatch.OFPFW_NW_DST_ALL;\n  }\n  return flags;\n}\n", "nl": "return the OpenFlow 'wire' integer representation of these wildcards. Sanitize nw_src and nw_dst to be max. 32 (values > 32 are technically possible, but don't make semantic sense)"}
{"code": "public ToHitData(TargetRollModifier targetRollModifier){\n  this(targetRollModifier.getValue(),targetRollModifier.getDesc());\n}\n", "nl": "Construct with a target roll modifier right off the bat."}
{"code": "@Override public void testSendReceive() throws Exception {\n  super.testSendReceive();\n  messages.clear();\n  consumer2.setMessageListener(this);\n  assertMessagesAreReceived();\n  LOG.info(\"\" + data.length + \" messages(s) received, closing down connections\");\n}\n", "nl": "Test if all the messages sent are being received."}
{"code": "public void changeState(boolean newState){\n  if (log.isDebugEnabled()) {\n    log.debug(\"Change state to \" + newState);\n  }\n  isOn=newState;\n  this.setSelected(isOn);\n  for (int i=0; i < listeners.size(); i++) {\n    listeners.get(i).notifyFunctionStateChanged(identity,isOn);\n  }\n}\n", "nl": "Change the state of the function."}
{"code": "@Override public Object eGet(int featureID,boolean resolve,boolean coreType){\nswitch (featureID) {\ncase ExpressionsPackage.SHIFT_EXPRESSION__LEFT_OPERAND:\n    return getLeftOperand();\ncase ExpressionsPackage.SHIFT_EXPRESSION__OPERATOR:\n  return getOperator();\ncase ExpressionsPackage.SHIFT_EXPRESSION__RIGHT_OPERAND:\nreturn getRightOperand();\n}\nreturn super.eGet(featureID,resolve,coreType);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "@Override public String toString(){\n  String result=toString;\n  if (result == null) {\n    result=computeToString();\n    toString=result;\n  }\n  return result;\n}\n", "nl": "Returns the string representation of this media type in the format described in <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>."}
{"code": "public static Border createBevelBorder(int type,Color highlightOuter,Color highlightInner,Color shadowOuter,Color shadowInner){\n  return new BevelBorder(type,highlightOuter,highlightInner,shadowOuter,shadowInner);\n}\n", "nl": "Creates a beveled border of the specified type, using the specified colors for the inner and outer highlight and shadow areas."}
{"code": "public boolean canUserModifyEntry(User user,Entry entry,boolean isAdmin){\n  return canUserSeeEntry(user,entry,isAdmin);\n}\n", "nl": "API method. Checks if the user is entitled to modify the entry."}
{"code": "public Shape3DPortrayal3D(Geometry geometry,Appearance appearance){\n  this(new Shape3D(geometry),appearance);\n}\n", "nl": "Constructs a Shape3DPortrayal3D with the given geometry and appearance."}
{"code": "public MessageProducer createProducer(Session session,Destination destination) throws JMSException {\n  MessageProducer producer=session.createProducer(destination);\n  producer.setDeliveryMode(deliveryMode);\n  return producer;\n}\n", "nl": "Creates a producer."}
{"code": "public static AppEventsLogger newLogger(Context context){\n  return new AppEventsLogger(context,null,null);\n}\n", "nl": "Build an AppEventsLogger instance to log events through.  The Facebook app that these events are targeted at comes from this application's metadata. The application ID used to log events will be determined from the app ID specified in the package metadata."}
{"code": "private boolean haveShownMessageBefore(UpdateMessage msg){\n  if (!msg.isShownOnce())   return false;\n  loadSeenMessages();\n  if (_seenMessages == null || _seenMessages.size() == 0 || !_seenMessages.contains(msg)) {\n    if (_seenMessages == null)     _seenMessages=new HashSet<>();\n    _seenMessages.add(msg);\n    saveSeenMessages();\n    return false;\n  }\n  return true;\n}\n", "nl": "Checks on a Message map, if we've seen this message before. The message map is serialized on disk every time we write to it. Its initialized from disk when we start the Update Manager."}
{"code": "public <T>JsonArray<T> createListDtoFromJson(String json,Class<T> dtoInterface){\n  final DtoProvider<T> dtoProvider=getDtoProvider(dtoInterface);\n  final List<JsonElement> list=gson.fromJson(json,listTypeCache.getUnchecked(JsonElement.class));\n  final List<T> result=new ArrayList<>(list.size());\n  for (  JsonElement e : list) {\n    result.add(dtoProvider.fromJson(e));\n  }\n  return new JsonArrayImpl<>(result);\n}\n", "nl": "Parses the JSON data from the specified sting into list of objects of the specified type."}
{"code": "public boolean isSetHeader(){\n  return this.header != null;\n}\n", "nl": "Returns true if field header is set (has been assigned a value) and false otherwise"}
{"code": "private void updateProgress(String progressLabel,int progress){\n  if (myHost != null && ((progress != previousProgress) || (!progressLabel.equals(previousProgressLabel)))) {\n    myHost.updateProgress(progressLabel,progress);\n  }\n  previousProgress=progress;\n  previousProgressLabel=progressLabel;\n}\n", "nl": "Used to communicate a progress update between a plugin tool and the main Whitebox user interface."}
{"code": "public SimpleProtein(String ac,String id,String name,int length,String md5,String crc64,boolean isProteinFragment){\n  this.ac=ac;\n  this.id=id;\n  this.name=name;\n  this.length=length;\n  this.md5=md5;\n  this.crc64=crc64;\n  this.taxId=null;\n  this.taxScienceName=null;\n  this.taxFullName=null;\n  this.isProteinFragment=isProteinFragment;\n}\n", "nl": "Construct a SimpleProtein without the taxonomy information."}
{"code": "public VfsStream(){\n}\n", "nl": "Create an empty VfsStream."}
{"code": "public synchronized Map<String,Class<T>> compile(final Map<String,CharSequence> classes,final DiagnosticCollector<JavaFileObject> diagnosticsList) throws CharSequenceCompilerException {\n  List<JavaFileObject> sources=new ArrayList<>();\n  for (  Map.Entry<String,CharSequence> entry : classes.entrySet()) {\n    String qualifiedClassName=entry.getKey();\n    CharSequence javaSource=entry.getValue();\n    if (javaSource != null) {\n      final int dotPos=qualifiedClassName.lastIndexOf('.');\n      final String className=dotPos == -1 ? qualifiedClassName : qualifiedClassName.substring(dotPos + 1);\n      final String packageName=dotPos == -1 ? \"\" : qualifiedClassName.substring(0,dotPos);\n      final JavaFileObjectImpl source=new JavaFileObjectImpl(className,javaSource);\n      sources.add(source);\n      javaFileManager.putFileForInput(StandardLocation.SOURCE_PATH,packageName,className + JAVA_EXTENSION,source);\n    }\n  }\n  final JavaCompiler.CompilationTask task=compiler.getTask(null,javaFileManager,diagnostics,options,null,sources);\n  final Boolean result=task.call();\n  if (result == null || !result) {\n    StringBuilder cause=new StringBuilder(\"\\n\");\n    for (    Diagnostic d : diagnostics.getDiagnostics()) {\n      cause.append(d).append(\" \");\n    }\n    throw new CharSequenceCompilerException(\"Compilation failed. Causes: \" + cause,classes.keySet(),diagnostics);\n  }\n  try {\n    Map<String,Class<T>> compiled=new HashMap<>();\n    for (    String qualifiedClassName : classLoader.classNames()) {\n      final Class<T> newClass=loadClass(qualifiedClassName);\n      compiled.put(qualifiedClassName,newClass);\n    }\n    return compiled;\n  }\n catch (  ClassNotFoundException|SecurityException|IllegalArgumentException e) {\n    throw new CharSequenceCompilerException(classes.keySet(),e,diagnostics);\n  }\n}\n", "nl": "Compile multiple Java source strings and return a Map containing the resulting classes. <p/> Thread safety: this method is thread safe if the <var>classes</var> and <var>diagnosticsList</var> are isolated to this thread."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2014-02-25 10:38:00.428 -0500\",hash_original_method=\"C7335716F5A5FE392DFA727356C682DF\",hash_generated_method=\"A329A8E4FAEC9FF6A4525B62EAF0DCD3\") public void addOptionHandler(TelnetOptionHandler opthand) throws InvalidTelnetOptionException {\n  super.addOptionHandler(opthand);\n}\n", "nl": "Registers a new TelnetOptionHandler for this telnet client to use. <p>"}
{"code": "public StateMachineConfigurationBuilder(){\n  super();\n}\n", "nl": "Instantiates a new state machine configuration builder."}
{"code": "public RowSetEvent(RowSet source){\n  super(source);\n}\n", "nl": "Constructs a <code>RowSetEvent</code> object initialized with the given <code>RowSet</code> object."}
{"code": "private void returnData(Object ret){\n  if (myHost != null) {\n    myHost.returnData(ret);\n  }\n}\n", "nl": "Used to communicate a return object from a plugin tool to the main Whitebox user-interface."}
{"code": "public MoveStaticMembersDescriptor(){\n  super(IJavaRefactorings.MOVE_STATIC_MEMBERS);\n}\n", "nl": "Creates a new refactoring descriptor."}
{"code": "public boolean isActivated() throws RcsGenericException {\n  if (sAccurateLog) {\n    Log.d(LOG_TAG,\"isActivated: Request()\");\n  }\n  Bundle result=queryRcsStackByIntent(new Intent(Intents.Service.ACTION_GET_ACTIVATION_MODE));\n  boolean activated=result.getBoolean(Intents.Service.EXTRA_GET_ACTIVATION_MODE,false);\n  if (sAccurateLog) {\n    Log.d(LOG_TAG,\"isActivated: Response() -> \" + activated + \" (in \"+ result.getLong(TIME_SPENT,-1)+ \"ms)\");\n  }\n  return activated;\n}\n", "nl": "Returns true if the RCS stack is marked as active on the device."}
{"code": "public void init(boolean encrypting,byte[] key){\n  this.doEncrypt=encrypting;\n  this.workingKey=key;\n  setKey(this.workingKey);\n}\n", "nl": "initialise a Blowfish cipher."}
{"code": "public static CTutorialDialog instance(){\n  return m_instance;\n}\n", "nl": "Returns the globally valid instance of the tutorial dialog."}
{"code": "public void play(URL url,String name){\n  AudioClip clip=getAudioClip(url,name);\n  if (clip != null) {\n    clip.play();\n  }\n}\n", "nl": "Plays the audio clip given the URL and a specifier that is relative to it. Nothing happens if the audio clip cannot be found."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:32:18.211 -0500\",hash_original_method=\"D2E29F254410117CE819574854BB79EC\",hash_generated_method=\"9E7D819F4E7FE83734719AA0B6321B58\") public boolean removeFooterView(View v){\n  if (mFooterViewInfos.size() > 0) {\n    boolean result=false;\n    if (mAdapter != null && ((HeaderViewListAdapter)mAdapter).removeFooter(v)) {\n      if (mDataSetObserver != null) {\n        mDataSetObserver.onChanged();\n      }\n      result=true;\n    }\n    removeFixedViewInfo(v,mFooterViewInfos);\n    return result;\n  }\n  return false;\n}\n", "nl": "Removes a previously-added footer view."}
{"code": "@AfterClass public static void closeTemporaryStore() throws InterruptedException {\n  if (temporaryStore == null) {\n    return;\n  }\n  ExecutorService executorService=temporaryStore.getExecutorService();\n  temporaryStore.close();\n  QueryEngine queryEngine=QueryEngineFactory.getInstance().getExistingQueryController(temporaryStore);\n  if (queryEngine != null) {\n    queryEngine.shutdownNow();\n  }\n  SynchronizedHardReferenceQueueWithTimeout.stopStaleReferenceCleaner();\n  executorService.awaitTermination(20,TimeUnit.SECONDS);\n  temporaryStore=null;\n}\n", "nl": "Close the temporary store used by this test."}
{"code": "public static boolean isSvnBuild(){\n  return getBuild().equalsIgnoreCase(\"svn\") ? true : false;\n}\n", "nl": "are we a SVN version?"}
{"code": "public void characters(char ch[],int start,int length) throws org.xml.sax.SAXException {\n  if (!m_shouldProcess)   return;\n  XSLTElementProcessor elemProcessor=getCurrentProcessor();\n  XSLTElementDef def=elemProcessor.getElemDef();\n  if (def.getType() != XSLTElementDef.T_PCDATA)   elemProcessor=def.getProcessorFor(null,\"text()\");\n  if (null == elemProcessor) {\n    if (!XMLCharacterRecognizer.isWhiteSpace(ch,start,length))     error(XSLMessages.createMessage(XSLTErrorResources.ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION,null),null);\n  }\n else   elemProcessor.characters(this,ch,start,length);\n}\n", "nl": "Receive notification of character data inside an element."}
{"code": "protected void sendProgrammingReply(ProgListener p,int value,int status){\n  int delay=20;\n  if (!mServiceMode) {\n    delay=100;\n  }\n  NotifyDelay r=new NotifyDelay(delay,p,value,status);\n  r.start();\n}\n", "nl": "Internal routine to forward a programing reply. This is delayed to prevent overruns of the command station."}
{"code": "public Bag(){\n  first=null;\n  n=0;\n}\n", "nl": "Initializes an empty bag."}
{"code": "public boolean isSuperclassOf(ReferenceBinding otherType){\n  while ((otherType=otherType.superclass()) != null) {\n    if (otherType.isEquivalentTo(this))     return true;\n  }\n  return false;\n}\n", "nl": "Answer true if the receiver is in the superclass hierarchy of aType NOTE: Object.isSuperclassOf(Object) -> false"}
{"code": "public void addPinger(Pinger pinger){\n  if (!mPingers.contains(pinger)) {\n    mPingers.add(pinger);\n    notifyDataSetChanged();\n  }\n}\n", "nl": "Add a pinger to the list."}
{"code": "void selectType(Environment env,Context ctx,int tm){\n  if ((left.type == Type.tString) && !right.type.isType(TC_VOID)) {\n    type=Type.tString;\n    return;\n  }\n else   if ((right.type == Type.tString) && !left.type.isType(TC_VOID)) {\n    type=Type.tString;\n    return;\n  }\n  super.selectType(env,ctx,tm);\n}\n", "nl": "Select the type"}
{"code": "public BatchUpdateException(Throwable cause){\n  this((cause == null ? null : cause.toString()),null,0,(int[])null,cause);\n}\n", "nl": "Constructs a <code>BatchUpdateException</code> object initialized with a given <code>cause</code>. The <code>SQLState</code> and <code>updateCounts</code> are initialized to <code>null</code> and the vendor code is initialized to 0. The <code>reason</code>  is initialized to <code>null</code> if <code>cause==null</code> or to <code>cause.toString()</code> if <code>cause!=null</code>."}
{"code": "public static DistinguishedNameException convertToApi(org.oscm.internal.types.exception.DistinguishedNameException oldEx){\n  return convertExceptionToApi(oldEx,DistinguishedNameException.class);\n}\n", "nl": "Convert source version Exception to target version Exception"}
{"code": "@SuppressWarnings(\"unchecked\") public static <K extends Comparable<? super K>,V>ImmutableSortedMap<K,V> of(K k1,V v1,K k2,V v2){\n  return ofEntries(entryOf(k1,v1),entryOf(k2,v2));\n}\n", "nl": "Returns an immutable sorted map containing the given entries, sorted by the natural ordering of their keys."}
{"code": "public boolean saveParameters(){\n  log.config(\"\");\n  if (!validateParameters())   return false;\n  for (int i=0; i < m_mFields.size(); i++) {\n    WEditor editor=(WEditor)m_wEditors.get(i);\n    WEditor editor2=(WEditor)m_wEditors2.get(i);\n    Object result=editor.getValue();\n    Object result2=null;\n    if (editor2 != null)     result2=editor2.getValue();\n    MPInstancePara para=new MPInstancePara(Env.getCtx(),m_processInfo.getAD_PInstance_ID(),i);\n    GridField mField=(GridField)m_mFields.get(i);\n    para.setParameterName(mField.getColumnName());\n    if (result instanceof Timestamp || result2 instanceof Timestamp) {\n      para.setP_Date((Timestamp)result);\n      if (editor2 != null && result2 != null)       para.setP_Date_To((Timestamp)result2);\n    }\n else     if (result instanceof Integer || result2 instanceof Integer) {\n      if (result != null) {\n        Integer ii=(Integer)result;\n        para.setP_Number(ii.intValue());\n      }\n      if (editor2 != null && result2 != null) {\n        Integer ii=(Integer)result2;\n        para.setP_Number_To(ii.intValue());\n      }\n    }\n else     if (result instanceof BigDecimal || result2 instanceof BigDecimal) {\n      para.setP_Number((BigDecimal)result);\n      if (editor2 != null && result2 != null)       para.setP_Number_To((BigDecimal)result2);\n    }\n else     if (result instanceof Boolean) {\n      Boolean bb=(Boolean)result;\n      String value=bb.booleanValue() ? \"Y\" : \"N\";\n      para.setP_String(value);\n    }\n else {\n      if (result != null)       para.setP_String(result.toString());\n      if (editor2 != null && result2 != null)       para.setP_String_To(result2.toString());\n    }\n    para.setInfo(editor.getDisplay());\n    if (editor2 != null)     para.setInfo_To(editor2.getDisplay());\n    para.saveEx();\n    log.fine(para.toString());\n  }\n  return true;\n}\n", "nl": "Save Parameter values"}
{"code": "public TrieNode find(String suffix){\n  TrieNode result;\n  Character c;\n  String newSuffix;\n  TrieNode child;\n  c=suffix.charAt(0);\n  newSuffix=suffix.substring(1);\n  child=m_Children.get(c);\n  if (child == null) {\n    result=null;\n  }\n else   if (newSuffix.length() == 0) {\n    result=child;\n  }\n else {\n    result=child.find(newSuffix);\n  }\n  return result;\n}\n", "nl": "returns the node with the given suffix"}
{"code": "private void processTokenResponse(String responseCode,String result){\n  String refreshToken;\n  String accessToken;\n  int timeToExpireSecond;\n  try {\n    IdentityProxy identityProxy=IdentityProxy.getInstance();\n    if (Constants.REQUEST_SUCCESSFUL.equals(responseCode)) {\n      JSONObject response=new JSONObject(result);\n      try {\n        accessToken=response.getString(Constants.ACCESS_TOKEN);\n        refreshToken=response.getString(Constants.REFRESH_TOKEN);\n        timeToExpireSecond=Integer.parseInt(response.getString(Constants.EXPIRE_LABEL));\n        Token token=new Token();\n        Date date=new Date();\n        String currentDate=dateFormat.format(date);\n        token.setDate(currentDate);\n        token.setRefreshToken(refreshToken);\n        token.setAccessToken(accessToken);\n        token.setExpired(false);\n        SharedPreferences mainPref=IdentityProxy.getInstance().getContext().getSharedPreferences(Constants.APPLICATION_PACKAGE,Context.MODE_PRIVATE);\n        Editor editor=mainPref.edit();\n        editor.putString(Constants.ACCESS_TOKEN,accessToken);\n        editor.putString(Constants.REFRESH_TOKEN,refreshToken);\n        editor.putString(USERNAME_LABEL,info.getUsername());\n        long expiresIn=date.getTime() + (timeToExpireSecond * 1000);\n        Date expireDate=new Date(expiresIn);\n        String strDate=dateFormat.format(expireDate);\n        token.setDate(strDate);\n        editor.putString(Constants.DATE_LABEL,strDate);\n        editor.commit();\n        identityProxy.receiveAccessToken(responseCode,Constants.SUCCESS_RESPONSE,token);\n      }\n catch (      JSONException e) {\n        Log.e(TAG,\"Invalid JSON format\",e);\n      }\n    }\n else     if (responseCode != null) {\n      if (Constants.INTERNAL_SERVER_ERROR.equals(responseCode)) {\n        identityProxy.receiveAccessToken(responseCode,result,null);\n      }\n else {\n        JSONObject mainObject=new JSONObject(result);\n        String errorDescription=mainObject.getString(Constants.ERROR_DESCRIPTION_LABEL);\n        identityProxy.receiveAccessToken(responseCode,errorDescription,null);\n      }\n    }\n  }\n catch (  JSONException e) {\n    Log.e(TAG,\"Invalid JSON\",e);\n  }\n}\n", "nl": "Processing token response from the server."}
{"code": "@Deprecated public static long checksum(final byte[] data){\n  return FitsCheckSum.checksum(data);\n}\n", "nl": "calculate the checksum for the block of data"}
{"code": "private void grow(){\n  if (keys == null || nkeys >= keys.length) {\n    String[] nk=new String[nkeys + 4];\n    String[] nv=new String[nkeys + 4];\n    if (keys != null)     System.arraycopy(keys,0,nk,0,nkeys);\n    if (values != null)     System.arraycopy(values,0,nv,0,nkeys);\n    keys=nk;\n    values=nv;\n  }\n}\n", "nl": "Grow the key/value arrays as needed"}
{"code": "public Analyzer showAggregate(){\n  showAggregate=true;\n  return this;\n}\n", "nl": "Enables the output of the metric value of the aggregate approximation set, produced by merging all individual seeds."}
{"code": "public static int ECHRNG(){\n  return 44;\n}\n", "nl": "Channel number out of range"}
{"code": "public void createDecSpecificInfoDescriptor(MP4DataStream bitstream) throws IOException {\n  decSpecificDataOffset=bitstream.getOffset();\n  dsid=new byte[size];\n  for (int b=0; b < size; b++) {\n    dsid[b]=(byte)bitstream.readBytes(1);\n    readed++;\n  }\n  decSpecificDataSize=size - readed;\n}\n", "nl": "Loads the MP4DecSpecificInfoDescriptor from the input bitstream."}
{"code": "public AsynchronousIndexWriteConfiguration(){\n}\n", "nl": "<strong>De-serialization ctor</strong>"}
{"code": "public void displayState(String state){\n  updateSize();\n  if (log.isDebugEnabled()) {\n    if (getSignalMast() == null) {\n      log.debug(\"Display state \" + state + \", disconnected\");\n    }\n else {\n      log.debug(\"Display state \" + state + \" for \"+ getSignalMast().getSystemName());\n    }\n  }\n  if (isText()) {\n    if (getSignalMast().getHeld()) {\n      if (isText()) {\n        super.setText(Bundle.getMessage(\"Held\"));\n      }\n      return;\n    }\n else     if (getLitMode() && !getSignalMast().getLit()) {\n      super.setText(Bundle.getMessage(\"Dark\"));\n      return;\n    }\n    super.setText(state);\n  }\n  if (isIcon()) {\n    if ((state != null) && (getSignalMast() != null)) {\n      String s=getSignalMast().getAppearanceMap().getImageLink(state,useIconSet);\n      if ((getSignalMast().getHeld()) && (getSignalMast().getAppearanceMap().getSpecificAppearance(jmri.SignalAppearanceMap.HELD) != null)) {\n        s=getSignalMast().getAppearanceMap().getImageLink(\" held\",useIconSet);\n      }\n else       if (getLitMode() && !getSignalMast().getLit() && (getSignalMast().getAppearanceMap().getImageLink(\" dark\",useIconSet) != null)) {\n        s=getSignalMast().getAppearanceMap().getImageLink(\" dark\",useIconSet);\n      }\n      if (s.equals(\"\")) {\n        return;\n      }\n      if (!s.contains(\"preference:\")) {\n        s=s.substring(s.indexOf(\"resources\"));\n      }\n      if (_iconMap == null) {\n        getIcons();\n      }\n      NamedIcon n=_iconMap.get(s);\n      super.setIcon(n);\n      updateSize();\n      setSize(n.getIconWidth(),n.getIconHeight());\n    }\n  }\n else {\n    super.setIcon(null);\n  }\n  return;\n}\n", "nl": "Drive the current state of the display from the state of the underlying SignalMast object."}
{"code": "private void withStaticallyMockedEnvironmentAndFileApis() throws IOException {\n  mockStatic(Environment.class,File.class);\n  when(Environment.getExternalStorageDirectory()).thenReturn(mDirectory);\n  when(File.createTempFile(anyString(),anyString(),eq(mDirectory))).thenReturn(mImageFile);\n}\n", "nl": "Mock static methods in android.jar"}
{"code": "public static boolean isImageFileCompatible(File f){\n  boolean result=true;\n  try {\n    BufferedImage img=ImageIO.read(f);\n    ColorLayout cl=new ColorLayout();\n    cl.extract(img);\n  }\n catch (  Exception e) {\n    result=false;\n  }\n  return result;\n}\n", "nl": "Just opens an image with Java and reports if false if there are problems. This method can be used to check for JPG etc. that are not supported by the employed Java version."}
{"code": "public <T>T read(Class<? extends T> type,Reader source,boolean strict) throws Exception {\n  return read(type,NodeBuilder.read(source),strict);\n}\n", "nl": "This <code>read</code> method will read the contents of the XML document from the provided source and convert it into an object of the specified type. If the XML source cannot be deserialized or there is a problem building the object graph an exception is thrown. The instance deserialized is returned."}
{"code": "public static Pointer to(float values[]){\n  return new Pointer(FloatBuffer.wrap(values));\n}\n", "nl": "Creates a new Pointer to the given values. The values may not be null."}
{"code": "public InvocationSequenceData(Timestamp timeStamp,long platformIdent,long sensorTypeIdent,long methodIdent){\n  super(timeStamp,platformIdent,sensorTypeIdent,methodIdent);\n}\n", "nl": "Creates a new instance."}
{"code": "public RedundantBranchElimination(){\n  super(\"RedundantBranchElimination\",new OptimizationPlanElement[]{new OptimizationPlanAtomicElement(new EnsureSSA()),new OptimizationPlanAtomicElement(new GlobalValueNumber()),new OptimizationPlanAtomicElement(new RBE())});\n}\n", "nl": "Create this phase element as a composite of other elements"}
{"code": "public void alignItemsInColumns(int columns[]){\n  ArrayList<Integer> rows=new ArrayList<Integer>();\n  for (int i=0; i < columns.length; i++) {\n    rows.add(columns[i]);\n  }\n  int height=-5;\n  int row=0, rowHeight=0, columnsOccupied=0, rowColumns;\n  for (int i=0; i < children_.size(); i++) {\n    CCMenuItem item=(CCMenuItem)children_.get(i);\n    assert row < rows.size() : \"Too many menu items for the amount of rows/columns.\";\n    rowColumns=rows.get(row);\n    assert rowColumns != 0 : \"Can't have zero columns on a row\";\n    rowHeight=(int)Math.max(rowHeight,item.getContentSize().height);\n    ++columnsOccupied;\n    if (columnsOccupied >= rowColumns) {\n      height+=rowHeight + 5;\n      columnsOccupied=0;\n      rowHeight=0;\n      ++row;\n    }\n  }\n  assert columnsOccupied != 0 : \"Too many rows/columns for available menu items.\";\n  CGSize winSize=CCDirector.sharedDirector().winSize();\n  row=0;\n  rowHeight=0;\n  rowColumns=0;\n  float w=0, x=0, y=height / 2;\n  for (int i=0; i < children_.size(); i++) {\n    CCMenuItem item=(CCMenuItem)children_.get(i);\n    if (rowColumns == 0) {\n      rowColumns=rows.get(row);\n      w=winSize.width / (1 + rowColumns);\n      x=w;\n    }\n    rowHeight=Math.max(rowHeight,(int)item.getContentSize().height);\n    item.setPosition(CGPoint.make(x - winSize.width / 2,y - item.getContentSize().height / 2));\n    x+=w + 10;\n    ++columnsOccupied;\n    if (columnsOccupied >= rowColumns) {\n      y-=rowHeight + 5;\n      columnsOccupied=0;\n      rowColumns=0;\n      rowHeight=0;\n      ++row;\n    }\n  }\n}\n", "nl": "align items in rows of columns"}
{"code": "public void testUrlEncoderEncodesNonPrintableNonAsciiCharacters() throws Exception {\n  assertEquals(\"%00\",URLEncoder.encode(\"\\u0000\",\"UTF-8\"));\n  assertEquals(\"%00\",URLEncoder.encode(\"\\u0000\"));\n  assertEquals(\"%E2%82%AC\",URLEncoder.encode(\"\\u20AC\",\"UTF-8\"));\n  assertEquals(\"%E2%82%AC\",URLEncoder.encode(\"\\u20AC\"));\n  assertEquals(\"%F0%A0%AE%9F\",URLEncoder.encode(\"\\ud842\\udf9f\",\"UTF-8\"));\n  assertEquals(\"%F0%A0%AE%9F\",URLEncoder.encode(\"\\ud842\\udf9f\"));\n}\n", "nl": "Android's URLEncoder.encode() failed for surrogate pairs, encoding them as two replacement characters (\"??\"). http://b/3436051"}
{"code": "public ServiceCall<TranslationResult> translate(final String text,final Language source,final Language target){\n  return translate(Collections.singletonList(text),source,target);\n}\n", "nl": "Translate text using source and target languages.<br>"}
{"code": "public static void displayImage(Context context,String url,ImageView image){\n  ImageLoader loader=getImageLoader(context);\n  ImageAware imageAware=new ImageViewAware(image,false);\n  loader.displayImage(url,imageAware);\n}\n", "nl": "Downloads the image for the url"}
{"code": "public static ImageSource resource(int resId){\n  return new ImageSource(resId);\n}\n", "nl": "Create an instance from a resource. The correct resource for the device screen resolution will be used."}
{"code": "public Object runSafely(Catbert.FastStack stack) throws Exception {\n  MediaFile mf=getMediaFile(stack);\n  return Boolean.valueOf(mf != null && mf.isLocalFile());\n}\n", "nl": "Returns true if the specified MediaFile is local to this system (i.e. doesn't need to be streamed from a server)"}
{"code": "@SuppressWarnings(\"unchecked\") @Override public void eSet(int featureID,Object newValue){\nswitch (featureID) {\ncase UmplePackage.AUTO_TRANSITION___AUTO_TRANSITION_BLOCK_1:\n    getAutoTransitionBlock_1().clear();\n  getAutoTransitionBlock_1().addAll((Collection<? extends AutoTransitionBlock_>)newValue);\nreturn;\ncase UmplePackage.AUTO_TRANSITION___ACTIVITY_1:\ngetActivity_1().clear();\ngetActivity_1().addAll((Collection<? extends Activity_>)newValue);\nreturn;\n}\nsuper.eSet(featureID,newValue);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public void load(Reader reader,G g) throws IOException {\n  this.current_graph=g;\n  this.graph_factory=null;\n  initializeData();\n  clearData();\n  parse(reader);\n}\n", "nl": "Populates the specified graph with the data parsed from the reader."}
{"code": "public synchronized void close() throws IOException {\n  if (journalWriter == null) {\n    return;\n  }\n  for (  Entry entry : new ArrayList<Entry>(lruEntries.values())) {\n    if (entry.currentEditor != null) {\n      entry.currentEditor.abort();\n    }\n  }\n  trimToSize();\n  journalWriter.close();\n  journalWriter=null;\n}\n", "nl": "Closes this cache. Stored values will remain on the filesystem."}
{"code": "private void addSubCollectionField(NutchDocument doc,String url){\n  for (  String collname : CollectionManager.getCollectionManager(getConf()).getSubCollections(url)) {\n    doc.add(FIELD_NAME,collname);\n  }\n}\n", "nl": "\"Mark\" document to be a part of subcollection"}
{"code": "public String toString(){\n  if (null != m_value) {\n    return (m_value.toString());\n  }\n else   if (null != m_invalidValue) {\n    return m_invalidValue;\n  }\n else {\n    return \"\";\n  }\n}\n", "nl": "Method toString."}
{"code": "public org.apache.nutch.storage.Host.Builder clearMetadata(){\n  metadata=null;\n  fieldSetFlags()[0]=false;\n  return this;\n}\n", "nl": "Clears the value of the 'metadata' field"}
{"code": "public String format(String str,Object... objs){\n  return MessageFormatter.format(str,objs).getMessage();\n}\n", "nl": "Format an slf4j message"}
{"code": "private void tryToAddDataPoint(){\n  if (traceData.size() == traceData.getBufferSize() && plotMode == PlotMode.N_STOP)   return;\nswitch (updateMode) {\ncase X_OR_Y:\n    if ((chronological && currentYDataChanged) || (!chronological && (currentXDataChanged || currentYDataChanged)))     addDataPoint();\n  break;\ncase X_AND_Y:\nif ((chronological && currentYDataChanged) || (!chronological && (currentXDataChanged && currentYDataChanged))) addDataPoint();\nbreak;\ncase X:\nif ((chronological && currentYDataChanged) || (!chronological && currentXDataChanged)) addDataPoint();\nbreak;\ncase Y:\nif (currentYDataChanged) addDataPoint();\nbreak;\ncase TRIGGER:\ndefault :\nbreak;\n}\n}\n", "nl": "Try to add a new data point to trace data.  Whether it will be added or not is up to the update mode."}
{"code": "private View makeAndAddHorizontalView(int position,int offset,int x,boolean fromLeft){\n  View child;\n  if (!mDataChanged) {\n    child=mRecycler.get(position);\n    if (child != null) {\n      int childLeft=child.getLeft();\n      mRightMost=Math.max(mRightMost,childLeft + child.getMeasuredWidth());\n      mLeftMost=Math.min(mLeftMost,childLeft);\n      setUpHorizontalChild(child,offset,x,fromLeft);\n      return child;\n    }\n  }\n  child=mAdapter.getView(position,null,this);\n  setUpHorizontalChild(child,offset,x,fromLeft);\n  return child;\n}\n", "nl": "Obtain a view, either by pulling an existing view from the recycler or by getting a new one from the adapter. If we are animating, make sure there is enough information in the view's layout parameters to animate from the old to new positions."}
{"code": "public final void print(double d) throws IOException {\n  print(String.valueOf(d));\n}\n", "nl": "Prints an double"}
{"code": "public int size(){\n  return nodes.size();\n}\n", "nl": "Returns the number of nodes in this lattice."}
{"code": "protected void finalize() throws Throwable {\n  this.systemID=null;\n  this.encapsulatedException=null;\n  super.finalize();\n}\n", "nl": "Cleans up the object when it's destroyed."}
{"code": "public void addToken(char[] array,int start,int end,int tokenType,int startOffset){\n  super.addToken(array,start,end,tokenType,startOffset);\n  zzStartRead=zzMarkedPos;\n}\n", "nl": "Adds the token specified to the current linked list of tokens."}
{"code": "public void testPing() throws Exception {\n  testServlet(\"/ping-test\");\n  testServlet(\"/ping-test-URL-path\");\n}\n", "nl": "Test the ping."}
{"code": "protected void releaseBeanContextResources(){\n  super.releaseBeanContextResources();\n  releaseAllDelegatedServices();\n  proxy=null;\n}\n", "nl": "Called before the parent context is updated. The implementation releases any service that is currently provided by the parent context."}
{"code": "public BaseCheckBox(String label){\n  this();\n  setText(label);\n}\n", "nl": "Creates a check box with the specified text label."}
{"code": "@Override public void eUnset(int featureID){\nswitch (featureID) {\ncase N4JSPackage.EXPORT_SPECIFIER__ELEMENT:\n    setElement((IdentifierRef)null);\n  return;\ncase N4JSPackage.EXPORT_SPECIFIER__ALIAS:\nsetAlias(ALIAS_EDEFAULT);\nreturn;\n}\nsuper.eUnset(featureID);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public Object clone(){\n  DefaultMutableTreeNode newNode;\n  try {\n    newNode=(DefaultMutableTreeNode)super.clone();\n    newNode.children=null;\n    newNode.parent=null;\n  }\n catch (  CloneNotSupportedException e) {\n    throw new Error(e.toString());\n  }\n  return newNode;\n}\n", "nl": "Overridden to make clone public.  Returns a shallow copy of this node; the new node has no parent or children and has a reference to the same user object, if any."}
{"code": "public TransactionOutput addOutput(BigInteger value,ECKey pubkey){\n  return addOutput(new TransactionOutput(params,this,value,pubkey));\n}\n", "nl": "Creates an output that pays to the given pubkey directly (no address) with the given value, adds it to this transaction, and returns the new output."}
{"code": "public static long index(final int segment,final int displacement){\n  return start(segment) + displacement;\n}\n", "nl": "Computes the index associated with given segment and displacement."}
{"code": "private void dropTables(SQLiteDatabase paramSQLiteDatabase){\n  for (  String table : sTables) {\n    try {\n      paramSQLiteDatabase.execSQL(\"DROP TABLE IF EXISTS \" + table);\n    }\n catch (    Exception localException) {\n      localException.printStackTrace();\n    }\n  }\n}\n", "nl": "Goes through all of the tables in sTables and drops each table if it exists. Altered to no longer make use of reflection."}
{"code": "static public void assertNotSame(Object expected,Object actual){\n  assertNotSame(null,expected,actual);\n}\n", "nl": "Asserts that two objects refer to the same object. If they are not the same an AssertionFailedError is thrown."}
{"code": "@Override public void process(Number tuple){\n  RMin.this.process(tuple);\n}\n", "nl": "Each tuple is compared to the min and a new min (if so) is stored."}
{"code": "protected Context createContext(HttpServletRequest request,HttpServletResponse response){\n  VelocityContext context=new VelocityContext();\n  context.put(REQUEST,request);\n  context.put(RESPONSE,response);\n  return context;\n}\n", "nl": "Returns a context suitable to pass to the handleRequest() method <br><br> Default implementation will create a VelocityContext object, put the HttpServletRequest and HttpServletResponse into the context accessable via the keys VelocityServlet.REQUEST and VelocityServlet.RESPONSE, respectively."}
{"code": "public static ArrayModifiableDBIDs[] partitionsFromIntegerLabels(DBIDs ids,IntegerDataStore assignment,int k){\n  int[] sizes=new int[k];\n  for (DBIDIter iter=ids.iter(); iter.valid(); iter.advance()) {\n    sizes[assignment.intValue(iter)]+=1;\n  }\n  ArrayModifiableDBIDs[] clusters=new ArrayModifiableDBIDs[k];\n  for (int i=0; i < k; i++) {\n    clusters[i]=DBIDUtil.newArray(sizes[i]);\n  }\n  for (DBIDIter iter=ids.iter(); iter.valid(); iter.advance()) {\n    clusters[assignment.intValue(iter)].add(iter);\n  }\n  return clusters;\n}\n", "nl": "Collect clusters from their [0;k-1] integer labels."}
{"code": "private static String resovlePropConfigFile(String prop){\n  if (prop != null && prop.startsWith(\"file://\")) {\n    try {\n      String filePath=prop.substring(7);\n      BufferedReader br=new BufferedReader(new InputStreamReader(new FileInputStream(filePath),\"UTF-8\"));\n      StringBuffer sb=new StringBuffer();\n      String str=br.readLine();\n      while (str != null) {\n        sb.append(str);\n        str=br.readLine();\n      }\n      return sb.toString();\n    }\n catch (    IOException e) {\n      System.err.println(\"read classpath failed!\");\n      throw new RuntimeException(\" read classpath failed \",e);\n    }\n  }\n  return prop;\n}\n", "nl": "To get the full list for classpath list, Note:sometimes the classpath will be very longer, especially when you are working on a Maven project. Since if classpath too long will cause command line too long issue, we use file to handle it in this case."}
{"code": "public Matrix4f translationRotateScaleInvert(Vector3fc translation,Quaternionfc quat,Vector3fc scale){\n  return translationRotateScaleInvert(translation.x(),translation.y(),translation.z(),quat.x(),quat.y(),quat.z(),quat.w(),scale.x(),scale.y(),scale.z());\n}\n", "nl": "Set <code>this</code> matrix to <tt>(T * R * S)<sup>-1</sup></tt>, where <tt>T</tt> is the given <code>translation</code>, <tt>R</tt> is a rotation transformation specified by the given quaternion, and <tt>S</tt> is a scaling transformation which scales the axes by <code>scale</code>. <p> This method is equivalent to calling: <tt>translationRotateScale(...).invert()</tt>"}
{"code": "public String closureClassName(){\n  return cloClsName;\n}\n", "nl": "Gets closure class name (applicable only for TRANSFORM operations)."}
{"code": "public static void charge(int slotID,IStrictEnergyStorage storer){\n  IInventory inv=(TileEntityContainerBlock)storer;\n  if (inv.getStackInSlot(slotID) != null && storer.getEnergy() > 0) {\n    if (inv.getStackInSlot(slotID).getItem() instanceof IEnergizedItem) {\n      storer.setEnergy(storer.getEnergy() - EnergizedItemManager.charge(inv.getStackInSlot(slotID),storer.getEnergy()));\n    }\n else     if (MekanismUtils.useIC2() && inv.getStackInSlot(slotID).getItem() instanceof IElectricItem) {\n      double sent=ElectricItem.manager.charge(inv.getStackInSlot(slotID),(int)(storer.getEnergy() * general.TO_IC2),4,true,false) * general.FROM_IC2;\n      storer.setEnergy(storer.getEnergy() - sent);\n    }\n else     if (MekanismUtils.useRF() && inv.getStackInSlot(slotID).getItem() instanceof IEnergyContainerItem) {\n      ItemStack itemStack=inv.getStackInSlot(slotID);\n      IEnergyContainerItem item=(IEnergyContainerItem)inv.getStackInSlot(slotID).getItem();\n      int itemEnergy=(int)Math.round(Math.min(Math.sqrt(item.getMaxEnergyStored(itemStack)),item.getMaxEnergyStored(itemStack) - item.getEnergyStored(itemStack)));\n      int toTransfer=(int)Math.round(Math.min(itemEnergy,(storer.getEnergy() * general.TO_TE)));\n      storer.setEnergy(storer.getEnergy() - (item.receiveEnergy(itemStack,toTransfer,false) * general.FROM_TE));\n    }\n  }\n}\n", "nl": "Universally charges an item, and updates the TileEntity's energy level."}
{"code": "public ZkBinLogStateConfig build(){\n  ZkBinLogStateConfig zkBinLogStateConfig=new ZkBinLogStateConfig(this);\n  return zkBinLogStateConfig;\n}\n", "nl": "Build the complete object with properties that were set."}
{"code": "public boolean offerFirst(E e){\n  addFirst(e);\n  return true;\n}\n", "nl": "Inserts the specified element at the front of this deque."}
{"code": "public TermNode right(){\n  return (TermNode)super.getRequiredProperty(Annotations.RIGHT);\n}\n", "nl": "Returns the right term."}
{"code": "private void advanceIfCurrentPieceFullyRead(){\n  if (currentPiece != null && currentPieceIndex == currentPieceSize) {\n    currentPieceOffsetInRope+=currentPieceSize;\n    currentPieceIndex=0;\n    if (pieceIterator.hasNext()) {\n      currentPiece=pieceIterator.next();\n      currentPieceSize=currentPiece.size();\n    }\n else {\n      currentPiece=null;\n      currentPieceSize=0;\n    }\n  }\n}\n", "nl": "Skips to the next piece if we have read all the data in the current piece.  Sets currentPiece to null if we have reached the end of the input."}
{"code": "private MapSettings(){\n  this(megamek.common.preference.PreferenceManager.getClientPreferences().getBoardWidth(),megamek.common.preference.PreferenceManager.getClientPreferences().getBoardHeight(),megamek.common.preference.PreferenceManager.getClientPreferences().getMapWidth(),megamek.common.preference.PreferenceManager.getClientPreferences().getMapHeight());\n}\n", "nl": "Creates new MapSettings"}
{"code": "public void addElement(int value){\n  if (!m_mutable)   throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE,null));\n  super.addElement(value);\n}\n", "nl": "Append a Node onto the vector."}
{"code": "public DefaultStateContext(Stage stage,Message<E> message,MessageHeaders messageHeaders,ExtendedState extendedState,Transition<S,E> transition,StateMachine<S,E> stateMachine,State<S,E> source,State<S,E> target,Exception exception){\n  this.stage=stage;\n  this.message=message;\n  this.messageHeaders=messageHeaders;\n  this.extendedState=extendedState;\n  this.transition=transition;\n  this.stateMachine=stateMachine;\n  this.source=source;\n  this.target=target;\n  this.exception=exception;\n  this.sources=null;\n  this.targets=null;\n}\n", "nl": "Instantiates a new default state context."}
{"code": "@Override @TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED) public InstanceStatus modifyInstance(String instanceId,ProvisioningSettings currentSettings,ProvisioningSettings newSettings) throws APPlatformException {\n  LOGGER.info(\"modifyInstance({})\",LogAndExceptionConverter.getLogText(instanceId,currentSettings));\n  try {\n    newSettings.getParameters().put(PropertyHandler.STACK_NAME,currentSettings.getParameters().get(PropertyHandler.STACK_NAME));\n    PropertyHandler ph=new PropertyHandler(newSettings);\n    ph.setState(FlowState.MODIFICATION_REQUESTED);\n    InstanceStatus result=new InstanceStatus();\n    result.setChangedParameters(newSettings.getParameters());\n    return result;\n  }\n catch (  Exception t) {\n    throw LogAndExceptionConverter.createAndLogPlatformException(t,Context.MODIFICATION);\n  }\n}\n", "nl": "Starts the modification of an application instance. <p> The internal status <code>MODIFICATION_REQUESTED</code> is stored as a controller configuration setting. It is evaluated and handled by the status dispatcher, which is invoked at regular intervals by APP through the <code>getInstanceStatus</code> method."}
{"code": "public void addDisconnectedEventListener(Executor executor,PeerDisconnectedEventListener listener){\n  disconnectedEventListeners.add(new ListenerRegistration(listener,executor));\n}\n", "nl": "Registers a listener that is invoked when a peer is disconnected."}
{"code": "public static Object invokeMethod(Object instance,Class<?> clazz,String methodName,Object... arguments) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException {\n  return getMethod(clazz,methodName,DataType.getPrimitive(arguments)).invoke(instance,arguments);\n}\n", "nl": "Invokes a method of the target class on an object with the given arguments"}
{"code": "@PostConstruct public void postConstruct() throws Exception {\n  timeStarted=System.currentTimeMillis();\n  dateStarted=new Date(timeStarted);\n  if (log.isInfoEnabled()) {\n    log.info(\"|-CMR Management Service active...\");\n  }\n}\n", "nl": "Is executed after dependency injection is done to perform any initialization."}
{"code": "public String toXML(boolean header){\n  XmlTextBuilder bdr;\n  String tagName=\"Sender\";\n  bdr=new XmlTextBuilder();\n  if (header)   bdr.setStandardHeader();\n  bdr.addOpeningTag(tagName);\n  bdr.addSimpleElement(\"Id\",id);\n  bdr.addSimpleElement(\"Name\",name);\n  bdr.addSimpleElement(\"FirstName\",firstName);\n  bdr.addSimpleElement(\"SurName\",surName);\n  bdr.addSimpleElement(\"SurName2\",surName2);\n  bdr.addSimpleElement(\"EMail\",email);\n  bdr.addSimpleElement(\"Certificate_Issuer\",certificateIssuer);\n  bdr.addSimpleElement(\"Certificate_SN\",certificateSN);\n  bdr.addSimpleElement(\"InQualityOf\",inQuality);\n  bdr.addSimpleElement(\"Social_Name\",socialName);\n  bdr.addSimpleElement(\"CIF\",CIF);\n  bdr.addClosingTag(tagName);\n  return bdr.getText();\n}\n", "nl": "Recoge los valores de la instancia en una cadena xml"}
{"code": "@DELETE @Produces(MediaType.APPLICATION_JSON) @Path(\"/{alertId}/notifications/{notificationId}\") @Description(\"Deletes a notification having the given ID if it is associated with the given alert ID.  Associated triggers are not deleted from the alert.\") public Response deleteNotificationsById(@Context HttpServletRequest req,@PathParam(\"alertId\") BigInteger alertId,@PathParam(\"notificationId\") BigInteger notificationId){\n  if (alertId == null || alertId.compareTo(BigInteger.ZERO) < 1) {\n    throw new WebApplicationException(\"Alert Id cannot be null and must be a positive non-zero number.\",Status.BAD_REQUEST);\n  }\n  if (notificationId == null || notificationId.compareTo(BigInteger.ZERO) < 1) {\n    throw new WebApplicationException(\"Notification Id cannot be null and must be a positive non-zero number.\",Status.BAD_REQUEST);\n  }\n  Alert alert=alertService.findAlertByPrimaryKey(alertId);\n  if (alert == null) {\n    throw new WebApplicationException(Response.Status.NOT_FOUND.getReasonPhrase(),Response.Status.NOT_FOUND);\n  }\n  validateResourceAuthorization(req,alert.getOwner(),getRemoteUser(req));\n  List<Notification> listNotification=new ArrayList<Notification>(alert.getNotifications());\n  Iterator<Notification> it=listNotification.iterator();\n  while (it.hasNext()) {\n    Notification notification=it.next();\n    if (notification.getId().equals(notificationId)) {\n      it.remove();\n      alert.setNotifications(listNotification);\n      alert.setModifiedBy(getRemoteUser(req));\n      alertService.updateAlert(alert);\n      return Response.status(Status.OK).build();\n    }\n  }\n  throw new WebApplicationException(Response.Status.NOT_FOUND.getReasonPhrase(),Response.Status.NOT_FOUND);\n}\n", "nl": "Deletes the notification."}
{"code": "protected static IJavaElement handleToElement(final String project,final String handle,final boolean check){\n  return handleToElement(null,project,handle,check);\n}\n", "nl": "Converts an input handle back to the corresponding java element."}
{"code": "public MetadataOmittedITCase(String name){\n  super(name);\n}\n", "nl": "Construct a new instance of this test case."}
{"code": "@Deprecated public static Header[] parseHeaders(final InputStream is) throws IOException, HttpException {\n  LOG.trace(\"enter HeaderParser.parseHeaders(InputStream, String)\");\n  return parseHeaders(is,\"US-ASCII\");\n}\n", "nl": "Parses headers from the given stream. Headers with the same name are not combined."}
{"code": "public boolean containsJoint(Joint joint){\n  return this.joints.contains(joint);\n}\n", "nl": "Returns true if this world contains the given joint."}
{"code": "private Builder(){\n  super(com.wipro.ats.bdre.imcrawler.mr.Contents.SCHEMA );\n}\n", "nl": "Creates a new Builder"}
{"code": "@Override public boolean supportsCreateDB(){\n  return false;\n}\n", "nl": "Indicate that MySQL can create database from the URL."}
{"code": "public ByteBuffer put(int index,byte b){\n  byteArray.set(index,b);\n  return this;\n}\n", "nl": "Write a byte to the specified index of this buffer without changing the position."}
{"code": "private boolean isParentProperty(MetaProperty metaProperty){\n  return parentProperty != null && metaProperty.getName().equals(parentProperty);\n}\n", "nl": "Checks if specified property is a reference to entity's parent entity. Parent entity can be specified during creating of this screen."}
{"code": "public void store(String filenameToSave,String comments) throws FileNotFoundException, FileAlreadyExistsException {\n  if (StringUtils.isEmpty(filenameToSave)) {\n    throw new FileNotFoundException();\n  }\n  if (filenameToSave.equals(filename)) {\n    throw new FileAlreadyExistsException(filenameToSave);\n  }\n  FileWriter fileWriter=null;\n  BufferedWriter bufferedWriter=null;\n  try {\n    fileWriter=new FileWriter(filenameToSave,false);\n    bufferedWriter=new BufferedWriter(fileWriter);\n    prop.store(bufferedWriter,comments);\n  }\n catch (  IOException e) {\n    logger.error(\"Fail on store properties.\",e);\n  }\n finally {\n    IOUtils.closeQuite(fileWriter);\n    IOUtils.closeQuite(bufferedWriter);\n  }\n}\n", "nl": "Store current properties to file. Always overwrite."}
{"code": "private void closeRemoteResources(){\n  if (reader != null) {\n    try {\n      reader.close();\n    }\n catch (    final IOException ignore) {\n    }\n    reader=null;\n  }\n  if (writer != null) {\n    writer.close();\n    writer=null;\n  }\n  if (socketOutstream != null) {\n    try {\n      socketOutstream.close();\n    }\n catch (    final IOException ignore) {\n    }\n    socketOutstream=null;\n  }\n  if (socketInstream != null) {\n    try {\n      socketInstream.close();\n    }\n catch (    final IOException ignore) {\n    }\n    socketInstream=null;\n  }\n  if (socket != null) {\n    try {\n      socket.close();\n    }\n catch (    final IOException ignore) {\n    }\n    socket=null;\n  }\n}\n", "nl": "Safely close remote resources"}
{"code": "public void delete(String key){\n  mStorage.deleteIfExists(key);\n}\n", "nl": "Delete saved object for given key if it is exist."}
{"code": "public boolean containsFieldValues(Object[] fieldValues){\n  return this.contents.contains(fieldValues);\n}\n", "nl": "Does this set contain a Struct of the correct type with the specified values?"}
{"code": "public RingOfLife(){\n  super(\"emerald ring\",\"ring\",\"emerald-ring\",null);\n  put(\"amount\",1);\n}\n", "nl": "Create a RingOfLife."}
{"code": "public TimeoutException(){\n}\n", "nl": "Creates a new exception."}
{"code": "private boolean processEsbSystemMonitorMessage(String payload){\n  boolean messageProcessed=false;\n  try {\n    sqsNotificationEventService.processSystemMonitorNotificationEvent(payload);\n    messageProcessed=true;\n  }\n catch (  Exception e) {\n    LOGGER.debug(\"Failed to process message from the JMS queue for a system monitor request. jmsQueueName=\\\"{}\\\" jmsMessagePayload={}\",HerdJmsDestinationResolver.SQS_DESTINATION_HERD_INCOMING,payload,e);\n  }\n  return messageProcessed;\n}\n", "nl": "Process the message as system monitor."}
{"code": "public void updateCredentials(String login,String password){\n  sharedPreferences.edit().putString(application.getString(R.string.shared_prefs_login),login).putString(application.getString(R.string.shared_prefs_password),password).apply();\n}\n", "nl": "Update the login and the password in the preferences."}
{"code": "public static boolean isNotEmpty(String[] array){\n  return array != null && array.length > 0;\n}\n", "nl": "Indica si un array tiene valores."}
{"code": "@Override public String toString(){\n  StringBuilder outputString=new StringBuilder();\n  HashSet<String> printed_keys=new HashSet<>();\n  for (int i=0; i < DENSE_FEATURE_NAMES.size(); i++) {\n    outputString.append(String.format(\"%s=%.3f \",DENSE_FEATURE_NAMES.get(i),getDense(i)));\n    printed_keys.add(DENSE_FEATURE_NAMES.get(i));\n  }\n  ArrayList<String> keys=new ArrayList<>(sparseFeatures.keySet());\n  Collections.sort(keys);\n  keys.stream().filter(null).forEach(null);\n  return outputString.toString().trim();\n}\n", "nl": "Outputs a list of feature names. All dense features are printed. Feature names are printed in the order they were read in."}
{"code": "public Bundler putShortArray(String key,short[] value){\n  bundle.putShortArray(key,value);\n  return this;\n}\n", "nl": "Inserts a short array value into the mapping of this Bundle, replacing any existing value for the given key.  Either key or value may be null."}
{"code": "public int hashCode(){\n  return getName().hashCode() + 31 * mask;\n}\n", "nl": "Returns the hash code value for this CardPermission object."}
{"code": "public static Number sign(Number a){\n  if (isFloatingPoint(a)) {\n    return Math.signum(a.doubleValue());\n  }\n else {\n    return Long.signum(a.longValue());\n  }\n}\n", "nl": "Returns the sign of the number."}
{"code": "public double[][] convertToDoubleMatrix(InputStream input,int rows,int cols) throws IOException {\n  double[][] ret=null;\n  try {\n    ReaderTextCell reader=(ReaderTextCell)MatrixReaderFactory.createMatrixReader(InputInfo.TextCellInputInfo);\n    MatrixBlock mb=reader.readMatrixFromInputStream(input,rows,cols,ConfigurationManager.getBlocksize(),ConfigurationManager.getBlocksize(),(long)rows * cols);\n    ret=DataConverter.convertToDoubleMatrix(mb);\n  }\n catch (  DMLRuntimeException rex) {\n    throw new IOException(rex);\n  }\n  return ret;\n}\n", "nl": "Converts an input stream of a string matrix in textcell format into a dense double array. The number of rows and columns need to be  specified because textcell only represents non-zero values and hence does not define the dimensions in the general case."}
{"code": "FileMenu(){\n  super(I18n.tr(\"&File\"));\n  MENU.add(createMenuItem(new FileMenuActions.SendFileAction()));\n  MENU.addSeparator();\n  MENU.add(createMenuItem(new FileMenuActions.OpenMagnetTorrentAction()));\n  MENU.add(createMenuItem(new FileMenuActions.CreateTorrentAction()));\n  if (!OSUtils.isMacOSX()) {\n    MENU.addSeparator();\n    MENU.add(createMenuItem(new FileMenuActions.CloseAction()));\n    MENU.add(createMenuItem(new FileMenuActions.ExitAction()));\n  }\n}\n", "nl": "Creates a new <tt>FileMenu</tt>, using the <tt>key</tt>  argument for setting the locale-specific title and  accessibility text."}
{"code": "public static String deviceToText(int hByte,int lByte){\n  int mask=0x01;\n  int x=lByte;\n  StringBuilder dev=new StringBuilder();\n  for (int i=8; i > 0; i--) {\n    if ((x & mask) != 0) {\n      dev.append(\" \" + i);\n    }\n    mask=mask << 1;\n  }\n  mask=0x01;\n  x=hByte;\n  for (int i=16; i > 8; i--) {\n    if ((x & mask) != 0) {\n      dev.append(\" \" + i);\n    }\n    mask=mask << 1;\n  }\n  return dev.toString();\n}\n", "nl": "Translate Device Bits to Text"}
{"code": "final float sloppyFreq() throws IOException {\n  ensureFreq();\n  return freq;\n}\n", "nl": "Returns the intermediate \"sloppy freq\" adjusted for edit distance"}
{"code": "public void testNynorskStemming() throws Exception {\n  Reader reader=new StringReader(\"gut guten gutar gutane gutens gutanes\");\n  TokenStream stream=new MockTokenizer(MockTokenizer.WHITESPACE,false);\n  ((Tokenizer)stream).setReader(reader);\n  stream=tokenFilterFactory(\"NorwegianMinimalStem\",\"variant\",\"nn\").create(stream);\n  assertTokenStreamContents(stream,new String[]{\"gut\",\"gut\",\"gut\",\"gut\",\"gut\",\"gut\"});\n}\n", "nl": "Test stemming with variant set explicitly to Nynorsk"}
{"code": "@Override @Inline public void processNode(ObjectReference object){\n  buffer.insert(object.toAddress());\n}\n", "nl": "Enqueue an object during a trace."}
{"code": "public int computePastValue(int[][][] data,int rowNumber,int columnNumber,int t){\n  int pastVal=0;\n  for (int p=0; p < k; p++) {\n    pastVal*=base;\n    pastVal+=data[t - k + 1 + p][rowNumber][columnNumber];\n  }\n  return pastVal;\n}\n", "nl": "Utility function to compute the combined embedded  past values of x up to and including time step t (i.e. (x_{t-k+1}, ... ,x_{t-1},x_{t})) where x is a time-series for a given row and column in data"}
{"code": "public NTLMException(int errorCode,String msg){\n  super(msg);\n  this.errorCode=errorCode;\n}\n", "nl": "Constructs an NTLMException object."}
{"code": "public static Trellis orderTrellis(Trellis trel,double I[][],Random rand){\n  int L=I.length;\n  int Y[]=new int[L];\n  ArrayList<Integer> list=new ArrayList<Integer>();\n  for (  int i : trel.indices) {\n    list.add(new Integer(i));\n  }\n  Y[0]=list.remove(rand.nextInt(L));\n  for (int j=1; j < L; j++) {\n    double max_w=-1.;\n    int j_=-1;\n    for (    int j_prop : list) {\n      double w=trel.weight(Y,j,j_prop,I);\n      if (w >= max_w) {\n        max_w=w;\n        j_=j_prop;\n      }\n    }\n    list.remove(new Integer(j_));\n    Y[j]=j_;\n  }\n  trel=new Trellis(Y,trel.WIDTH,trel.TYPE);\n  return trel;\n}\n", "nl": "OrderTrellis - order the trellis according to marginal label dependencies."}
{"code": "@Override public boolean hasName(){\n  log.log(Level.FINE,\"hasName(): {0}\",event == START_ELEMENT || event == END_ELEMENT);\n  return event == START_ELEMENT || event == END_ELEMENT;\n}\n", "nl": "returns true if the current event has a name (is a START_ELEMENT or END_ELEMENT) returns false otherwise"}
{"code": "public boolean isListenInBackground(){\n  return listenInBackground;\n}\n", "nl": "Returns whether this state is configured to allow background listening."}
{"code": "private void readObject(){\n}\n", "nl": "<!-- begin-user-doc --> Write your own initialization here <!-- end-user-doc -->"}
{"code": "public static boolean isLongCategory(ClassNode type){\n  return type == long_TYPE || isIntCategory(type);\n}\n", "nl": "It is of a long category, if the provided type is a long, its wrapper or if it is a long category."}
{"code": "public static byte[] decode(String s,int options) throws java.io.IOException {\n  if (s == null) {\n    throw new NullPointerException(\"Input string was null.\");\n  }\n  byte[] bytes;\n  try {\n    bytes=s.getBytes(PREFERRED_ENCODING);\n  }\n catch (  java.io.UnsupportedEncodingException uee) {\n    bytes=s.getBytes();\n  }\n  bytes=decode(bytes,0,bytes.length,options);\n  boolean dontGunzip=(options & DONT_GUNZIP) != 0;\n  if ((bytes != null) && (bytes.length >= 4) && (!dontGunzip)) {\n    int head=((int)bytes[0] & 0xff) | ((bytes[1] << 8) & 0xff00);\n    if (java.util.zip.GZIPInputStream.GZIP_MAGIC == head) {\n      java.io.ByteArrayInputStream bais=null;\n      java.util.zip.GZIPInputStream gzis=null;\n      java.io.ByteArrayOutputStream baos=null;\n      byte[] buffer=new byte[2048];\n      int length=0;\n      try {\n        baos=new java.io.ByteArrayOutputStream();\n        bais=new java.io.ByteArrayInputStream(bytes);\n        gzis=new java.util.zip.GZIPInputStream(bais);\n        while ((length=gzis.read(buffer)) >= 0) {\n          baos.write(buffer,0,length);\n        }\n        bytes=baos.toByteArray();\n      }\n catch (      java.io.IOException e) {\n        e.printStackTrace();\n      }\n finally {\n        try {\n          baos.close();\n        }\n catch (        Exception e) {\n        }\n        try {\n          gzis.close();\n        }\n catch (        Exception e) {\n        }\n        try {\n          bais.close();\n        }\n catch (        Exception e) {\n        }\n      }\n    }\n  }\n  return bytes;\n}\n", "nl": "Decodes data from Base64 notation, automatically detecting gzip-compressed data and decompressing it."}
{"code": "public CViewsTableRenderer(final IViewsTable table,final IViewContainer container){\n  this.container=Preconditions.checkNotNull(container,\"IE02032: Container argument can't be null\");\n  this.table=Preconditions.checkNotNull(table,\"IE02351: table argument can not be null\");\n  if (starImage == null) {\n    try {\n      starImage=new ImageIcon(CMain.class.getResource(\"data/star.png\").toURI().toURL()).getImage();\n    }\n catch (    MalformedURLException|URISyntaxException e) {\n    }\n  }\n  CWindowManager.instance().addListener(listener);\n  for (  final CGraphWindow window : CWindowManager.instance().getOpenWindows()) {\n    window.addListener(panelListener);\n  }\n}\n", "nl": "Creates a new renderer object."}
{"code": "public void output(OutputStream out){\n  m_html.output(out);\n}\n", "nl": "Output Document"}
{"code": "protected void sequence_ParameterizedTypeRefNominal_TypeRefWithModifiers_TypeRefWithoutModifiers(ISerializationContext context,ParameterizedTypeRef semanticObject){\n  genericSequencer.createSequence(context,semanticObject);\n}\n", "nl": "Contexts: BogusTypeRef returns ParameterizedTypeRef TypeRefWithModifiers returns ParameterizedTypeRef Constraint: ( undefModifier=UndefModifierToken |  (declaredType=[Type|TypeReferenceName] (typeArgs+=TypeArgument typeArgs+=TypeArgument*)? dynamic?='+'? undefModifier=UndefModifierToken?) )"}
{"code": "public static ArchiveAccess createArchiveAccess(){\n  return new ArchiveAccessImpl();\n}\n", "nl": "Crea la instancia para obtener el acceso al sistema de archivadores."}
{"code": "public synchronized final int evictionCount(){\n  return evictionCount;\n}\n", "nl": "Returns the number of values that have been evicted."}
{"code": "public void testAnalyse(){\n  System.out.println(\"analyse\");\n  AuditCommandImpl instance=null;\n}\n", "nl": "Test of analyse method, of class AuditCommandImpl."}
{"code": "public void put(final String key,final int value){\n  pageLookup.put(key,value);\n}\n", "nl": "The pageLookup to set."}
{"code": "public static long estimateMemory(long nrows,long ncols,double sparsity){\n  double cnnz=Math.max(SparseRow.initialCapacity,Math.ceil(sparsity * ncols));\n  double rlen=Math.min(nrows,Math.ceil(sparsity * nrows * ncols));\n  double size=16;\n  size+=rlen * (116 + cnnz * 12);\n  size+=32 + nrows * 8d;\n  return (long)Math.min(size,Long.MAX_VALUE);\n}\n", "nl": "Get the estimated in-memory size of the sparse block in MCSR  with the given dimensions w/o accounting for overallocation."}
{"code": "static boolean isWhiteSpace(char ch){\n  return ((ch == ' ') || (ch == '\\n') || (ch == '\\t')|| (ch == 10)|| (ch == 13));\n}\n", "nl": "Checks if the specified character is a white space or not. Exposed to packaage since used by HTMLComponent as well"}
{"code": "protected double measureHermitianOverlap(ComplexVector other){\n  other.toCartesian();\n  double result=0;\n  double norm1=0;\n  double norm2=0;\n  for (int i=0; i < dimension * 2; ++i) {\n    result+=coordinates[i] * other.coordinates[i];\n    norm1+=coordinates[i] * coordinates[i];\n    norm2+=other.coordinates[i] * other.coordinates[i];\n  }\n  return result / Math.sqrt(norm1 * norm2);\n}\n", "nl": "Measure overlap, again using the Hermitian / Euclidean scalar product."}
{"code": "protected void baselineLayout(int targetSpan,int axis,int[] offsets,int[] spans){\n  int totalAscent=(int)(targetSpan * getAlignment(axis));\n  int totalDescent=targetSpan - totalAscent;\n  int n=getViewCount();\n  for (int i=0; i < n; i++) {\n    View v=getView(i);\n    float align=v.getAlignment(axis);\n    float viewSpan;\n    if (v.getResizeWeight(axis) > 0) {\n      float minSpan=v.getMinimumSpan(axis);\n      float maxSpan=v.getMaximumSpan(axis);\n      if (align == 0.0f) {\n        viewSpan=Math.max(Math.min(maxSpan,totalDescent),minSpan);\n      }\n else       if (align == 1.0f) {\n        viewSpan=Math.max(Math.min(maxSpan,totalAscent),minSpan);\n      }\n else {\n        float fitSpan=Math.min(totalAscent / align,totalDescent / (1.0f - align));\n        viewSpan=Math.max(Math.min(maxSpan,fitSpan),minSpan);\n      }\n    }\n else {\n      viewSpan=v.getPreferredSpan(axis);\n    }\n    offsets[i]=totalAscent - (int)(viewSpan * align);\n    spans[i]=(int)viewSpan;\n  }\n}\n", "nl": "Computes the location and extent of each child view in this <code>BoxView</code> given the <code>targetSpan</code>, which is the width (or height) of the region we have to work with."}
{"code": "public void validateBusinessObjectDataStatusInformation(BusinessObjectDataKey expectedBusinessObjectDataKey,String expectedBusinessObjectDataStatus,BusinessObjectDataStatusInformation businessObjectDataStatusInformation){\n  assertNotNull(businessObjectDataStatusInformation);\n  assertEquals(expectedBusinessObjectDataKey,businessObjectDataStatusInformation.getBusinessObjectDataKey());\n  assertEquals(expectedBusinessObjectDataStatus,businessObjectDataStatusInformation.getStatus());\n}\n", "nl": "Validates the contents of a business object data status information against the specified parameters."}
{"code": "@Override public boolean add(E value){\n  final int hash;\n  int index;\n  if (value == null) {\n    hash=0;\n    index=indexOfNull();\n  }\n else {\n    hash=value.hashCode();\n    index=indexOf(value,hash);\n  }\n  if (index >= 0) {\n    return false;\n  }\n  index=~index;\n  if (mSize >= mHashes.length) {\n    final int n=mSize >= (BASE_SIZE * 2) ? (mSize + (mSize >> 1)) : (mSize >= BASE_SIZE ? (BASE_SIZE * 2) : BASE_SIZE);\n    if (DEBUG)     Log.d(TAG,\"add: grow from \" + mHashes.length + \" to \"+ n);\n    final int[] ohashes=mHashes;\n    final Object[] oarray=mArray;\n    allocArrays(n);\n    if (mHashes.length > 0) {\n      if (DEBUG)       Log.d(TAG,\"add: copy 0-\" + mSize + \" to 0\");\n      System.arraycopy(ohashes,0,mHashes,0,ohashes.length);\n      System.arraycopy(oarray,0,mArray,0,oarray.length);\n    }\n    freeArrays(ohashes,oarray,mSize);\n  }\n  if (index < mSize) {\n    if (DEBUG)     Log.d(TAG,\"add: move \" + index + \"-\"+ (mSize - index)+ \" to \"+ (index + 1));\n    System.arraycopy(mHashes,index,mHashes,index + 1,mSize - index);\n    System.arraycopy(mArray,index,mArray,index + 1,mSize - index);\n  }\n  mHashes[index]=hash;\n  mArray[index]=value;\n  mSize++;\n  return true;\n}\n", "nl": "Adds the specified object to this set. The set is not modified if it already contains the object."}
{"code": "public ArrowNeedle(boolean isArrowAtTop){\n  this.isArrowAtTop=isArrowAtTop;\n}\n", "nl": "Constructs a new arrow needle."}
{"code": "public void deHalfOp(UserHostmask user){\n  if (user == null)   throw new IllegalArgumentException(\"Can't remove halfop on null user\");\n  setMode(\"-h \" + user.getNick());\n}\n", "nl": "Removes owner privileges to a user on a channel. Successful use of this method may require the bot to have operator or halfOp status itself. <p> <b>Warning:</b> Not all IRC servers support this. Some servers may even use it to mean something else!"}
{"code": "@Override public String address(Class<?> api,String address){\n  Objects.requireNonNull(address);\n  if (address.isEmpty()) {\n    address=addressDefault(api);\n  }\n  int slash=address.indexOf(\"/\");\n  if (address.endsWith(\":\") && slash < 0) {\n    address+=\"//\";\n  }\n  int p=address.indexOf(\"://\");\n  int q=-1;\n  if (p > 0) {\n    q=address.indexOf('/',p + 3);\n  }\n  if (address.indexOf('{') > 0) {\n    return addressBraces(api,address);\n  }\n  boolean isPrefix=address.startsWith(\"session:\") || address.startsWith(\"pod:\");\n  if (address.isEmpty() || p > 0 && q < 0 && isPrefix) {\n    if (Vault.class.isAssignableFrom(api)) {\n      TypeRef itemRef=TypeRef.of(api).to(Vault.class).param(\"T\");\n      Class<?> assetClass=itemRef.rawClass();\n      address=address + \"/\" + apiAddress(assetClass);\n    }\n else {\n      address=address + \"/\" + apiAddress(api);\n    }\n  }\n  return address;\n}\n", "nl": "Calculate address from an API with an address default"}
{"code": "private void checkOrMarkPrivateAccess(Expression source,MethodNode mn){\n  if (mn == null) {\n    return;\n  }\n  ClassNode declaringClass=mn.getDeclaringClass();\n  ClassNode enclosingClassNode=typeCheckingContext.getEnclosingClassNode();\n  if (declaringClass != enclosingClassNode || typeCheckingContext.getEnclosingClosure() != null) {\n    int mods=mn.getModifiers();\n    boolean sameModule=declaringClass.getModule() == enclosingClassNode.getModule();\n    String packageName=declaringClass.getPackageName();\n    if (packageName == null) {\n      packageName=\"\";\n    }\n    if ((Modifier.isPrivate(mods) && sameModule)) {\n      addPrivateFieldOrMethodAccess(source,declaringClass,StaticTypesMarker.PV_METHODS_ACCESS,mn);\n    }\n else     if (Modifier.isProtected(mods) && !packageName.equals(enclosingClassNode.getPackageName()) && !implementsInterfaceOrIsSubclassOf(enclosingClassNode,declaringClass)) {\n      ClassNode cn=enclosingClassNode;\n      while ((cn=cn.getOuterClass()) != null) {\n        if (implementsInterfaceOrIsSubclassOf(cn,declaringClass)) {\n          addPrivateFieldOrMethodAccess(source,cn,StaticTypesMarker.PV_METHODS_ACCESS,mn);\n          break;\n        }\n      }\n    }\n  }\n}\n", "nl": "Given a method node, checks if we are calling a private method from an inner class."}
{"code": "public static void zipAndEncryptAll(File inZipFile,File outFile,String password,AESEncrypter encrypter) throws IOException {\n  AesZipFileEncrypter enc=new AesZipFileEncrypter(outFile,encrypter);\n  try {\n    enc.addAll(inZipFile,password);\n  }\n  finally {\n    enc.close();\n  }\n}\n", "nl": "Encrypt all files from an existing zip to one new \"zipOutFile\" using \"password\"."}
{"code": "void resetCache(Panel boundaryPanel,DragContext context){\n  ArrayList<Candidate> list=new ArrayList<Candidate>();\n  if (context.draggable != null) {\n    WidgetArea boundaryArea=new WidgetArea(boundaryPanel,null);\n    for (    DropController dropController : dropControllerList) {\n      Candidate candidate=new Candidate(dropController);\n      Widget dropTarget=candidate.getDropTarget();\n      if (DOM.isOrHasChild(context.draggable.getElement(),dropTarget.getElement())) {\n        continue;\n      }\n      if (candidate.getTargetArea().intersects(boundaryArea)) {\n        list.add(candidate);\n      }\n    }\n  }\n  sortedCandidates=list.toArray(new Candidate[list.size()]);\n  Arrays.sort(sortedCandidates);\n}\n", "nl": "Cache a list of eligible drop controllers, sorted by relative DOM positions of their respective drop targets. Called at the beginning of each drag operation, or whenever drop target eligibility has changed while dragging."}
{"code": "public static void main(String[] args){\n  ArrayList<String> tmpArgs=new ArrayList<String>(Arrays.asList(args));\n  int numThreads=1;\n  for (int i=0; i < tmpArgs.size() - 1; i++) {\n    if (tmpArgs.get(i).equals(\"-t\")) {\n      try {\n        numThreads=Integer.parseInt(tmpArgs.get(i + 1));\n        tmpArgs.remove(i + 1);\n        tmpArgs.remove(i);\n      }\n catch (      NumberFormatException e) {\n        System.err.println(\"Invalid number of threads.\");\n        System.err.println(e.getStackTrace());\n      }\n    }\n  }\n  logger.info(\"Number of threads:{}\",numThreads);\n  args=tmpArgs.toArray(new String[0]);\n  StringBuilder cliString=new StringBuilder();\n  for (int i=0; i < args.length; i++) {\n    cliString.append(\" \").append(args[i]);\n  }\n  logger.debug(\"Command line string = {}\",cliString.toString());\n  System.out.println(\"Command line string = \" + cliString.toString());\n  Task task=null;\n  try {\n    task=(Task)ClassOption.cliStringToObject(cliString.toString(),Task.class,null);\n    logger.info(\"Sucessfully instantiating {}\",task.getClass().getCanonicalName());\n  }\n catch (  Exception e) {\n    logger.error(\"Fail to initialize the task\",e);\n    System.out.println(\"Fail to initialize the task\" + e);\n    return;\n  }\n  task.setFactory(new ThreadsComponentFactory());\n  task.init();\n  ThreadsEngine.submitTopology(task.getTopology(),numThreads);\n}\n", "nl": "The main method."}
{"code": "public void testKeyPairGenerator11() throws NoSuchAlgorithmException, NoSuchProviderException {\n  if (!DSASupported) {\n    fail(NotSupportMsg);\n    return;\n  }\n  int[] keys={-10000,-1024,-1,0,10000};\n  KeyPairGenerator[] kpg=createKPGen();\n  assertNotNull(\"KeyPairGenerator objects were not created\",kpg);\n  SecureRandom random=new SecureRandom();\n  AlgorithmParameterSpec aps=null;\n  for (int i=0; i < kpg.length; i++) {\n    for (int j=0; j < keys.length; j++) {\n      try {\n        kpg[i].initialize(keys[j]);\n        kpg[i].initialize(keys[j],random);\n      }\n catch (      InvalidParameterException e) {\n      }\n    }\n    try {\n      kpg[i].initialize(aps);\n      kpg[i].initialize(aps,random);\n    }\n catch (    InvalidAlgorithmParameterException e) {\n    }\n  }\n}\n", "nl": "Test for methods: <code>initialize(int keysize)</code> <code>initialize(int keysize, SecureRandom random)</code> <code>initialize(AlgorithmParameterSpec param)</code> <code>initialize(AlgorithmParameterSpec param, SecureRandom random)</code> Assertion: throws InvalidParameterException or InvalidAlgorithmParameterException when parameters keysize or param are incorrect"}
{"code": "public static IMultiPoint[] randomPoints(int n,int d){\n  IMultiPoint points[]=new IMultiPoint[n];\n  for (int i=0; i < n; i++) {\n    StringBuilder sb=new StringBuilder();\n    for (int j=0; j < d; j++) {\n      sb.append(rGen.nextDouble());\n      if (j < d - 1) {\n        sb.append(\",\");\n      }\n    }\n    points[i]=new Hyperpoint(sb.toString());\n  }\n  return points;\n}\n", "nl": "generate array of n d-dimensional points whose coordinates are values in the range 0 .. 1"}
{"code": "public ObjectMatrix2D like2D(int rows,int columns){\n  return new SparseObjectMatrix2D(rows,columns);\n}\n", "nl": "Construct and returns a new 2-d matrix <i>of the corresponding dynamic type</i>, entirelly independent of the receiver. For example, if the receiver is an instance of type <tt>DenseObjectMatrix1D</tt> the new matrix must be of type <tt>DenseObjectMatrix2D</tt>, if the receiver is an instance of type <tt>SparseObjectMatrix1D</tt> the new matrix must be of type <tt>SparseObjectMatrix2D</tt>, etc."}
{"code": "public int connectSrcHandlerToPackageSync(Context srcContext,Handler srcHandler,String dstPackageName,String dstClassName){\n  if (DBG)   log(\"connect srcHandler to dst Package & class E\");\n  mConnection=new AsyncChannelConnection();\n  mSrcContext=srcContext;\n  mSrcHandler=srcHandler;\n  mSrcMessenger=new Messenger(srcHandler);\n  mDstMessenger=null;\n  Intent intent=new Intent(Intent.ACTION_MAIN);\n  intent.setClassName(dstPackageName,dstClassName);\n  boolean result=srcContext.bindService(intent,mConnection,Context.BIND_AUTO_CREATE);\n  if (DBG)   log(\"connect srcHandler to dst Package & class X result=\" + result);\n  return result ? STATUS_SUCCESSFUL : STATUS_BINDING_UNSUCCESSFUL;\n}\n", "nl": "Connect handler to named package/class synchronously."}
{"code": "@Override public int read() throws IOException {\nsynchronized (lock) {\n    checkNotClosed();\n    if (pos != count) {\n      return str.charAt(pos++);\n    }\n    return -1;\n  }\n}\n", "nl": "Reads a single character from the source string and returns it as an integer with the two higher-order bytes set to 0. Returns -1 if the end of the source string has been reached."}
{"code": "private void showFeedback(String message){\n  if (myHost != null) {\n    myHost.showFeedback(message);\n  }\n else {\n    System.out.println(message);\n  }\n}\n", "nl": "Used to communicate feedback pop-up messages between a plugin tool and the main Whitebox user-interface."}
{"code": "public boolean canBuildFormatter(){\n  return isFormatter(getFormatter());\n}\n", "nl": "Returns true if toFormatter can be called without throwing an UnsupportedOperationException."}
{"code": "public void unsetMatchColumn(int[] columnIdxes) throws SQLException {\n  throw new UnsupportedOperationException();\n}\n", "nl": "Unsets the designated parameter to the given int array. This was set using <code>setMatchColumn</code> as the column which will form the basis of the join. <P> The parameter value unset by this method should be same as was set."}
{"code": "public static boolean areColinear(Vec4 a,Vec4 b,Vec4 c){\n  if (a == null || b == null || c == null) {\n    String msg=Logging.getMessage(\"nullValue.Vec4IsNull\");\n    Logging.logger().severe(msg);\n    throw new IllegalArgumentException(msg);\n  }\n  Vec4 ab=b.subtract3(a).normalize3();\n  Vec4 bc=c.subtract3(b).normalize3();\n  return Math.abs(ab.dot3(bc)) > 0.999;\n}\n", "nl": "Indicates whether three vectors are colinear."}
{"code": "protected void reset(Point treePoint){\n  this.drawPoint.x=this.bounds.x + treePoint.x;\n  this.drawPoint.y=this.bounds.y + treePoint.y;\n  this.screenBounds=new Rectangle(this.drawPoint.x,this.drawPoint.y,this.bounds.width,this.bounds.height);\n  int pickX=this.pickBounds.x + treePoint.x;\n  int pickY=this.pickBounds.y + treePoint.y;\n  this.pickScreenBounds=new Rectangle(pickX,pickY,this.pickBounds.width,this.pickBounds.height);\n}\n", "nl": "Reset the draw point to the lower left corner of the node bounds."}
{"code": "public SimpleName newSimpleName(String identifier){\n  if (identifier == null) {\n    throw new IllegalArgumentException();\n  }\n  SimpleName result=new SimpleName(this);\n  result.setIdentifier(identifier);\n  return result;\n}\n", "nl": "Creates and returns a new unparented simple name node for the given identifier. The identifier should be a legal Java identifier, but not a keyword, boolean literal (\"true\", \"false\") or null literal (\"null\")."}
{"code": "public double unweightedMacroFmeasure(){\n  return m_delegate.unweightedMacroFmeasure();\n}\n", "nl": "Unweighted macro-averaged F-measure. If some classes not present in the test set, they're just skipped (since recall is undefined there anyway) ."}
{"code": "public HadoopJobHistoryNodeExtractor(Properties prop) throws Exception {\n  this.serverURL=prop.getProperty(Constant.AZ_HADOOP_JOBHISTORY_KEY);\n  String CURRENT_DIR=System.getProperty(\"user.dir\");\n  String WH_HOME=System.getenv(\"WH_HOME\");\n  String USER_HOME=System.getenv(\"HOME\") + \"/.kerberos\";\n  String ETC=\"/etc\";\n  String TMP=\"/var/tmp\" + \"/.kerberos\";\n  String[] allPositions=new String[]{CURRENT_DIR,WH_HOME,USER_HOME,TMP};\n  for (  String possition : allPositions) {\n    String gssFileName=possition + \"/gss-jaas.conf\";\n    File gssFile=new File(gssFileName);\n    if (gssFile.exists()) {\n      logger.debug(\"find gss-jaas.conf file in : {}\",gssFile.getAbsolutePath());\n      System.setProperty(\"java.security.auth.login.config\",gssFile.getAbsolutePath());\n      break;\n    }\n else {\n      logger.debug(\"can't find here: {}\",gssFile.getAbsolutePath());\n    }\n  }\n  for (  String possition : allPositions) {\n    String krb5FileName=possition + \"/krb5.conf\";\n    File krb5File=new File(krb5FileName);\n    if (krb5File.exists()) {\n      logger.debug(\"find krb5.conf file in : {}\",krb5File.getAbsolutePath());\n      System.setProperty(\"java.security.krb5.conf\",krb5File.getAbsolutePath());\n      break;\n    }\n else {\n      logger.debug(\"can't find here: {}\",krb5File.getAbsolutePath());\n    }\n  }\n  if (System.getProperty(\"java.security.auth.login.config\") == null || System.getProperty(\"java.security.krb5.conf\") == null) {\n    throw new Exception(\"Can't find java security config files\");\n  }\n  if (logger.isTraceEnabled()) {\n    System.setProperty(\"sun.security.krb5.debug\",\"true\");\n  }\n else {\n    System.setProperty(\"sun.security.krb5.debug\",\"false\");\n  }\n  System.setProperty(\"javax.security.auth.useSubjectCredsOnly\",\"false\");\n  System.setProperty(\"java.security.krb5.realm\",prop.getProperty(\"krb5.realm\"));\n  System.setProperty(\"java.security.krb5.kdc\",prop.getProperty(\"krb5.kdc\"));\n  PoolingHttpClientConnectionManager cm=new PoolingHttpClientConnectionManager();\n  cm.setMaxTotal(200);\n  cm.setDefaultMaxPerRoute(100);\n  CredentialsProvider credsProvider=new BasicCredentialsProvider();\n  credsProvider.setCredentials(AuthScope.ANY,new UsernamePasswordCredentials(\"DUMMY\",null));\n  Lookup<AuthSchemeProvider> authRegistry=RegistryBuilder.<AuthSchemeProvider>create().register(AuthSchemes.SPNEGO,new SPNegoSchemeFactory()).build();\n  httpClient=HttpClients.custom().setDefaultCredentialsProvider(credsProvider).setDefaultAuthSchemeRegistry(authRegistry).setConnectionManager(cm).build();\n}\n", "nl": "Use HTTPClient to connect to Hadoop job history server. Need to set the environment for kerberos, keytab..."}
{"code": "public Interval withDurationBeforeEnd(ReadableDuration duration){\n  long durationMillis=DateTimeUtils.getDurationMillis(duration);\n  if (durationMillis == toDurationMillis()) {\n    return this;\n  }\n  Chronology chrono=getChronology();\n  long endMillis=getEndMillis();\n  long startMillis=chrono.add(endMillis,durationMillis,-1);\n  return new Interval(startMillis,endMillis,chrono);\n}\n", "nl": "Creates a new interval with the specified duration before the end instant."}
{"code": "public void yypushback(int number){\n  if (number > yylength())   zzScanError(ZZ_PUSHBACK_2BIG);\n  zzMarkedPos-=number;\n}\n", "nl": "Pushes the specified amount of characters back into the input stream. They will be read again by then next call of the scanning method"}
{"code": "public Projection create(Properties props) throws ProjectionException {\n  try {\n    LatLonPoint llp=convertToLLP((Point2D)props.get(ProjectionFactory.CENTER));\n    float scale=PropUtils.floatFromProperties(props,ProjectionFactory.SCALE,10000000);\n    int height=PropUtils.intFromProperties(props,ProjectionFactory.HEIGHT,100);\n    int width=PropUtils.intFromProperties(props,ProjectionFactory.WIDTH,100);\n    return new Mercator(llp,scale,width,height);\n  }\n catch (  Exception e) {\n    if (Debug.debugging(\"proj\")) {\n      Debug.output(\"MercatorLoader: problem creating Mercator projection \" + e.getMessage());\n    }\n  }\n  throw new ProjectionException(\"MercatorLoader: problem creating Mercator projection\");\n}\n", "nl": "Create the projection with the given parameters."}
{"code": "@Override public void zoomRangeAxes(double lowerPercent,double upperPercent,PlotRenderingInfo info,Point2D source){\n  XYPlot subplot=findSubplot(info,source);\n  if (subplot != null) {\n    subplot.zoomRangeAxes(lowerPercent,upperPercent,info,source);\n  }\n else {\n    for (    XYPlot p : this.subplots) {\n      p.zoomRangeAxes(lowerPercent,upperPercent,info,source);\n    }\n  }\n}\n", "nl": "Zooms in on the range axes."}
{"code": "private void startReconcilingPositions(){\n  presenter.addAllPositions(removedPositions);\n  removedPositionCount=removedPositions.size();\n}\n", "nl": "Start reconciling positions."}
{"code": "public void actionPerformed(ActionEvent e){\n  log.info(\"Cmd=\" + e.getActionCommand());\n  if (e.getActionCommand().equals(ConfirmPanel.A_CANCEL)) {\n    dispose();\n    return;\n  }\n  saveSelection();\n  if (selection != null && selection.size() > 0 && m_selectionActive && m_DD_Order_ID != null && m_MovementDate != null)   generateMovements();\n else   dispose();\n}\n", "nl": "Action Listener"}
{"code": "UniformModel(final int numOutcomes){\n  mNumOutcomes=numOutcomes;\n}\n", "nl": "Construct a uniform model."}
{"code": "public int lengthOfLastWord(String s){\n  if (s == null || s.length() == 0)   return 0;\n  int len=s.length();\n  int count=0;\n  for (int i=len - 1; i >= 0; i--) {\n    if (s.charAt(i) != ' ')     count++;\n    if (s.charAt(i) == ' ' && count != 0)     return count;\n  }\n  return count;\n}\n", "nl": "Traverse backwards Use count to remember length of word Start counting from non-space char Return when next space is met and length is not zero"}
{"code": "private void updateProgress(String progressLabel,int progress){\n  if (myHost != null && ((progress != previousProgress) || (!progressLabel.equals(previousProgressLabel)))) {\n    myHost.updateProgress(progressLabel,progress);\n  }\n  previousProgress=progress;\n  previousProgressLabel=progressLabel;\n}\n", "nl": "Used to communicate a progress update between a plugin tool and the main Whitebox user interface."}
{"code": "public void trace(String msg,Throwable t){\n}\n", "nl": "Do nothing"}
{"code": "@Override protected void doGet(HttpServletRequest request,HttpServletResponse response){\n  processGetRequest(request,response);\n}\n", "nl": "Handles the HTTP <code>GET</code> method."}
{"code": "public ListIterator<VariableMapElement> iterator(){\n  return list.listIterator(0);\n}\n", "nl": "Creates and returns an enumerator for this object"}
{"code": "public GPUImage3x3ConvolutionFilter(final float[] convolutionKernel){\n  super(THREE_X_THREE_TEXTURE_SAMPLING_FRAGMENT_SHADER);\n  mConvolutionKernel=convolutionKernel;\n}\n", "nl": "Instantiates a new GPUimage3x3ConvolutionFilter with given convolution kernel."}
{"code": "@RequestMapping(value=BUSINESS_OBJECT_DATA_NOTIFICATIONS_URI_PREFIX + \"/namespaces/{namespace}/notificationNames/{notificationName}\",method=RequestMethod.PUT) @Secured(SecurityFunctions.FN_BUSINESS_OBJECT_DATA_NOTIFICATION_REGISTRATIONS_PUT) public BusinessObjectDataNotificationRegistration updateBusinessObjectDataNotificationRegistration(@PathVariable(\"namespace\") String namespace,@PathVariable(\"notificationName\") String notificationName,@RequestBody BusinessObjectDataNotificationRegistrationUpdateRequest request){\n  return businessObjectDataNotificationRegistrationService.updateBusinessObjectDataNotificationRegistration(new NotificationRegistrationKey(namespace,notificationName),request);\n}\n", "nl": "Updates an existing business object data notification by key. <p>Requires WRITE permission on namespace</p> <p>Requires READ permission on filter namespace</p> <p>Requires EXECUTE permission on ALL job action namespaces</p>"}
{"code": "boolean isDimming(){\n  return mTargetAlpha != 0;\n}\n", "nl": "Return true if dim layer is showing"}
{"code": "public static StringSet declaredSymbolsInScopeSet(ModuleNode module,Location loc){\n  StringSet result=new StringSet();\n  addDeclaredSymbolsInScopeSet(result,module,loc);\n  return result;\n}\n", "nl": "Returns a HashSet containing all user-definable names that are globally  defined or declared at Location loc of the module.  The returned value may or may not contain strings that are not user-definable names--in particular strings like \"I!bar\".   If the statement at loc defines or declares a symbol, that symbol does not appear in the returned value.  However, the implementation assumes that there there is no declaration or definition that begins on the same line as the beginning of loc.  If there is, the symbol it defines will not  appear in the returned result.  The method also assumes that loc is after any EXTENDS statement in the module."}
{"code": "private final void increaseConcentration(double by){\n  setConcentration(getConcentration() + by);\n}\n", "nl": "Increase the current concentration by a certain amount. According to increase the concentration the amount of nectar has to be recomputed."}
{"code": "public PostProcessor(int fboWidth,int fboHeight,boolean useDepth,boolean useAlphaChannel,boolean use32Bits){\n  this(fboWidth,fboHeight,useDepth,useAlphaChannel,use32Bits,TextureWrap.ClampToEdge,TextureWrap.ClampToEdge);\n}\n", "nl": "Construct a new PostProcessor with the given parameters, defaulting to <em>TextureWrap.ClampToEdge</em> as texture wrap mode"}
{"code": "public static void main(String[] args){\n  ComparableCircle comparableCircle1=new ComparableCircle(12.5);\n  ComparableCircle comparableCircle2=new ComparableCircle(18.3);\n  System.out.println(\"\\nComparableCircle1:\");\n  System.out.println(comparableCircle1);\n  System.out.println(\"\\nComparableCircle2:\");\n  System.out.println(comparableCircle2);\n  System.out.println((comparableCircle1.compareTo(comparableCircle2) == 1 ? \"\\nComparableCircle1 \" : \"\\nComparableCircle2 \") + \"is the larger of the two Circles\");\n}\n", "nl": "Main method"}
{"code": "public FilterQuery track(final String[] track){\n  this.track=track;\n  return this;\n}\n", "nl": "Sets track"}
{"code": "public static PolygonRDD SpatialRangeQueryUsingIndex(PolygonRDD polygonRDD,Envelope envelope,Integer condition){\n  if (polygonRDD.indexedRDDNoId == null) {\n    throw new NullPointerException(\"Need to invoke buildIndex() first, indexedRDDNoId is null\");\n  }\n  JavaRDD<Polygon> result=polygonRDD.indexedRDDNoId.mapPartitions(new PolygonRangeFilterUsingIndex(envelope));\n  return new PolygonRDD(result);\n}\n", "nl": "Spatial range query on top of PolygonRDD"}
{"code": "public byte[] analyzeWavData(InputStream i){\n  try {\n    int headSize=44, metaDataSize=48;\n    byte[] data=IOUtils.toByteArray(i);\n    if (data.length < headSize) {\n      throw new IOException(\"Wrong Wav header\");\n    }\n    if (this.sampleRate == 0 && data.length > 28) {\n      this.sampleRate=readInt(data,24);\n    }\n    int destPos=headSize + metaDataSize;\n    int rawLength=data.length - destPos;\n    byte[] d=new byte[rawLength];\n    System.arraycopy(data,destPos,d,0,rawLength);\n    return d;\n  }\n catch (  IOException e) {\n    Log.e(TAG,\"Error while formatting header\");\n  }\n  return new byte[0];\n}\n", "nl": "Analyze sample rate and return the PCM data"}
{"code": "public Quaterniond scale(double factor){\n  return scale(factor,this);\n}\n", "nl": "Scale the rotation represented by this quaternion by the given <code>factor</code> using spherical linear interpolation. <p> This method is equivalent to performing a spherical linear interpolation between the unit quaternion and <code>this</code>, and thus equivalent to calling: <tt>new Quaterniond().slerp(this, factor)</tt> <p> Reference: <a href=\"http://fabiensanglard.net/doom3_documentation/37725-293747_293747.pdf\">http://fabiensanglard.net</a>"}
{"code": "private void handleDispose(){\n  if (infoFont != null && !infoFont.isDisposed()) {\n    infoFont.dispose();\n  }\n  infoFont=null;\n  if (titleFont != null && !titleFont.isDisposed()) {\n    titleFont.dispose();\n  }\n  titleFont=null;\n}\n", "nl": "The dialog is being disposed. Dispose of any resources allocated."}
{"code": "public String prepareTable(ColumnInfo[] layout,String from,String where,boolean multiSelection,String tableName,boolean addAccessSQL){\n  int columnIndex=0;\n  StringBuffer sql=new StringBuffer(\"SELECT \");\n  setLayout(layout);\n  clearColumns();\n  setColorColumn(-1);\n  setMultiSelection(multiSelection);\n  for (columnIndex=0; columnIndex < layout.length; columnIndex++) {\n    if (columnIndex > 0) {\n      sql.append(\", \");\n    }\n    sql.append(layout[columnIndex].getColSQL());\n    if (layout[columnIndex].isKeyPairCol()) {\n      sql.append(\",\").append(layout[columnIndex].getKeyPairColSQL());\n    }\n    addColumn(layout[columnIndex]);\n    if (layout[columnIndex].isColorColumn()) {\n      setColorColumn(columnIndex);\n    }\n    if (layout[columnIndex].getColClass() == IDColumn.class) {\n      setKeyColumnIndex(columnIndex);\n    }\n  }\n  for (columnIndex=0; columnIndex < layout.length; columnIndex++) {\n    setColumnClass(columnIndex,layout[columnIndex].getColClass(),layout[columnIndex].isReadOnly(),layout[columnIndex].getColHeader());\n  }\n  sql.append(\" FROM \").append(from);\n  sql.append(\" WHERE \").append(where);\n  if (from.length() == 0) {\n    return sql.toString();\n  }\n  if (addAccessSQL) {\n    String finalSQL=MRole.getDefault().addAccessSQL(sql.toString(),tableName,MRole.SQL_FULLYQUALIFIED,MRole.SQL_RO);\n    logger.finest(finalSQL);\n    return finalSQL;\n  }\n else {\n    return sql.toString();\n  }\n}\n", "nl": "Prepare Table and return SQL required to get resultset to populate table"}
{"code": "public ReadInputRegistersRequest(int ref,int count){\n  super();\n  setFunctionCode(Modbus.READ_INPUT_REGISTERS);\n  setDataLength(4);\n  setReference(ref);\n  setWordCount(count);\n}\n", "nl": "Constructs a new <tt>ReadInputRegistersRequest</tt> instance with a given reference and count of words to be read. <p>"}
{"code": "protected void correlatedPointAddedCallback(int correlatedTimeStep){\n  boolean sourceMatches=false;\n  if (Math.abs(sourceObs - source[correlatedTimeStep]) <= kernelWidthSourceInUse) {\n    countPastSource++;\n    sourceMatches=true;\n  }\n  if (Math.abs(destNextObs - destNext[correlatedTimeStep]) <= kernelWidthsInUse[0]) {\n    countNextPast++;\n    if (sourceMatches) {\n      countNextPastSource++;\n    }\n  }\n}\n", "nl": "A callback for where a correlated point is found at correlatedTimeStep in the destination's past. Now check whether we need to increment the joint counts."}
{"code": "public void showFab(float translationX,float translationY){\n  setFabAnchor(translationX,translationY);\n  if (!isSheetVisible()) {\n    fab.show(translationX,translationY);\n  }\n}\n", "nl": "Shows the FAB and sets the FAB's translation."}
{"code": "@Override public void add(Permission permission){\n  if (!(permission instanceof PackagePermission))   throw new IllegalArgumentException(\"invalid permission: \" + permission);\n  if (isReadOnly())   throw new SecurityException(\"attempt to add a Permission to a \" + \"readonly PermissionCollection\");\n  PackagePermission pp=(PackagePermission)permission;\n  String name=pp.getName();\n  PackagePermission existing=(PackagePermission)permissions.get(name);\n  if (existing != null) {\n    int oldMask=existing.getMask();\n    int newMask=pp.getMask();\n    if (oldMask != newMask) {\n      permissions.put(name,new PackagePermission(name,oldMask | newMask));\n    }\n  }\n else {\n    permissions.put(name,permission);\n  }\n  if (!all_allowed) {\n    if (name.equals(\"*\"))     all_allowed=true;\n  }\n}\n", "nl": "Adds a permission to the <tt>PackagePermission</tt> objects. The key for the hash is the name."}
{"code": "protected boolean convertToUppercase(){\n  return false;\n}\n", "nl": "Method convertToUppercase."}
{"code": "public void queryGreaterThan(String type,int index,String value,int page,int limit,int visibilityScope,CloudResponse<CloudObject[]> response){\n  try {\n    queryImpl(type,value,index,page,limit,visibilityScope,2,0,false,false,false,response);\n  }\n catch (  CloudException e) {\n    response.onError(e);\n  }\n}\n", "nl": "Performs a query to the server finding the objects where the key value is greater than the given value.  This operation executes immeditely without waiting for commit."}
{"code": "public static byte[] parseSchemeSpecificData(byte[] atom,UUID uuid){\n  Pair<UUID,byte[]> parsedAtom=parsePsshAtom(atom);\n  if (parsedAtom == null) {\n    return null;\n  }\n  if (uuid != null && !uuid.equals(parsedAtom.first)) {\n    Log.w(TAG,\"UUID mismatch. Expected: \" + uuid + \", got: \"+ parsedAtom.first+ \".\");\n    return null;\n  }\n  return parsedAtom.second;\n}\n", "nl": "Parses the scheme specific data from a PSSH atom. Version 0 and 1 PSSH atoms are supported. <p> The scheme specific data is only parsed if the data is a valid PSSH atom matching the given UUID, or if the data is a valid PSSH atom of any type in the case that the passed UUID is null."}
{"code": "private boolean termFilter(Term term,String[] desiredFields,int minFreq,int maxFreq,int maxNonAlphabet,boolean filterNumbers,int minTermLength){\n  if (filterNumbers) {\n    try {\n      Double.parseDouble(term.text());\n      return false;\n    }\n catch (    Exception e) {\n    }\n  }\n  return termFilter(term,desiredFields,minFreq,maxFreq,maxNonAlphabet,minTermLength);\n}\n", "nl": "Applies termFilter and additionally (if requested) filters out digit-only words."}
{"code": "protected String int2singlealphaCount(long val,CharArrayWrapper table){\n  int radix=table.getLength();\n  if (val > radix) {\n    return getZeroString();\n  }\n else   return (new Character(table.getChar((int)val - 1))).toString();\n}\n", "nl": "Convert a long integer into alphabetic counting, in other words count using the sequence A B C ... Z."}
{"code": "public void componentHidden(final ComponentEvent e){\n  setVisible(false);\n}\n", "nl": "Invoked when the component has been made invisible. MenuComponent.setVisible does nothing, so we remove the ScreenMenuItem from the ScreenMenu but leave it in fItems"}
{"code": "protected Position computeMainLabelPosition(DrawContext dc,TacticalGraphicLabel label,Position midpoint,Position posB){\n  Globe globe=dc.getGlobe();\n  Vec4 pMid=globe.computePointFromPosition(midpoint);\n  Vec4 pB=globe.computePointFromPosition(posB);\n  Vec4 normal=globe.computeSurfaceNormalAtPoint(pMid);\n  Vec4 vMB=pB.subtract3(pMid);\n  Vec4 eyePoint=dc.getView().getEyePoint();\n  double pixelSize=dc.getView().computePixelSizeAtDistance(eyePoint.distanceTo3(pMid));\n  Rectangle labelBounds=label.getBounds(dc);\n  double labelDiagonal=labelBounds != null ? Math.hypot(labelBounds.width,labelBounds.height) : 0d;\n  double pixelDistance=labelDiagonal / 2.0;\n  Vec4 perpendicular=vMB.cross3(normal);\n  perpendicular=perpendicular.normalize3().multiply3(this.getWidth() / 2.0 + pixelDistance * pixelSize);\n  Vec4 pLabel=pMid.add3(perpendicular);\n  return globe.computePositionFromPoint(pLabel);\n}\n", "nl": "Compute the position of the graphic's main label. This label is positioned to the side of the first segment along the route."}
{"code": "protected void validateState(State currentState){\n  ValidationUtils.validateState(currentState);\n}\n", "nl": "Validate the service state for coherence."}
{"code": "public void updateTableEntity(TableEntity tableEntity,boolean commit){\n  SolrInputDocument doc=new SolrInputDocument();\n  doc.setField(ID,tableEntity.getFqdn());\n  doc.setField(TYPE,TYPE_TABLE);\n  doc.setField(DATABASE_NAME,tableEntity.getDatabaseName());\n  doc.setField(TABLE_NAME,tableEntity.getTableName());\n  doc.setField(FIELDS,tableEntity.getFieldNames());\n  doc.setField(TRANSFORMATION,tableEntity.getTransformationType().split(\" -> \")[0]);\n  doc.setField(EXPORTS,tableEntity.getExportNames());\n  doc.setField(STORAGE_FORMAT,tableEntity.getStorageFormat());\n  doc.setField(MATERIALIZE_ONCE,tableEntity.isMaterializeOnce());\n  doc.setField(EXTERNAL,tableEntity.isExternalTable());\n  doc.setField(CREATED_AT,tableEntity.getCreatedAt());\n  doc.setField(OWNER,tableEntity.getTableOwner());\n  doc.setField(DESCRIPTION,tableEntity.getTableDescription());\n  doc.setField(TAXONOMIES,tableEntity.getTaxonomyNames());\n  doc.setField(CATEGORIES,tableEntity.getCategoryNames());\n  doc.setField(CATEGORIE_OBJECTSS,tableEntity.getCategoryObjectNames());\n  doc.setField(TAGS,tableEntity.getTags());\n  doc.setField(STATUS,tableEntity.getStatus());\n  if (tableEntity.getComment() != null) {\n    doc.setField(DOCUMENTATION,tableEntity.getComment().getPlainText());\n    String comments=\"\";\n    for (    CommentEntity comment : tableEntity.getComments()) {\n      if (!comments.isEmpty()) {\n        comments+=\"     \";\n      }\n      comments+=comment.getUsername() + \": \" + comment.getPlainText();\n    }\n    if (!comments.isEmpty()) {\n      doc.setField(COMMENTS,comments);\n    }\n  }\n  addDocument(doc);\n  if (commit) {\n    commit();\n  }\n}\n", "nl": "Updates the Solr document for the given table entity"}
{"code": "private ArrayDBIDs initialSet(DBIDs sampleSet,int k,Random random){\n  return DBIDUtil.ensureArray(DBIDUtil.randomSample(sampleSet,k,random));\n}\n", "nl": "Returns a set of k elements from the specified sample set."}
{"code": "private byte[] blockFragmentizerSafe(long blockIdx) throws IOException {\n  try {\n    try {\n      return block(blockIdx);\n    }\n catch (    IgfsCorruptedFileException e) {\n      if (log.isDebugEnabled())       log.debug(\"Failed to fetch file block [path=\" + path + \", fileInfo=\"+ fileInfo+ \", blockIdx=\"+ blockIdx+ \", errMsg=\"+ e.getMessage()+ ']');\n      if (fileInfo != null && fileInfo.fileMap() != null && !fileInfo.fileMap().ranges().isEmpty()) {\n        IgfsEntryInfo newInfo=igfsCtx.meta().info(fileInfo.id());\n        if (newInfo == null)         throw new IgfsPathNotFoundException(\"Failed to read file block (file was concurrently \" + \"deleted) [path=\" + path + \", blockIdx=\"+ blockIdx+ ']');\n        fileInfo=newInfo;\n        locCache.clear();\n        if (log.isDebugEnabled())         log.debug(\"Updated input stream file info after block fetch failure [path=\" + path + \", fileInfo=\"+ fileInfo+ ']');\n        return block(blockIdx);\n      }\n      throw new IOException(e.getMessage(),e);\n    }\n  }\n catch (  IgniteCheckedException e) {\n    throw new IOException(e.getMessage(),e);\n  }\n}\n", "nl": "Method to safely retrieve file block. In case if file block is missing this method will check file map and update file info. This may be needed when file that we are reading is concurrently fragmented."}
{"code": "public ReplacableProperties loadProperties(){\n  ReplacableProperties propertiesBeingLoaded=new ReplacableProperties();\n  try (InputStream propertiesToLoad=PlayOnLinuxContext.class.getClassLoader().getResourceAsStream(this.getPropertyFileName())){\n    propertiesBeingLoaded.load(propertiesToLoad);\n  }\n catch (  PlayOnLinuxException|IOException e) {\n    throw new PlayOnLinuxRuntimeException(\"Cannot load properties\",e);\n  }\n  return propertiesBeingLoaded;\n}\n", "nl": "Get the properties for the current OS"}
{"code": "public ThumbnailParameterBuilder fitWithinDimensions(boolean fit){\n  this.fitWithinDimensions=fit;\n  return this;\n}\n", "nl": "Sets whether or not the thumbnail should fit within the specified dimensions."}
{"code": "private boolean isBoundsEnforced(){\n  return boundsEnforced;\n}\n", "nl": "True iff bounds checking is performed on variable values indices."}
{"code": "@SuppressWarnings(\"unchecked\") public JdbcData(Connection connection,String table,boolean buffered){\n  this.connection=connection;\n  this.table=table;\n  setBuffered(buffered);\n  try {\n    setColumnTypes(getJdbcColumnTypes());\n  }\n catch (  SQLException e) {\n    e.printStackTrace();\n  }\n}\n", "nl": "Initializes a new instance to query the data from a specified table using a specified JDBC connection. It is assumed the table columns are constant during the connection."}
{"code": "public void dispatch(){\n  try {\n    if (catchExceptions) {\n      try {\n        runnable.run();\n      }\n catch (      Throwable t) {\n        if (t instanceof Exception) {\n          exception=(Exception)t;\n        }\n        throwable=t;\n      }\n    }\n else {\n      runnable.run();\n    }\n  }\n  finally {\n    finishedDispatching(true);\n  }\n}\n", "nl": "Executes the Runnable's <code>run()</code> method and notifies the notifier (if any) when <code>run()</code> has returned or thrown an exception."}
{"code": "public void lock(){\n  lockPositions(true);\n  this.locked=true;\n}\n", "nl": "Lock this Order."}
{"code": "private int measureLong(int measureSpec){\n  int result;\n  int specMode=MeasureSpec.getMode(measureSpec);\n  int specSize=MeasureSpec.getSize(measureSpec);\n  if ((specMode == MeasureSpec.EXACTLY) || (mViewPager == null)) {\n    result=specSize;\n  }\n else {\n    final int count=mViewPager.getAdapter().getCount();\n    result=(int)(getPaddingLeft() + getPaddingRight() + (count * 2 * mRadius)+ (count - 1) * mRadius + 1);\n    if (specMode == MeasureSpec.AT_MOST) {\n      result=Math.min(result,specSize);\n    }\n  }\n  return result;\n}\n", "nl": "Determines the width of this view"}
{"code": "public void trace(String format,Object arg1,Object arg2){\n}\n", "nl": "Do nothing"}
{"code": "public static String makeKey(String host,int port,String transport){\n  return new StringBuffer(host).append(\":\").append(port).append(\"/\").append(transport).toString().toLowerCase();\n}\n", "nl": "Construct a key to refer to this structure from the SIP stack"}
{"code": "protected void buildSettings(){\n  SETTINGS=SEARCH_SETTINGS;\n}\n", "nl": "Sets SETTINGS to be the static SEARCH_SETTINGS, instead of constructing a new one for each ResultPanel."}
{"code": "public void testNoElementThrowsException(){\n  try {\n    util.selectElementMatchingXPath(\"app-deployment\",testElement);\n    fail(\"should have thrown an exception\");\n  }\n catch (  ElementNotFoundException e) {\n    assertEquals(testElement,e.getSearched());\n  }\n}\n", "nl": "Test that search for a non-existing element throws an exception."}
{"code": "public String replace(final StringBuffer source,final int offset,final int length){\n  if (source == null) {\n    return null;\n  }\n  final StrBuilder buf=new StrBuilder(length).append(source,offset,length);\n  substitute(buf,0,length);\n  return buf.toString();\n}\n", "nl": "Replaces all the occurrences of variables with their matching values from the resolver using the given source buffer as a template. The buffer is not altered by this method. <p> Only the specified portion of the buffer will be processed. The rest of the buffer is not processed, and is not returned."}
{"code": "public Builder addKernel(Script.KernelID k){\n  if (mLines.size() != 0) {\n    throw new RSInvalidStateException(\"Kernels may not be added once connections exist.\");\n  }\n  if (findNode(k) != null) {\n    return this;\n  }\n  mKernelCount++;\n  Node n=findNode(k.mScript);\n  if (n == null) {\n    n=new Node(k.mScript);\n    mNodes.add(n);\n  }\n  n.mKernels.add(k);\n  return this;\n}\n", "nl": "Adds a Kernel to the group."}
{"code": "@Override public void unregisterVASACertificate(String existingCertificate) throws InvalidCertificate, InvalidSession, StorageFault {\n  final String methodName=\"unregisterVASACertificate(): \";\n  log.debug(methodName + \"Entry with input existingCertificate[\" + (existingCertificate != null ? \"***\" : null)+ \"]\");\n  try {\n    _sslUtil.checkHttpRequest(true,true);\n    X509Certificate x509Cert=(X509Certificate)_sslUtil.buildCertificate(existingCertificate);\n    SimpleTimeCounter counter=new SimpleTimeCounter(\"unregisterVASACertificate\");\n    unregisterCertificate(x509Cert);\n    counter.stop();\n  }\n catch (  InvalidSession is) {\n    log.error(methodName + \"invalid session\",is);\n    throw is;\n  }\ncatch (  InvalidCertificate ic) {\n    log.error(methodName + \"invalid certificate\",ic);\n    throw ic;\n  }\ncatch (  StorageFault sf) {\n    log.error(methodName + \"storage fault occured \",sf);\n    throw sf;\n  }\ncatch (  Exception e) {\n    log.error(methodName + \"unknown exception\",e);\n    throw FaultUtil.StorageFault(\"runtime \",e);\n  }\n  log.debug(methodName + \"Exit\");\n}\n", "nl": "vasaService interface"}
{"code": "K key(){\n  return key;\n}\n", "nl": "Getter of key."}
{"code": "private void clearListSelection(){\n  _pathList.clearSelection();\n  int state=_block.getState() & ~OBlock.ALLOCATED;\n  _block.pseudoPropertyChange(\"state\",Integer.valueOf(0),Integer.valueOf(state));\n  _length.setText(\"\");\n}\n", "nl": "*********************** end setup"}
{"code": "public static String[] stringArrayFromString(String string,char delimiter){\n  List<String> result=new ArrayList<String>(10);\n  if (StringUtils.isNotBlank(string)) {\n    RaptorStringTokenizer tok=new RaptorStringTokenizer(string,String.valueOf(delimiter),false);\n    while (tok.hasMoreTokens()) {\n      String token=tok.nextToken();\n      result.add(token);\n    }\n  }\n  return result.toArray(new String[0]);\n}\n", "nl": "Returns a String[] of strings from a string that is formatted in what toString(String[]) returns."}
{"code": "public boolean startsWith(XMLString prefix){\n  return startsWith(prefix,0);\n}\n", "nl": "Tests if this string starts with the specified prefix."}
{"code": "public boolean isEnableMove(){\n  return this.enableMove;\n}\n", "nl": "Specifies whether the user can move the frame by dragging the title bar."}
{"code": "public String toString(){\n  return \"[Certificate Exception: \" + getMessage() + \"]\";\n}\n", "nl": "Returns a string describing the certificate exception."}
{"code": "public DistributionLocatorId(int port,String bindAddress){\n  this(port,bindAddress,null);\n}\n", "nl": "Constructs a DistributionLocatorId with the given port. The host will be set to the local host."}
{"code": "@Override public double kurtosis(){\n  QL.require(sampleNumber_ > 3,UNSUFFICIENT_SAMPLE_NUMBER_3);\n  double m=mean();\n  double v=variance();\n  double c=(sampleNumber_ - 1.0) / (sampleNumber_ - 2.0);\n  c*=(sampleNumber_ - 1.0) / (sampleNumber_ - 3.0);\n  c*=3.0;\n  if (v == 0)   return c;\n  double result=fourthPowerSum_ / sampleWeight_;\n  result-=4.0 * m * (cubicSum_ / sampleWeight_);\n  result+=6.0 * m * m* (quadraticSum_ / sampleWeight_);\n  result-=3.0 * m * m* m* m;\n  result/=v * v;\n  result*=sampleNumber_ / (sampleNumber_ - 1.0);\n  result*=sampleNumber_ / (sampleNumber_ - 2.0);\n  result*=(sampleNumber_ + 1.0) / (sampleNumber_ - 3.0);\n  return result - c;\n}\n", "nl": "returns the excess kurtosis, defined as \\fracN^2(N+1)}{(N-1)(N-2)(N-3)} \\frac{\\left\\langle \\left(x-\\langle x \\rangle \\right)^4 \\right\\rangle}{\\sigma^4} - \\frac{3(N-1)^2}{(N-2)(N-3)}. } The above evaluates to 0 for a Gaussian distribution."}
{"code": "public void testSneakyFieldTypes() throws Exception {\n  TypeFactory tf=TypeFactory.defaultInstance();\n  Field field=SneakyBean.class.getDeclaredField(\"intMap\");\n  JavaType type=tf.constructType(field.getGenericType());\n  assertTrue(type instanceof MapType);\n  MapType mapType=(MapType)type;\n  assertEquals(tf.constructType(Integer.class),mapType.getKeyType());\n  assertEquals(tf.constructType(Long.class),mapType.getContentType());\n  field=SneakyBean.class.getDeclaredField(\"longList\");\n  type=tf.constructType(field.getGenericType());\n  assertTrue(type instanceof CollectionType);\n  CollectionType collectionType=(CollectionType)type;\n  assertEquals(tf.constructType(Long.class),collectionType.getContentType());\n}\n", "nl": "Plus sneaky types may be found via introspection as well."}
{"code": "public LambdaContainer(LambdaBlock wrapper,int arity){\n  super();\n  this.loadFXML(\"LambdaContainer\");\n  this.wrapper=wrapper;\n  attachedBlocks=new HashSet<>();\n  this.args=new ArrayList<>();\n  for (int i=0; i < arity; i++) {\n    this.args.add(new BinderAnchor(this,wrapper,new Binder(\"a_\" + i)));\n  }\n  this.res=new ResultAnchor(this,wrapper,Optional.empty());\n  this.argSpace.getChildren().addAll(this.args);\n  this.resSpace.getChildren().add(this.res);\n  TouchContext context=new TouchContext(this,false);\n  context.setPanningAction(null);\n}\n", "nl": "Constructs a LambdaContainer for an untyped lambda of n arguments."}
{"code": "public void mouseDragged(final MouseEvent e){\n  if (drawingWalls) {\n    draggingPoint=e.getPoint();\n    repaint();\n  }\n  if (selectedEntity != null) {\n    final Point test=new Point(e.getPoint().x + distanceX,e.getPoint().y + distanceY);\n    final Rectangle testRect=new Rectangle((int)test.getX(),(int)test.getY(),selectedEntity.getWidth(),selectedEntity.getHeight());\n    testRect.grow(-5,-5);\n    if (getBounds().contains((testRect.getBounds()))) {\n      selectedEntity.setX(test.x);\n      selectedEntity.setY(test.y);\n      repaint();\n    }\n  }\n}\n", "nl": "Task to perform when mouse button is held and mouse moved."}
{"code": "private void fillNewTags(final Map<String,Object> dataModel) throws Exception {\n  dataModel.put(Common.NEW_TAGS,tagQueryService.getNewTags(Symphonys.getInt(\"newTagsCnt\")));\n}\n", "nl": "Fils new tags."}
{"code": "public void listaTiposDocumentosExecuteLogic(ActionMapping mappings,ActionForm form,HttpServletRequest request,HttpServletResponse response){\n  saveCurrentInvocation(KeysClientsInvocations.DOCUMENTOS_VITALES_VER_TIPOS_DOCUMENTOS,request);\n  request.setAttribute(DocumentosVitalesConstants.TIPOS_DOCUMENTOS_VITALES_KEY,getGestionDocumentosVitalesBI(request).getTiposDocumentosVitales());\n  setReturnActionFordward(request,mappings.findForward(\"ver_tipos\"));\n}\n", "nl": "Muestra la lista de tipos de documentos vitales."}
{"code": "public MicroPipelineManager(final String processingNodeId,final ComponentRepository componentRepository,final int maxNumberOfThreads) throws RequiredInputMissingException {\n  if (componentRepository == null)   throw new RequiredInputMissingException(\"Missing required component repository\");\n  if (StringUtils.isBlank(processingNodeId))   throw new RequiredInputMissingException(\"Missing required processing node identifier\");\n  this.processingNodeId=StringUtils.lowerCase(StringUtils.trim(processingNodeId));\n  this.microPipelineFactory=new MicroPipelineFactory(this.processingNodeId,componentRepository);\n  if (maxNumberOfThreads == 1)   this.executorService=Executors.newSingleThreadExecutor();\n else   if (maxNumberOfThreads > 1)   this.executorService=Executors.newFixedThreadPool(maxNumberOfThreads);\n else   this.executorService=Executors.newCachedThreadPool();\n}\n", "nl": "Initializes the micro pipeline manager"}
{"code": "@Override public void close(){\n  _client.destroy();\n}\n", "nl": "Close the client"}
{"code": "private void returnData(Object ret){\n  if (myHost != null) {\n    myHost.returnData(ret);\n  }\n}\n", "nl": "Used to communicate a return object from a plugin tool to the main Whitebox user-interface."}
{"code": "public static LoggingFraction createDefaultLoggingFraction(Level level){\n  return new LoggingFraction().applyDefaults(level);\n}\n", "nl": "Create a default logging fraction for the specified level."}
{"code": "public void init() throws ServletException {\n}\n", "nl": "Initialization of the servlet. <br>"}
{"code": "public static synchronized Bitmap decodeSampledBitmapFromFile(String filename,int reqWidth,int reqHeight){\n  final BitmapFactory.Options options=new BitmapFactory.Options();\n  options.inJustDecodeBounds=true;\n  BitmapFactory.decodeFile(filename,options);\n  options.inSampleSize=calculateInSampleSize(options,reqWidth,reqHeight);\n  options.inJustDecodeBounds=false;\n  return BitmapFactory.decodeFile(filename,options);\n}\n", "nl": "Decode and sample down a bitmap from a file to the requested width and height."}
{"code": "public Quaterniond rotateLocalX(double angle){\n  return rotateLocalX(angle,this);\n}\n", "nl": "Apply a rotation to <code>this</code> quaternion rotating the given radians about the local x axis. <p> If <code>Q</code> is <code>this</code> quaternion and <code>R</code> the quaternion representing the  specified rotation, then the new quaternion will be <code>R * Q</code>. So when transforming a vector <code>v</code> with the new quaternion by using <code>R * Q * v</code>, the rotation represented by <code>this</code> will be applied first!"}
{"code": "DrmConstraintInfo(){\n  count=-1;\n  startDate=-1;\n  endDate=-1;\n  interval=-1;\n}\n", "nl": "Construct the DrmConstraint."}
{"code": "private InstrumentationNode cloneWithNewTarget(ValueNode newTarget,VirtualizerTool tool){\n  InstrumentationNode clone=new InstrumentationNode(newTarget,anchored,weakDependencies.size(),stateBefore);\n  clone.instrumentationGraph=instrumentationGraph;\n  for (int i=0; i < weakDependencies.size(); i++) {\n    ValueNode input=weakDependencies.get(i);\n    if (!(input instanceof VirtualObjectNode)) {\n      ValueNode alias=tool.getAlias(input);\n      if (alias instanceof VirtualObjectNode) {\n        clone.weakDependencies.initialize(i,alias);\n        continue;\n      }\n    }\n    clone.weakDependencies.initialize(i,input);\n  }\n  return clone;\n}\n", "nl": "Clone the InstrumentationNode with the given new target. The weakDependencies will be initialized with aliased nodes."}
{"code": "public SaveAsAction(KseFrame kseFrame){\n  super(kseFrame);\n  putValue(ACCELERATOR_KEY,KeyStroke.getKeyStroke(res.getString(\"SaveAsAction.accelerator\").charAt(0),Toolkit.getDefaultToolkit().getMenuShortcutKeyMask() + InputEvent.ALT_MASK));\n  putValue(LONG_DESCRIPTION,res.getString(\"SaveAsAction.statusbar\"));\n  putValue(NAME,res.getString(\"SaveAsAction.text\"));\n  putValue(SHORT_DESCRIPTION,res.getString(\"SaveAsAction.tooltip\"));\n  putValue(SMALL_ICON,new ImageIcon(Toolkit.getDefaultToolkit().createImage(getClass().getResource(res.getString(\"SaveAsAction.image\")))));\n}\n", "nl": "Construct action."}
{"code": "public synchronized void flush() throws IOException {\n  checkNotClosed();\n  trimToSize();\n  trimToFileCount();\n  journalWriter.flush();\n}\n", "nl": "Force buffered operations to the filesystem."}
{"code": "@Override void initAnimation(){\n  if (!mInitialized) {\n    int numValues=mValues.length;\n    for (int i=0; i < numValues; ++i) {\n      mValues[i].setupSetterAndGetter(mTarget);\n    }\n    super.initAnimation();\n  }\n}\n", "nl": "This function is called immediately before processing the first animation frame of an animation. If there is a nonzero <code>startDelay</code>, the function is called after that delay ends. It takes care of the final initialization steps for the animation. This includes setting mEvaluator, if the user has not yet set it up, and the setter/getter methods, if the user did not supply them. <p>Overriders of this method should call the superclass method to cause internal mechanisms to be set up correctly.</p>"}
{"code": "public StatementBuilder(String string){\n  builder=new StringBuilder(string);\n}\n", "nl": "Create a new builder."}
{"code": "private void relocateFromHeaders(ByteBuffer f,SceModule module,int baseAddress,Elf32 elf,int elfOffset) throws IOException {\n  int i=0;\n  for (  Elf32ProgramHeader phdr : elf.getProgramHeaderList()) {\n    if (phdr.getP_type() == 0x700000A0L) {\n      int RelCount=phdr.getP_filesz() / Elf32Relocate.sizeof();\n      if (log.isDebugEnabled()) {\n        log.debug(String.format(\"PH#%d: relocating %d entries\",i,RelCount));\n      }\n      f.position(elfOffset + phdr.getP_offset());\n      relocateFromBuffer(f,module,baseAddress,elf,RelCount,true);\n      return;\n    }\n else     if (phdr.getP_type() == 0x700000A1L) {\n      if (log.isDebugEnabled()) {\n        log.debug(String.format(\"Type 0x700000A1 PH#%d: relocating A1 entries, size=0x%X\",i,phdr.getP_filesz()));\n      }\n      f.position(elfOffset + phdr.getP_offset());\n      relocateFromBufferA1(f,elf,baseAddress,i,phdr.getP_filesz());\n      return;\n    }\n    i++;\n  }\n  for (  Elf32SectionHeader shdr : elf.getSectionHeaderList()) {\n    if (mustRelocate(elf,shdr)) {\n      int RelCount=shdr.getSh_size() / Elf32Relocate.sizeof();\n      if (log.isDebugEnabled()) {\n        log.debug(shdr.getSh_namez() + \": relocating \" + RelCount+ \" entries\");\n      }\n      f.position(elfOffset + shdr.getSh_offset());\n      relocateFromBuffer(f,module,baseAddress,elf,RelCount,shdr.getSh_type() != Elf32SectionHeader.SHT_REL);\n    }\n  }\n}\n", "nl": "Uses info from the elf program headers and elf section headers to relocate a PRX."}
{"code": "public CompiledST defineTemplate(String name,String argsS,String template){\n  if (name.charAt(0) != '/')   name=\"/\" + name;\n  String[] args=argsS.split(\",\");\n  List<FormalArgument> a=new ArrayList<FormalArgument>();\n  for (  String arg : args) {\n    a.add(new FormalArgument(arg));\n  }\n  return defineTemplate(name,new CommonToken(GroupParser.ID,name),a,template,null);\n}\n", "nl": "for testing"}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2014-03-24 16:07:23.812 -0400\",hash_original_method=\"F5106D0386D3020336DFAB8E81694EB1\",hash_generated_method=\"19EBF7A8C1F496ACA7BB8F658932423D\") private void onAgentCancel(){\n  Intent intent=new Intent(BluetoothDevice.ACTION_PAIRING_CANCEL);\n  mContext.sendBroadcast(intent,BLUETOOTH_ADMIN_PERM);\n  mHandler.sendMessageDelayed(mHandler.obtainMessage(EVENT_AGENT_CANCEL),1500);\n  return;\n}\n", "nl": "Called by native code on a Cancel method call to org.bluez.Agent."}
{"code": "public String optString(int index){\n  return this.optString(index,\"\");\n}\n", "nl": "Get the optional string value associated with an index. It returns an empty string if there is no value at that index. If the value is not a string and is not null, then it is coverted to a string."}
{"code": "public void addOutMessage(final String address){\n}\n", "nl": "Add a new OSC out message with the specified address."}
{"code": "@Override public void remove(){\n  throw new UnsupportedOperationException(\"The remove  operation is not supported by this Iterator.\");\n}\n", "nl": "The remove  operation is not supported by this Iterator."}
{"code": "@PostMapping(consumes=\"multipart/form-data\") public ResponseEntity<FileInfo> uploadFile(@RequestParam(\"file\") MultipartFile file,@RequestParam(required=false) String name,HttpServletRequest request){\n  try {\n    if (Strings.isNullOrEmpty(name)) {\n      name=file.getOriginalFilename();\n    }\n    long size=file.getSize();\n    FileDescriptor fd=createFileDescriptor(name,size);\n    InputStream is=file.getInputStream();\n    uploadToMiddleware(is,fd);\n    saveFileDescriptor(fd);\n    return createFileInfoResponseEntity(request,fd);\n  }\n catch (  Exception e) {\n    log.error(\"File upload failed\",e);\n    throw new RestAPIException(\"File upload failed\",\"File upload failed\",HttpStatus.INTERNAL_SERVER_ERROR);\n  }\n}\n", "nl": "Method for multipart file upload. It expects the file contents to be passed in the part called 'file'"}
{"code": "static double ensureNonNegative(double value){\n  checkArgument(!isNaN(value));\n  if (value > 0.0) {\n    return value;\n  }\n else {\n    return 0.0;\n  }\n}\n", "nl": "Returns its argument if it is non-negative, zero if it is negative."}
{"code": "public v4ParserException(){\n}\n", "nl": "Used for remote debugger deserialization"}
{"code": "void log(String msg){\n  System.err.println(msg);\n}\n", "nl": "Write a message to stderr."}
{"code": "@After public void tearDown() throws Exception {\n  Locale.setDefault(this.savedLocale);\n}\n", "nl": "Restore the default locale after the tests complete."}
{"code": "public void multiply(Matrix2f rhs){\n  Matrix2f tmp=new Matrix2f();\n  tmp.loadMultiply(this,rhs);\n  load(tmp);\n}\n", "nl": "Post-multiplies the current matrix by a given parameter"}
{"code": "public Quaternionf mul(float qx,float qy,float qz,float qw){\n  set(w * qx + x * qw + y * qz - z * qy,w * qy - x * qz + y * qw + z * qx,w * qz + x * qy - y * qx + z * qw,w * qw - x * qx - y * qy - z * qz);\n  return this;\n}\n", "nl": "Multiply this quaternion by the quaternion represented via <tt>(qx, qy, qz, qw)</tt>. <p> If <tt>T</tt> is <code>this</code> and <tt>Q</tt> is the given quaternion, then the resulting quaternion <tt>R</tt> is: <p> <tt>R = T * Q</tt> <p> So, this method uses post-multiplication like the matrix classes, resulting in a vector to be transformed by <tt>Q</tt> first, and then by <tt>T</tt>."}
{"code": "public JRangeSlider createRangeSlider(int orientation,int direction){\n  return new JRangeSlider(m_model,orientation,direction);\n}\n", "nl": "Create a new range slider for interacting with the query, using the given orientation and direction."}
{"code": "private JPopupMenu createOperatorPopupMenu(){\n  JPopupMenu menu=new JPopupMenu();\n  menu.add(EXPAND_ALL_ACTION);\n  menu.add(COLLAPSE_ALL_ACTION);\n  menu.addSeparator();\n  String name=\"Tree\";\n  if (mainFrame.getProcess().getProcessLocation() != null) {\n    name=mainFrame.getProcess().getProcessLocation().getShortName();\n  }\n  menu.add(PrintingTools.makeExportPrintMenu(this,name));\n  return menu;\n}\n", "nl": "Creates a new popup menu for the selected operator."}
{"code": "public final LC rightToLeft(){\n  setLeftToRight(Boolean.FALSE);\n  return this;\n}\n", "nl": "Same functionality as setLeftToRight(false) only this method returns <code>this</code> for chaining multiple calls. <p> For a more thorough explanation of what this constraint does see the white paper or cheat Sheet at www.migcomponents.com."}
{"code": "private boolean removeOrMaterializeIf(SimplifierTool tool){\n  assert trueSuccessor().hasNoUsages() && falseSuccessor().hasNoUsages();\n  if (trueSuccessor().next() instanceof AbstractEndNode && falseSuccessor().next() instanceof AbstractEndNode) {\n    AbstractEndNode trueEnd=(AbstractEndNode)trueSuccessor().next();\n    AbstractEndNode falseEnd=(AbstractEndNode)falseSuccessor().next();\n    AbstractMergeNode merge=trueEnd.merge();\n    if (merge == falseEnd.merge() && trueSuccessor().anchored().isEmpty() && falseSuccessor().anchored().isEmpty()) {\n      PhiNode singlePhi=null;\n      int distinct=0;\n      for (      PhiNode phi : merge.phis()) {\n        ValueNode trueValue=phi.valueAt(trueEnd);\n        ValueNode falseValue=phi.valueAt(falseEnd);\n        if (trueValue != falseValue) {\n          distinct++;\n          singlePhi=phi;\n        }\n      }\n      if (distinct == 0) {\n        removeThroughFalseBranch(tool);\n        return true;\n      }\n else       if (distinct == 1) {\n        ValueNode trueValue=singlePhi.valueAt(trueEnd);\n        ValueNode falseValue=singlePhi.valueAt(falseEnd);\n        ConditionalNode conditional=canonicalizeConditionalCascade(trueValue,falseValue);\n        if (conditional != null) {\n          singlePhi.setValueAt(trueEnd,conditional);\n          removeThroughFalseBranch(tool);\n          return true;\n        }\n      }\n    }\n  }\n  if (trueSuccessor().next() instanceof ReturnNode && falseSuccessor().next() instanceof ReturnNode) {\n    ReturnNode trueEnd=(ReturnNode)trueSuccessor().next();\n    ReturnNode falseEnd=(ReturnNode)falseSuccessor().next();\n    ValueNode trueValue=trueEnd.result();\n    ValueNode falseValue=falseEnd.result();\n    ValueNode value=null;\n    if (trueValue != null) {\n      if (trueValue == falseValue) {\n        value=trueValue;\n      }\n else {\n        value=canonicalizeConditionalCascade(trueValue,falseValue);\n        if (value == null) {\n          return false;\n        }\n      }\n    }\n    ReturnNode newReturn=graph().add(new ReturnNode(value));\n    replaceAtPredecessor(newReturn);\n    GraphUtil.killCFG(this);\n    return true;\n  }\n  return false;\n}\n", "nl": "Tries to remove an empty if construct or replace an if construct with a materialization."}
{"code": "@Override public boolean isActive(){\n  return amIActive;\n}\n", "nl": "Used by the Whitebox GUI to tell if this plugin is still running."}
{"code": "private void resize(int c){\n  int[] newItems=new int[c];\n  for (int i=0; i < items.length; i+=1) {\n    newItems[i]=items[i];\n  }\n  items=newItems;\n}\n", "nl": "Resizes ITEMS to C, copying things over."}
{"code": "public static double calculateRSquared(Instances data,double ssr) throws Exception {\n  double yMean=data.meanOrMode(data.classIndex());\n  double tss=0.0;\n  for (int i=0; i < data.numInstances(); i++) {\n    tss+=(data.instance(i).value(data.classIndex()) - yMean) * (data.instance(i).value(data.classIndex()) - yMean);\n  }\n  double rsq=1 - (ssr / tss);\n  return rsq;\n}\n", "nl": "Returns the R-squared value for a linear regression model, where sum of squared residuals is already calculated. This works for either a simple or a multiple linear regression model."}
{"code": "public final void testSetCaseSensitivity(){\n  Case caseSensitivity=Case.UPPERCASE;\n  LetterOrNumberValidator characterOrNumberValidator=new LetterOrNumberValidator(\"foo\",Case.CASE_INSENSITIVE,true);\n  characterOrNumberValidator.setCaseSensitivity(caseSensitivity);\n  assertEquals(caseSensitivity,characterOrNumberValidator.getCaseSensitivity());\n}\n", "nl": "Tests the functionality of the method, which allows to set the case sensitivity."}
{"code": "@Util public static void resetAdminTenantId(){\n  session.put(TENANT_ID,Security.getUserInfo().getTenant());\n}\n", "nl": "Resets the AdminTenant in the session back to the users TenantId"}
{"code": "public void closeAllFiles(){\n  while (m_TabbedPane.getTabCount() > 0) {\n    if (!saveChanges(true)) {\n      return;\n    }\n    m_TabbedPane.removeTabAt(getCurrentIndex());\n    updateFrameTitle();\n    System.gc();\n  }\n}\n", "nl": "closes all open files"}
{"code": "@Override public final int size(){\n  return (int)Math.max((tail.get() - head.get()),0);\n}\n", "nl": "This implemention is known to be broken if preemption were to occur after reading the tail pointer. Code should not depend on size for a correct result."}
{"code": "public RAkELdTest(String name){\n  super(name);\n}\n", "nl": "Initializes the test."}
{"code": "public static void main(String[] args){\n  try {\n    int fdNum=Integer.parseInt(args[0],10);\n    int targetSdkVersion=Integer.parseInt(args[1],10);\n    if (fdNum != 0) {\n      try {\n        FileDescriptor fd=ZygoteInit.createFileDescriptor(fdNum);\n        DataOutputStream os=new DataOutputStream(new FileOutputStream(fd));\n        os.writeInt(Process.myPid());\n        os.close();\n        IoUtils.closeQuietly(fd);\n      }\n catch (      IOException ex) {\n        Slog.d(TAG,\"Could not write pid of wrapped process to Zygote pipe.\",ex);\n      }\n    }\n    ZygoteInit.preload();\n    String[] runtimeArgs=new String[args.length - 2];\n    System.arraycopy(args,2,runtimeArgs,0,runtimeArgs.length);\n    RuntimeInit.wrapperInit(targetSdkVersion,runtimeArgs);\n  }\n catch (  ZygoteInit.MethodAndArgsCaller caller) {\n    caller.run();\n  }\n}\n", "nl": "The main function called when starting a runtime application through a wrapper process instead of by forking Zygote. The first argument specifies the file descriptor for a pipe that should receive the pid of this process, or 0 if none. The second argument is the target SDK version for the app. The remaining arguments are passed to the runtime."}
{"code": "private final void completeConstruction(){\n  if (mDbg)   mSm.log(\"completeConstruction: E\");\n  int maxDepth=0;\n  for (  StateInfo si : mStateInfo.values()) {\n    int depth=0;\n    for (StateInfo i=si; i != null; depth++) {\n      i=i.parentStateInfo;\n    }\n    if (maxDepth < depth) {\n      maxDepth=depth;\n    }\n  }\n  if (mDbg)   mSm.log(\"completeConstruction: maxDepth=\" + maxDepth);\n  mStateStack=new StateInfo[maxDepth];\n  mTempStateStack=new StateInfo[maxDepth];\n  setupInitialStateStack();\n  sendMessageAtFrontOfQueue(obtainMessage(SM_INIT_CMD,mSmHandlerObj));\n  if (mDbg)   mSm.log(\"completeConstruction: X\");\n}\n", "nl": "Complete the construction of the state machine."}
{"code": "private void createTestImage(){\n  mInitialImage=new byte[3 * mSize / 2];\n  for (int i=0; i < mSize; i++) {\n    mInitialImage[i]=(byte)(40 + i % 199);\n  }\n  for (int i=mSize; i < 3 * mSize / 2; i+=2) {\n    mInitialImage[i]=(byte)(40 + i % 200);\n    mInitialImage[i + 1]=(byte)(40 + (i + 99) % 200);\n  }\n}\n", "nl": "Creates the test image that will be used to feed the encoder."}
{"code": "public void addCascaded(Component comp,Integer layer){\n  this.add(comp,layer);\n  if (comp instanceof JInternalFrame) {\n    this.cascade(comp);\n  }\n  this.moveToFront(comp);\n}\n", "nl": "Method addCascaded."}
{"code": "private static void dualPivotQuicksort(long[] a,int left,int right){\n  int sixth=(right - left + 1) / 6;\n  int e1=left + sixth;\n  int e5=right - sixth;\n  int e3=(left + right) >>> 1;\n  int e4=e3 + sixth;\n  int e2=e3 - sixth;\n  long ae1=a[e1], ae2=a[e2], ae3=a[e3], ae4=a[e4], ae5=a[e5];\n  if (ae1 > ae2) {\n    long t=ae1;\n    ae1=ae2;\n    ae2=t;\n  }\n  if (ae4 > ae5) {\n    long t=ae4;\n    ae4=ae5;\n    ae5=t;\n  }\n  if (ae1 > ae3) {\n    long t=ae1;\n    ae1=ae3;\n    ae3=t;\n  }\n  if (ae2 > ae3) {\n    long t=ae2;\n    ae2=ae3;\n    ae3=t;\n  }\n  if (ae1 > ae4) {\n    long t=ae1;\n    ae1=ae4;\n    ae4=t;\n  }\n  if (ae3 > ae4) {\n    long t=ae3;\n    ae3=ae4;\n    ae4=t;\n  }\n  if (ae2 > ae5) {\n    long t=ae2;\n    ae2=ae5;\n    ae5=t;\n  }\n  if (ae2 > ae3) {\n    long t=ae2;\n    ae2=ae3;\n    ae3=t;\n  }\n  if (ae4 > ae5) {\n    long t=ae4;\n    ae4=ae5;\n    ae5=t;\n  }\n  a[e1]=ae1;\n  a[e3]=ae3;\n  a[e5]=ae5;\n  long pivot1=ae2;\n  a[e2]=a[left];\n  long pivot2=ae4;\n  a[e4]=a[right];\n  int less=left + 1;\n  int great=right - 1;\n  boolean pivotsDiffer=(pivot1 != pivot2);\n  if (pivotsDiffer) {\n    outer:     for (int k=less; k <= great; k++) {\n      long ak=a[k];\n      if (ak < pivot1) {\n        if (k != less) {\n          a[k]=a[less];\n          a[less]=ak;\n        }\n        less++;\n      }\n else       if (ak > pivot2) {\n        while (a[great] > pivot2) {\n          if (great-- == k) {\n            break outer;\n          }\n        }\n        if (a[great] < pivot1) {\n          a[k]=a[less];\n          a[less++]=a[great];\n          a[great--]=ak;\n        }\n else {\n          a[k]=a[great];\n          a[great--]=ak;\n        }\n      }\n    }\n  }\n else {\n    for (int k=less; k <= great; k++) {\n      long ak=a[k];\n      if (ak == pivot1) {\n        continue;\n      }\n      if (ak < pivot1) {\n        if (k != less) {\n          a[k]=a[less];\n          a[less]=ak;\n        }\n        less++;\n      }\n else {\n        while (a[great] > pivot1) {\n          great--;\n        }\n        if (a[great] < pivot1) {\n          a[k]=a[less];\n          a[less++]=a[great];\n          a[great--]=ak;\n        }\n else {\n          a[k]=pivot1;\n          a[great--]=ak;\n        }\n      }\n    }\n  }\n  a[left]=a[less - 1];\n  a[less - 1]=pivot1;\n  a[right]=a[great + 1];\n  a[great + 1]=pivot2;\n  doSort(a,left,less - 2);\n  doSort(a,great + 2,right);\n  if (!pivotsDiffer) {\n    return;\n  }\n  if (less < e1 && great > e5) {\n    while (a[less] == pivot1) {\n      less++;\n    }\n    while (a[great] == pivot2) {\n      great--;\n    }\n    outer:     for (int k=less; k <= great; k++) {\n      long ak=a[k];\n      if (ak == pivot2) {\n        while (a[great] == pivot2) {\n          if (great-- == k) {\n            break outer;\n          }\n        }\n        if (a[great] == pivot1) {\n          a[k]=a[less];\n          a[less++]=pivot1;\n        }\n else {\n          a[k]=a[great];\n        }\n        a[great--]=pivot2;\n      }\n else       if (ak == pivot1) {\n        a[k]=a[less];\n        a[less++]=pivot1;\n      }\n    }\n  }\n  doSort(a,less,great);\n}\n", "nl": "Sorts the specified range of the array into ascending order by the Dual-Pivot Quicksort algorithm."}
{"code": "public final int yystate(){\n  return zzLexicalState;\n}\n", "nl": "Returns the current lexical state."}
{"code": "@Override public void onSeekComplete(MediaPlayer mp){\n  Log.d(TAG,\"onSeekComplete\");\n  stopLoading();\n  if (lastState != null) {\nswitch (lastState) {\ncase STARTED:\n{\n        start();\n        break;\n      }\ncase PLAYBACKCOMPLETED:\n{\n      currentState=State.PLAYBACKCOMPLETED;\n      break;\n    }\ncase PREPARED:\n{\n    currentState=State.PREPARED;\n    break;\n  }\n}\n}\nif (this.seekCompleteListener != null) this.seekCompleteListener.onSeekComplete(mp);\n}\n", "nl": "Restore the last State before seekTo()"}
{"code": "public int computeWordValue(Vertex word){\n  int value=2;\n  int count=0;\n  if (word.instanceOf(Primitive.NOUN)) {\n    value=value + 12;\n    count++;\n  }\n  if (word.instanceOf(Primitive.ADJECTIVE)) {\n    value=value + 6;\n    count++;\n  }\n  if (word.instanceOf(Primitive.INTERJECTION)) {\n    value=value + 6;\n    count++;\n  }\n  if (word.instanceOf(Primitive.VERB)) {\n    value=value + 4;\n    count++;\n  }\n  if (word.instanceOf(Primitive.QUESTION)) {\n    value=value + 3;\n    count++;\n  }\n  if (word.instanceOf(Primitive.ADVERB)) {\n    value=value + 2;\n    count++;\n  }\n  if (count == 0) {\n    Collection<Relationship> meanings=word.getRelationships(Primitive.MEANING);\n    if (meanings != null) {\n      for (      Relationship relation : meanings) {\n        Vertex meaning=relation.getTarget();\n        if (meaning.instanceOf(Primitive.THING)) {\n          value=value + 12;\n        }\n else         if (meaning.instanceOf(Primitive.DESCRIPTION)) {\n          value=value + 6;\n        }\n else         if (meaning.instanceOf(Primitive.INTERJECTION)) {\n          value=value + 6;\n        }\n else         if (meaning.instanceOf(Primitive.ACTION)) {\n          value=value + 4;\n        }\n else         if (meaning.instanceOf(Primitive.QUESTION)) {\n          value=value + 3;\n        }\n else {\n          value=value + 2;\n        }\n      }\n      value=value / meanings.size();\n    }\n else {\n      value=value + 4;\n    }\n  }\n else {\n    value=value / count;\n  }\n  if (word.instanceOf(Primitive.PUNCTUATION) || (word.instanceOf(Primitive.ARTICLE))) {\n    value=1;\n  }\n  if (word.instanceOf(Primitive.KEYWORD)) {\n    value=25;\n  }\n  return value;\n}\n", "nl": "Return the matching value for the word, some word types are worth more than others."}
{"code": "public TenantResource tenant(){\n  return tenant;\n}\n", "nl": "Get the subresource containing all of the commands related to a tenant"}
{"code": "public static <E>List<E> of(E e1,E e2,E e3,E e4){\n  List<E> list=new ArrayList<>();\n  list.add(e1);\n  list.add(e2);\n  list.add(e3);\n  list.add(e4);\n  return list;\n}\n", "nl": "Returns a list of the given elements, in order."}
{"code": "@Deprecated public BitmapDrawable(){\n  mBitmapState=new BitmapState((Bitmap)null);\n}\n", "nl": "Create an empty drawable, not dealing with density."}
{"code": "public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {\n  String l_szRequestID=null;\n  HttpSession sess=request.getSession(true);\n  sess.setMaxInactiveInterval(WebEnv.TIMEOUT);\n  ctx=getCtx();\n  if (sess.getAttribute(\"ctx\") != null)   ctx=(Properties)sess.getAttribute(\"ctx\");\n  WebSessionCtx wsc=(WebSessionCtx)sess.getAttribute(WebSessionCtx.NAME);\n  if (wsc != null) {\n    String mode=WebUtil.getParameter(request,\"Mode\");\n    if (mode != null && mode.equals(\"RequestNew\")) {\n      l_szRequestID=Request.createRequest(request,ctx);\n    }\n else     if (mode != null && mode.equals(\"RequestChange\")) {\n      l_szRequestID=Request.changeRequest(request,ctx);\n    }\n  }\n  String url=request.getParameter(\"ForwardTo\") + l_szRequestID;\n  if (!url.startsWith(\"/\"))   url=\"/\" + url;\n  response.sendRedirect(url);\n}\n", "nl": "Process Get Request"}
{"code": "public short convertIndexToLocation(int index){\n  if (index == 0)   return 0;\n  if (index <= currentNumLocals) {\n    return currentCompiledMethod.getGeneralLocalLocation(index - 1);\n  }\n else {\n    return currentCompiledMethod.getGeneralStackLocation(index - 1 - currentNumLocals);\n  }\n}\n", "nl": "given a index in the local area (biased : local0 has index 1) this routine determines the correspondig offset in the stack"}
{"code": "protected POInfo initPO(Properties ctx){\n  POInfo poi=POInfo.getPOInfo(ctx,Table_ID,get_TrxName());\n  return poi;\n}\n", "nl": "Load Meta Data"}
{"code": "public void load(String filename,G g) throws IOException {\n  load(new FileReader(filename),g);\n}\n", "nl": "Populates the specified graph with the data parsed from the specified file."}
{"code": "public MockNioSession(){\n}\n", "nl": "Creates empty mock session."}
{"code": "public void reduceNetworkCapacity(String outputFilename,double fraction){\n  log.info(\"Changing the network capacity. Multiplying by \" + fraction);\n  int counter=0;\n  int multiplier=1;\n  for (  Id<Link> id : sc.getNetwork().getLinks().keySet()) {\n    double old=sc.getNetwork().getLinks().get(id).getCapacity();\n    sc.getNetwork().getLinks().get(id).setCapacity(old * fraction);\n    if (++counter == multiplier) {\n      log.info(\"   Links adapted: \" + counter);\n      multiplier*=2;\n    }\n  }\n  log.info(\"   Links adapted: \" + counter + \" (Done)\");\n  NetworkWriter nw=new NetworkWriter(sc.getNetwork());\n  nw.write(outputFilename);\n}\n", "nl": "Changing the network's capacity. Values smaller than 1.0 implies a reduction, while values greater than 1.0 implies an increase."}
{"code": "public static boolean isDangerous(double d){\n  return Double.isInfinite(d) || Double.isNaN(d) || d == 0.0;\n}\n", "nl": "Returns true if the argument is a \"dangerous\" double to have around, namely one that is infinite, NaN or zero."}
{"code": "static public void saveData(Context context,String key,String val){\n  context.getSharedPreferences(PREF_APP,Context.MODE_PRIVATE).edit().putString(key,val).apply();\n}\n", "nl": "Save data."}
{"code": "private String createChoiceWithFictionalProgressXML(String choiceId,String choiceDescription,String nextMomentId,boolean depleteWeaponCharge,boolean incrementNumEnemiesDefeated,String progressDescription,String iconResourceName){\n  String xml=\"\";\n  xml+=\"<choice \";\n  xml+=\"id='\" + choiceId + \"' >\";\n  xml+=\"<description>\" + choiceDescription + \"</description>\";\n  xml+=createNextMomentXml(nextMomentId);\n  xml+=\"<outcome \";\n  xml+=\"deplete_weapon='\" + Boolean.toString(depleteWeaponCharge) + \"' \";\n  xml+=\"increment_enemies='\" + Boolean.toString(incrementNumEnemiesDefeated) + \"' />\";\n  xml+=createFictionalProgressXml(progressDescription);\n  if (iconResourceName != null) {\n    xml+=createIconXML(iconResourceName);\n  }\n  xml+=\"</choice>\";\n  return xml;\n}\n", "nl": "A helper function to create an XML string representing a choice.  Choices are found within choice moments. Contains a piece of fictional progress."}
{"code": "public static void sort(char[] a){\n  sort1(a,0,a.length);\n}\n", "nl": "Sorts the specified array of chars into ascending numerical order. The sorting algorithm is a tuned quicksort, adapted from Jon L. Bentley and M. Douglas McIlroy's \"Engineering a Sort Function\", Software-Practice and Experience, Vol. 23(11) P. 1249-1265 (November 1993).  This algorithm offers n*log(n) performance on many data sets that cause other quicksorts to degrade to quadratic performance."}
{"code": "private void addOrUpdateNode(AStarNode newNode){\n  boolean found=false;\n  for (  AStarNode toUpdate : closedNodes) {\n    if (newNode.equals(toUpdate)) {\n      toUpdate.updateDistance(newNode.getG(),newNode.parent);\n      found=true;\n      break;\n    }\n  }\n  if (!found) {\n    openQueue.offer(newNode);\n  }\n}\n", "nl": "Adds a new AStarNode to the queue unless it is already among the closed nodes, in which case it only updates the closed Node with the new distance."}
{"code": "public boolean hasUnsupportedCriticalExtension(){\n  Set extns=getCriticalExtensionOIDs();\n  if (extns == null) {\n    return false;\n  }\n  extns.remove(RFC3280CertPathUtilities.ISSUING_DISTRIBUTION_POINT);\n  extns.remove(RFC3280CertPathUtilities.DELTA_CRL_INDICATOR);\n  return !extns.isEmpty();\n}\n", "nl": "Will return true if any extensions are present and marked as critical as we currently dont handle any extensions!"}
{"code": "public void test_MultipleAccessToSeveralTables() throws SQLException {\n  threadPool.runTask(createTask1(1));\n  threadPool.runTask(createTask2(2));\n  threadPool.runTask(createTask3(3));\n}\n", "nl": "A few threads execute select operation in the same time for different tables in the database. Number of threads is defined by numThreads variable"}
{"code": "synchronized void releaseLocalIdOnDisk(String localId){\n  MapEntry entry=getMapEntry(localId);\n  entry.retainCount--;\n  if (entry.retainCount > 0) {\n    putMapEntry(localId,entry);\n  }\n else {\n    removeMapEntry(localId);\n  }\n}\n", "nl": "Decrements the retain count of a local id on disk. If the retain count hits zero, the id is forgotten forever."}
{"code": "public CCriteriumWrapper(final ICriteriumCreator creator){\n  super(creator);\n}\n", "nl": "Creates a new criterium object."}
{"code": "@Get(\"json\") public Map<String,Object> retrieve(){\n  return retrieveInternal(false);\n}\n", "nl": "Retrieves information about all modules available to Floodlight."}
{"code": "public boolean springBackX(int start,int min,int max){\n  mScrollerX.mMode=FLING_MODE;\n  return mScrollerX.springback(start,min,max);\n}\n", "nl": "Call this when you want to 'spring back' into a valid coordinate range."}
{"code": "@Override protected int sizeOf(String key,BitmapDrawable value){\n  final int bitmapSize=getBitmapSize(value) / 1024;\n  return bitmapSize == 0 ? 1 : bitmapSize;\n}\n", "nl": "Measure item size in kilobytes rather than units which is more practical for a bitmap cache"}
{"code": "public PersianCharFilterFactory(Map<String,String> args){\n  super(args);\n  if (!args.isEmpty()) {\n    throw new IllegalArgumentException(\"Unknown parameters: \" + args);\n  }\n}\n", "nl": "Creates a new PersianCharFilterFactory"}
{"code": "public boolean hasPercentComplete(){\n  return hasExtension(PercentComplete.class);\n}\n", "nl": "Returns whether it has the percent complete."}
{"code": "private void prohibitLandrushIfExactlyOneSunrise(Registry registry) throws UncontestedSunriseApplicationBlockedInLandrushException {\n  if (registry.getTldState(now) == TldState.LANDRUSH) {\n    ImmutableSet<DomainApplication> applications=loadActiveApplicationsByDomainName(targetId,now);\n    if (applications.size() == 1 && getOnlyElement(applications).getPhase().equals(LaunchPhase.SUNRISE)) {\n      throw new UncontestedSunriseApplicationBlockedInLandrushException();\n    }\n  }\n}\n", "nl": "Prohibit creating a landrush application in LANDRUSH (but not in SUNRUSH) if there is exactly one sunrise application for the same name."}
{"code": "private void resetNamePatternSection(){\n  disposeOptionalControls(NAME_PATTERN_ID);\n  validationManager.validationRemoved(NAME_PATTERN_TEXT);\n  validationManager.validationRemoved(REGULAR_EXPRESSION_TEXT);\n  useRegexForNameRadioButton.setSelection(false);\n  useStringValueAsNameRadioButton.setSelection(true);\n  useDefaultPattern=true;\n}\n", "nl": "Resets the name pattern section."}
{"code": "public static PurityResult checkPurity(Tree statement,AnnotationProvider annoProvider,boolean assumeSideEffectFree){\n  PurityCheckerHelper helper=new PurityCheckerHelper(annoProvider,assumeSideEffectFree);\n  PurityResult res=helper.scan(statement,new PurityResult());\n  return res;\n}\n", "nl": "Compute whether the given statement is side-effect-free, deterministic, or both. Returns a result that can be queried."}
{"code": "public Node buildTreeFull(Class<?> type,int depth){\n  if (depth == 0) {\n    return PRNG.nextItem(listAvailableTerminals(type)).copyNode();\n  }\n else {\n    Node node=PRNG.nextItem(listAvailableFunctions(type)).copyNode();\n    for (int i=0; i < node.getNumberOfArguments(); i++) {\n      node.setArgument(i,buildTreeFull(node.getArgumentType(i),depth - 1));\n    }\n    return node;\n  }\n}\n", "nl": "Generates an expression tree with the given return type using the <i>full</i> initialization method.  This method builds the tree so every leaf node is at the specified depth."}
{"code": "private static void sort(DefaultListModel model){\n  Object[] elements=model.toArray();\n  Arrays.sort(elements);\n  model.clear();\n  for (  Object element : elements) {\n    model.addElement(element);\n  }\n}\n", "nl": "Sorts the elemenets of a default list model"}
{"code": "protected boolean handleMarkSeenNotPermanent(MimeMessage aMessage) throws MessagingException {\n  return aMessage.isSet(Flags.Flag.SEEN);\n}\n", "nl": "<p> Handler for when the folder does not support the SEEN flag. The default behaviour implemented here is to answer the value of the SEEN flag anyway. </p> <p> Subclasses may choose to override this method and implement their own solutions. </p>"}
{"code": "public PatternsRequestCondition(String[] patterns,HttpRequestPathHelper pathHelper,PathMatcher pathMatcher,boolean useSuffixPatternMatch,boolean useTrailingSlashMatch,Set<String> extensions){\n  this(asList(patterns),pathHelper,pathMatcher,useSuffixPatternMatch,useTrailingSlashMatch,extensions);\n}\n", "nl": "Creates a new instance with the given URL patterns. Each pattern that is not empty and does not start with \"/\" is pre-pended with \"/\"."}
{"code": "public DataAsyncHttpResponseHandler(){\n  super();\n}\n", "nl": "Creates a new AsyncHttpResponseHandler"}
{"code": "public DDFSubfield(DDFSubfieldDefinition ddfsd,Object value){\n  setDefn(ddfsd);\n  setValue(value);\n}\n", "nl": "Create a subfield with a definition and a value."}
{"code": "private java.lang.String registerPrefix(javax.xml.stream.XMLStreamWriter xmlWriter,java.lang.String namespace) throws javax.xml.stream.XMLStreamException {\n  java.lang.String prefix=xmlWriter.getPrefix(namespace);\n  if (prefix == null) {\n    prefix=generatePrefix(namespace);\n    while (xmlWriter.getNamespaceContext().getNamespaceURI(prefix) != null) {\n      prefix=org.apache.axis2.databinding.utils.BeanUtil.getUniquePrefix();\n    }\n    xmlWriter.writeNamespace(prefix,namespace);\n    xmlWriter.setPrefix(prefix,namespace);\n  }\n  return prefix;\n}\n", "nl": "Register a namespace prefix"}
{"code": "static void testBytes(int numBytes,long expectedCount,long start,long lim) throws UnsupportedEncodingException {\n  Random rnd=new Random();\n  byte[] bytes=new byte[numBytes];\n  if (lim == -1) {\n    lim=1L << (numBytes * 8);\n  }\n  long count=0;\n  long countRoundTripped=0;\n  for (long byteChar=start; byteChar < lim; byteChar++) {\n    long tmpByteChar=byteChar;\n    for (int i=0; i < numBytes; i++) {\n      bytes[bytes.length - i - 1]=(byte)tmpByteChar;\n      tmpByteChar=tmpByteChar >> 8;\n    }\n    ByteString bs=ByteString.copyFrom(bytes);\n    boolean isRoundTrippable=bs.isValidUtf8();\n    String s=new String(bytes,\"UTF-8\");\n    byte[] bytesReencoded=s.getBytes(\"UTF-8\");\n    boolean bytesEqual=Arrays.equals(bytes,bytesReencoded);\n    if (bytesEqual != isRoundTrippable) {\n      outputFailure(byteChar,bytes,bytesReencoded);\n    }\n    assertEquals(isRoundTrippable,Utf8.isValidUtf8(bytes));\n    assertEquals(isRoundTrippable,Utf8.isValidUtf8(bytes,0,numBytes));\n    int i=rnd.nextInt(numBytes);\n    int j=rnd.nextInt(numBytes);\n    if (j < i) {\n      int tmp=i;\n      i=j;\n      j=tmp;\n    }\n    int state1=Utf8.partialIsValidUtf8(Utf8.COMPLETE,bytes,0,i);\n    int state2=Utf8.partialIsValidUtf8(state1,bytes,i,j);\n    int state3=Utf8.partialIsValidUtf8(state2,bytes,j,numBytes);\n    if (isRoundTrippable != (state3 == Utf8.COMPLETE)) {\n      System.out.printf(\"state=%04x %04x %04x i=%d j=%d%n\",state1,state2,state3,i,j);\n      outputFailure(byteChar,bytes,bytesReencoded);\n    }\n    assertEquals(isRoundTrippable,(state3 == Utf8.COMPLETE));\n    ByteString rope=RopeByteString.newInstanceForTest(bs.substring(0,i),RopeByteString.newInstanceForTest(bs.substring(i,j),bs.substring(j,numBytes)));\n    assertSame(RopeByteString.class,rope.getClass());\n    ByteString[] byteStrings={bs,bs.substring(0,numBytes),rope};\n    for (    ByteString x : byteStrings) {\n      assertEquals(isRoundTrippable,x.isValidUtf8());\n      assertEquals(state3,x.partialIsValidUtf8(Utf8.COMPLETE,0,numBytes));\n      assertEquals(state1,x.partialIsValidUtf8(Utf8.COMPLETE,0,i));\n      assertEquals(state1,x.substring(0,i).partialIsValidUtf8(Utf8.COMPLETE,0,i));\n      assertEquals(state2,x.partialIsValidUtf8(state1,i,j - i));\n      assertEquals(state2,x.substring(i,j).partialIsValidUtf8(state1,0,j - i));\n      assertEquals(state3,x.partialIsValidUtf8(state2,j,numBytes - j));\n      assertEquals(state3,x.substring(j,numBytes).partialIsValidUtf8(state2,0,numBytes - j));\n    }\n    ByteString ropeADope=RopeByteString.newInstanceForTest(bs,bs.substring(0,numBytes));\n    assertEquals(isRoundTrippable,ropeADope.isValidUtf8());\n    if (isRoundTrippable) {\n      countRoundTripped++;\n    }\n    count++;\n    if (byteChar != 0 && byteChar % 1000000L == 0) {\n      logger.info(\"Processed \" + (byteChar / 1000000L) + \" million characters\");\n    }\n  }\n  logger.info(\"Round tripped \" + countRoundTripped + \" of \"+ count);\n  assertEquals(expectedCount,countRoundTripped);\n}\n", "nl": "Helper to run the loop to test all the permutations for the number of bytes specified. This overload is useful for debugging to get the loop to start at a certain character."}
{"code": "public void addParameterValues(final String requestParameterName,final Object... requestParameterValues){\n  if (requestParameterValues != null) {\n    for (    final Object requestParameterValue : requestParameterValues) {\n      getParameters().add(requestParameterName,requestParameterValue);\n    }\n  }\n}\n", "nl": "Adds 1 or more parameter values to the HTTP request. <p/>"}
{"code": "public String globalInfo(){\n  return \"An instance filter that assumes instances form time-series data and \" + \"replaces attribute values in the current instance with the difference \" + \"between the current value and the equivalent attribute attribute value \"+ \"of some previous (or future) instance. For instances where the time-shifted \"+ \"value is unknown either the instance may be dropped, or missing values \"+ \"used. Skips the class attribute if it is set.\";\n}\n", "nl": "Returns a string describing this classifier"}
{"code": "protected CCBitmapFontAtlas(CharSequence theString,String fntFile){\n  super((parsed=FNTConfigLoadFile(fntFile)).atlasName,theString.length());\n  configuration_=parsed;\n  opacity_=255;\n  color_=new ccColor3B(ccColor3B.ccWHITE);\n  contentSize_=CGSize.zero();\n  opacityModifyRGB_=textureAtlas_.getTexture().hasPremultipliedAlpha();\n  anchorPoint_=CGPoint.ccp(0.5f,0.5f);\n  string_=new TextBuilder();\n  setString(theString);\n}\n", "nl": "init a bitmap font altas with an initial string and the FNT file"}
{"code": "public static <T>T checkNotNull(T reference,@Nullable String errorMessageTemplate,@Nullable Object... errorMessageArgs){\n  if (reference == null) {\n    throw new NullPointerException(format(errorMessageTemplate,errorMessageArgs));\n  }\n  return reference;\n}\n", "nl": "Ensures that an object reference passed as a parameter to the calling method is not null."}
{"code": "public X509Name(String dirName,X509NameEntryConverter converter){\n  this(DefaultReverse,DefaultLookUp,dirName,converter);\n}\n", "nl": "Takes an X509 dir name as a string of the format \"C=AU, ST=Victoria\", or some such, converting it into an ordered set of name attributes with each string value being converted to its associated ASN.1 type using the passed in converter."}
{"code": "void fireMonitorsUpdatedEvents(){\n  ArrayList registered=null;\n  VmEvent ev=null;\nsynchronized (listeners) {\n    registered=(ArrayList)listeners.clone();\n  }\n  for (Iterator i=registered.iterator(); i.hasNext(); ) {\n    VmListener l=(VmListener)i.next();\n    if (ev == null) {\n      ev=new VmEvent(this);\n    }\n    l.monitorsUpdated(ev);\n  }\n}\n", "nl": "Fire MonitoredVmStructureChanged events."}
{"code": "private void exportGuideLine(Project aProject,File aCopyDir) throws IOException {\n  File guidelineDir=new File(aCopyDir + GUIDELINES_FOLDER);\n  FileUtils.forceMkdir(guidelineDir);\n  File annotationGuidlines=repository.getGuidelinesFile(aProject);\n  if (annotationGuidlines.exists()) {\n    for (    File annotationGuideline : annotationGuidlines.listFiles()) {\n      FileUtils.copyFileToDirectory(annotationGuideline,guidelineDir);\n    }\n  }\n}\n", "nl": "Copy Project guidelines from the file system of this project to the export folder"}
{"code": "public boolean hasChild(String name){\n  return (getChild(name) != null);\n}\n", "nl": "Checks whether the node has a child with the given name."}
{"code": "public static double value(double x){\n  if ((x >= 0) && (x <= epsilon)) {\n    return 0.0;\n  }\n  if ((x < 0) && (-x <= epsilon)) {\n    return 0.0;\n  }\n  return x;\n}\n", "nl": "See if the value is close enough to actually be considered 0.0 and return 0.0 if need be. <p> Otherwise the value is returned."}
{"code": "public static void updateComponentTreeUI(@Nullable Component c){\n  if (c == null)   return;\n  for (  Component component : uiTraverser().postOrderTraversal(c)) {\n    if (component instanceof JComponent)     ((JComponent)component).updateUI();\n  }\n  c.invalidate();\n  c.validate();\n  c.repaint();\n}\n", "nl": "A copy of javax.swing.SwingUtilities#updateComponentTreeUI that invokes children updateUI() first"}
{"code": "void addTopLevel(String key,JFrame frame){\n  if (frame != this) {\n    toplevels.put(key,frame);\n  }\n}\n", "nl": "Records a new internal frame."}
{"code": "protected void resultSetLogError(String message,Throwable error){\n  Logger.sqlErrorLog(message,error);\n}\n", "nl": "Description: <br>"}
{"code": "private boolean validate(Class type,InputNode node,Session session) throws Exception {\n  return validate(type,node,new Source(strategy,support,session));\n}\n", "nl": "This <code>validate</code> method will validate the contents of the XML document against the specified XML class schema. This is used to perform a read traversal of the class schema such that  the document can be tested against it. This is preferred to reading the document as it does not instantiate the objects or invoke any callback methods, thus making it a safe validation."}
