public class AgelessEntity extends CardImpl {§public AgelessEntity(UUID ownerId) {§super(ownerId, 18, "Ageless Entity", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{G}{G}");§this.expansionSetCode = "DDH";§this.subtype.add("Elemental");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(new GainLifeControllerTriggeredAbility(new AgelessEntityEffect(), false, true));§}§public AgelessEntity(final AgelessEntity card) {§super(card);§}§@Override§public AgelessEntity copy() {§return new AgelessEntity(this);§}§}§class AgelessEntityEffect extends OneShotEffect {§public AgelessEntityEffect() {§super(Outcome.Benefit);§this.staticText = "put that many +1/+1 counters on this creature";§}§public AgelessEntityEffect(final AgelessEntityEffect effect) {§super(effect);§}§@Override§public AgelessEntityEffect copy() {§return new AgelessEntityEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§int lifeGained = (Integer) this.getValue("gainedLife");§if (lifeGained > 0) {§return new AddCountersSourceEffect(CounterType.P1P1.createInstance(lifeGained)).apply(game, source);§}§return false;§}§}§
public class AgonizingDemise extends CardImpl {§private static final FilterCreaturePermanent filterNonBlackCreature = new FilterCreaturePermanent("nonblack creature");§static {§filterNonBlackCreature.add(Predicates.not(new ColorPredicate(ObjectColor.BLACK)));§}§public AgonizingDemise(UUID ownerId) {§super(ownerId, 66, "Agonizing Demise", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{3}{B}");§this.expansionSetCode = "DDH";§this.addAbility(new KickerAbility("{1}{R}"));§this.getSpellAbility().addEffect(new DestroyTargetEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent(filterNonBlackCreature));§this.getSpellAbility().addEffect(new ConditionalOneShotEffect(§new AgonizingDemiseEffect(),§KickedCondition.getInstance(),§"If {this} was kicked, it deals damage equal to that creature's power to the creature's controller."));§}§public AgonizingDemise(final AgonizingDemise card) {§super(card);§}§@Override§public AgonizingDemise copy() {§return new AgonizingDemise(this);§}§}§class AgonizingDemiseEffect extends OneShotEffect {§public AgonizingDemiseEffect() {§super(Outcome.Damage);§}§public AgonizingDemiseEffect(final AgonizingDemiseEffect effect) {§super(effect);§}§@Override§public AgonizingDemiseEffect copy() {§return new AgonizingDemiseEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getPermanentOrLKIBattlefield(this.getTargetPointer().getFirst(game, source));§if(permanent != null) {§Player controller = game.getPlayer(permanent.getControllerId());§if(controller != null) {§int amount = permanent.getPower().getValue();§controller.damage(amount, source.getSourceId(), game, false, true);§return true;§}§}§return false;§}§}§
public class OgreSavant extends CardImpl {§public OgreSavant(UUID ownerId) {§super(ownerId, 55, "Ogre Savant", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{R}");§this.expansionSetCode = "DDH";§this.subtype.add("Ogre");§this.subtype.add("Wizard");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§TriggeredAbility ability = new EntersBattlefieldTriggeredAbility(new ReturnToHandTargetEffect(),false);§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(new ConditionalTriggeredAbility(ability, new ManaWasSpentCondition(ColoredManaSymbol.U),§"if {U} was spent to cast {this}, return target creature to its owner's hand."),§new ManaSpentToCastWatcher());§}§public OgreSavant(final OgreSavant card) {§super(card);§}§@Override§public OgreSavant copy() {§return new OgreSavant(this);§}§}§
public class Anathemancer extends CardImpl {§public Anathemancer(UUID ownerId) {§super(ownerId, 33, "Anathemancer", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{B}{R}");§this.expansionSetCode = "ARB";§this.subtype.add("Zombie");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§EntersBattlefieldTriggeredAbility ability = new EntersBattlefieldTriggeredAbility(new DamageTargetEffect(new AnathemancerCount()));§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§this.addAbility(new UnearthAbility(new ManaCostsImpl("{5}{B}{R}")));§}§public Anathemancer(final Anathemancer card) {§super(card);§}§@Override§public Anathemancer copy() {§return new Anathemancer(this);§}§}§class AnathemancerCount implements DynamicValue {§@Override§public int calculate(Game game, Ability sourceAbility, Effect effect) {§if (sourceAbility.getFirstTarget() == null) {§return 0;§}§FilterLandPermanent filter = new FilterLandPermanent();§filter.add(Predicates.not(new SupertypePredicate("Basic")));§filter.add(new ControllerIdPredicate(sourceAbility.getFirstTarget()));§return game.getBattlefield().count(filter, sourceAbility.getSourceId(), sourceAbility.getControllerId(), game);§}§@Override§public DynamicValue copy() {§return new AnathemancerCount();§}§@Override§public String toString() {§return "1";§}§@Override§public String getMessage() {§return "nonbasic lands that player controls";§}§}§
public class ArchitectsOfWill extends CardImpl {§public ArchitectsOfWill(UUID ownerId) {§super(ownerId, 17, "Architects of Will", Rarity.COMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{2}{U}{B}");§this.expansionSetCode = "ARB";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§Ability ability = new EntersBattlefieldTriggeredAbility(new ArchitectsOfWillEffect(), false);§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§this.addAbility(new CyclingAbility(new ManaCostsImpl("{U/B}")));§}§public ArchitectsOfWill(final ArchitectsOfWill card) {§super(card);§}§@Override§public ArchitectsOfWill copy() {§return new ArchitectsOfWill(this);§}§}§class ArchitectsOfWillEffect extends OneShotEffect {§public ArchitectsOfWillEffect() {§super(Outcome.DrawCard);§this.staticText = "look at the top three cards of target player's library, then put them back in any order";§}§public ArchitectsOfWillEffect(final ArchitectsOfWillEffect effect) {§super(effect);§}§@Override§public ArchitectsOfWillEffect copy() {§return new ArchitectsOfWillEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§Player targetPlayer = game.getPlayer(source.getFirstTarget());§if (targetPlayer == null§|| controller == null) {§return false;§}§Cards cards = new CardsImpl();§int count = Math.min(targetPlayer.getLibrary().size(), 3);§for (int i = 0; i < count; i++) {§Card card = targetPlayer.getLibrary().removeFromTop(game);§if (card != null) {§cards.add(card);§}§}§controller.lookAtCards("Architects of Will", cards, game);§controller.putCardsOnTopOfLibrary(cards, game, source, true);§return true;§}§}§
public class ArdentPlea extends CardImpl {§public ArdentPlea (UUID ownerId) {§super(ownerId, 1, "Ardent Plea", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{W}{U}");§this.expansionSetCode = "ARB";§this.addAbility(new ExaltedAbility());§this.addAbility(new CascadeAbility());§}§public ArdentPlea (final ArdentPlea card) {§super(card);§}§@Override§public ArdentPlea copy() {§return new ArdentPlea(this);§}§}§
public class ArsenalThresher extends CardImpl {§public ArsenalThresher(UUID ownerId) {§super(ownerId, 131, "Arsenal Thresher", Rarity.COMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{2}{W/B}{U}");§this.expansionSetCode = "ARB";§this.subtype.add("Construct");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new AsEntersBattlefieldAbility(new ArsenalThresherEffect(),§"you may reveal any number of other artifact cards from your hand. {this} enters the battlefield with a +1/+1 counter on it for each card revealed this way"));§}§public ArsenalThresher(final ArsenalThresher card) {§super(card);§}§@Override§public ArsenalThresher copy() {§return new ArsenalThresher(this);§}§}§class ArsenalThresherEffect extends OneShotEffect {§public ArsenalThresherEffect() {§super(Outcome.Benefit);§}§public ArsenalThresherEffect(final ArsenalThresherEffect effect) {§super(effect);§}§@Override§public ArsenalThresherEffect copy() {§return new ArsenalThresherEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller == null) {§return false;§}§Permanent arsenalThresher = game.getPermanentEntering(source.getSourceId());§FilterArtifactCard filter = new FilterArtifactCard();§filter.add(new AnotherCardPredicate());§if (controller.chooseUse(Outcome.Benefit, "Do you want to reveal other artifacts in your hand?", source, game)) {§Cards cards = new CardsImpl();§if (controller.getHand().count(filter, source.getSourceId(), source.getControllerId(), game) > 0) {§TargetCardInHand target = new TargetCardInHand(0, Integer.MAX_VALUE, filter);§if (controller.choose(Outcome.Benefit, target, source.getSourceId(), game)) {§for (UUID uuid : target.getTargets()) {§cards.add(controller.getHand().get(uuid, game));§}§if (arsenalThresher != null) {§controller.revealCards(arsenalThresher.getIdName(), cards, game);§arsenalThresher.addCounters(CounterType.P1P1.createInstance(cards.size()), game);§}§}§}§return true;§}§return false;§}§}§
public class AvenMimeomancer extends CardImpl {§public AvenMimeomancer(UUID ownerId) {§super(ownerId, 2, "Aven Mimeomancer", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{W}{U}");§this.expansionSetCode = "ARB";§this.subtype.add("Bird");§this.subtype.add("Wizard");§this.power = new MageInt(3);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new BeginningOfUpkeepTriggeredAbility(Zone.BATTLEFIELD, new AddCountersTargetEffect(CounterType.FEATHER.createInstance()), TargetController.YOU, true);§ability.addTarget(new TargetCreaturePermanent());§ability.addEffect(new AvenEffect());§ability.addEffect(new AvenEffect2());§this.addAbility(ability);§}§public AvenMimeomancer(final AvenMimeomancer card) {§super(card);§}§@Override§public AvenMimeomancer copy() {§return new AvenMimeomancer(this);§}§}§class AvenEffect extends ContinuousEffectImpl {§public AvenEffect() {§super(Duration.Custom, Layer.PTChangingEffects_7, SubLayer.SetPT_7b, Outcome.BoostCreature);§}§public AvenEffect(final AvenEffect effect) {§super(effect);§}§@Override§public AvenEffect copy() {§return new AvenEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent target = game.getPermanent(source.getFirstTarget());§if (target != null) {§target.getPower().setValue(3);§target.getToughness().setValue(1);§return true;§}§return false;§}§@Override§public boolean isInactive(Ability source, Game game) {§Permanent creature = game.getPermanent(this.targetPointer.getFirst(game, source));§if (creature != null && creature.getCounters().getCount(CounterType.FEATHER) < 1) {§return true;§}§return false;§}§@Override§public String getText(Mode mode) {§StringBuilder sb = new StringBuilder();§sb.append("If you do, that creature has base power and toughness 3/1 and has flying for as long as it has a feather counter on it");§return sb.toString();§}§}§class AvenEffect2 extends ContinuousEffectImpl {§public AvenEffect2() {§super(Duration.Custom, Layer.AbilityAddingRemovingEffects_6, SubLayer.NA, Outcome.BoostCreature);§}§public AvenEffect2(final AvenEffect2 effect) {§super(effect);§}§@Override§public AvenEffect2 copy() {§return new AvenEffect2(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent target = game.getPermanent(source.getFirstTarget());§if (target != null) {§if (!target.getAbilities().contains(FlyingAbility.getInstance())) {§target.addAbility(FlyingAbility.getInstance(), source.getSourceId(), game);§return true;§}§}§return false;§}§@Override§public boolean isInactive(Ability source, Game game) {§Permanent creature = game.getPermanent(this.targetPointer.getFirst(game, source));§if (creature != null && creature.getCounters().getCount(CounterType.FEATHER) < 1) {§return true;§}§return false;§}§}§
public class BantSojourners extends CardImpl {§public BantSojourners(UUID ownerId) {§super(ownerId, 125, "Bant Sojourners", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{G}{W}{U}");§this.expansionSetCode = "ARB";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(4);§Ability ability1 = new CycleTriggeredAbility(new CreateTokenEffect(new SoldierToken()), true);§Ability ability2 = new DiesTriggeredAbility(new CreateTokenEffect(new SoldierToken()), true);§this.addAbility(ability1);§this.addAbility(ability2);§this.addAbility(new CyclingAbility(new ManaCostsImpl("{2}{W}")));§}§public BantSojourners(final BantSojourners card) {§super(card);§}§@Override§public BantSojourners copy() {§return new BantSojourners(this);§}§}§
public class BantSureblade extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("another multicolor permanent");§static {§filter.add(new MulticoloredPredicate());§filter.add(new AnotherPredicate());§}§public BantSureblade(UUID ownerId) {§super(ownerId, 143, "Bant Sureblade", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{G/U}{W}");§this.expansionSetCode = "ARB";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new ConditionalContinuousEffect(§new BoostSourceEffect(1,1, Duration.WhileOnBattlefield),§new PermanentsOnTheBattlefieldCondition(filter),§"As long as you control another multicolored permanent, {this} gets +1/+1"));§ability.addEffect(new ConditionalContinuousEffect(§new GainAbilitySourceEffect(FirstStrikeAbility.getInstance()),§new PermanentsOnTheBattlefieldCondition(filter),§"and has first strike"));§this.addAbility(ability);§}§public BantSureblade(final BantSureblade card) {§super(card);§}§@Override§public BantSureblade copy() {§return new BantSureblade(this);§}§}§
public class BehemothSledge extends CardImpl {§public BehemothSledge(UUID ownerId) {§super(ownerId, 65, "Behemoth Sledge", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{1}{G}{W}");§this.expansionSetCode = "ARB";§this.subtype.add("Equipment");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEquippedEffect(2, 2)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(LifelinkAbility.getInstance(), AttachmentType.EQUIPMENT)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(TrampleAbility.getInstance(), AttachmentType.EQUIPMENT)));§this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(3)));§}§protected BehemothSledge(BehemothSledge me) {§super(me);§}§@Override§public BehemothSledge copy() {§return new BehemothSledge(this);§}§}§
public class BituminousBlast extends CardImpl {§public BituminousBlast(UUID ownerId) {§super(ownerId, 34, "Bituminous Blast", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{3}{B}{R}");§this.expansionSetCode = "ARB";§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.getSpellAbility().addEffect(new DamageTargetEffect(4));§this.addAbility(new CascadeAbility());§}§public BituminousBlast(final BituminousBlast card) {§super(card);§}§@Override§public BituminousBlast copy() {§return new BituminousBlast(this);§}§}§
public class BlitzHellion extends CardImpl {§public BlitzHellion(UUID ownerId) {§super(ownerId, 49, "Blitz Hellion", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{R}{G}");§this.expansionSetCode = "ARB";§this.subtype.add("Hellion");§this.power = new MageInt(7);§this.toughness = new MageInt(7);§this.addAbility(TrampleAbility.getInstance());§this.addAbility(HasteAbility.getInstance());§Effect effect = new ShuffleIntoLibrarySourceEffect();§effect.setText("{this}'s owner shuffles it into his or her library.");§this.addAbility(new BeginningOfEndStepTriggeredAbility(Zone.BATTLEFIELD, effect, TargetController.ANY, null, false));§}§public BlitzHellion(final BlitzHellion card) {§super(card);§}§@Override§public BlitzHellion copy() {§return new BlitzHellion(this);§}§}§
public class BloodbraidElf extends CardImpl {§public BloodbraidElf(UUID ownerId) {§super(ownerId, 50, "Bloodbraid Elf", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{R}{G}");§this.expansionSetCode = "ARB";§this.subtype.add("Elf");§this.subtype.add("Berserker");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§this.addAbility(HasteAbility.getInstance());§this.addAbility(new CascadeAbility());§}§public BloodbraidElf(final BloodbraidElf card) {§super(card);§}§@Override§public BloodbraidElf copy() {§return new BloodbraidElf(this);§}§}§
public class Brainbite extends CardImpl {§public Brainbite(UUID ownerId) {§super(ownerId, 18, "Brainbite", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{2}{U}{B}");§this.expansionSetCode = "ARB";§this.getSpellAbility().addEffect(new DiscardCardYouChooseTargetEffect());§this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(1));§this.getSpellAbility().addTarget(new TargetOpponent());§}§public Brainbite(final Brainbite card) {§super(card);§}§@Override§public Brainbite copy() {§return new Brainbite(this);§}§}§
public class BreathOfMalfegor extends CardImpl {§public BreathOfMalfegor(UUID ownerId) {§super(ownerId, 35, "Breath of Malfegor", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{3}{B}{R}");§this.expansionSetCode = "ARB";§this.getSpellAbility().addEffect(new DamagePlayersEffect(5, TargetController.OPPONENT));§}§public BreathOfMalfegor(final BreathOfMalfegor card) {§super(card);§}§@Override§public BreathOfMalfegor copy() {§return new BreathOfMalfegor(this);§}§}§
public class CapturedSunlight extends CardImpl {§public CapturedSunlight (UUID ownerId) {§super(ownerId, 66, "Captured Sunlight", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{2}{G}{W}");§this.expansionSetCode = "ARB";§this.getSpellAbility().addEffect(new GainLifeEffect(4));§this.addAbility(new CascadeAbility());§}§public CapturedSunlight (final CapturedSunlight card) {§super(card);§}§@Override§public CapturedSunlight copy() {§return new CapturedSunlight(this);§}§}§
public class CerodonYearling extends CardImpl {§public CerodonYearling(UUID ownerId) {§super(ownerId, 96, "Cerodon Yearling", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{R}{W}");§this.expansionSetCode = "ARB";§this.subtype.add("Beast");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(VigilanceAbility.getInstance());§this.addAbility(HasteAbility.getInstance());§}§public CerodonYearling(final CerodonYearling card) {§super(card);§}§@Override§public CerodonYearling copy() {§return new CerodonYearling(this);§}§}§
public class Crystallization extends CardImpl {§public Crystallization(UUID ownerId) {§super(ownerId, 144, "Crystallization", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{G/U}{W}");§this.expansionSetCode = "ARB";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new CantAttackBlockAttachedEffect(AttachmentType.AURA)));§this.addAbility(new CrystallizationTriggeredAbility());§}§public Crystallization(final Crystallization card) {§super(card);§}§@Override§public Crystallization copy() {§return new Crystallization(this);§}§}§class CrystallizationTriggeredAbility extends TriggeredAbilityImpl {§public CrystallizationTriggeredAbility() {§super(Zone.BATTLEFIELD, new ExileTargetEffect());§}§public CrystallizationTriggeredAbility(final CrystallizationTriggeredAbility ability) {§super(ability);§}§@Override§public CrystallizationTriggeredAbility copy() {§return new CrystallizationTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.TARGETED;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§Permanent enchantment = game.getPermanent(sourceId);§if (enchantment != null && enchantment.getAttachedTo() != null) {§UUID enchanted = enchantment.getAttachedTo();§if (event.getTargetId().equals(enchanted)) {§getEffects().get(0).setTargetPointer(new FixedTarget(enchanted));§return true;§}§}§return false;§}§@Override§public String getRule() {§return "When enchanted creature becomes the target of a spell or ability, exile that creature.";§}§}§
public class DauntlessEscort extends CardImpl {§public DauntlessEscort(UUID ownerId) {§super(ownerId, 67, "Dauntless Escort", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{G}{W}");§this.expansionSetCode = "ARB";§this.subtype.add("Rhino");§this.subtype.add("Soldier");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§FilterPermanent filter = new FilterControlledCreaturePermanent("Creatures you control");§Effect effect = new GainAbilityAllEffect(IndestructibleAbility.getInstance(), Duration.EndOfTurn, filter, false);§effect.setText("Creatures you control are indestructible this turn");§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new SacrificeSourceCost()));§}§public DauntlessEscort(final DauntlessEscort card) {§super(card);§}§@Override§public DauntlessEscort copy() {§return new DauntlessEscort(this);§}§}§
public class DeadshotMinotaur extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature with flying");§static {§filter.add(new AbilityPredicate(FlyingAbility.class));§}§public DeadshotMinotaur(UUID ownerId) {§super(ownerId, 52, "Deadshot Minotaur", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{R}{G}");§this.expansionSetCode = "ARB";§this.subtype.add("Minotaur");§this.power = new MageInt(3);§this.toughness = new MageInt(4);§Ability ability = new EntersBattlefieldTriggeredAbility(new DamageTargetEffect(3), false);§ability.addTarget(new TargetCreaturePermanent(filter));§this.addAbility(ability);§this.addAbility(new CyclingAbility(new ManaCostsImpl("{R/G}")));§}§public DeadshotMinotaur(final DeadshotMinotaur card) {§super(card);§}§@Override§public DeadshotMinotaur copy() {§return new DeadshotMinotaur(this);§}§}§
public class DeathbringerThoctar extends CardImpl {§public DeathbringerThoctar(UUID ownerId) {§super(ownerId, 36, "Deathbringer Thoctar", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{B}{R}");§this.expansionSetCode = "ARB";§this.subtype.add("Zombie");§this.subtype.add("Beast");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new DiesCreatureTriggeredAbility(new AddCountersSourceEffect(CounterType.P1P1.createInstance()), true, true));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(1), new RemoveCountersSourceCost(CounterType.P1P1.createInstance()));§ability.addTarget(new TargetCreatureOrPlayer());§this.addAbility(ability);§}§public DeathbringerThoctar(final DeathbringerThoctar card) {§super(card);§}§@Override§public DeathbringerThoctar copy() {§return new DeathbringerThoctar(this);§}§}§
public class DefilerOfSouls extends CardImpl {§public DefilerOfSouls(UUID ownerId) {§super(ownerId, 37, "Defiler of Souls", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{3}{B}{B}{R}");§this.expansionSetCode = "ARB";§this.subtype.add("Demon");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new BeginningOfUpkeepTriggeredAbility(Zone.BATTLEFIELD, new DefilerOfSoulsEffect(), TargetController.ANY, false, true));§}§public DefilerOfSouls(final DefilerOfSouls card) {§super(card);§}§@Override§public DefilerOfSouls copy() {§return new DefilerOfSouls(this);§}§}§class DefilerOfSoulsEffect extends OneShotEffect {§DefilerOfSoulsEffect() {§super(Outcome.Sacrifice);§staticText = "that player sacrifices a monocolored creature";§}§DefilerOfSoulsEffect(final DefilerOfSoulsEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("monocolored creature");§Player player = game.getPlayer(targetPointer.getFirst(game, source));§if (player == null) {§return false;§}§filter.add(new MonocoloredPredicate());§int amount;§int realCount = game.getBattlefield().countAll(filter, player.getId(), game);§amount = Math.min(1, realCount);§Target target = new TargetControlledPermanent(amount, amount, filter, false);§target.setNotTarget(true);§if (amount > 0 && target.canChoose(source.getSourceId(), player.getId(), game)) {§boolean abilityApplied = false;§while (player.canRespond() && !target.isChosen() && target.canChoose(player.getId(), game)) {§player.choose(Outcome.Sacrifice, target, source.getSourceId(), game);§}§for ( int idx = 0; idx < target.getTargets().size(); idx++) {§Permanent permanent = game.getPermanent((UUID)target.getTargets().get(idx));§if ( permanent != null ) {§abilityApplied |= permanent.sacrifice(source.getSourceId(), game);§}§}§return abilityApplied;§}§return false;§}§@Override§public DefilerOfSoulsEffect copy() {§return new DefilerOfSoulsEffect(this);§}§}§
public class DemonicDread extends CardImpl {§public DemonicDread(UUID ownerId) {§super(ownerId, 38, "Demonic Dread", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{1}{B}{R}");§this.expansionSetCode = "ARB";§this.addAbility(new CascadeAbility());§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.getSpellAbility().addEffect(new CantBlockTargetEffect(Duration.EndOfTurn));§}§public DemonicDread(final DemonicDread card) {§super(card);§}§@Override§public DemonicDread copy() {§return new DemonicDread(this);§}§}§
public class DemonspineWhip extends CardImpl {§public DemonspineWhip(UUID ownerId) {§super(ownerId, 39, "Demonspine Whip", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{B}{R}");§this.expansionSetCode = "ARB";§this.subtype.add("Equipment");§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostEquippedEffect(new XPaid(), new StaticValue(0), Duration.EndOfTurn), new ManaCostsImpl("{X}")));§this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(1)));§}§public DemonspineWhip(final DemonspineWhip card) {§super(card);§}§@Override§public DemonspineWhip copy() {§return new DemonspineWhip(this);§}§}§class XPaid implements DynamicValue {§@Override§public int calculate(Game game, Ability sourceAbility, Effect effect) {§int paid = sourceAbility.getManaCostsToPay().getX();§return paid;§}§@Override§public DynamicValue copy() {§return this;§}§@Override§public String getMessage() {§return "X paid";§}§@Override§public String toString() {§return "X";§}§}§
public class DenyReality extends CardImpl {§public DenyReality (UUID ownerId) {§super(ownerId, 19, "Deny Reality", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{3}{U}{B}");§this.expansionSetCode = "ARB";§this.getSpellAbility().addTarget(new TargetPermanent());§this.getSpellAbility().addEffect(new ReturnToHandTargetEffect());§this.addAbility(new CascadeAbility());§}§public DenyReality (final DenyReality card) {§super(card);§}§@Override§public DenyReality copy() {§return new DenyReality(this);§}§}§
public class DoubleNegative extends CardImpl {§public DoubleNegative(UUID ownerId) {§super(ownerId, 87, "Double Negative", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{U}{U}{R}");§this.expansionSetCode = "ARB";§Effect effect = new CounterTargetEffect();§effect.setText("Counter up to two target spells");§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addTarget(new TargetSpell(0, 2, new FilterSpell()));§}§public DoubleNegative(final DoubleNegative card) {§super(card);§}§@Override§public DoubleNegative copy() {§return new DoubleNegative(this);§}§}§
public class DragonAppeasement extends CardImpl {§public DragonAppeasement(UUID ownerId) {§super(ownerId, 115, "Dragon Appeasement", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{3}{B}{R}{G}");§this.expansionSetCode = "ARB";§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new SkipDrawStepEffect()));§this.addAbility(new DragonAppeasementTriggeredAbility());§}§public DragonAppeasement(final DragonAppeasement card) {§super(card);§}§@Override§public DragonAppeasement copy() {§return new DragonAppeasement(this);§}§}§class DragonAppeasementTriggeredAbility extends TriggeredAbilityImpl {§public DragonAppeasementTriggeredAbility() {§super(Zone.BATTLEFIELD, new DrawCardSourceControllerEffect(1), true);§setLeavesTheBattlefieldTrigger(true);§}§public DragonAppeasementTriggeredAbility(final DragonAppeasementTriggeredAbility ability) {§super(ability);§}§@Override§public DragonAppeasementTriggeredAbility copy() {§return new DragonAppeasementTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.SACRIFICED_PERMANENT;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§return event.getPlayerId().equals(this.getControllerId())§&& game.getLastKnownInformation(event.getTargetId(), Zone.BATTLEFIELD).getCardType().contains(CardType.CREATURE);§}§@Override§public String getRule() {§return "Whenever you sacrifice a creature, " + super.getRule();§}§}§
public class DragonBroodmother extends CardImpl {§public DragonBroodmother(UUID ownerId) {§super(ownerId, 53, "Dragon Broodmother", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{2}{R}{R}{R}{G}");§this.expansionSetCode = "ARB";§this.subtype.add("Dragon");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new BeginningOfUpkeepTriggeredAbility(new CreateTokenEffect(new DragonToken()), TargetController.ANY, false));§}§public DragonBroodmother(final DragonBroodmother card) {§super(card);§}§@Override§public DragonBroodmother copy() {§return new DragonBroodmother(this);§}§}§class DragonToken extends Token {§DragonToken() {§super("Dragon", "1/1 red and green Dragon creature token with flying and devour 2");§cardType.add(CardType.CREATURE);§color.setGreen(true);§color.setRed(true);§subtype.add("Dragon");§power = new MageInt(1);§toughness = new MageInt(1);§addAbility(FlyingAbility.getInstance());§addAbility(new DevourAbility(DevourEffect.DevourFactor.Devour2));§}§}§
public class DrasticRevelation extends CardImpl {§public DrasticRevelation(UUID ownerId) {§super(ownerId, 111, "Drastic Revelation", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{2}{U}{B}{R}");§this.expansionSetCode = "ARB";§this.getSpellAbility().addEffect(new DrasticRevelationEffect());§}§public DrasticRevelation(final DrasticRevelation card) {§super(card);§}§@Override§public DrasticRevelation copy() {§return new DrasticRevelation(this);§}§}§class DrasticRevelationEffect extends OneShotEffect {§DrasticRevelationEffect() {§super(Outcome.DrawCard);§staticText = "Discard your hand. Draw seven cards, then discard three cards at random";§}§DrasticRevelationEffect(final DrasticRevelationEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player you = game.getPlayer(source.getControllerId());§you.discardToMax(game);§you.drawCards(7, game);§Cards hand = you.getHand();§for (int i = 0; i < 3; i++) {§Card card = hand.getRandom(game);§if (card != null) {§you.discard(card, source, game);§}§}§return false;§}§@Override§public DrasticRevelationEffect copy() {§return new DrasticRevelationEffect(this);§}§}§
public class EnigmaSphinx extends CardImpl {§public EnigmaSphinx(UUID ownerId) {§super(ownerId, 106, "Enigma Sphinx", Rarity.RARE, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{4}{W}{U}{B}");§this.expansionSetCode = "ARB";§this.subtype.add("Sphinx");§this.power = new MageInt(5);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new EnigmaSphinxTriggeredAbility(new EnigmaSphinxEffect()));§this.addAbility(new CascadeAbility());§}§public EnigmaSphinx(final EnigmaSphinx card) {§super(card);§}§@Override§public EnigmaSphinx copy() {§return new EnigmaSphinx(this);§}§}§class EnigmaSphinxTriggeredAbility extends TriggeredAbilityImpl {§public EnigmaSphinxTriggeredAbility(Effect effect) {§this(effect, false);§}§public EnigmaSphinxTriggeredAbility(Effect effect, boolean optional) {§super(Zone.ALL, effect, optional);§}§EnigmaSphinxTriggeredAbility(EnigmaSphinxTriggeredAbility ability) {§super(ability);§}§@Override§public EnigmaSphinxTriggeredAbility copy() {§return new EnigmaSphinxTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.ZONE_CHANGE;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§ZoneChangeEvent zEvent = (ZoneChangeEvent) event;§Permanent permanent = zEvent.getTarget();§if (permanent != null &&§zEvent.getToZone() == Zone.GRAVEYARD &&§zEvent.getFromZone() == Zone.BATTLEFIELD &&§permanent.getId().equals(this.getSourceId()) &&§permanent.getOwnerId().equals(permanent.getControllerId())) {§return true;§}§return false;§}§@Override§public String getRule() {§return "When {this} is put into your graveyard from the battlefield, " + super.getRule();§}§}§class EnigmaSphinxEffect extends OneShotEffect {§public EnigmaSphinxEffect() {§super(Outcome.ReturnToHand);§staticText = "put it into your library third from the top";§}§public EnigmaSphinxEffect(final EnigmaSphinxEffect effect) {§super(effect);§}§@Override§public EnigmaSphinxEffect copy() {§return new EnigmaSphinxEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Card card = game.getCard(source.getSourceId());§if (card != null && game.getState().getZone(source.getSourceId()) == Zone.GRAVEYARD) {§Player owner = game.getPlayer(card.getOwnerId());§if (owner != null && card.moveToZone(Zone.LIBRARY, source.getSourceId(), game, true)) {§game.informPlayers(card.getLogName() + " is put into " + owner.getLogName() +"'s library third from the top");§Library lib = owner.getLibrary();§if (lib != null) {§Card card1 = lib.removeFromTop(game);§if (card1 != null && card1.getId().equals(source.getSourceId())) {§Card card2 = lib.removeFromTop(game);§Card card3 = lib.removeFromTop(game);§lib.putOnTop(card1, game);§if (card3 != null) {§lib.putOnTop(card3, game);§}§if (card2 != null) {§lib.putOnTop(card2, game);§}§return true;§}§}§}§}§return false;§}§}§
public class EnlistedWurm extends CardImpl {§public EnlistedWurm(UUID ownerId) {§super(ownerId, 68, "Enlisted Wurm", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{G}{W}");§this.expansionSetCode = "ARB";§this.subtype.add("Wurm");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(new CascadeAbility());§}§public EnlistedWurm(final EnlistedWurm card) {§super(card);§}§@Override§public EnlistedWurm copy() {§return new EnlistedWurm(this);§}§}§
public class EsperSojourners extends CardImpl {§public EsperSojourners(UUID ownerId) {§super(ownerId, 107, "Esper Sojourners", Rarity.COMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{W}{U}{B}");§this.expansionSetCode = "ARB";§this.subtype.add("Vedalken");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§Ability ability1 = new CycleTriggeredAbility(new MayTapOrUntapTargetEffect());§Ability ability2 = new DiesTriggeredAbility(new MayTapOrUntapTargetEffect());§ability1.addTarget(new TargetPermanent());§ability2.addTarget(new TargetPermanent());§this.addAbility(ability1);§this.addAbility(ability2);§this.addAbility(new CyclingAbility(new ManaCostsImpl("{2}{U}")));§}§public EsperSojourners(final EsperSojourners card) {§super(card);§}§@Override§public EsperSojourners copy() {§return new EsperSojourners(this);§}§}§
public class EsperStormblade extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("another multicolor permanent");§static {§filter.add(new MulticoloredPredicate());§filter.add(new AnotherPredicate());§}§public EsperStormblade(UUID ownerId) {§super(ownerId, 132, "Esper Stormblade", Rarity.COMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{W/B}{U}");§this.expansionSetCode = "ARB";§this.subtype.add("Vedalken");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new ConditionalContinuousEffect(§new BoostSourceEffect(1,1, Duration.WhileOnBattlefield),§new PermanentsOnTheBattlefieldCondition(filter),§"As long as you control another multicolored permanent, {this} gets +1/+1"));§ability.addEffect(new ConditionalContinuousEffect(§new GainAbilitySourceEffect(FlyingAbility.getInstance()),§new PermanentsOnTheBattlefieldCondition(filter),§"and has flying"));§this.addAbility(ability);§}§public EsperStormblade(final EsperStormblade card) {§super(card);§}§@Override§public EsperStormblade copy() {§return new EsperStormblade(this);§}§}§
public class EthercasteKnight extends CardImpl {§public EthercasteKnight (UUID ownerId) {§super(ownerId, 3, "Ethercaste Knight", Rarity.COMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{W}{U}");§this.expansionSetCode = "ARB";§this.subtype.add("Human");§this.subtype.add("Knight");§this.power = new MageInt(1);§this.toughness = new MageInt(3);§this.addAbility(new ExaltedAbility());§}§public EthercasteKnight (final EthercasteKnight card) {§super(card);§}§@Override§public EthercasteKnight copy() {§return new EthercasteKnight(this);§}§}§
public class EtheriumAbomination extends CardImpl {§public EtheriumAbomination (UUID ownerId) {§super(ownerId, 20, "Etherium Abomination", Rarity.COMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{3}{U}{B}");§this.expansionSetCode = "ARB";§this.subtype.add("Horror");§this.power = new MageInt(4);§this.toughness = new MageInt(3);§this.addAbility(new UnearthAbility(new ManaCostsImpl("{1}{U}{B}")));§}§public EtheriumAbomination (final EtheriumAbomination card) {§super(card);§}§@Override§public EtheriumAbomination copy() {§return new EtheriumAbomination(this);§}§}§
public class FieldmistBorderpost extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledLandPermanent("a basic land");§static {§filter.add(new SupertypePredicate("Basic"));§}§public FieldmistBorderpost (UUID ownerId) {§super(ownerId, 5, "Fieldmist Borderpost", Rarity.COMMON, new CardType[]{CardType.ARTIFACT}, "{1}{W}{U}");§this.expansionSetCode = "ARB";§Ability ability = new AlternativeCostSourceAbility(new GenericManaCost(1));§ability.addCost(new ReturnToHandChosenControlledPermanentCost(new TargetControlledPermanent(filter)));§this.addAbility(ability);§this.addAbility(new EntersBattlefieldTappedAbility());§this.addAbility(new WhiteManaAbility());§this.addAbility(new BlueManaAbility());§}§public FieldmistBorderpost (final FieldmistBorderpost card) {§super(card);§}§@Override§public FieldmistBorderpost copy() {§return new FieldmistBorderpost(this);§}§}§
public class FightToTheDeath extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("all blocking creatures and all blocked creatures");§static {§filter.add(Predicates.or(§new BlockingPredicate(),§new BlockedPredicate()));§}§public FightToTheDeath(UUID ownerId) {§super(ownerId, 97, "Fight to the Death", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{R}{W}");§this.expansionSetCode = "ARB";§this.getSpellAbility().addEffect(new DestroyAllEffect(filter));§}§public FightToTheDeath(final FightToTheDeath card) {§super(card);§}§@Override§public FightToTheDeath copy() {§return new FightToTheDeath(this);§}§}§
public class FiligreeAngel extends CardImpl {§public FiligreeAngel (UUID ownerId) {§super(ownerId, 6, "Filigree Angel", Rarity.RARE, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{5}{W}{W}{U}");§this.expansionSetCode = "ARB";§this.subtype.add("Angel");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new EntersBattlefieldTriggeredAbility(new FiligreeAngelEffect()));§}§public FiligreeAngel (final FiligreeAngel card) {§super(card);§}§@Override§public FiligreeAngel copy() {§return new FiligreeAngel(this);§}§}§class FiligreeAngelEffect extends OneShotEffect {§private static final FilterPermanent filter = new FilterControlledPermanent();§static {§filter.add(new CardTypePredicate(CardType.ARTIFACT));§}§public FiligreeAngelEffect() {§super(Outcome.GainLife);§staticText = "you gain 3 life for each artifact you control";§}§public FiligreeAngelEffect(final FiligreeAngelEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§int life = game.getBattlefield().count(filter, source.getSourceId(), source.getControllerId(), game) * 3;§player.gainLife(life, game);§}§return true;§}§@Override§public FiligreeAngelEffect copy() {§return new FiligreeAngelEffect(this);§}§}§
public class FinestHour extends CardImpl {§public FinestHour(UUID ownerId) {§super(ownerId, 126, "Finest Hour", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{2}{G}{W}{U}");§this.expansionSetCode = "ARB";§this.addAbility(new ExaltedAbility());§this.addAbility(new FinestHourAbility());§}§public FinestHour(final FinestHour card) {§super(card);§}§@Override§public FinestHour copy() {§return new FinestHour(this);§}§}§class FinestHourAbility extends TriggeredAbilityImpl {§public FinestHourAbility() {§super(Zone.BATTLEFIELD, new FinestHourEffect());§}§public FinestHourAbility(final FinestHourAbility ability) {§super(ability);§}§@Override§public FinestHourAbility copy() {§return new FinestHourAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.DECLARED_ATTACKERS;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (game.getActivePlayerId().equals(this.controllerId)) {§if (game.getCombat().attacksAlone()) {§for (Effect effect: this.getEffects()) {§effect.setTargetPointer(new FixedTarget(game.getCombat().getAttackers().get(0)));§}§return true;§}§}§return false;§}§@Override§public boolean checkInterveningIfClause(Game game) {§return game.getTurn().getPhase(TurnPhase.COMBAT).getCount() == 0;§}§@Override§public String getRule() {§return "Whenever a creature you control attacks alone, if it's the first combat phase of the turn, untap that creature. After this phase, there is an additional combat phase.";§}§}§class FinestHourEffect extends OneShotEffect {§public FinestHourEffect() {§super(Outcome.Benefit);§}§public FinestHourEffect(final FinestHourEffect effect) {§super(effect);§}§@Override§public FinestHourEffect copy() {§return new FinestHourEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getPermanent(this.getTargetPointer().getFirst(game, source));§if (permanent != null) {§permanent.untap(game);§game.getState().getTurnMods().add(new TurnMod(source.getControllerId(), TurnPhase.COMBAT, null, false));§return true;§}§return false;§}§}§
public class FirewildBorderpost extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledLandPermanent("a basic land");§static {§filter.add(new SupertypePredicate("Basic"));§}§public FirewildBorderpost (UUID ownerId) {§super(ownerId, 54, "Firewild Borderpost", Rarity.COMMON, new CardType[]{CardType.ARTIFACT}, "{1}{R}{G}");§this.expansionSetCode = "ARB";§Ability ability = new AlternativeCostSourceAbility(new GenericManaCost(1));§ability.addCost(new ReturnToHandChosenControlledPermanentCost(new TargetControlledPermanent(filter)));§this.addAbility(ability);§this.addAbility(new EntersBattlefieldTappedAbility());§this.addAbility(new RedManaAbility());§this.addAbility(new GreenManaAbility());§}§public FirewildBorderpost (final FirewildBorderpost card) {§super(card);§}§@Override§public FirewildBorderpost copy() {§return new FirewildBorderpost(this);§}§}§
public class FlurryOfWings extends CardImpl {§private static final FilterAttackingCreature filter = new FilterAttackingCreature("the number of attacking creatures");§public FlurryOfWings(UUID ownerId) {§super(ownerId, 127, "Flurry of Wings", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{G}{W}{U}");§this.expansionSetCode = "ARB";§this.getSpellAbility().addEffect(new CreateTokenEffect(new BirdSoldierToken(), new PermanentsOnBattlefieldCount(filter)));§}§public FlurryOfWings(final FlurryOfWings card) {§super(card);§}§@Override§public FlurryOfWings copy() {§return new FlurryOfWings(this);§}§}§class BirdSoldierToken extends Token {§public BirdSoldierToken() {§super("Bird Soldier", "1/1 white Bird Soldier creature with flying");§cardType.add(CardType.CREATURE);§subtype.add("Bird");§color.setWhite(true);§power = new MageInt(1);§toughness = new MageInt(1);§addAbility(FlyingAbility.getInstance());§}§}§
public class GiantAmbushBeetle extends CardImpl {§public GiantAmbushBeetle(UUID ownerId) {§super(ownerId, 137, "Giant Ambush Beetle", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{B/G}{R}");§this.expansionSetCode = "ARB";§this.subtype.add("Insect");§this.power = new MageInt(4);§this.toughness = new MageInt(3);§this.addAbility(HasteAbility.getInstance());§Ability ability = new EntersBattlefieldTriggeredAbility(new MustBeBlockedByTargetSourceEffect(Duration.EndOfTurn), true);§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public GiantAmbushBeetle(final GiantAmbushBeetle card) {§super(card);§}§@Override§public GiantAmbushBeetle copy() {§return new GiantAmbushBeetle(this);§}§}§
public class GlassdustHulk extends CardImpl {§private static final FilterPermanent filter = new FilterArtifactPermanent("another artifact");§static {§filter.add(new ControllerPredicate(TargetController.YOU));§filter.add(new AnotherPredicate());§}§public GlassdustHulk(UUID ownerId) {§super(ownerId, 7, "Glassdust Hulk", Rarity.COMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{3}{W}{U}");§this.expansionSetCode = "ARB";§this.subtype.add("Golem");§this.power = new MageInt(3);§this.toughness = new MageInt(4);§Ability ability = new EntersBattlefieldControlledTriggeredAbility(new BoostSourceEffect(1, 1, Duration.EndOfTurn), filter,§"Whenever another artifact enters the battlefield under your control, Glassdust Hulk gets +1/+1 until end of turn and can't be blocked this turn.");§ability.addEffect(new CantBeBlockedSourceEffect(Duration.EndOfTurn));§this.addAbility(ability);§this.addAbility(new CyclingAbility(new ManaCostsImpl("{W/U}")));§}§public GlassdustHulk(final GlassdustHulk card) {§super(card);§}§@Override§public GlassdustHulk copy() {§return new GlassdustHulk(this);§}§}§
public class GloryOfWarfare extends CardImpl {§public GloryOfWarfare (UUID ownerId) {§super(ownerId, 98, "Glory of Warfare", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{2}{R}{W}");§this.expansionSetCode = "ARB";§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new ConditionalContinuousEffect(§new BoostControlledEffect(2, 0, Duration.WhileOnBattlefield),§MyTurnCondition.getInstance(),§"As long as it's your turn, creatures you control get +2/+0")));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new ConditionalContinuousEffect(§new BoostControlledEffect(0, 2, Duration.WhileOnBattlefield),§NotMyTurnCondition.getInstance(),§"As long as it's not your turn, creatures you control get +0/+2")));§}§public GloryOfWarfare (final GloryOfWarfare card) {§super(card);§}§@Override§public GloryOfWarfare copy() {§return new GloryOfWarfare(this);§}§}§
public class GloryscaleViashino extends CardImpl {§private static final FilterSpell filter = new FilterSpell("a multicolored spell");§static {§filter.add(new MulticoloredPredicate());§}§public GloryscaleViashino (UUID ownerId) {§super(ownerId, 120, "Gloryscale Viashino", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{R}{G}{W}");§this.expansionSetCode = "ARB";§this.subtype.add("Viashino");§this.subtype.add("Soldier");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new SpellCastControllerTriggeredAbility(new BoostSourceEffect(3, 3, Duration.EndOfTurn), filter, false));§}§public GloryscaleViashino (final GloryscaleViashino card) {§super(card);§}§@Override§public GloryscaleViashino copy() {§return new GloryscaleViashino(this);§}§}§
public class GodtrackerOfJund extends CardImpl {§final private static FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent();§static {§filter.add(new PowerPredicate(Filter.ComparisonType.GreaterThan, 4));§}§String rule = "Whenever a creature with power 5 or greater enters the battlefield under your control, you may put a +1/+1 counter on {this}.";§public GodtrackerOfJund(UUID ownerId) {§super(ownerId, 55, "Godtracker of Jund", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{R}{G}");§this.expansionSetCode = "ARB";§this.subtype.add("Elf");§this.subtype.add("Shaman");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new EntersBattlefieldAllTriggeredAbility(Zone.BATTLEFIELD, new AddCountersSourceEffect(CounterType.P1P1.createInstance()), filter, true, rule, true));§}§public GodtrackerOfJund(final GodtrackerOfJund card) {§super(card);§}§@Override§public GodtrackerOfJund copy() {§return new GodtrackerOfJund(this);§}§}§
public class GorgerWurm extends CardImpl {§public GorgerWurm(UUID ownerId) {§super(ownerId, 56, "Gorger Wurm", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{R}{G}");§this.expansionSetCode = "ARB";§this.subtype.add("Wurm");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(new DevourAbility(DevourEffect.DevourFactor.Devour1));§}§public GorgerWurm(final GorgerWurm card) {§super(card);§}§@Override§public GorgerWurm copy() {§return new GorgerWurm(this);§}§}§
public class GrixisGrimblade extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("another multicolor permanent");§static {§filter.add(new MulticoloredPredicate());§filter.add(new AnotherPredicate());§}§public GrixisGrimblade(UUID ownerId) {§super(ownerId, 134, "Grixis Grimblade", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{U/R}{B}");§this.expansionSetCode = "ARB";§this.subtype.add("Zombie");§this.subtype.add("Warrior");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new ConditionalContinuousEffect(§new BoostSourceEffect(1,1, Duration.WhileOnBattlefield),§new PermanentsOnTheBattlefieldCondition(filter),§"As long as you control another multicolored permanent, {this} gets +1/+1"));§ability.addEffect(new ConditionalContinuousEffect(§new GainAbilitySourceEffect(DeathtouchAbility.getInstance()),§new PermanentsOnTheBattlefieldCondition(filter),§"and has deathtouch"));§this.addAbility(ability);§}§public GrixisGrimblade(final GrixisGrimblade card) {§super(card);§}§@Override§public GrixisGrimblade copy() {§return new GrixisGrimblade(this);§}§}§
public class GrixisSojourners extends CardImpl {§public GrixisSojourners(UUID ownerId) {§super(ownerId, 112, "Grixis Sojourners", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{U}{B}{R}");§this.expansionSetCode = "ARB";§this.subtype.add("Zombie");§this.subtype.add("Ogre");§this.power = new MageInt(4);§this.toughness = new MageInt(3);§Ability ability1 = new CycleTriggeredAbility(new ExileTargetEffect(), true);§Ability ability2 = new DiesTriggeredAbility(new ExileTargetEffect(), true);§ability1.addTarget(new TargetCardInASingleGraveyard(1, 1, new FilterCard()));§ability2.addTarget(new TargetCardInASingleGraveyard(1, 1, new FilterCard()));§this.addAbility(ability1);§this.addAbility(ability2);§this.addAbility(new CyclingAbility(new ManaCostsImpl("{2}{B}")));§}§public GrixisSojourners(final GrixisSojourners card) {§super(card);§}§@Override§public GrixisSojourners copy() {§return new GrixisSojourners(this);§}§}§
public class GrizzledLeotau extends CardImpl {§public GrizzledLeotau(UUID ownerId) {§super(ownerId, 69, "Grizzled Leotau", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{G}{W}");§this.expansionSetCode = "ARB";§this.subtype.add("Cat");§this.power = new MageInt(1);§this.toughness = new MageInt(5);§}§public GrizzledLeotau(final GrizzledLeotau card) {§super(card);§}§@Override§public GrizzledLeotau copy() {§return new GrizzledLeotau(this);§}§}§
public class IdentityCrisis extends CardImpl {§public IdentityCrisis (UUID ownerId) {§super(ownerId, 81, "Identity Crisis", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{2}{W}{W}{B}{B}");§this.expansionSetCode = "ARB";§this.getSpellAbility().addEffect(new IdentityCrisisEffect());§this.getSpellAbility().addTarget(new TargetPlayer());§}§public IdentityCrisis (final IdentityCrisis card) {§super(card);§}§@Override§public IdentityCrisis copy() {§return new IdentityCrisis(this);§}§}§class IdentityCrisisEffect extends OneShotEffect {§IdentityCrisisEffect() {§super(Outcome.Exile);§staticText = "Exile all cards from target player's hand and graveyard";§}§IdentityCrisisEffect(final IdentityCrisisEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getFirstTarget());§if (player != null) {§for (UUID cid : player.getHand().copy()) {§Card c = game.getCard(cid);§if (c != null) {§c.moveToExile(null, null, source.getSourceId(), game);§}§}§for (UUID cid : player.getGraveyard().copy()) {§Card c = game.getCard(cid);§if (c != null) {§c.moveToExile(null, null, source.getSourceId(), game);§}§}§return true;§}§return false;§}§@Override§public IdentityCrisisEffect copy() {§return new IdentityCrisisEffect(this);§}§}§
public class IgneousPouncer extends CardImpl {§public IgneousPouncer(UUID ownerId) {§super(ownerId, 40, "Igneous Pouncer", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{B}{R}");§this.expansionSetCode = "ARB";§this.subtype.add("Elemental");§this.power = new MageInt(5);§this.toughness = new MageInt(1);§this.addAbility(HasteAbility.getInstance());§this.addAbility(new SwampcyclingAbility(new ManaCostsImpl("{2}")));§this.addAbility(new MountaincyclingAbility(new ManaCostsImpl("{2}")));§}§public IgneousPouncer(final IgneousPouncer card) {§super(card);§}§@Override§public IgneousPouncer copy() {§return new IgneousPouncer(this);§}§}§
public class IllusoryDemon extends CardImpl {§public IllusoryDemon(UUID ownerId) {§super(ownerId, 21, "Illusory Demon", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{U}{B}");§this.expansionSetCode = "ARB";§this.subtype.add("Demon");§this.subtype.add("Illusion");§this.power = new MageInt(4);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new SpellCastControllerTriggeredAbility(new SacrificeSourceEffect(), false));§}§public IllusoryDemon(final IllusoryDemon card) {§super(card);§}§@Override§public IllusoryDemon copy() {§return new IllusoryDemon(this);§}§}§
public class JhessianZombies extends CardImpl {§public JhessianZombies(UUID ownerId) {§super(ownerId, 22, "Jhessian Zombies", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{U}{B}");§this.expansionSetCode = "ARB";§this.subtype.add("Zombie");§this.power = new MageInt(2);§this.toughness = new MageInt(4);§this.addAbility(FearAbility.getInstance());§this.addAbility(new IslandcyclingAbility(new ManaCostsImpl("{2}")));§this.addAbility(new SwampcyclingAbility(new ManaCostsImpl("{2}")));§}§public JhessianZombies(final JhessianZombies card) {§super(card);§}§@Override§public JhessianZombies copy() {§return new JhessianZombies(this);§}§}§
public class JundHackblade extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("another multicolor permanent");§static {§filter.add(new MulticoloredPredicate());§filter.add(new AnotherPredicate());§}§public JundHackblade(UUID ownerId) {§super(ownerId, 138, "Jund Hackblade", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{B/G}{R}");§this.expansionSetCode = "ARB";§this.subtype.add("Goblin");§this.subtype.add("Berserker");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new ConditionalContinuousEffect(§new BoostSourceEffect(1,1, Duration.WhileOnBattlefield),§new PermanentsOnTheBattlefieldCondition(filter),§"As long as you control another multicolored permanent, {this} gets +1/+1"));§ability.addEffect(new ConditionalContinuousEffect(§new GainAbilitySourceEffect(HasteAbility.getInstance()),§new PermanentsOnTheBattlefieldCondition(filter),§"and has haste"));§this.addAbility(ability);§}§public JundHackblade(final JundHackblade card) {§super(card);§}§@Override§public JundHackblade copy() {§return new JundHackblade(this);§}§}§
public class JundSojourners extends CardImpl {§public JundSojourners(UUID ownerId) {§super(ownerId, 116, "Jund Sojourners", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{B}{R}{G}");§this.expansionSetCode = "ARB";§this.subtype.add("Viashino");§this.subtype.add("Shaman");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§Ability ability1 = new CycleTriggeredAbility(new DamageTargetEffect(1));§Ability ability2 = new DiesTriggeredAbility(new DamageTargetEffect(1));§ability1.addTarget(new TargetCreatureOrPlayer());§ability2.addTarget(new TargetCreatureOrPlayer());§this.addAbility(ability1);§this.addAbility(ability2);§this.addAbility(new CyclingAbility(new ManaCostsImpl("{2}{R}")));§}§public JundSojourners(final JundSojourners card) {§super(card);§}§@Override§public JundSojourners copy() {§return new JundSojourners(this);§}§}§
public class KarrthusTyrantOfJund extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("Dragon creatures you control");§static {§filter.add(new AnotherPredicate());§filter.add(new SubtypePredicate("Dragon"));§}§public KarrthusTyrantOfJund(UUID ownerId) {§super(ownerId, 117, "Karrthus, Tyrant of Jund", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{4}{B}{R}{G}");§this.expansionSetCode = "ARB";§this.supertype.add("Legendary");§this.subtype.add("Dragon");§this.power = new MageInt(7);§this.toughness = new MageInt(7);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(HasteAbility.getInstance());§this.addAbility(new EntersBattlefieldTriggeredAbility(new KarrthusEffect()));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAllEffect(HasteAbility.getInstance(), Duration.WhileOnBattlefield, filter, true)));§}§public KarrthusTyrantOfJund(final KarrthusTyrantOfJund card) {§super(card);§}§@Override§public KarrthusTyrantOfJund copy() {§return new KarrthusTyrantOfJund(this);§}§}§class KarrthusEffect extends OneShotEffect {§public KarrthusEffect() {§super(Outcome.GainControl);§this.staticText = "gain control of all Dragons, then untap all Dragons";§}§public KarrthusEffect(final KarrthusEffect effect) {§super(effect);§}§@Override§public KarrthusEffect copy() {§return new KarrthusEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§FilterPermanent filter = new FilterPermanent();§filter.add(new SubtypePredicate("Dragon"));§List<Permanent> dragons = game.getBattlefield().getAllActivePermanents(filter, game);§for (Permanent dragon : dragons) {§ContinuousEffect effect = new KarrthusControlEffect(source.getControllerId());§effect.setTargetPointer(new FixedTarget(dragon.getId()));§game.addEffect(effect, source);§}§for (Permanent dragon : dragons) {§dragon.untap(game);§}§return true;§}§}§class KarrthusControlEffect extends ContinuousEffectImpl {§private UUID controllerId;§public KarrthusControlEffect(UUID controllerId) {§super(Duration.EndOfGame, Layer.ControlChangingEffects_2, SubLayer.NA, Outcome.GainControl);§this.controllerId = controllerId;§}§public KarrthusControlEffect(final KarrthusControlEffect effect) {§super(effect);§this.controllerId = effect.controllerId;§}§@Override§public KarrthusControlEffect copy() {§return new KarrthusControlEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent dragon = game.getPermanent(targetPointer.getFirst(game, source));§if (dragon != null && controllerId != null) {§return dragon.changeControllerId(controllerId, game);§}§return false;§}§}§
public class KathariBomber extends CardImpl {§public KathariBomber(UUID ownerId) {§super(ownerId, 41, "Kathari Bomber", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{B}{R}");§this.expansionSetCode = "ARB";§this.subtype.add("Bird");§this.subtype.add("Shaman");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new DealsCombatDamageToAPlayerTriggeredAbility(new CreateTokenEffect(new GoblinToken(), 2), false);§ability.addEffect(new SacrificeSourceEffect());§this.addAbility(ability);§this.addAbility(new UnearthAbility(new ManaCostsImpl("{3}{B}{R}")));§}§public KathariBomber(final KathariBomber card) {§super(card);§}§@Override§public KathariBomber copy() {§return new KathariBomber(this);§}§}§
public class KathariRemnant extends CardImpl {§public KathariRemnant (UUID ownerId) {§super(ownerId, 23, "Kathari Remnant", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{U}{B}");§this.expansionSetCode = "ARB";§this.subtype.add("Bird");§this.subtype.add("Skeleton");§this.power = new MageInt(0);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new RegenerateSourceEffect(), new ManaCostsImpl("{B}")));§this.addAbility(new CascadeAbility());§}§public KathariRemnant (final KathariRemnant card) {§super(card);§}§@Override§public KathariRemnant copy() {§return new KathariRemnant(this);§}§}§
public class KnightOfNewAlara extends CardImpl {§public KnightOfNewAlara(UUID ownerId) {§super(ownerId, 70, "Knight of New Alara", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{G}{W}");§this.expansionSetCode = "ARB";§this.subtype.add("Human");§this.subtype.add("Knight");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new KnightOfNewAlaraEffect()));§}§public KnightOfNewAlara(final KnightOfNewAlara card) {§super(card);§}§@Override§public KnightOfNewAlara copy() {§return new KnightOfNewAlara(this);§}§}§class KnightOfNewAlaraEffect extends ContinuousEffectImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent();§static {§filter.add(new MulticoloredPredicate());§}§public KnightOfNewAlaraEffect() {§super(Duration.WhileOnBattlefield, Layer.PTChangingEffects_7, SubLayer.ModifyPT_7c, Outcome.BoostCreature);§staticText = "Each other multicolored creature you control gets +1/+1 for each of its colors";§}§public KnightOfNewAlaraEffect(final KnightOfNewAlaraEffect effect) {§super(effect);§}§@Override§public KnightOfNewAlaraEffect copy() {§return new KnightOfNewAlaraEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§for (Permanent creature : game.getBattlefield().getAllActivePermanents(filter, source.getControllerId(), game)) {§if (creature != null && !creature.getId().equals(source.getSourceId())) {§int colors = creature.getColor(game).getColorCount();§creature.addPower(colors);§creature.addToughness(colors);§}§}§return true;§}§}§
public class KnotvinePaladin extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("untapped creature you control");§static {§filter.add(Predicates.not(new TappedPredicate()));§}§public KnotvinePaladin(UUID ownerId) {§super(ownerId, 71, "Knotvine Paladin", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{G}{W}");§this.expansionSetCode = "ARB";§this.subtype.add("Human");§this.subtype.add("Knight");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new AttacksTriggeredAbility(new BoostSourceEffect(new PermanentsOnBattlefieldCount(filter), new PermanentsOnBattlefieldCount(filter), Duration.EndOfTurn), false));§}§public KnotvinePaladin(final KnotvinePaladin card) {§super(card);§}§@Override§public KnotvinePaladin copy() {§return new KnotvinePaladin(this);§}§}§
public class Lavalanche extends CardImpl {§public Lavalanche(UUID ownerId) {§super(ownerId, 118, "Lavalanche", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{X}{B}{R}{G}");§this.expansionSetCode = "ARB";§this.getSpellAbility().addEffect(new LavalancheEffect(new ManacostVariableValue()));§this.getSpellAbility().addTarget(new TargetPlayer());§}§public Lavalanche(final Lavalanche card) {§super(card);§}§@Override§public Lavalanche copy() {§return new Lavalanche(this);§}§}§class LavalancheEffect extends OneShotEffect {§private DynamicValue amount;§public LavalancheEffect(DynamicValue amount) {§super(Outcome.Damage);§this.amount = amount;§staticText = "Lavalanche deals X damage to target player and each creature he or she controls";§}§public LavalancheEffect(final LavalancheEffect effect) {§super(effect);§this.amount = effect.amount;§}§@Override§public LavalancheEffect copy() {§return new LavalancheEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player targetPlayer = game.getPlayer(source.getFirstTarget());§if (targetPlayer == null) {§return false;§}§targetPlayer.damage(amount.calculate(game, source, this), source.getSourceId(), game, false, true);§FilterPermanent filter = new FilterPermanent("and each creature he or she controls");§filter.add(new CardTypePredicate(CardType.CREATURE));§filter.add(new ControllerIdPredicate(targetPlayer.getId()));§List<Permanent> permanents = game.getBattlefield().getActivePermanents(filter, source.getControllerId(), source.getSourceId(), game);§for (Permanent permanent: permanents) {§permanent.damage(amount.calculate(game, source, this), source.getSourceId(), game, false, true);§}§return true;§}§}§
public class LeoninArmorguard extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creatures you control");§static {§filter.add(new ControllerPredicate(TargetController.YOU));§}§public LeoninArmorguard(UUID ownerId) {§super(ownerId, 72, "Leonin Armorguard", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{G}{W}");§this.expansionSetCode = "ARB";§this.subtype.add("Cat");§this.subtype.add("Soldier");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new EntersBattlefieldTriggeredAbility(new BoostAllEffect(1, 1, Duration.EndOfTurn, filter, false)));§}§public LeoninArmorguard(final LeoninArmorguard card) {§super(card);§}§@Override§public LeoninArmorguard copy() {§return new LeoninArmorguard(this);§}§}§
public class LichLordOfUnx extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("Zombies you control");§static {§filter.add(new SubtypePredicate("Zombie"));§}§public LichLordOfUnx (UUID ownerId) {§super(ownerId, 24, "Lich Lord of Unx", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{U}{B}");§this.expansionSetCode = "ARB";§this.subtype.add("Zombie");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new CreateTokenEffect(new ZombieWizardToken()), new ManaCostsImpl("{U}{B}"));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new LoseLifeTargetEffect(new PermanentsOnBattlefieldCount(filter)), new ManaCostsImpl("{U}{U}{B}{B}"));§ability.addEffect(new PutLibraryIntoGraveTargetEffect(new PermanentsOnBattlefieldCount(filter, 1)));§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§}§public LichLordOfUnx (final LichLordOfUnx card) {§super(card);§}§@Override§public LichLordOfUnx copy() {§return new LichLordOfUnx(this);§}§}§class ZombieWizardToken extends Token {§ZombieWizardToken() {§super("Zombie Wizard", "a 1/1 blue and black Zombie Wizard creature token");§cardType.add(CardType.CREATURE);§color.setGreen(true);§color.setBlack(true);§subtype.add("Zombie");§subtype.add("Wizard");§power = new MageInt(1);§toughness = new MageInt(1);§}§}§
public class LightningReaver extends CardImpl {§public LightningReaver(UUID ownerId) {§super(ownerId, 42, "Lightning Reaver", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{B}{R}");§this.expansionSetCode = "ARB";§this.subtype.add("Zombie");§this.subtype.add("Beast");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(HasteAbility.getInstance());§this.addAbility(FearAbility.getInstance());§this.addAbility(new DealsCombatDamageToAPlayerTriggeredAbility(new AddCountersSourceEffect(CounterType.CHARGE.createInstance()), false));§this.addAbility(new BeginningOfEndStepTriggeredAbility(new DamageOpponentsEffect(), TargetController.YOU, false));§}§public LightningReaver(final LightningReaver card) {§super(card);§}§@Override§public LightningReaver copy() {§return new LightningReaver(this);§}§}§class DamageOpponentsEffect extends OneShotEffect {§public DamageOpponentsEffect() {§super(Outcome.Damage);§staticText = "Lightning Reaver deals damage equal to the number of charge counters on it to each opponent";§}§public DamageOpponentsEffect(final DamageOpponentsEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§DynamicValue amount = new CountersCount(CounterType.CHARGE);§for (UUID playerId : game.getOpponents(source.getControllerId())) {§Player player = game.getPlayer(playerId);§if (player != null) {§player.damage(amount.calculate(game, source, this), source.getSourceId(), game, false, true);§}§}§return true;§}§@Override§public DamageOpponentsEffect copy() {§return new DamageOpponentsEffect(this);§}§}§
public class LordOfExtinction extends CardImpl {§public LordOfExtinction(UUID ownerId) {§super(ownerId, 91, "Lord of Extinction", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{3}{B}{G}");§this.expansionSetCode = "ARB";§this.subtype.add("Elemental");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§this.addAbility(new SimpleStaticAbility(Zone.ALL, new SetPowerToughnessSourceEffect(new LordOfExtinctionDynamicCount(), Duration.EndOfGame)));§}§public LordOfExtinction(final LordOfExtinction card) {§super(card);§}§@Override§public LordOfExtinction copy() {§return new LordOfExtinction(this);§}§}§class LordOfExtinctionDynamicCount implements DynamicValue {§@Override§public int calculate(Game game, Ability sourceAbility, Effect effect) {§int count = 0;§for (UUID playerId : game.getState().getPlayersInRange(sourceAbility.getControllerId(), game)) {§Player player = game.getPlayer(playerId);§if (player != null) {§count += player.getGraveyard().size();§}§}§return count;§}§@Override§public DynamicValue copy() {§return new LordOfExtinctionDynamicCount();§}§@Override§public String getMessage() {§return "cards in all graveyards";§}§@Override§public String toString() {§return "1";§}§}§
public class LorescaleCoatl extends CardImpl {§public LorescaleCoatl (UUID ownerId) {§super(ownerId, 101, "Lorescale Coatl", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{G}{U}");§this.expansionSetCode = "ARB";§this.subtype.add("Snake");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new DrawCardControllerTriggeredAbility(new AddCountersSourceEffect(CounterType.P1P1.createInstance()), true));§}§public LorescaleCoatl (final LorescaleCoatl card) {§super(card);§}§@Override§public LorescaleCoatl copy() {§return new LorescaleCoatl(this);§}§}§
public class MadrushCyclops extends CardImpl {§public MadrushCyclops (UUID ownerId) {§super(ownerId, 119, "Madrush Cyclops", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{B}{R}{G}");§this.expansionSetCode = "ARB";§this.subtype.add("Cyclops");§this.subtype.add("Warrior");§this.power = new MageInt(3);§this.toughness = new MageInt(4);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityControlledEffect(HasteAbility.getInstance(), Duration.WhileOnBattlefield, new FilterCreaturePermanent())));§}§public MadrushCyclops (final MadrushCyclops card) {§super(card);§}§@Override§public MadrushCyclops copy() {§return new MadrushCyclops(this);§}§}§
public class MaelstromNexus extends CardImpl {§public MaelstromNexus(UUID ownerId) {§super(ownerId, 130, "Maelstrom Nexus", Rarity.MYTHIC, new CardType[]{CardType.ENCHANTMENT}, "{W}{U}{B}{R}{G}");§this.expansionSetCode = "ARB";§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new MaelstromNexusGainCascadeFirstSpellEffect()), new FirstSpellCastThisTurnWatcher());§}§public MaelstromNexus(final MaelstromNexus card) {§super(card);§}§@Override§public MaelstromNexus copy() {§return new MaelstromNexus(this);§}§}§class MaelstromNexusGainCascadeFirstSpellEffect extends ContinuousEffectImpl {§private Ability cascadeAbility = new CascadeAbility();§public MaelstromNexusGainCascadeFirstSpellEffect() {§super(Duration.WhileOnBattlefield, Layer.AbilityAddingRemovingEffects_6, SubLayer.NA, Outcome.AddAbility);§staticText = "The first spell you cast each turn has cascade";§}§public MaelstromNexusGainCascadeFirstSpellEffect(final MaelstromNexusGainCascadeFirstSpellEffect effect) {§super(effect);§}§@Override§public MaelstromNexusGainCascadeFirstSpellEffect copy() {§return new MaelstromNexusGainCascadeFirstSpellEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§for (StackObject stackObject : game.getStack()) {§if ((stackObject instanceof Spell) && !stackObject.isCopy() && stackObject.getControllerId().equals(source.getControllerId())) {§Spell spell = (Spell) stackObject;§FirstSpellCastThisTurnWatcher watcher = (FirstSpellCastThisTurnWatcher) game.getState().getWatchers().get("FirstSpellCastThisTurn");§if (watcher != null && spell.getId().equals(watcher.getIdOfFirstCastSpell(source.getControllerId()))) {§game.getState().addOtherAbility(spell.getCard(), cascadeAbility);§}§}§}§return true;§}§return false;§}§}§class FirstSpellCastThisTurnWatcher extends Watcher {§Map<UUID, UUID> playerFirstSpellCast = new HashMap<>();§Map<UUID, UUID> playerFirstCastSpell = new HashMap<>();§public FirstSpellCastThisTurnWatcher() {§super("FirstSpellCastThisTurn", WatcherScope.GAME);§}§public FirstSpellCastThisTurnWatcher(final FirstSpellCastThisTurnWatcher watcher) {§super(watcher);§}§@Override§public void watch(GameEvent event, Game game) {§switch (event.getType()) {§case SPELL_CAST:§case CAST_SPELL:§Spell spell = (Spell) game.getObject(event.getTargetId());§if (spell != null && !playerFirstSpellCast.containsKey(spell.getControllerId())) {§if (event.getType().equals(EventType.SPELL_CAST)) {§playerFirstSpellCast.put(spell.getControllerId(), spell.getId());§} else if (event.getType().equals(EventType.CAST_SPELL)) {§playerFirstCastSpell.put(spell.getControllerId(), spell.getId());§}§}§}§}§@Override§public FirstSpellCastThisTurnWatcher copy() {§return new FirstSpellCastThisTurnWatcher(this);§}§@Override§public void reset() {§super.reset();§playerFirstSpellCast.clear();§playerFirstCastSpell.clear();§}§public UUID getIdOfFirstCastSpell(UUID playerId) {§if (playerFirstSpellCast.get(playerId) == null) {§return playerFirstCastSpell.get(playerId);§} else {§return playerFirstSpellCast.get(playerId);§}§}§}§
public class MaelstromPulse extends CardImpl {§public MaelstromPulse(UUID ownerId) {§super(ownerId, 92, "Maelstrom Pulse", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{1}{B}{G}");§this.expansionSetCode = "ARB";§this.getSpellAbility().addTarget(new TargetNonlandPermanent());§this.getSpellAbility().addEffect(new DestroyAllNamedPermanentsEffect());§}§public MaelstromPulse(final MaelstromPulse card) {§super(card);§}§@Override§public MaelstromPulse copy() {§return new MaelstromPulse(this);§}§}§
public class MagefireWings extends CardImpl {§public MagefireWings (UUID ownerId) {§super(ownerId, 88, "Magefire Wings", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{U}{R}");§this.expansionSetCode = "ARB";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(2, 0, Duration.WhileOnBattlefield)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(FlyingAbility.getInstance(), AttachmentType.AURA)));§}§public MagefireWings (final MagefireWings card) {§super(card);§}§@Override§public MagefireWings copy() {§return new MagefireWings(this);§}§}§
public class MarrowChomper extends CardImpl {§public MarrowChomper(UUID ownerId) {§super(ownerId, 93, "Marrow Chomper", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{B}{G}");§this.expansionSetCode = "ARB";§this.subtype.add("Zombie");§this.subtype.add("Lizard");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new DevourAbility(DevourEffect.DevourFactor.Devour2));§this.addAbility(new EntersBattlefieldTriggeredAbility(new GainLifeEffect(new DevouredCreaturesCount(2))));§}§public MarrowChomper(final MarrowChomper card) {§super(card);§}§@Override§public MarrowChomper copy() {§return new MarrowChomper(this);§}§}§
public class MaskOfRiddles extends CardImpl {§public MaskOfRiddles(UUID ownerId) {§super(ownerId, 25, "Mask of Riddles", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{U}{B}");§this.expansionSetCode = "ARB";§this.subtype.add("Equipment");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(FearAbility.getInstance(), AttachmentType.EQUIPMENT)));§this.addAbility(new DealsDamageToAPlayerAttachedTriggeredAbility(new DrawCardSourceControllerEffect(1), "equipped", true));§this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(2)));§}§public MaskOfRiddles(final MaskOfRiddles card) {§super(card);§}§@Override§public MaskOfRiddles copy() {§return new MaskOfRiddles(this);§}§}§
public class MayaelsAria extends CardImpl {§public MayaelsAria(UUID ownerId) {§super(ownerId, 121, "Mayael's Aria", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{R}{G}{W}");§this.expansionSetCode = "ARB";§this.addAbility(new BeginningOfUpkeepTriggeredAbility(Zone.BATTLEFIELD, new MayaelsAriaEffect(), TargetController.YOU, false));§}§public MayaelsAria(final MayaelsAria card) {§super(card);§}§@Override§public MayaelsAria copy() {§return new MayaelsAria(this);§}§}§class MayaelsAriaEffect extends OneShotEffect {§public MayaelsAriaEffect() {§super(Outcome.Benefit);§this.staticText = "put a +1/+1 counter on each creature you control if you control a creature with power 5 or greater. Then you gain 10 life if you control a creature with power 10 or greater. Then you win the game if you control a creature with power 20 or greater";§}§public MayaelsAriaEffect(final MayaelsAriaEffect effect) {§super(effect);§}§@Override§public MayaelsAriaEffect copy() {§return new MayaelsAriaEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller == null) {§return false;§}§FilterCreaturePermanent filter = new FilterCreaturePermanent();§filter.add(new PowerPredicate(Filter.ComparisonType.GreaterThan, 4));§if (game.getState().getBattlefield().countAll(filter, controller.getId(), game) > 0) {§for (Permanent creature : game.getBattlefield().getAllActivePermanents(filter, source.getControllerId(), game)) {§creature.addCounters(CounterType.P1P1.createInstance(), game);§}§}§game.applyEffects(); §
public class MeddlingMage extends CardImpl {§public MeddlingMage(UUID ownerId) {§super(ownerId, 8, "Meddling Mage", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{W}{U}");§this.expansionSetCode = "ARB";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new AsEntersBattlefieldAbility(new NameACardEffect(NameACardEffect.TypeOfName.NON_LAND_NAME)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new MeddlingMageReplacementEffect()));§}§public MeddlingMage(final MeddlingMage card) {§super(card);§}§@Override§public MeddlingMage copy() {§return new MeddlingMage(this);§}§}§class MeddlingMageReplacementEffect extends ContinuousRuleModifyingEffectImpl {§public MeddlingMageReplacementEffect() {§super(Duration.WhileOnBattlefield, Outcome.Detriment);§staticText = "The named card can't be cast";§}§public MeddlingMageReplacementEffect(final MeddlingMageReplacementEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public MeddlingMageReplacementEffect copy() {§return new MeddlingMageReplacementEffect(this);§}§@Override§public String getInfoMessage(Ability source, GameEvent event, Game game) {§MageObject mageObject = game.getObject(source.getSourceId());§if (mageObject != null) {§return "You can't cast a card with that name (" + mageObject.getLogName() + " in play).";§}§return null;§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == EventType.CAST_SPELL;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§MageObject object = game.getObject(event.getSourceId());§return object != null && !object.isCopy() && object.getName().equals(game.getState().getValue(source.getSourceId().toString() + NameACardEffect.INFO_KEY));§}§}§
public class MessengerFalcons extends CardImpl {§public MessengerFalcons(UUID ownerId) {§super(ownerId, 145, "Messenger Falcons", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{G/U}{W}");§this.expansionSetCode = "ARB";§this.subtype.add("Bird");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new EntersBattlefieldTriggeredAbility(new DrawCardSourceControllerEffect(1), false));§}§public MessengerFalcons(final MessengerFalcons card) {§super(card);§}§@Override§public MessengerFalcons copy() {§return new MessengerFalcons(this);§}§}§
public class MindFuneral extends CardImpl {§public MindFuneral(UUID ownerId) {§super(ownerId, 26, "Mind Funeral", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{1}{U}{B}");§this.expansionSetCode = "ARB";§this.getSpellAbility().addEffect(new MindFuneralEffect());§this.getSpellAbility().addTarget(new TargetOpponent());§}§public MindFuneral(final MindFuneral card) {§super(card);§}§@Override§public MindFuneral copy() {§return new MindFuneral(this);§}§}§class MindFuneralEffect extends OneShotEffect {§public MindFuneralEffect() {§super(Outcome.Detriment);§this.staticText = "Target opponent reveals cards from the top of his or her library until four land cards are revealed. That player puts all cards revealed this way into his or her graveyard";§}§public MindFuneralEffect(final MindFuneralEffect effect) {§super(effect);§}§@Override§public MindFuneralEffect copy() {§return new MindFuneralEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player opponent = game.getPlayer(getTargetPointer().getFirst(game, source));§if (opponent != null) {§Cards cards = new CardsImpl();§int landsFound = 0;§while (landsFound < 4 && opponent.getLibrary().size() > 0) {§Card card = opponent.getLibrary().removeFromTop(game);§if (card == null) {§break;§}§if (card.getCardType().contains(CardType.LAND)) {§landsFound++;§}§cards.add(card);§}§opponent.revealCards("Mind Funeral", cards, game);§opponent.moveCards(cards, Zone.LIBRARY, Zone.GRAVEYARD, source, game);§return true;§}§return false;§}§}§
public class MistveinBorderpost extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledLandPermanent("a basic land");§static {§filter.add(new SupertypePredicate("Basic"));§}§public MistveinBorderpost (UUID ownerId) {§super(ownerId, 27, "Mistvein Borderpost", Rarity.COMMON, new CardType[]{CardType.ARTIFACT}, "{1}{U}{B}");§this.expansionSetCode = "ARB";§Ability ability = new AlternativeCostSourceAbility(new GenericManaCost(1));§ability.addCost(new ReturnToHandChosenControlledPermanentCost(new TargetControlledPermanent(filter)));§this.addAbility(ability);§this.addAbility(new EntersBattlefieldTappedAbility());§this.addAbility(new BlueManaAbility());§this.addAbility(new BlackManaAbility());§}§public MistveinBorderpost (final MistveinBorderpost card) {§super(card);§}§@Override§public MistveinBorderpost copy() {§return new MistveinBorderpost(this);§}§}§
public class MonstrousCarabid extends CardImpl {§public MonstrousCarabid(UUID ownerId) {§super(ownerId, 43, "Monstrous Carabid", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{B}{R}");§this.expansionSetCode = "ARB";§this.subtype.add("Insect");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(new AttacksEachTurnStaticAbility());§this.addAbility(new CyclingAbility(new ManaCostsImpl("{B/R}")));§}§public MonstrousCarabid(final MonstrousCarabid card) {§super(card);§}§@Override§public MonstrousCarabid copy() {§return new MonstrousCarabid(this);§}§}§
public class MorbidBloom extends CardImpl {§public MorbidBloom(UUID ownerId) {§super(ownerId, 94, "Morbid Bloom", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{4}{B}{G}");§this.expansionSetCode = "ARB";§this.getSpellAbility().addEffect(new MorbidBloomEffect());§this.getSpellAbility().addTarget(new TargetCardInGraveyard(new FilterCreatureCard("creature from a graveyard")));§}§public MorbidBloom(final MorbidBloom card) {§super(card);§}§@Override§public MorbidBloom copy() {§return new MorbidBloom(this);§}§}§class MorbidBloomEffect extends OneShotEffect {§public MorbidBloomEffect() {§super(Outcome.PutCreatureInPlay);§staticText = "Exile target creature card from a graveyard, then put X 1/1 green Saproling creature tokens onto the battlefield, where X is the exiled card's toughness";§}§public MorbidBloomEffect(final MorbidBloomEffect effect) {§super(effect);§}§@Override§public MorbidBloomEffect copy() {§return new MorbidBloomEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Card targetCreatureCard = game.getCard(source.getFirstTarget());§if (targetCreatureCard != null) {§targetCreatureCard.moveToExile(null, null, source.getSourceId(), game);§int toughness = targetCreatureCard.getToughness().getValue();§SaprolingToken token = new SaprolingToken();§return token.putOntoBattlefield(toughness, game, source.getSourceId(), source.getControllerId());§}§return false;§}§}§
public class MycoidShepherd extends CardImpl {§public MycoidShepherd(UUID ownerId) {§super(ownerId, 73, "Mycoid Shepherd", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{G}{G}{W}");§this.expansionSetCode = "ARB";§this.subtype.add("Fungus");§this.power = new MageInt(5);§this.toughness = new MageInt(4);§this.addAbility(new MycoidShepherdTriggeredAbility());§}§public MycoidShepherd(final MycoidShepherd card) {§super(card);§}§@Override§public MycoidShepherd copy() {§return new MycoidShepherd(this);§}§}§class MycoidShepherdTriggeredAbility extends TriggeredAbilityImpl {§public MycoidShepherdTriggeredAbility() {§super(Zone.BATTLEFIELD, new GainLifeEffect(5), true);§}§public MycoidShepherdTriggeredAbility(final MycoidShepherdTriggeredAbility ability) {§super(ability);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.ZONE_CHANGE;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§MageObject lastKnown = game.getLastKnownInformation(event.getTargetId(), Zone.BATTLEFIELD);§if (lastKnown == null) {§return false;§}§ZoneChangeEvent zEvent = (ZoneChangeEvent) event;§Permanent permanent = zEvent.getTarget();§if (permanent == null) {§return false;§}§if (super.getSourceId().equals(event.getTargetId())§|| permanent.getPower().getValue() > 4§&& permanent.getControllerId().equals(controllerId)) {§Zone after = game.getState().getZone(event.getTargetId());§return after != null && Zone.GRAVEYARD.match(after);§}§return false;§}§@Override§public String getRule() {§return "Whenever Mycoid Shepherd or another creature you control with power 5 or greater dies, you may gain 5 life.";§}§@Override§public MycoidShepherdTriggeredAbility copy() {§return new MycoidShepherdTriggeredAbility(this);§}§}§
public class NayaHushblade extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("another multicolor permanent");§static {§filter.add(new MulticoloredPredicate());§filter.add(new AnotherPredicate());§}§public NayaHushblade(UUID ownerId) {§super(ownerId, 141, "Naya Hushblade", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{R/W}{G}");§this.expansionSetCode = "ARB";§this.subtype.add("Elf");§this.subtype.add("Rogue");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new ConditionalContinuousEffect(§new BoostSourceEffect(1,1, Duration.WhileOnBattlefield),§new PermanentsOnTheBattlefieldCondition(filter),§"As long as you control another multicolored permanent, Naya Hushblade gets +1/+1"));§ability.addEffect(new ConditionalContinuousEffect(§new GainAbilitySourceEffect(ShroudAbility.getInstance()),§new PermanentsOnTheBattlefieldCondition(filter),§" and has shroud"));§this.addAbility(ability);§}§public NayaHushblade(final NayaHushblade card) {§super(card);§}§@Override§public NayaHushblade copy() {§return new NayaHushblade(this);§}§}§
public class NayaSojourners extends CardImpl {§public NayaSojourners(UUID ownerId) {§super(ownerId, 122, "Naya Sojourners", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{R}{G}{W}");§this.expansionSetCode = "ARB";§this.subtype.add("Elf");§this.subtype.add("Shaman");§this.power = new MageInt(5);§this.toughness = new MageInt(3);§Ability ability1 = new CycleTriggeredAbility(new AddCountersTargetEffect(CounterType.P1P1.createInstance()));§Ability ability2 = new DiesTriggeredAbility(new AddCountersTargetEffect(CounterType.P1P1.createInstance()));§ability1.addTarget(new TargetCreaturePermanent());§ability2.addTarget(new TargetCreaturePermanent());§this.addAbility(ability1);§this.addAbility(ability2);§this.addAbility(new CyclingAbility(new ManaCostsImpl("{2}{G}")));§}§public NayaSojourners(final NayaSojourners card) {§super(card);§}§@Override§public NayaSojourners copy() {§return new NayaSojourners(this);§}§}§
public class NecromancersCovenant extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("Zombies you control");§static {§filter.add(new SubtypePredicate("Zombie"));§}§public NecromancersCovenant(UUID ownerId) {§super(ownerId, 82, "Necromancer's Covenant", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{3}{W}{B}{B}");§this.expansionSetCode = "ARB";§Ability ability = new EntersBattlefieldTriggeredAbility(new NecromancersConvenantEffect(), false);§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAllEffect(LifelinkAbility.getInstance(), Duration.WhileOnBattlefield, filter)));§}§public NecromancersCovenant(final NecromancersCovenant card) {§super(card);§}§@Override§public NecromancersCovenant copy() {§return new NecromancersCovenant(this);§}§}§class NecromancersConvenantEffect extends OneShotEffect {§public NecromancersConvenantEffect() {§super(Outcome.PutCreatureInPlay);§staticText = "exile all creature cards from target player's graveyard, then put a 2/2 black Zombie creature token onto the battlefield for each card exiled this way";§}§public NecromancersConvenantEffect(NecromancersConvenantEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getFirstTarget());§if (player == null) {§return false;§}§int count = 0;§for (Card card : player.getGraveyard().getCards(new FilterCreatureCard(), game)) {§if (card.moveToExile(source.getSourceId(), "Necromancer Covenant", source.getSourceId(), game)) {§count += 1;§}§}§ZombieToken zombieToken = new ZombieToken();§if (zombieToken.putOntoBattlefield(count, game, source.getSourceId(), source.getControllerId())) {§return true;§}§return false;§}§@Override§public NecromancersConvenantEffect copy() {§return new NecromancersConvenantEffect(this);§}§}§
public class NemesisOfReason extends CardImpl {§public NemesisOfReason (UUID ownerId) {§super(ownerId, 28, "Nemesis of Reason", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{U}{B}");§this.expansionSetCode = "ARB";§this.subtype.add("Leviathan");§this.subtype.add("Horror");§this.power = new MageInt(3);§this.toughness = new MageInt(7);§Effect effect = new PutLibraryIntoGraveTargetEffect(10);§effect.setText("defending player puts the top ten cards of his or her library into his or her graveyard");§this.addAbility(new NemesisOfReasonTriggeredAbility(effect));§}§public NemesisOfReason (final NemesisOfReason card) {§super(card);§}§@Override§public NemesisOfReason copy() {§return new NemesisOfReason(this);§}§}§class NemesisOfReasonTriggeredAbility extends TriggeredAbilityImpl {§NemesisOfReasonTriggeredAbility(Effect effect) {§super(Zone.BATTLEFIELD, effect);§}§NemesisOfReasonTriggeredAbility(final NemesisOfReasonTriggeredAbility ability) {§super(ability);§}§@Override§public NemesisOfReasonTriggeredAbility copy() {§return new NemesisOfReasonTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.ATTACKER_DECLARED;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (event.getSourceId().equals(this.getSourceId()) ) {§UUID defenderId = game.getCombat().getDefendingPlayerId(this.getSourceId(), game);§for (Effect effect : this.getEffects()) {§effect.setTargetPointer(new FixedTarget(defenderId));§}§return true;§}§return false;§}§@Override§public String getRule() {§return "Whenever {this} attacks, defending player puts the top ten cards of his or her library into his or her graveyard.";§}§}§
public class NulltreadGargantuan extends CardImpl {§public NulltreadGargantuan (UUID ownerId) {§super(ownerId, 102, "Nulltread Gargantuan", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{G}{U}");§this.expansionSetCode = "ARB";§this.subtype.add("Beast");§this.power = new MageInt(5);§this.toughness = new MageInt(6);§Ability ability = new EntersBattlefieldTriggeredAbility(new PutOnLibraryTargetEffect(true), false);§Target target = new TargetControlledCreaturePermanent();§target.setNotTarget(true);§ability.addTarget(target);§this.addAbility(ability);§}§public NulltreadGargantuan (final NulltreadGargantuan card) {§super(card);§}§@Override§public NulltreadGargantuan copy() {§return new NulltreadGargantuan(this);§}§}§
public class OfferingToAsha extends CardImpl {§public OfferingToAsha(UUID ownerId) {§super(ownerId, 9, "Offering to Asha", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{W}{U}");§this.expansionSetCode = "ARB";§this.getSpellAbility().addTarget(new TargetSpell());§this.getSpellAbility().addEffect(new CounterUnlessPaysEffect(new GenericManaCost(4)));§this.getSpellAbility().addEffect(new GainLifeEffect(4));§}§public OfferingToAsha(final OfferingToAsha card) {§super(card);§}§@Override§public OfferingToAsha copy() {§return new OfferingToAsha(this);§}§}§
public class PaleRecluse extends CardImpl {§public PaleRecluse(UUID ownerId) {§super(ownerId, 74, "Pale Recluse", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{G}{W}");§this.expansionSetCode = "ARB";§this.subtype.add("Spider");§this.power = new MageInt(4);§this.toughness = new MageInt(5);§this.addAbility(ReachAbility.getInstance());§this.addAbility(new ForestcyclingAbility(new ManaCostsImpl("{2}")));§this.addAbility(new PlainscyclingAbility(new ManaCostsImpl("{2}")));§}§public PaleRecluse(final PaleRecluse card) {§super(card);§}§@Override§public PaleRecluse copy() {§return new PaleRecluse(this);§}§}§
public class PredatoryAdvantage extends CardImpl {§public PredatoryAdvantage(UUID ownerId) {§super(ownerId, 58, "Predatory Advantage", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{3}{R}{G}");§this.expansionSetCode = "ARB";§this.addAbility(new BeginningOfEndStepTriggeredAbility(Zone.BATTLEFIELD, new CreateTokenEffect(new LizardToken()), TargetController.OPPONENT, new DidNotCastCreatureCondition(), false), new CastCreatureWatcher());§}§public PredatoryAdvantage(final PredatoryAdvantage card) {§super(card);§}§@Override§public PredatoryAdvantage copy() {§return new PredatoryAdvantage(this);§}§}§class DidNotCastCreatureCondition implements Condition {§@Override§public boolean apply(Game game, Ability source) {§Permanent p = game.getPermanent(source.getSourceId());§if (p != null) {§Watcher watcher = game.getState().getWatchers().get("CastCreature", source.getSourceId());§if (watcher != null && !watcher.conditionMet()) {§return true;§}§}§return false;§}§@Override§public String toString() {§StringBuilder sb = new StringBuilder("if that player didn't cast a creature spell this turn");§return sb.toString();§}§}§class CastCreatureWatcher extends Watcher {§public CastCreatureWatcher() {§super("CastCreature", WatcherScope.CARD);§}§public CastCreatureWatcher(final CastCreatureWatcher watcher) {§super(watcher);§}§@Override§public void watch(GameEvent event, Game game) {§if (event.getType() == GameEvent.EventType.SPELL_CAST§&& game.getActivePlayerId().equals(event.getPlayerId())§&& game.getOpponents(controllerId).contains(event.getPlayerId())) {§Spell spell = (Spell) game.getObject(event.getTargetId());§if (spell.getCardType().contains(CardType.CREATURE)) {§condition = true;§}§}§}§@Override§public CastCreatureWatcher copy() {§return new CastCreatureWatcher(this);§}§}§class LizardToken extends Token {§public LizardToken() {§super("Lizard", "2/2 green Lizard creature token onto the battlefield");§cardType.add(CardType.CREATURE);§color.setGreen(true);§subtype.add("Lizard");§power = new MageInt(2);§toughness = new MageInt(2);§}§}§
public class RebornHope extends CardImpl {§private static final FilterCard filter = new FilterCard("multicolored card from your graveyard");§static {§filter.add(new MulticoloredPredicate());§}§public RebornHope(UUID ownerId) {§super(ownerId, 76, "Reborn Hope", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{G}{W}");§this.expansionSetCode = "ARB";§this.getSpellAbility().addTarget(new TargetCardInYourGraveyard(filter));§this.getSpellAbility().addEffect(new ReturnFromGraveyardToHandTargetEffect());§}§public RebornHope(final RebornHope card) {§super(card);§}§@Override§public RebornHope copy() {§return new RebornHope(this);§}§}§
public class RetaliatorGriffin extends CardImpl {§public RetaliatorGriffin(UUID ownerId) {§super(ownerId, 123, "Retaliator Griffin", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{R}{G}{W}");§this.expansionSetCode = "ARB";§this.subtype.add("Griffin");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new RetaliatorGriffinTriggeredAbility());§}§public RetaliatorGriffin(final RetaliatorGriffin card) {§super(card);§}§@Override§public RetaliatorGriffin copy() {§return new RetaliatorGriffin(this);§}§}§class RetaliatorGriffinTriggeredAbility extends TriggeredAbilityImpl {§public RetaliatorGriffinTriggeredAbility() {§super(Zone.BATTLEFIELD, new RetaliatorGriffinEffect(), true);§}§public RetaliatorGriffinTriggeredAbility(final RetaliatorGriffinTriggeredAbility ability) {§super(ability);§}§@Override§public RetaliatorGriffinTriggeredAbility copy() {§return new RetaliatorGriffinTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType().equals(GameEvent.EventType.DAMAGED_PLAYER);§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (event.getTargetId().equals(getControllerId())) {§UUID sourceControllerId = game.getControllerId(event.getSourceId());§if (sourceControllerId != null &&§game.getOpponents(getControllerId()).contains(sourceControllerId)) {§getEffects().get(0).setValue("damageAmount", event.getAmount());§return true;§}§}§return false;§}§@Override§public String getRule() {§return "Whenever a source an opponent controls deals damage to you, you may put that many +1/+1 counters on {this}.";§}§}§class RetaliatorGriffinEffect extends OneShotEffect {§public RetaliatorGriffinEffect() {§super(Outcome.BoostCreature);§}§public RetaliatorGriffinEffect(final RetaliatorGriffinEffect effect) {§super(effect);§}§@Override§public RetaliatorGriffinEffect copy() {§return new RetaliatorGriffinEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Permanent permanent = game.getPermanent(source.getSourceId());§Integer amount = (Integer) this.getValue("damageAmount");§if (permanent != null && amount != null && amount > 0) {§new AddCountersSourceEffect(CounterType.P1P1.createInstance(amount), true).apply(game, source);§}§return true;§}§return false;§}§}§
public class RhoxBrute extends CardImpl {§public RhoxBrute (UUID ownerId) {§super(ownerId, 59, "Rhox Brute", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{R}{G}");§this.expansionSetCode = "ARB";§this.subtype.add("Rhino");§this.subtype.add("Warrior");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§}§public RhoxBrute (final RhoxBrute card) {§super(card);§}§@Override§public RhoxBrute copy() {§return new RhoxBrute(this);§}§}§
public class SagesOfTheAnima extends CardImpl {§public SagesOfTheAnima(UUID ownerId) {§super(ownerId, 103, "Sages of the Anima", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{G}{U}");§this.expansionSetCode = "ARB";§this.subtype.add("Elf");§this.subtype.add("Wizard");§this.power = new MageInt(3);§this.toughness = new MageInt(4);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new SagesOfTheAnimaReplacementEffect()));§}§public SagesOfTheAnima(final SagesOfTheAnima card) {§super(card);§}§@Override§public SagesOfTheAnima copy() {§return new SagesOfTheAnima(this);§}§}§class SagesOfTheAnimaReplacementEffect extends ReplacementEffectImpl {§public SagesOfTheAnimaReplacementEffect() {§super(Duration.WhileOnBattlefield, Outcome.Benefit);§staticText = "If you would draw a card, instead reveal the top three cards of your library. Put all creature cards revealed this way into your hand and the rest on the bottom of your library in any order";§}§public SagesOfTheAnimaReplacementEffect(final SagesOfTheAnimaReplacementEffect effect) {§super(effect);§}§@Override§public SagesOfTheAnimaReplacementEffect copy() {§return new SagesOfTheAnimaReplacementEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§FilterCard filter = new FilterCard();§filter.add(new CardTypePredicate(CardType.CREATURE));§Player player = game.getPlayer(event.getPlayerId());§Cards cards = new CardsImpl();§if (player != null) {§for (int i = 0; i < 3; i++) {§Card card = player.getLibrary().removeFromTop(game);§if (card != null) {§cards.add(card);§}§}§player.revealCards("Top three cards of library revealed", cards, game);§for (Card revealedCard : cards.getCards(game)) {§if (revealedCard.getCardType().contains(CardType.CREATURE)) {§revealedCard.moveToZone(Zone.HAND, source.getSourceId(), game, false);§cards.remove(revealedCard);§}§}§TargetCard target = new TargetCard(Zone.LIBRARY, new FilterCard());§while (player.canRespond() && cards.size() > 1) {§player.choose(Outcome.Neutral, cards, target, game);§Card card = cards.get(target.getFirstTarget(), game);§if (card != null) {§cards.remove(card);§card.moveToZone(Zone.LIBRARY, source.getSourceId(), game, false);§}§target.clearChosen();§}§if (cards.size() == 1) {§Card card = cards.get(cards.iterator().next(), game);§card.moveToZone(Zone.LIBRARY, source.getSourceId(), game, false);§}§}§return true;§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.DRAW_CARD;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§return event.getPlayerId().equals(source.getControllerId());§}§}§
public class SanctumPlowbeast extends CardImpl {§public SanctumPlowbeast(UUID ownerId) {§super(ownerId, 10, "Sanctum Plowbeast", Rarity.COMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{4}{W}{U}");§this.expansionSetCode = "ARB";§this.subtype.add("Beast");§this.power = new MageInt(3);§this.toughness = new MageInt(6);§this.addAbility(DefenderAbility.getInstance());§this.addAbility(new PlainscyclingAbility(new ManaCostsImpl("{2}")));§this.addAbility(new IslandcyclingAbility(new ManaCostsImpl("{2}")));§}§public SanctumPlowbeast(final SanctumPlowbeast card) {§super(card);§}§@Override§public SanctumPlowbeast copy() {§return new SanctumPlowbeast(this);§}§}§
public class SangriteBacklash extends CardImpl {§public SangriteBacklash(UUID ownerId) {§super(ownerId, 139, "Sangrite Backlash", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{B/G}{R}");§this.expansionSetCode = "ARB";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(3, -3)));§}§public SangriteBacklash(final SangriteBacklash card) {§super(card);§}§@Override§public SangriteBacklash copy() {§return new SangriteBacklash(this);§}§}§
public class SanityGnawers extends CardImpl {§public SanityGnawers(UUID ownerId) {§super(ownerId, 44, "Sanity Gnawers", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{B}{R}");§this.expansionSetCode = "ARB";§this.subtype.add("Rat");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new EntersBattlefieldTriggeredAbility(new DiscardTargetEffect(1, true), false);§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§}§public SanityGnawers(final SanityGnawers card) {§super(card);§}§@Override§public SanityGnawers copy() {§return new SanityGnawers(this);§}§}§
public class SenTriplets extends CardImpl {§public SenTriplets(UUID ownerId) {§super(ownerId, 109, "Sen Triplets", Rarity.MYTHIC, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{2}{W}{U}{B}");§this.expansionSetCode = "ARB";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§Ability ability = new BeginningOfUpkeepTriggeredAbility(Zone.BATTLEFIELD, new SenTripletsRuleModifyingEffect(), TargetController.YOU, false, false);§ability.addEffect(new SenTripletsOpponentRevealsHandEffect());§ability.addEffect(new SenTripletsPlayFromOpponentsHandEffect());§ability.addTarget(new TargetOpponent());§this.addAbility(ability);§}§public SenTriplets(final SenTriplets card) {§super(card);§}§@Override§public SenTriplets copy() {§return new SenTriplets(this);§}§}§class SenTripletsRuleModifyingEffect extends ContinuousRuleModifyingEffectImpl {§public SenTripletsRuleModifyingEffect() {§super(Duration.EndOfTurn, Outcome.Benefit);§staticText = "At the beginning of your upkeep, choose target opponent. This turn, that player can't cast spells or activate abilities";§}§public SenTripletsRuleModifyingEffect(final SenTripletsRuleModifyingEffect effect) {§super(effect);§}§@Override§public SenTripletsRuleModifyingEffect copy() {§return new SenTripletsRuleModifyingEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public String getInfoMessage(Ability source, GameEvent event, Game game) {§Player targetPlayer = game.getPlayer(getTargetPointer().getFirst(game, source));§MageObject mageObject = game.getObject(source.getSourceId());§if (targetPlayer != null && mageObject != null) {§return "This turn you can't cast spells or activate abilities" +§" (" + mageObject.getLogName() + ")";§}§return null;§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.CAST_SPELL || event.getType() == GameEvent.EventType.ACTIVATE_ABILITY;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§return event.getPlayerId().equals(getTargetPointer().getFirst(game, source));§}§}§class SenTripletsOpponentRevealsHandEffect extends ContinuousEffectImpl {§public SenTripletsOpponentRevealsHandEffect() {§super(Duration.EndOfTurn, Layer.PlayerEffects, SubLayer.NA, Outcome.Detriment);§staticText = "and plays with his or her hand revealed";§}§public SenTripletsOpponentRevealsHandEffect(final SenTripletsOpponentRevealsHandEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(getTargetPointer().getFirst(game, source));§if (player != null) {§player.revealCards(player.getName() + "'s hand cards", player.getHand(), game, false);§}§return true;§}§@Override§public SenTripletsOpponentRevealsHandEffect copy() {§return new SenTripletsOpponentRevealsHandEffect(this);§}§}§class SenTripletsPlayFromOpponentsHandEffect extends AsThoughEffectImpl {§public SenTripletsPlayFromOpponentsHandEffect() {§super(AsThoughEffectType.PLAY_FROM_NOT_OWN_HAND_ZONE, Duration.EndOfTurn, Outcome.Benefit);§staticText = "You may play cards from that player's hand this turn";§}§public SenTripletsPlayFromOpponentsHandEffect(final SenTripletsPlayFromOpponentsHandEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public SenTripletsPlayFromOpponentsHandEffect copy() {§return new SenTripletsPlayFromOpponentsHandEffect(this);§}§@Override§public boolean applies(UUID objectId, Ability source, UUID affectedControllerId, Game game) {§Card card = game.getCard(objectId);§return card != null &&§card.getOwnerId().equals(getTargetPointer().getFirst(game, source)) &&§game.getState().getZone(objectId).equals(Zone.HAND) &&§affectedControllerId.equals(source.getControllerId());§}§}§
public class SewnEyeDrake extends CardImpl {§public SewnEyeDrake (UUID ownerId) {§super(ownerId, 135, "Sewn-Eye Drake", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{U/R}{B}");§this.expansionSetCode = "ARB";§this.subtype.add("Zombie");§this.subtype.add("Drake");§this.power = new MageInt(3);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(HasteAbility.getInstance());§}§public SewnEyeDrake (final SewnEyeDrake card) {§super(card);§}§@Override§public SewnEyeDrake copy() {§return new SewnEyeDrake(this);§}§}§
public class ShieldOfTheRighteous extends CardImpl {§public ShieldOfTheRighteous(UUID ownerId) {§super(ownerId, 11, "Shield of the Righteous", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{W}{U}");§this.expansionSetCode = "ARB";§this.subtype.add("Equipment");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEquippedEffect(0, 2)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(VigilanceAbility.getInstance(), AttachmentType.EQUIPMENT)));§this.addAbility(new BlocksCreatureAttachedTriggeredAbility(new DontUntapInControllersNextUntapStepTargetEffect("that creature"), "equipped", false, false, true));§this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(2), new TargetControlledCreaturePermanent()));§}§public ShieldOfTheRighteous(final ShieldOfTheRighteous card) {§super(card);§}§@Override§public ShieldOfTheRighteous copy() {§return new ShieldOfTheRighteous(this);§}§}§
public class SigilCaptain extends CardImpl {§public SigilCaptain(UUID ownerId) {§super(ownerId, 77, "Sigil Captain", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{G}{W}{W}");§this.expansionSetCode = "ARB";§this.subtype.add("Rhino");§this.subtype.add("Soldier");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new SigilCaptainTriggeredAbility());§}§public SigilCaptain(final SigilCaptain card) {§super(card);§}§@Override§public SigilCaptain copy() {§return new SigilCaptain(this);§}§}§class SigilCaptainTriggeredAbility extends TriggeredAbilityImpl {§public SigilCaptainTriggeredAbility() {§super(Zone.BATTLEFIELD, new AddCountersTargetEffect(CounterType.P1P1.createInstance(2)));§}§public SigilCaptainTriggeredAbility(final SigilCaptainTriggeredAbility ability) {§super(ability);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.ENTERS_THE_BATTLEFIELD;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§Permanent permanent = game.getPermanent(event.getTargetId());§if (permanent == null) {§return false;§}§if (permanent.getControllerId().equals(controllerId)§&& permanent.getPower().getValue() == 1§&& permanent.getToughness().getValue() == 1) {§for (Effect effect : this.getEffects()) {§effect.setTargetPointer(new FixedTarget(event.getTargetId()));§}§return true;§}§return false;§}§@Override§public SigilCaptainTriggeredAbility copy() {§return new SigilCaptainTriggeredAbility(this);§}§@Override§public String getRule() {§StringBuilder sb = new StringBuilder();§sb.append("Whenever a creature enters the battlefield under your control, if that creature is 1/1, put two +1/+1 counters on it");§return sb.toString();§}§}§
public class SigiledBehemoth extends CardImpl {§public SigiledBehemoth (UUID ownerId) {§super(ownerId, 79, "Sigiled Behemoth", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{G}{W}");§this.expansionSetCode = "ARB";§this.subtype.add("Beast");§this.power = new MageInt(5);§this.toughness = new MageInt(4);§this.addAbility(new ExaltedAbility());§}§public SigiledBehemoth (final SigiledBehemoth card) {§super(card);§}§@Override§public SigiledBehemoth copy() {§return new SigiledBehemoth(this);§}§}§
public class SigilOfTheNayanGods extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent();§public SigilOfTheNayanGods(UUID ownerId) {§super(ownerId, 78, "Sigil of the Nayan Gods", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{G}{W}");§this.expansionSetCode = "ARB";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));§this.addAbility(new EnchantAbility(auraTarget.getTargetName()));§PermanentsOnBattlefieldCount amount = new PermanentsOnBattlefieldCount(filter, 1);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(amount, amount, Duration.WhileOnBattlefield)));§this.addAbility(new CyclingAbility(new ManaCostsImpl("{G/W}")));§}§public SigilOfTheNayanGods(final SigilOfTheNayanGods card) {§super(card);§}§@Override§public SigilOfTheNayanGods copy() {§return new SigilOfTheNayanGods(this);§}§}§
public class SingeMindOgre extends CardImpl {§public SingeMindOgre(UUID ownerId) {§super(ownerId, 45, "Singe-Mind Ogre", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{B}{R}");§this.expansionSetCode = "ARB";§this.subtype.add("Ogre");§this.subtype.add("Mutant");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§Ability ability = new EntersBattlefieldTriggeredAbility(new SingeMindOgreEffect(), false);§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§}§public SingeMindOgre(final SingeMindOgre card) {§super(card);§}§@Override§public SingeMindOgre copy() {§return new SingeMindOgre(this);§}§}§class SingeMindOgreEffect extends OneShotEffect {§public SingeMindOgreEffect() {§super(Outcome.LoseLife);§this.staticText = "target player reveals a card at random from his or her hand, then loses life equal to that card's converted mana cost";§}§public SingeMindOgreEffect(final SingeMindOgreEffect effect) {§super(effect);§}§@Override§public SingeMindOgreEffect copy() {§return new SingeMindOgreEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player targetPlayer = game.getPlayer(source.getFirstTarget());§if (targetPlayer != null && targetPlayer.getHand().size() > 0) {§Cards revealed = new CardsImpl();§Card card = targetPlayer.getHand().getRandom(game);§revealed.add(card);§targetPlayer.revealCards("Singe-Mind Ogre", revealed, game);§targetPlayer.loseLife(card.getManaCost().convertedManaCost(), game);§return true;§}§return false;§}§}§
public class SkyclawThrash extends CardImpl {§public SkyclawThrash(UUID ownerId) {§super(ownerId, 89, "Skyclaw Thrash", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{3}{U}{R}");§this.expansionSetCode = "ARB";§this.subtype.add("Viashino");§this.subtype.add("Warrior");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§}§public SkyclawThrash(final SkyclawThrash card) {§super(card);§}§@Override§public SkyclawThrash copy() {§return new SkyclawThrash(this);§}§}§
public class SlaveOfBolas extends CardImpl {§public SlaveOfBolas(UUID ownerId) {§super(ownerId, 136, "Slave of Bolas", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{3}{U/R}{B}");§this.expansionSetCode = "ARB";§this.getSpellAbility().addEffect(new GainControlTargetEffect(Duration.EndOfTurn));§this.getSpellAbility().addEffect(new UntapTargetEffect());§this.getSpellAbility().addEffect(new GainAbilityTargetEffect(HasteAbility.getInstance(), Duration.EndOfTurn));§this.getSpellAbility().addEffect(new SlaveOfBolasEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public SlaveOfBolas(final SlaveOfBolas card) {§super(card);§}§@Override§public SlaveOfBolas copy() {§return new SlaveOfBolas(this);§}§}§class SlaveOfBolasEffect extends OneShotEffect {§public SlaveOfBolasEffect() {§super(Outcome.Sacrifice);§staticText = "Sacrifice it at the beginning of the next end step";§}§public SlaveOfBolasEffect(final SlaveOfBolasEffect effect) {§super(effect);§}§@Override§public SlaveOfBolasEffect copy() {§return new SlaveOfBolasEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getPermanent(source.getFirstTarget());§if (permanent != null) {§SacrificeTargetEffect sacrificeEffect = new SacrificeTargetEffect("sacrifice this", source.getControllerId());§sacrificeEffect.setTargetPointer(new FixedTarget(permanent, game));§DelayedTriggeredAbility delayedAbility = new AtTheBeginOfNextEndStepDelayedTriggeredAbility(sacrificeEffect);§game.addDelayedTriggeredAbility(delayedAbility, source);§return true;§}§return false;§}§}§
public class SoulManipulation extends CardImpl {§private static final FilterSpell filter = new FilterSpell("creature spell");§private static final FilterCreatureCard filter2 = new FilterCreatureCard("creature card from your graveyard");§static {§filter.add(new CardTypePredicate(CardType.CREATURE));§}§public SoulManipulation(UUID ownerId) {§super(ownerId, 29, "Soul Manipulation", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{U}{B}");§this.expansionSetCode = "ARB";§this.getSpellAbility().getModes().setMinModes(1);§this.getSpellAbility().getModes().setMaxModes(2);§this.getSpellAbility().addEffect(new CounterTargetEffect());§this.getSpellAbility().addTarget(new TargetSpell(filter));§Mode mode = new Mode();§mode.getEffects().add(new ReturnFromGraveyardToHandTargetEffect());§mode.getTargets().add(new TargetCardInYourGraveyard(filter2));§this.getSpellAbility().addMode(mode);§}§public SoulManipulation(final SoulManipulation card) {§super(card);§}§@Override§public SoulManipulation copy() {§return new SoulManipulation(this);§}§}§
public class Soulquake extends CardImpl {§public Soulquake(UUID ownerId) {§super(ownerId, 30, "Soulquake", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{3}{U}{U}{B}{B}");§this.expansionSetCode = "ARB";§this.getSpellAbility().addEffect(new SoulquakeEffect());§}§public Soulquake(final Soulquake card) {§super(card);§}§@Override§public Soulquake copy() {§return new Soulquake(this);§}§}§class SoulquakeEffect extends OneShotEffect {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature");§private static final FilterCreatureCard filter2 = new FilterCreatureCard("creature");§public SoulquakeEffect() {§super(Outcome.ReturnToHand);§staticText = "Return all creatures on the battlefield and all creature cards in graveyards to their owners' hands";§}§public SoulquakeEffect(final SoulquakeEffect effect) {§super(effect);§}§@Override§public SoulquakeEffect copy() {§return new SoulquakeEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§for (Permanent permanent : game.getBattlefield().getActivePermanents(filter, source.getControllerId(), source.getSourceId(), game)) {§permanent.moveToZone(Zone.HAND, source.getSourceId(), game, true);§}§for (UUID playerId : game.getState().getPlayersInRange(source.getControllerId(), game)) {§Player player = game.getPlayer(playerId);§if (player != null) {§for (Card card : player.getGraveyard().getCards(filter2, game)) {§card.moveToZone(Zone.HAND, source.getSourceId(), game, true);§}§}§}§return true;§}§}§
public class SpellbreakerBehemoth extends CardImpl {§private static final FilterSpell filter = new FilterSpell("Creature spells you control with power 5 or greater");§static {§filter.add(new CardTypePredicate(CardType.CREATURE));§filter.add(new PowerPredicate(Filter.ComparisonType.GreaterThan, 4));§}§public SpellbreakerBehemoth(UUID ownerId) {§super(ownerId, 60, "Spellbreaker Behemoth", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{R}{G}{G}");§this.expansionSetCode = "ARB";§this.subtype.add("Beast");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(new SimpleStaticAbility(Zone.STACK, new CantBeCounteredSourceEffect()));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new CantBeCounteredControlledEffect(filter, Duration.WhileOnBattlefield)));§}§public SpellbreakerBehemoth(final SpellbreakerBehemoth card) {§super(card);§}§@Override§public SpellbreakerBehemoth copy() {§return new SpellbreakerBehemoth(this);§}§}§
public class SphinxOfTheSteelWind extends CardImpl {§private static final FilterCard filter = new FilterCard("red and from green");§static {§filter.add(Predicates.or(§new ColorPredicate(ObjectColor.RED),§new ColorPredicate(ObjectColor.GREEN)));§}§public SphinxOfTheSteelWind (UUID ownerId) {§super(ownerId, 110, "Sphinx of the Steel Wind", Rarity.MYTHIC, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{5}{W}{U}{B}");§this.expansionSetCode = "ARB";§this.subtype.add("Sphinx");§this.power = new MageInt(6);§this.toughness = new MageInt(6);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(FirstStrikeAbility.getInstance());§this.addAbility(VigilanceAbility.getInstance());§this.addAbility(LifelinkAbility.getInstance());§this.addAbility(new ProtectionAbility(filter));§}§public SphinxOfTheSteelWind (final SphinxOfTheSteelWind card) {§super(card);§}§@Override§public SphinxOfTheSteelWind copy() {§return new SphinxOfTheSteelWind(this);§}§}§
public class StormcallersBoon extends CardImpl {§public StormcallersBoon(UUID ownerId) {§super(ownerId, 13, "Stormcaller's Boon", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{W}{U}");§this.expansionSetCode = "ARB";§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilityControlledEffect(FlyingAbility.getInstance(), Duration.EndOfTurn, new FilterControlledCreaturePermanent("Creatures")), new SacrificeSourceCost()));§this.addAbility(new CascadeAbility());§}§public StormcallersBoon(final StormcallersBoon card) {§super(card);§}§@Override§public StormcallersBoon copy() {§return new StormcallersBoon(this);§}§}§
public class StunSniper extends CardImpl {§public StunSniper (UUID ownerId) {§super(ownerId, 100, "Stun Sniper", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{R}{W}");§this.expansionSetCode = "ARB";§this.subtype.add("Human");§this.subtype.add("Archer");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(1), new GenericManaCost(1));§ability.addCost(new TapSourceCost());§ability.addEffect(new TapTargetEffect());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public StunSniper (final StunSniper card) {§super(card);§}§@Override§public StunSniper copy() {§return new StunSniper(this);§}§}§
public class TaintedSigil extends CardImpl {§String rule = "You gain life equal to the total life lost by all players this turn";§public TaintedSigil(UUID ownerId) {§super(ownerId, 83, "Tainted Sigil", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{1}{W}{B}");§this.expansionSetCode = "ARB";§AllPlayersLostLifeCount totalLifeLostThisTurn = new AllPlayersLostLifeCount();§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainLifeEffect(totalLifeLostThisTurn, rule), new TapSourceCost());§ability.addCost(new SacrificeSourceCost());§this.addAbility(ability);§}§public TaintedSigil(final TaintedSigil card) {§super(card);§}§@Override§public TaintedSigil copy() {§return new TaintedSigil(this);§}§}§class AllPlayersLostLifeCount implements DynamicValue {§@Override§public int calculate(Game game, Ability sourceAbility, Effect effect) {§return this.calculate(game, sourceAbility.getControllerId());§}§public int calculate(Game game, UUID controllerId) {§PlayerLostLifeWatcher watcher = (PlayerLostLifeWatcher) game.getState().getWatchers().get("PlayerLostLifeWatcher");§if (watcher != null) {§int amountLifeLost = 0;§for (UUID playerId : game.getPlayerList()) {§amountLifeLost += watcher.getLiveLost(playerId);§}§return amountLifeLost;§}§return 0;§}§@Override§public DynamicValue copy() {§return new AllPlayersLostLifeCount();§}§@Override§public String toString() {§return "X";§}§@Override§public String getMessage() {§return "the total life lost by all players this turn";§}§}§
public class TalonTrooper extends CardImpl {§public TalonTrooper (UUID ownerId) {§super(ownerId, 14, "Talon Trooper", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{W}{U}");§this.expansionSetCode = "ARB";§this.subtype.add("Bird");§this.subtype.add("Scout");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§}§public TalonTrooper (final TalonTrooper card) {§super(card);§}§@Override§public TalonTrooper copy() {§return new TalonTrooper(this);§}§}§
public class Terminate extends CardImpl {§public Terminate(UUID ownerId) {§super(ownerId, 46, "Terminate", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{B}{R}");§this.expansionSetCode = "ARB";§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.getSpellAbility().addEffect(new DestroyTargetEffect(true));§}§public Terminate(final Terminate card) {§super(card);§}§@Override§public Terminate copy() {§return new Terminate(this);§}§}§
public class ThopterFoundry extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("a nontoken artifact");§static {§filter.add(new CardTypePredicate(CardType.ARTIFACT));§filter.add(Predicates.not(new TokenPredicate()));§}§public ThopterFoundry(UUID ownerId) {§super(ownerId, 133, "Thopter Foundry", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{W/B}{U}");§this.expansionSetCode = "ARB";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new CreateTokenEffect(new ThopterToken()), new GenericManaCost(1));§ability.addEffect(new GainLifeEffect(1));§ability.addCost(new SacrificeTargetCost(new TargetControlledPermanent(filter)));§this.addAbility(ability);§}§public ThopterFoundry(final ThopterFoundry card) {§super(card);§}§@Override§public ThopterFoundry copy() {§return new ThopterFoundry(this);§}§}§class ThopterToken extends Token {§ThopterToken() {§super("Thopter", "a 1/1 blue Thopter artifact creature token with flying");§cardType.add(CardType.CREATURE);§cardType.add(CardType.ARTIFACT);§color.setBlue(true);§subtype.add("Thopter");§power = new MageInt(1);§toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§}§}§
public class ThoughtHemorrhage extends CardImpl {§public ThoughtHemorrhage(UUID ownerId) {§super(ownerId, 47, "Thought Hemorrhage", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{2}{B}{R}");§this.expansionSetCode = "ARB";§this.getSpellAbility().addTarget(new TargetPlayer());§this.getSpellAbility().addEffect(new NameACardEffect(NameACardEffect.TypeOfName.NON_LAND_NAME));§this.getSpellAbility().addEffect(new ThoughtHemorrhageEffect());§}§public ThoughtHemorrhage(final ThoughtHemorrhage card) {§super(card);§}§@Override§public ThoughtHemorrhage copy() {§return new ThoughtHemorrhage(this);§}§}§class ThoughtHemorrhageEffect extends OneShotEffect {§final String rule = "Target player reveals his or her hand. {this} deals 3 damage to that player for each card with that name revealed this way. Search that player's graveyard, hand, and library for all cards with that name and exile them. Then that player shuffles his or her library";§public ThoughtHemorrhageEffect() {§super(Outcome.Detriment);§staticText = rule;§}§public ThoughtHemorrhageEffect(final ThoughtHemorrhageEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§MageObject sourceObject = game.getObject(source.getSourceId());§String cardName = (String) game.getState().getValue(source.getSourceId().toString() + NameACardEffect.INFO_KEY);§if (sourceObject != null && controller != null && cardName != null && !cardName.isEmpty()) {§Player targetPlayer = game.getPlayer(source.getFirstTarget());§if (targetPlayer != null) {§targetPlayer.revealCards("hand of " + targetPlayer.getName(), targetPlayer.getHand(), game);§int cardsFound = 0;§for (Card card : targetPlayer.getHand().getCards(game)) {§if (card.getName().equals(cardName)) {§cardsFound++;§}§}§if (cardsFound > 0) {§targetPlayer.damage(3 * cardsFound, source.getSourceId(), game, false, true);§}§FilterCard filterNamedCards = new FilterCard();§filterNamedCards.add(new NamePredicate(cardName));§for (Card checkCard : targetPlayer.getGraveyard().getCards(game)) {§if (checkCard.getName().equals(cardName)) {§controller.moveCardToExileWithInfo(checkCard, null, "", source.getSourceId(), game, Zone.GRAVEYARD, true);§}§}§TargetCardInHand targetCardsHand = new TargetCardInHand(0, Integer.MAX_VALUE, filterNamedCards);§controller.chooseTarget(outcome, targetPlayer.getGraveyard(), targetCardsHand, source, game);§for(UUID cardId: targetCardsHand.getTargets()) {§Card card = game.getCard(cardId);§if (card != null) {§controller.moveCardToExileWithInfo(card, null, "", source.getSourceId(), game, Zone.HAND, true);§}§}§TargetCardInLibrary targetCardsLibrary = new TargetCardInLibrary(0, Integer.MAX_VALUE, filterNamedCards);§controller.searchLibrary(targetCardsLibrary, game, targetPlayer.getId());§for(UUID cardId: targetCardsLibrary.getTargets()) {§Card card = game.getCard(cardId);§if (card != null) {§controller.moveCardToExileWithInfo(card, null, "", source.getSourceId(), game, Zone.LIBRARY, true);§}§}§targetPlayer.shuffleLibrary(game);§return true;§}§}§return false;§}§@Override§public ThoughtHemorrhageEffect copy() {§return new ThoughtHemorrhageEffect(this);§}§}§
public class Thraximundar extends CardImpl {§public Thraximundar(UUID ownerId) {§super(ownerId, 113, "Thraximundar", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{4}{U}{B}{R}");§this.expansionSetCode = "ARB";§this.supertype.add("Legendary");§this.subtype.add("Zombie");§this.subtype.add("Assassin");§this.power = new MageInt(6);§this.toughness = new MageInt(6);§this.addAbility(HasteAbility.getInstance());§this.addAbility(new ThraximundarTriggeredAbility());§this.addAbility(new PlayerSacrificesCreatureTriggeredAbility(new AddCountersSourceEffect(CounterType.P1P1.createInstance()), true));§}§public Thraximundar(final Thraximundar card) {§super(card);§}§@Override§public Thraximundar copy() {§return new Thraximundar(this);§}§}§class ThraximundarTriggeredAbility extends TriggeredAbilityImpl {§private static final FilterControlledPermanent filter;§static {§filter = new FilterControlledPermanent(" a creature");§filter.add(new CardTypePredicate(CardType.CREATURE));§}§public ThraximundarTriggeredAbility() {§super(Zone.BATTLEFIELD, new SacrificeEffect(filter, 1, "defending player"));§}§public ThraximundarTriggeredAbility(final ThraximundarTriggeredAbility ability) {§super(ability);§}§@Override§public ThraximundarTriggeredAbility copy() {§return new ThraximundarTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.ATTACKER_DECLARED;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (event.getSourceId() != null§&& event.getSourceId().equals(this.getSourceId())) {§UUID defender = game.getCombat().getDefendingPlayerId(this.getSourceId(), game);§this.getEffects().get(0).setTargetPointer(new FixedTarget(defender));§return true;§}§return false;§}§@Override§public String getRule() {§return "Whenever {this} attacks, defending player sacrifices a creature.";§}§}§class PlayerSacrificesCreatureTriggeredAbility extends TriggeredAbilityImpl {§public PlayerSacrificesCreatureTriggeredAbility(Effect effect, boolean optional) {§super(Zone.BATTLEFIELD, effect, optional);§}§public PlayerSacrificesCreatureTriggeredAbility(final PlayerSacrificesCreatureTriggeredAbility ability) {§super(ability);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.SACRIFICED_PERMANENT;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§MageObject mageObject = game.getLastKnownInformation(event.getTargetId(), Zone.BATTLEFIELD);§return mageObject != null && mageObject.getCardType().contains(CardType.CREATURE);§}§@Override§public String getRule() {§return "Whenever a player sacrifices a creature, " + super.getRule();§}§@Override§public PlayerSacrificesCreatureTriggeredAbility copy() {§return new PlayerSacrificesCreatureTriggeredAbility(this);§}§}§
public class TimeSieve extends CardImpl {§public TimeSieve(UUID ownerId) {§super(ownerId, 31, "Time Sieve", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{U}{B}");§this.expansionSetCode = "ARB";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new AddExtraTurnControllerEffect(), new TapSourceCost());§ability.addCost(new SacrificeTargetCost(new TargetControlledPermanent(5, 5, new FilterControlledArtifactPermanent("five artifacts"), true)));§this.addAbility(ability);§}§public TimeSieve(final TimeSieve card) {§super(card);§}§@Override§public TimeSieve copy() {§return new TimeSieve(this);§}§}§
public class TraceOfAbundance extends CardImpl {§private String rule = "Enchanted land has shroud";§public TraceOfAbundance(UUID ownerId) {§super(ownerId, 142, "Trace of Abundance", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{R/W}{G}");§this.expansionSetCode = "ARB";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetLandPermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.Benefit));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(ShroudAbility.getInstance(), AttachmentType.AURA, Duration.WhileOnBattlefield, rule)));§this.addAbility(new TraceOfAbundanceTriggeredAbility());§}§public TraceOfAbundance(final TraceOfAbundance card) {§super(card);§}§@Override§public TraceOfAbundance copy() {§return new TraceOfAbundance(this);§}§}§class TraceOfAbundanceTriggeredAbility extends TriggeredManaAbility {§public TraceOfAbundanceTriggeredAbility() {§super(Zone.BATTLEFIELD, new AddManaAnyColorAttachedControllerEffect());§}§public TraceOfAbundanceTriggeredAbility(final TraceOfAbundanceTriggeredAbility ability) {§super(ability);§}§@Override§public TraceOfAbundanceTriggeredAbility copy() {§return new TraceOfAbundanceTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.TAPPED_FOR_MANA;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§Permanent enchantment = game.getPermanent(this.getSourceId());§return enchantment != null && event.getSourceId().equals(enchantment.getAttachedTo());§}§@Override§public String getRule() {§return "Whenever enchanted land is tapped for mana, its controller adds one mana of any color to his or her mana pool.";§}§}§
public class UnbenderTine extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("another target permanent");§static {§filter.add(new AnotherPredicate());§}§public UnbenderTine(UUID ownerId) {§super(ownerId, 15, "Unbender Tine", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{2}{W}{U}");§this.expansionSetCode = "ARB";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new UnbenderTineEffect(), new TapSourceCost());§ability.addTarget(new TargetPermanent(filter));§this.addAbility(ability);§}§public UnbenderTine(final UnbenderTine card) {§super(card);§}§@Override§public UnbenderTine copy() {§return new UnbenderTine(this);§}§}§class UnbenderTineEffect extends OneShotEffect {§public UnbenderTineEffect() {§super(Outcome.Untap);§this.staticText = "Untap another target permanent";§}§public UnbenderTineEffect(final UnbenderTineEffect effect) {§super(effect);§}§@Override§public UnbenderTineEffect copy() {§return new UnbenderTineEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent targetPermanent = game.getPermanent(source.getFirstTarget());§if (targetPermanent == null) {§return false;§}§return targetPermanent.untap(game);§}§}§
public class UnscytheKillerOfKings extends CardImpl {§public UnscytheKillerOfKings(UUID ownerId) {§super(ownerId, 114, "Unscythe, Killer of Kings", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{U}{B}{B}{R}");§this.expansionSetCode = "ARB";§this.supertype.add("Legendary");§this.subtype.add("Equipment");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEquippedEffect(3, 3)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(FirstStrikeAbility.getInstance(), AttachmentType.EQUIPMENT)));§this.addAbility(new UnscytheKillerOfKingsTriggeredAbility(new UnscytheEffect()));§this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(2), new TargetControlledCreaturePermanent()));§}§public UnscytheKillerOfKings(final UnscytheKillerOfKings card) {§super(card);§}§@Override§public UnscytheKillerOfKings copy() {§return new UnscytheKillerOfKings(this);§}§}§class UnscytheKillerOfKingsTriggeredAbility extends TriggeredAbilityImpl {§public UnscytheKillerOfKingsTriggeredAbility(Effect effect) {§super(Zone.ALL, effect, true);§}§public UnscytheKillerOfKingsTriggeredAbility(final UnscytheKillerOfKingsTriggeredAbility ability) {§super(ability);§}§@Override§public UnscytheKillerOfKingsTriggeredAbility copy() {§return new UnscytheKillerOfKingsTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.ZONE_CHANGE;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (((ZoneChangeEvent) event).isDiesEvent()) {§ZoneChangeEvent zEvent = (ZoneChangeEvent) event;§if (zEvent.getTarget().getCardType().contains(CardType.CREATURE)) { §
public class UrilTheMiststalker extends CardImpl {§public UrilTheMiststalker(UUID ownerId) {§super(ownerId, 124, "Uril, the Miststalker", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{2}{R}{G}{W}");§this.expansionSetCode = "ARB";§this.supertype.add("Legendary");§this.subtype.add("Beast");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(HexproofAbility.getInstance());§AuraAttachedCount count = new AuraAttachedCount(2);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostSourceEffect(count, count, Duration.WhileOnBattlefield)));§}§public UrilTheMiststalker(final UrilTheMiststalker card) {§super(card);§}§@Override§public UrilTheMiststalker copy() {§return new UrilTheMiststalker(this);§}§}§
public class ValleyRannet extends CardImpl {§public ValleyRannet(UUID ownerId) {§super(ownerId, 61, "Valley Rannet", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{R}{G}");§this.expansionSetCode = "ARB";§this.subtype.add("Beast");§this.power = new MageInt(6);§this.toughness = new MageInt(3);§this.addAbility(new MountaincyclingAbility(new ManaCostsImpl("{2}")));§this.addAbility(new ForestcyclingAbility(new ManaCostsImpl("{2}")));§}§public ValleyRannet(final ValleyRannet card) {§super(card);§}§@Override§public ValleyRannet copy() {§return new ValleyRannet(this);§}§}§
public class VectisDominator extends CardImpl {§public VectisDominator(UUID ownerId) {§super(ownerId, 84, "Vectis Dominator", Rarity.COMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{1}{W}{B}");§this.expansionSetCode = "ARB";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(0);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new VectisDominatorEffect(new PayLifeCost(2)), new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public VectisDominator(final VectisDominator card) {§super(card);§}§@Override§public VectisDominator copy() {§return new VectisDominator(this);§}§}§class VectisDominatorEffect extends OneShotEffect {§protected Cost cost;§public VectisDominatorEffect(Cost cost) {§super(Outcome.Detriment);§this.staticText = "Tap target creature unless its controller pays 2 life";§this.cost = cost;§}§public VectisDominatorEffect(final VectisDominatorEffect effect) {§super(effect);§this.cost = effect.cost.copy();§}§@Override§public VectisDominatorEffect copy() {§return new VectisDominatorEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent targetCreature = game.getPermanent(source.getFirstTarget());§if (targetCreature != null) {§Player player = game.getPlayer(targetCreature.getControllerId());§if (player != null) {§cost.clearPaid();§final StringBuilder sb = new StringBuilder("Pay 2 life? (Otherwise ").append(targetCreature.getName()).append(" will be tapped)");§if (player.chooseUse(Outcome.Benefit, sb.toString(), source, game)) {§cost.pay(source, game, targetCreature.getControllerId(), targetCreature.getControllerId(), true, null);§}§if (!cost.isPaid()) {§return targetCreature.tap(game);§}§}§}§return false;§}§}§
public class VedalkenGhoul extends CardImpl {§public VedalkenGhoul(UUID ownerId) {§super(ownerId, 32, "Vedalken Ghoul", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{U}{B}");§this.expansionSetCode = "ARB";§this.subtype.add("Vedalken");§this.subtype.add("Zombie");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new VedalkenGhoulTriggeredAbility());§}§public VedalkenGhoul(final VedalkenGhoul card) {§super(card);§}§@Override§public VedalkenGhoul copy() {§return new VedalkenGhoul(this);§}§}§class VedalkenGhoulTriggeredAbility extends TriggeredAbilityImpl {§public VedalkenGhoulTriggeredAbility() {§super(Zone.BATTLEFIELD, new LoseLifeTargetEffect(4), false);§}§public VedalkenGhoulTriggeredAbility(final VedalkenGhoulTriggeredAbility ability) {§super(ability);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.CREATURE_BLOCKED;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (event.getTargetId().equals(this.getSourceId())) {§UUID defendingPlayer = game.getCombat().getDefenderId(this.getSourceId());§if (defendingPlayer != null) {§for (Effect effect : this.getEffects()) {§effect.setTargetPointer(new FixedTarget(defendingPlayer));§}§return true;§}§}§return false;§}§@Override§public String getRule() {§return "Whenever {this} becomes blocked, defending player loses 4 life.";§}§@Override§public VedalkenGhoulTriggeredAbility copy() {§return new VedalkenGhoulTriggeredAbility(this);§}§}§
public class VengefulRebirth extends CardImpl {§public VengefulRebirth(UUID ownerId) {§super(ownerId, 62, "Vengeful Rebirth", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{4}{R}{G}");§this.expansionSetCode = "ARB";§this.getSpellAbility().addTarget(new TargetCardInYourGraveyard());§this.getSpellAbility().addTarget(new TargetCreatureOrPlayer());§this.getSpellAbility().addEffect(new VengefulRebirthEffect());§this.getSpellAbility().addEffect(ExileSpellEffect.getInstance());§}§public VengefulRebirth(final VengefulRebirth card) {§super(card);§}§@Override§public VengefulRebirth copy() {§return new VengefulRebirth(this);§}§}§class VengefulRebirthEffect extends OneShotEffect {§public VengefulRebirthEffect() {§super(Outcome.DrawCard);§staticText = "Return target card from your graveyard to your hand. If you return a nonland card to your hand this way, {this} deals damage equal to that card's converted mana cost to target creature or player";§}§public VengefulRebirthEffect(final VengefulRebirthEffect effect) {§super(effect);§}§@Override§public VengefulRebirthEffect copy() {§return new VengefulRebirthEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§Card card = (Card)game.getObject(source.getFirstTarget());§if (controller != null && card != null && controller.removeFromGraveyard(card, game)) {§controller.moveCards(card, Zone.GRAVEYARD, Zone.HAND, source, game);§if (!card.getCardType().contains(CardType.LAND)) {§int damage = card.getManaCost().convertedManaCost();§Permanent permanent = game.getPermanent(source.getTargets().get(1).getFirstTarget());§if (permanent != null) {§permanent.damage(damage, source.getSourceId(), game, false, true);§}§Player targetPlayer = game.getPlayer(source.getTargets().get(1).getFirstTarget());§if (targetPlayer != null) {§targetPlayer.damage(damage, source.getSourceId(), game, false, true);§}§}§return true;§}§return false;§}§}§
public class ViolentOutburst extends CardImpl {§public ViolentOutburst(UUID ownerId) {§super(ownerId, 63, "Violent Outburst", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{R}{G}");§this.expansionSetCode = "ARB";§this.addAbility(new CascadeAbility());§this.getSpellAbility().addEffect(new BoostControlledEffect(1, 0, Duration.EndOfTurn));§}§public ViolentOutburst(final ViolentOutburst card) {§super(card);§}§@Override§public ViolentOutburst copy() {§return new ViolentOutburst(this);§}§}§
public class VithianRenegades extends CardImpl {§public VithianRenegades (UUID ownerId) {§super(ownerId, 64, "Vithian Renegades", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{R}{G}");§this.expansionSetCode = "ARB";§this.subtype.add("Human");§this.subtype.add("Shaman");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§Ability ability = new EntersBattlefieldTriggeredAbility(new DestroyTargetEffect());§ability.addTarget(new TargetPermanent(new FilterArtifactPermanent()));§this.addAbility(ability);§}§public VithianRenegades (final VithianRenegades card) {§super(card);§}§@Override§public VithianRenegades copy() {§return new VithianRenegades(this);§}§}§
public class WallOfDenial extends CardImpl {§public WallOfDenial (UUID ownerId) {§super(ownerId, 16, "Wall of Denial", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{W}{U}");§this.expansionSetCode = "ARB";§this.subtype.add("Wall");§this.power = new MageInt(0);§this.toughness = new MageInt(8);§this.addAbility(DefenderAbility.getInstance());§this.addAbility(FlyingAbility.getInstance());§this.addAbility(ShroudAbility.getInstance());§}§public WallOfDenial (final WallOfDenial card) {§super(card);§}§@Override§public WallOfDenial copy() {§return new WallOfDenial(this);§}§}§
public class Wargate extends CardImpl {§public Wargate(UUID ownerId) {§super(ownerId, 129, "Wargate", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{X}{G}{W}{U}");§this.expansionSetCode = "ARB";§this.getSpellAbility().addEffect(new WargateEffect());§}§public Wargate(final Wargate card) {§super(card);§}§@Override§public Wargate copy() {§return new Wargate(this);§}§}§class WargateEffect extends OneShotEffect {§WargateEffect() {§super(Outcome.PutCreatureInPlay);§staticText = "Search your library for a permanent card with converted mana cost X or less, put it onto the battlefield, then shuffle your library";§}§WargateEffect(final WargateEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller == null) {§return false;§}§FilterPermanentCard filter = new FilterPermanentCard("permanent card with converted mana cost X or less");§filter.add(new ConvertedManaCostPredicate(Filter.ComparisonType.LessThan, source.getManaCostsToPay().getX() + 1));§TargetCardInLibrary target = new TargetCardInLibrary(filter);§if (controller.searchLibrary(target, game)) {§if (target.getTargets().size() > 0) {§Card card = controller.getLibrary().getCard(target.getFirstTarget(), game);§if (card != null) {§controller.moveCards(card, Zone.BATTLEFIELD, source, game);§}§}§}§controller.shuffleLibrary(game);§return false;§}§@Override§public WargateEffect copy() {§return new WargateEffect(this);§}§}§
public class WildfieldBorderpost extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledLandPermanent("a basic land");§static {§filter.add(new SupertypePredicate("Basic"));§}§public WildfieldBorderpost (UUID ownerId) {§super(ownerId, 80, "Wildfield Borderpost", Rarity.COMMON, new CardType[]{CardType.ARTIFACT}, "{1}{G}{W}");§this.expansionSetCode = "ARB";§Ability ability = new AlternativeCostSourceAbility(new GenericManaCost(1));§ability.addCost(new ReturnToHandChosenControlledPermanentCost(new TargetControlledPermanent(filter)));§this.addAbility(ability);§this.addAbility(new EntersBattlefieldTappedAbility());§this.addAbility(new GreenManaAbility());§this.addAbility(new WhiteManaAbility());§}§public WildfieldBorderpost (final WildfieldBorderpost card) {§super(card);§}§@Override§public WildfieldBorderpost copy() {§return new WildfieldBorderpost(this);§}§}§
public class WingedCoatl extends CardImpl {§public WingedCoatl (UUID ownerId) {§super(ownerId, 105, "Winged Coatl", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{G}{U}");§this.expansionSetCode = "ARB";§this.subtype.add("Snake");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(FlashAbility.getInstance());§this.addAbility(FlyingAbility.getInstance());§this.addAbility(DeathtouchAbility.getInstance());§}§public WingedCoatl (final WingedCoatl card) {§super(card);§}§@Override§public WingedCoatl copy() {§return new WingedCoatl(this);§}§}§
public class ZealousPersecution extends CardImpl {§public ZealousPersecution(UUID ownerId) {§super(ownerId, 85, "Zealous Persecution", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{W}{B}");§this.expansionSetCode = "ARB";§this.getSpellAbility().addEffect(new BoostControlledEffect(1, 1, Duration.EndOfTurn));§this.getSpellAbility().addEffect(new BoostOpponentsEffect(-1, -1, Duration.EndOfTurn));§}§public ZealousPersecution(final ZealousPersecution card) {§super(card);§}§@Override§public ZealousPersecution copy() {§return new ZealousPersecution(this);§}§}§
public class AesthirGlider1 extends CardImpl {§public AesthirGlider1(UUID ownerId) {§super(ownerId, 156, "Aesthir Glider", Rarity.COMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{3}");§this.expansionSetCode = "ALL";§this.subtype.add("Bird");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new CantBlockAbility());§}§public AesthirGlider1(final AesthirGlider1 card) {§super(card);§}§@Override§public AesthirGlider1 copy() {§return new AesthirGlider1(this);§}§}§
public class AgentOfStromgald1 extends CardImpl {§public AgentOfStromgald1(UUID ownerId) {§super(ownerId, 94, "Agent of Stromgald", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{R}");§this.expansionSetCode = "ALL";§this.subtype.add("Human");§this.subtype.add("Knight");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new SimpleManaAbility(Zone.BATTLEFIELD, Mana.BlackMana(1), new ManaCostsImpl("{R}")));§}§public AgentOfStromgald1(final AgentOfStromgald1 card) {§super(card);§}§@Override§public AgentOfStromgald1 copy() {§return new AgentOfStromgald1(this);§}§}§
public class BalduvianHorde extends CardImpl {§public BalduvianHorde(UUID ownerId) {§super(ownerId, 96, "Balduvian Horde", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{R}{R}");§this.expansionSetCode = "ALL";§this.subtype.add("Human");§this.subtype.add("Barbarian");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(new EntersBattlefieldTriggeredAbility(new SacrificeSourceUnlessPaysEffect(new DiscardCardCost(true))));§}§public BalduvianHorde(final BalduvianHorde card) {§super(card);§}§@Override§public BalduvianHorde copy() {§return new BalduvianHorde(this);§}§}§
public class BalduvianTradingPost extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("an untapped Mountain");§static {§filter.add(new SubtypePredicate("Mountain"));§filter.add(Predicates.not(new TappedPredicate()));§}§public BalduvianTradingPost(UUID ownerId) {§super(ownerId, 182, "Balduvian Trading Post", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "ALL";§this.addAbility(new SimpleStaticAbility(Zone.ALL, new EnterBattlefieldPayCostOrPutGraveyardEffect(new SacrificeTargetCost(new TargetControlledPermanent(filter)))));§this.addAbility(new SimpleManaAbility(Zone.BATTLEFIELD, new Mana(1, 0, 0, 0, 0, 0, 0, 1), new TapSourceCost()));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(1), new GenericManaCost(1));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetAttackingCreature());§this.addAbility(ability);§}§public BalduvianTradingPost(final BalduvianTradingPost card) {§super(card);§}§@Override§public BalduvianTradingPost copy() {§return new BalduvianTradingPost(this);§}§}§
public class BalduvianWarMakers1 extends CardImpl {§public BalduvianWarMakers1(UUID ownerId) {§super(ownerId, 97, "Balduvian War-Makers", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{R}");§this.expansionSetCode = "ALL";§this.subtype.add("Human");§this.subtype.add("Barbarian");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(HasteAbility.getInstance());§this.addAbility(new RampageAbility(1));§}§public BalduvianWarMakers1(final BalduvianWarMakers1 card) {§super(card);§}§@Override§public BalduvianWarMakers1 copy() {§return new BalduvianWarMakers1(this);§}§}§
public class Browse extends CardImpl {§public Browse(UUID ownerId) {§super(ownerId, 38, "Browse", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{U}{U}");§this.expansionSetCode = "ALL";§SimpleActivatedAbility ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BrowseEffect(), new ManaCostsImpl("{2}{U}{U}"));§this.addAbility(ability);§}§public Browse(final Browse card) {§super(card);§}§@Override§public Browse copy() {§return new Browse(this);§}§}§class BrowseEffect extends OneShotEffect {§public BrowseEffect() {§super(Outcome.DrawCard);§this.staticText = "Look at the top five cards of your library, put one of them into your hand, and exile the rest";§}§public BrowseEffect(final BrowseEffect effect) {§super(effect);§}§@Override§public BrowseEffect copy() {§return new BrowseEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§Cards cards = new CardsImpl();§int cardsCount = Math.min(5, player.getLibrary().size());§for (int i = 0; i < cardsCount; i++) {§Card card = player.getLibrary().removeFromTop(game);§if (card != null) {§cards.add(card);§}§}§if (cards.size() > 0) {§player.lookAtCards("Browse", cards, game);§TargetCard target = new TargetCard(Zone.LIBRARY, new FilterCard("card to put in your hand"));§if (player.choose(Outcome.Benefit, cards, target, game)) {§Card card = cards.get(target.getFirstTarget(), game);§if (card != null) {§card.moveToZone(Zone.HAND, source.getSourceId(), game, false);§cards.remove(card);§}§}§for (Card card : cards.getCards(game)) {§card.moveToExile(null, null, source.getSourceId(), game);§}§}§return true;§}§return false;§}§}§
public class Burnout extends CardImpl {§private static final FilterSpell filter = new FilterSpell("instant spell");§static {§filter.add(new CardTypePredicate(CardType.INSTANT));§}§public Burnout(UUID ownerId) {§super(ownerId, 101, "Burnout", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{1}{R}");§this.expansionSetCode = "ALL";§Effect effect = new BurnoutCounterTargetEffect();§effect.setText("Counter target instant spell if it's blue");§this.getSpellAbility().addTarget(new TargetSpell(filter));§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addEffect(new CreateDelayedTriggeredAbilityEffect(§new AtTheBeginOfNextUpkeepDelayedTriggeredAbility(new DrawCardSourceControllerEffect(1), Duration.OneUse), false));§}§public Burnout(final Burnout card) {§super(card);§}§@Override§public Burnout copy() {§return new Burnout(this);§}§}§class BurnoutCounterTargetEffect extends OneShotEffect {§public BurnoutCounterTargetEffect() {§super(Outcome.Detriment);§}§public BurnoutCounterTargetEffect(final BurnoutCounterTargetEffect effect) {§super(effect);§}§@Override§public BurnoutCounterTargetEffect copy() {§return new BurnoutCounterTargetEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Spell targetSpell = game.getStack().getSpell(source.getFirstTarget());§if(targetSpell != null && targetSpell.getColor(game).isBlue()){§game.getStack().counter(source.getFirstTarget(), source.getSourceId(), game);§}§return true;§}§}§
public class CarrierPigeons1 extends CardImpl {§public CarrierPigeons1(UUID ownerId) {§super(ownerId, 125, "Carrier Pigeons", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{W}");§this.expansionSetCode = "ALL";§this.subtype.add("Bird");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new EntersBattlefieldTriggeredAbility(new CreateDelayedTriggeredAbilityEffect(§new AtTheBeginOfNextUpkeepDelayedTriggeredAbility(new DrawCardSourceControllerEffect(1), Duration.OneUse), false)));§}§public CarrierPigeons1(final CarrierPigeons1 card) {§super(card);§}§@Override§public CarrierPigeons1 copy() {§return new CarrierPigeons1(this);§}§}§
public class Contagion extends CardImpl {§public Contagion(UUID ownerId) {§super(ownerId, 4, "Contagion", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{3}{B}{B}");§this.expansionSetCode = "ALL";§FilterOwnedCard filter = new FilterOwnedCard("black card from your hand");§filter.add(new ColorPredicate(ObjectColor.BLACK));§filter.add(Predicates.not(new CardIdPredicate(this.getId()))); §
public class DiminishingReturns extends CardImpl {§public DiminishingReturns(UUID ownerId) {§super(ownerId, 39, "Diminishing Returns", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{2}{U}{U}");§this.expansionSetCode = "ALL";§this.getSpellAbility().addEffect(new DiminishingReturnsEffect());§}§public DiminishingReturns(final DiminishingReturns card) {§super(card);§}§@Override§public DiminishingReturns copy() {§return new DiminishingReturns(this);§}§}§class DiminishingReturnsEffect extends OneShotEffect {§public DiminishingReturnsEffect() {§super(Outcome.Neutral);§staticText = "Each player shuffles his or her hand and graveyard into his or her library. You exile the top ten cards of your library. Then each player draws up to seven cards.";§}§public DiminishingReturnsEffect(final DiminishingReturnsEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§for (UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {§Player player = game.getPlayer(playerId);§if (player != null) {§for (Card card: player.getHand().getCards(game)) {§card.moveToZone(Zone.LIBRARY, source.getSourceId(), game, true);§}§for (Card card: player.getGraveyard().getCards(game)) {§card.moveToZone(Zone.LIBRARY, source.getSourceId(), game, true);§}§player.shuffleLibrary(game);§}§}§for (Card card: controller.getLibrary().getTopCards(game, 10)) {§controller.moveCardToExileWithInfo(card, null, "", source.getSourceId(), game, Zone.LIBRARY, true);§}§for (UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {§Player player = game.getPlayer(playerId);§if (player != null) {§int cardsToDrawCount = player.getAmount(0, 7, "How many cards to draw (up to 7)?", game);§player.drawCards(cardsToDrawCount, game);§}§}§}§return true;§}§@Override§public DiminishingReturnsEffect copy() {§return new DiminishingReturnsEffect(this);§}§}§
public class EnslavedScout1 extends CardImpl {§public EnslavedScout1(UUID ownerId) {§super(ownerId, 104, "Enslaved Scout", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "ALL";§this.subtype.add("Goblin");§this.subtype.add("Scout");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD,§new GainAbilitySourceEffect(new MountainwalkAbility(false), Duration.EndOfTurn),§new GenericManaCost(2)));§}§public EnslavedScout1(final EnslavedScout1 card) {§super(card);§}§@Override§public EnslavedScout1 copy() {§return new EnslavedScout1(this);§}§}§
public class Exile extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("nonwhite attacking creature");§static {§filter.add(new AttackingPredicate());§filter.add(Predicates.not(new ColorPredicate(ObjectColor.WHITE)));§}§public Exile(UUID ownerId) {§super(ownerId, 129, "Exile", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{2}{W}");§this.expansionSetCode = "ALL";§this.getSpellAbility().addTarget(new TargetCreaturePermanent(filter));§this.getSpellAbility().addEffect(new ExileTargetEffect());§this.getSpellAbility().addEffect(new ExileEffect());§}§public Exile(final Exile card) {§super(card);§}§@Override§public Exile copy() {§return new Exile(this);§}§}§class ExileEffect extends OneShotEffect {§public ExileEffect() {§super(Outcome.GainLife);§staticText = "You gain life equal to its toughness";§}§public ExileEffect(final ExileEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = (Permanent) game.getLastKnownInformation(source.getFirstTarget(), Zone.BATTLEFIELD);§if (permanent != null) {§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§player.gainLife(permanent.getToughness().getValue(), game);§}§}§return false;§}§@Override§public ExileEffect copy() {§return new ExileEffect(this);§}§}§
public class FeveredStrength1 extends CardImpl {§public FeveredStrength1(UUID ownerId) {§super(ownerId, 10, "Fevered Strength", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{B}");§this.expansionSetCode = "ALL";§this.getSpellAbility().addEffect(new BoostTargetEffect(2, 0, Duration.EndOfTurn));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.getSpellAbility().addEffect(new CreateDelayedTriggeredAbilityEffect(§new AtTheBeginOfNextUpkeepDelayedTriggeredAbility(new DrawCardSourceControllerEffect(1), Duration.OneUse), false));§}§public FeveredStrength1(final FeveredStrength1 card) {§super(card);§}§@Override§public FeveredStrength1 copy() {§return new FeveredStrength1(this);§}§}§
public class ForceOfWill extends CardImpl {§public ForceOfWill(UUID ownerId) {§super(ownerId, 42, "Force of Will", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{3}{U}{U}");§this.expansionSetCode = "ALL";§FilterOwnedCard filter = new FilterOwnedCard("a blue card from your hand");§filter.add(new ColorPredicate(ObjectColor.BLUE));§filter.add(Predicates.not(new CardIdPredicate(this.getId()))); §
public class GorillaBerserkers1 extends CardImpl {§public GorillaBerserkers1(UUID ownerId) {§super(ownerId, 75, "Gorilla Berserkers", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{G}{G}");§this.expansionSetCode = "ALL";§this.subtype.add("Ape");§this.subtype.add("Berserker");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(TrampleAbility.getInstance());§this.addAbility(new RampageAbility(2));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new CantBeBlockedByOneEffect(3)));§}§public GorillaBerserkers1(final GorillaBerserkers1 card) {§super(card);§}§@Override§public GorillaBerserkers1 copy() {§return new GorillaBerserkers1(this);§}§}§
public class GorillaShaman1 extends CardImpl {§private final UUID originalId;§public GorillaShaman1(UUID ownerId) {§super(ownerId, 106, "Gorilla Shaman", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{R}");§this.expansionSetCode = "ALL";§this.subtype.add("Ape");§this.subtype.add("Shaman");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DestroyTargetEffect(), new ManaCostsImpl("{X}{X}{1}"));§ability.addTarget(new TargetPermanent(new FilterArtifactPermanent("noncreature artifact with converted mana cost X")));§originalId = ability.getOriginalId();§this.addAbility(ability);§}§@Override§public void adjustTargets(Ability ability, Game game) {§if (ability.getOriginalId().equals(originalId)) {§int xValue = ability.getManaCostsToPay().getX();§ability.getTargets().clear();§FilterArtifactPermanent filter = new FilterArtifactPermanent(new StringBuilder("noncreature artifact with converted mana cost ").append(xValue).toString());§filter.add(new ConvertedManaCostPredicate(Filter.ComparisonType.Equal, xValue));§filter.add(Predicates.not(new CardTypePredicate(CardType.CREATURE)));§Target target = new TargetPermanent(filter);§ability.addTarget(target);§}§}§public GorillaShaman1(final GorillaShaman1 card) {§super(card);§this.originalId = card.originalId;§}§@Override§public GorillaShaman1 copy() {§return new GorillaShaman1(this);§}§}§
public class HeartOfYavimaya extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("a Forest");§static {§filter.add(new SubtypePredicate("Forest"));§}§public HeartOfYavimaya(UUID ownerId) {§super(ownerId, 183, "Heart of Yavimaya", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "ALL";§this.addAbility(new SimpleStaticAbility(Zone.ALL, new EnterBattlefieldPayCostOrPutGraveyardEffect(new SacrificeTargetCost(new TargetControlledPermanent(filter)))));§this.addAbility(new GreenManaAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostTargetEffect(1,1,Duration.EndOfTurn), new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public HeartOfYavimaya(final HeartOfYavimaya card) {§super(card);§}§@Override§public HeartOfYavimaya copy() {§return new HeartOfYavimaya(this);§}§}§
public class HelmOfObedience extends CardImpl {§public HelmOfObedience(UUID ownerId) {§super(ownerId, 163, "Helm of Obedience", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{4}");§this.expansionSetCode = "ALL";§VariableManaCost xCosts = new VariableManaCost();§xCosts.setMinX(1);§SimpleActivatedAbility abilitiy = new SimpleActivatedAbility(Zone.BATTLEFIELD, new HelmOfObedienceEffect(), xCosts);§abilitiy.addCost(new TapSourceCost());§abilitiy.addTarget(new TargetOpponent());§this.addAbility(abilitiy);§}§public HelmOfObedience(final HelmOfObedience card) {§super(card);§}§@Override§public HelmOfObedience copy() {§return new HelmOfObedience(this);§}§}§class HelmOfObedienceEffect extends OneShotEffect {§private static final ManacostVariableValue amount = new ManacostVariableValue();§public HelmOfObedienceEffect() {§super(Outcome.Detriment);§staticText = "Target opponent puts cards from the top of his or her library into his or her graveyard until a creature card or X cards are put into that graveyard this way, whichever comes first. If a creature card is put into that graveyard this way, sacrifice Helm of Obedience and put that card onto the battlefield under your control. X can't be 0";§}§public HelmOfObedienceEffect(final HelmOfObedienceEffect effect) {§super(effect);§}§@Override§public HelmOfObedienceEffect copy() {§return new HelmOfObedienceEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player targetOpponent = game.getPlayer(targetPointer.getFirst(game, source));§if (targetOpponent != null) {§int max = amount.calculate(game, source, this);§if(max != 0){§int numberOfCard = 0;§while(targetOpponent.getLibrary().size() > 0) {§Card card = targetOpponent.getLibrary().removeFromTop(game);§if (card != null){§if (targetOpponent.moveCards(card, Zone.LIBRARY, Zone.GRAVEYARD, source, game)) {§if(card.getCardType().contains(CardType.CREATURE)){§Permanent sourcePermanent = game.getPermanent(source.getSourceId());§if (sourcePermanent != null) {§sourcePermanent.sacrifice(source.getSourceId(), game);§}§if (game.getState().getZone(card.getId()).equals(Zone.GRAVEYARD)) {§card.putOntoBattlefield(game, Zone.GRAVEYARD, source.getSourceId(), source.getControllerId());§}§break;§} else{§numberOfCard++;§if(numberOfCard >= max){§break;§}§}§}§} else{§return false;§}§}§}§return true;§}§return false;§}§}§
public class Inheritance extends CardImpl {§public Inheritance(UUID ownerId) {§super(ownerId, 130, "Inheritance", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{W}");§this.expansionSetCode = "ALL";§Ability ability = new DiesCreatureTriggeredAbility(new DoIfCostPaid(new DrawCardSourceControllerEffect(1), new ManaCostsImpl("{3}")), false);§this.addAbility(ability);§}§public Inheritance(final Inheritance card) {§super(card);§}§@Override§public Inheritance copy() {§return new Inheritance(this);§}§}§
public class InsidiousBookworms1 extends CardImpl {§public InsidiousBookworms1(UUID ownerId) {§super(ownerId, 12, "Insidious Bookworms", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{B}");§this.expansionSetCode = "ALL";§this.subtype.add("Worm");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new DiesTriggeredAbility(new DoIfCostPaid(new DiscardTargetEffect(1, true), new ManaCostsImpl("{1}{B}")));§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§}§public InsidiousBookworms1(final InsidiousBookworms1 card) {§super(card);§}§@Override§public InsidiousBookworms1 copy() {§return new InsidiousBookworms1(this);§}§}§
public class JuniperOrderAdvocate extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("green creatures you control");§static {§filter.add(new ColorPredicate(ObjectColor.GREEN));§filter.add(new ControllerPredicate(TargetController.YOU));§}§public JuniperOrderAdvocate(UUID ownerId) {§super(ownerId, 132, "Juniper Order Advocate", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "ALL";§this.subtype.add("Human");§this.subtype.add("Knight");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new ConditionalContinuousEffect(§new BoostAllEffect(1, 1, Duration.WhileOnBattlefield, filter, false),§new InvertCondition(new SourceTappedCondition()),§"As long as {this} is untapped, green creatures you control get +1/+1.")));§}§public JuniperOrderAdvocate(final JuniperOrderAdvocate card) {§super(card);§}§@Override§public JuniperOrderAdvocate copy() {§return new JuniperOrderAdvocate(this);§}§}§
public class Kaysa extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Green creatures");§static {§filter.add(new ColorPredicate(ObjectColor.GREEN));§}§public Kaysa(UUID ownerId) {§super(ownerId, 80, "Kaysa", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{G}{G}");§this.expansionSetCode = "ALL";§this.supertype.add("Legendary");§this.subtype.add("Elf");§this.subtype.add("Druid");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostControlledEffect(1,1, Duration.WhileOnBattlefield, filter)));§}§public Kaysa(final Kaysa card) {§super(card);§}§@Override§public Kaysa copy() {§return new Kaysa(this);§}§}§
public class KeeperOfTresserhorn extends CardImpl {§public KeeperOfTresserhorn(UUID ownerId) {§super(ownerId, 14, "Keeper of Tresserhorn", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}{B}");§this.expansionSetCode = "ALL";§this.subtype.add("Avatar");§this.power = new MageInt(6);§this.toughness = new MageInt(6);§Effect effect = new AssignNoCombatDamageSourceEffect(Duration.EndOfTurn);§effect.setText("it assigns no combat damage this turn");§Ability ability = new AttacksAndIsNotBlockedTriggeredAbility(effect, false, true);§effect = new LoseLifeTargetEffect(2);§effect.setText("and defending player loses 2 life");§ability.addEffect(effect);§this.addAbility(ability);§}§public KeeperOfTresserhorn(final KeeperOfTresserhorn card) {§super(card);§}§@Override§public KeeperOfTresserhorn copy() {§return new KeeperOfTresserhorn(this);§}§}§
public class LibraryOfLatNam extends CardImpl {§public LibraryOfLatNam(UUID ownerId) {§super(ownerId, 47, "Library of Lat-Nam", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{4}{U}");§this.expansionSetCode = "ALL";§this.getSpellAbility().getModes().setModeChooser(TargetController.OPPONENT);§this.getSpellAbility().addEffect(new CreateDelayedTriggeredAbilityEffect(new AtTheBeginOfNextUpkeepDelayedTriggeredAbility(new DrawCardSourceControllerEffect(3)), false));§Mode mode = new Mode();§Effect effect = new SearchLibraryPutInHandEffect(new TargetCardInLibrary(), false, true);§mode.getEffects().add(effect);§this.getSpellAbility().addMode(mode);§}§public LibraryOfLatNam(final LibraryOfLatNam card) {§super(card);§}§@Override§public LibraryOfLatNam copy() {§return new LibraryOfLatNam(this);§}§}§
public class LimDulsHighGuard1 extends CardImpl {§public LimDulsHighGuard1(UUID ownerId) {§super(ownerId, 17, "Lim-Dul's High Guard", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{B}{B}");§this.expansionSetCode = "ALL";§this.subtype.add("Skeleton");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(FirstStrikeAbility.getInstance());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new RegenerateSourceEffect(), new ManaCostsImpl("{1}{B}")));§}§public LimDulsHighGuard1(final LimDulsHighGuard1 card) {§super(card);§}§@Override§public LimDulsHighGuard1 copy() {§return new LimDulsHighGuard1(this);§}§}§
public class LimDulsPaladin extends CardImpl {§public LimDulsPaladin(UUID ownerId) {§super(ownerId, 191, "Lim-Dul's Paladin", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{B}{R}");§this.expansionSetCode = "ALL";§this.subtype.add("Human");§this.subtype.add("Knight");§this.power = new MageInt(0);§this.toughness = new MageInt(3);§this.addAbility(TrampleAbility.getInstance());§this.addAbility(new BeginningOfUpkeepTriggeredAbility(Zone.BATTLEFIELD, new LimDulsPaladinEffect(), TargetController.YOU, false));§this.addAbility(new BecomesBlockedTriggeredAbility(new BoostSourceEffect(6, 3, Duration.EndOfTurn), false));§Effect effect = new AssignNoCombatDamageSourceEffect(Duration.EndOfTurn);§effect.setText("it assigns no combat damage this turn");§Ability ability = new AttacksAndIsNotBlockedTriggeredAbility(effect, false, true);§effect = new LoseLifeTargetEffect(4);§effect.setText("and defending player loses 4 life");§ability.addEffect(effect);§this.addAbility(ability);§}§public LimDulsPaladin(final LimDulsPaladin card) {§super(card);§}§@Override§public LimDulsPaladin copy() {§return new LimDulsPaladin(this);§}§}§class LimDulsPaladinEffect extends SacrificeSourceUnlessPaysEffect {§public LimDulsPaladinEffect() {§super(new DiscardTargetCost(new TargetCardInHand()));§staticText = "you may discard a card. If you don't, sacrifice {this} and draw a card.";§}§public LimDulsPaladinEffect(final LimDulsPaladinEffect effect) {§super(effect);§}§@Override§public LimDulsPaladinEffect copy() {§return new LimDulsPaladinEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getPermanent(source.getSourceId());§if(permanent != null) {§super.apply(game, source);§if(game.getPermanent(source.getSourceId()) == null) {§return new DrawCardSourceControllerEffect(1).apply(game, source);§}§return true;§}§return false;§}§}§
public class LordOfTresserhorn extends CardImpl {§public LordOfTresserhorn(UUID ownerId) {§super(ownerId, 193, "Lord of Tresserhorn", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{U}{B}{R}");§this.expansionSetCode = "ALL";§this.supertype.add("Legendary");§this.subtype.add("Zombie");§this.power = new MageInt(10);§this.toughness = new MageInt(4);§Ability ability = new EntersBattlefieldTriggeredAbility(new LoseLifeSourceControllerEffect(2), false);§ability.addEffect(new SacrificeControllerEffect(new FilterControlledCreaturePermanent("creatures"), 2, "you"));§Effect effect = new DrawCardTargetEffect(2);§effect.setText(", and target opponent draws two cards");§ability.addEffect(effect);§ability.addTarget(new TargetOpponent());§this.addAbility(ability);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new RegenerateSourceEffect(), new ManaCostsImpl("{B}")));§}§public LordOfTresserhorn(final LordOfTresserhorn card) {§super(card);§}§@Override§public LordOfTresserhorn copy() {§return new LordOfTresserhorn(this);§}§}§
public class MysticCompass extends CardImpl {§public MysticCompass(UUID ownerId) {§super(ownerId, 166, "Mystic Compass", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{2}");§this.expansionSetCode = "ALL";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BecomesBasicLandTargetEffect(Duration.EndOfTurn), new ManaCostsImpl("{1}"));§ability.addCost(new TapSourceCost());§Target target = new TargetLandPermanent();§ability.addTarget(target);§this.addAbility(ability);§}§public MysticCompass(final MysticCompass card) {§super(card);§}§@Override§public MysticCompass copy() {§return new MysticCompass(this);§}§}§
public class PhyrexianWarBeast1 extends CardImpl {§public PhyrexianWarBeast1(UUID ownerId) {§super(ownerId, 169, "Phyrexian War Beast", Rarity.COMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{3}");§this.expansionSetCode = "ALL";§this.subtype.add("Beast");§this.power = new MageInt(3);§this.toughness = new MageInt(4);§Ability ability = new LeavesBattlefieldTriggeredAbility(new SacrificeControllerEffect(new FilterControlledLandPermanent(), 1, ""), false);§Effect effect = new DamageControllerEffect(1);§effect.setText("and {this} deals 1 damage to you");§ability.addEffect(effect);§ability.addTarget(new TargetControlledPermanent(new FilterControlledLandPermanent()));§this.addAbility(ability);§}§public PhyrexianWarBeast1(final PhyrexianWarBeast1 card) {§super(card);§}§@Override§public PhyrexianWarBeast1 copy() {§return new PhyrexianWarBeast1(this);§}§}§
public class Pyrokinesis extends CardImpl {§public Pyrokinesis(UUID ownerId) {§super(ownerId, 115, "Pyrokinesis", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{4}{R}{R}");§this.expansionSetCode = "ALL";§FilterOwnedCard filter = new FilterOwnedCard("a red card from your hand");§filter.add(new ColorPredicate(ObjectColor.RED));§filter.add(Predicates.not(new CardIdPredicate(this.getId()))); §
public class RoyalHerbalist1 extends CardImpl {§public RoyalHerbalist1(UUID ownerId) {§super(ownerId, 147, "Royal Herbalist", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{W}");§this.expansionSetCode = "ALL";§this.subtype.add("Human");§this.subtype.add("Cleric");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainLifeEffect(1), new ManaCostsImpl("{2}"));§ability.addCost(new ExileFromTopOfLibraryCost(1));§this.addAbility(ability);§}§public RoyalHerbalist1(final RoyalHerbalist1 card) {§super(card);§}§@Override§public RoyalHerbalist1 copy() {§return new RoyalHerbalist1(this);§}§}§
public class SchoolOfTheUnseen extends CardImpl {§public SchoolOfTheUnseen(UUID ownerId) {§super(ownerId, 186, "School of the Unseen", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "ALL";§this.addAbility(new ColorlessManaAbility());§Ability ability = new AnyColorManaAbility(new GenericManaCost(2));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§}§public SchoolOfTheUnseen(final SchoolOfTheUnseen card) {§super(card);§}§@Override§public SchoolOfTheUnseen copy() {§return new SchoolOfTheUnseen(this);§}§}§
public class SeasonedTactician extends CardImpl {§public SeasonedTactician(UUID ownerId) {§super(ownerId, 150, "Seasoned Tactician", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "ALL";§this.subtype.add("Human");§this.subtype.add("Advisor");§this.power = new MageInt(1);§this.toughness = new MageInt(3);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new PreventNextDamageFromChosenSourceToYouEffect(Duration.EndOfTurn),§new ManaCostsImpl("{3}"));§ability.addCost(new ExileFromTopOfLibraryCost(4));§this.addAbility(ability);§}§public SeasonedTactician(final SeasonedTactician card) {§super(card);§}§@Override§public SeasonedTactician copy() {§return new SeasonedTactician(this);§}§}§
public class ShelteredValley extends CardImpl {§private static final FilterLandPermanent filter = new FilterLandPermanent();§private static final FilterPermanent filterShelteredValley = new FilterPermanent("permanent named Sheltered Valley");§static {§filterShelteredValley.add(new NamePredicate("Sheltered Valley"));§}§public ShelteredValley(UUID ownerId) {§super(ownerId, 187, "Sheltered Valley", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "ALL";§Effect effect = new EnterBattlefieldPayCostOrPutGraveyardEffect(new SacrificeAllCost(filterShelteredValley));§effect.setText("If {this} would enter the battlefield, instead sacrifice each other permanent named {this} you control, then put {this} onto the battlefield.");§Ability ability = new SimpleStaticAbility(Zone.ALL, effect);§this.addAbility(ability);§Condition controls = new PermanentsOnTheBattlefieldCondition(filter, PermanentsOnTheBattlefieldCondition.CountType.FEWER_THAN, 4);§effect = new ConditionalOneShotEffect(new GainLifeEffect(1), controls);§effect.setText("if you control three or fewer lands, you gain 1 life");§ability = new BeginningOfUpkeepTriggeredAbility(Zone.BATTLEFIELD, effect, TargetController.YOU, false);§this.addAbility(ability);§this.addAbility(new ColorlessManaAbility());§}§public ShelteredValley(final ShelteredValley card) {§super(card);§}§@Override§public ShelteredValley copy() {§return new ShelteredValley(this);§}§}§
public class ShieldSphere extends CardImpl {§public ShieldSphere(UUID ownerId) {§super(ownerId, 172, "Shield Sphere", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{0}");§this.expansionSetCode = "ALL";§this.subtype.add("Wall");§this.power = new MageInt(0);§this.toughness = new MageInt(6);§this.addAbility(DefenderAbility.getInstance());§this.addAbility(new BlocksTriggeredAbility(new AddCountersSourceEffect(new BoostCounter(0, -1)), false));§}§public ShieldSphere(final ShieldSphere card) {§super(card);§}§@Override§public ShieldSphere copy() {§return new ShieldSphere(this);§}§}§
public class SoldeviAdnate1 extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("black or artifact creature");§static {§filter.add(Predicates.or(new ColorPredicate(ObjectColor.BLACK), new CardTypePredicate(CardType.ARTIFACT)));§}§public SoldeviAdnate1(UUID ownerId) {§super(ownerId, 25, "Soldevi Adnate", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{B}");§this.expansionSetCode = "ALL";§this.subtype.add("Human");§this.subtype.add("Cleric");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§Ability ability = new DynamicManaAbility(Mana.BlackMana(1), new SacrificeCostConvertedMana("creature"),§new TapSourceCost(), "add to your mana pool an amount of {B} equal to the sacrificed creature's converted mana cost");§ability.addCost(new SacrificeTargetCost(new TargetControlledPermanent(filter)));§this.addAbility(ability);§}§public SoldeviAdnate1(final SoldeviAdnate1 card) {§super(card);§}§@Override§public SoldeviAdnate1 copy() {§return new SoldeviAdnate1(this);§}§}§
public class SoldeviDigger extends CardImpl {§public SoldeviDigger(UUID ownerId) {§super(ownerId, 174, "Soldevi Digger", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{2}");§this.expansionSetCode = "ALL";§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new SoldeviDiggerEffect(), new ManaCostsImpl("{2}")));§}§public SoldeviDigger(final SoldeviDigger card) {§super(card);§}§@Override§public SoldeviDigger copy() {§return new SoldeviDigger(this);§}§}§class SoldeviDiggerEffect extends OneShotEffect {§public SoldeviDiggerEffect() {§super(Outcome.Benefit);§this.staticText = "put the top card of your graveyard on the bottom of your library";§}§public SoldeviDiggerEffect(final SoldeviDiggerEffect effect) {§super(effect);§}§@Override§public SoldeviDiggerEffect copy() {§return new SoldeviDiggerEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Card topCard = null;§for (Card card :controller.getGraveyard().getCards(game)) {§topCard = card;§}§if (topCard != null) {§return controller.moveCardToLibraryWithInfo(topCard, source.getSourceId(), game, Zone.GRAVEYARD, false, true);§}§return true;§}§return false;§}§}§
public class SoldeviExcavations extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("an untapped Island");§static {§filter.add(new SubtypePredicate("Island"));§filter.add(Predicates.not(new TappedPredicate()));§}§public SoldeviExcavations(UUID ownerId) {§super(ownerId, 188, "Soldevi Excavations", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "ALL";§this.addAbility(new SimpleStaticAbility(Zone.ALL, new EnterBattlefieldPayCostOrPutGraveyardEffect(new SacrificeTargetCost(new TargetControlledPermanent(filter)))));§this.addAbility(new SimpleManaAbility(Zone.BATTLEFIELD, new Mana(0, 0, 1, 0, 0, 0, 0, 1), new TapSourceCost()));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ScryEffect(1), new GenericManaCost(1));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§}§public SoldeviExcavations(final SoldeviExcavations card) {§super(card);§}§@Override§public SoldeviExcavations copy() {§return new SoldeviExcavations(this);§}§}§
public class SoldeviSage1 extends CardImpl {§public SoldeviSage1(UUID ownerId) {§super(ownerId, 51, "Soldevi Sage", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{U}");§this.expansionSetCode = "ALL";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new SoldeviSageEffect(), new TapSourceCost());§ability.addCost(new SacrificeTargetCost(new TargetControlledPermanent(2, 2, new FilterControlledLandPermanent("two lands"), true)));§this.addAbility(ability);§}§public SoldeviSage1(final SoldeviSage1 card) {§super(card);§}§@Override§public SoldeviSage1 copy() {§return new SoldeviSage1(this);§}§}§class SoldeviSageEffect extends OneShotEffect {§public SoldeviSageEffect() {§super(Outcome.DrawCard);§this.staticText = "Draw three cards, then discard one of them";§}§public SoldeviSageEffect(final SoldeviSageEffect effect) {§super(effect);§}§@Override§public SoldeviSageEffect copy() {§return new SoldeviSageEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§Cards initialHand = player.getHand().copy();§player.drawCards(3, game);§Cards drawnCards = new CardsImpl();§for (UUID cardId : player.getHand()) {§if (!initialHand.contains(cardId)) {§drawnCards.add(cardId);§}§}§if (drawnCards.size() > 0) {§TargetCard cardToDiscard = new TargetCard(Zone.HAND, new FilterCard("card to discard"));§cardToDiscard.setNotTarget(true);§if (player.choose(Outcome.Discard, drawnCards, cardToDiscard, game)) {§Card card = player.getHand().get(cardToDiscard.getFirstTarget(), game);§if (card != null) {§return player.discard(card, source, game);§}§}§}§return true;§}§return false;§}§}§
public class SoldierOfFortune extends CardImpl {§public SoldierOfFortune(UUID ownerId) {§super(ownerId, 117, "Soldier of Fortune", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{R}");§this.expansionSetCode = "ALL";§this.subtype.add("Human");§this.subtype.add("Mercenary");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ShuffleLibraryTargetEffect(), new TapSourceCost());§ability.addManaCost(new ManaCostsImpl("{R}"));§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§}§public SoldierOfFortune(final SoldierOfFortune card) {§super(card);§}§@Override§public SoldierOfFortune copy() {§return new SoldierOfFortune(this);§}§}§
public class SolGrail extends CardImpl {§public SolGrail(UUID ownerId) {§super(ownerId, 173, "Sol Grail", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "ALL";§this.addAbility(new EntersBattlefieldAbility(new ChooseColorEffect(Outcome.Neutral)));§this.addAbility(new SimpleManaAbility(Zone.BATTLEFIELD, new SolGrailManaEffect(), new TapSourceCost()));§}§public SolGrail(final SolGrail card) {§super(card);§}§@Override§public SolGrail copy() {§return new SolGrail(this);§}§}§class SolGrailManaEffect extends ManaEffect {§public SolGrailManaEffect() {§super();§staticText = "Add one mana of the chosen color to your mana pool";§}§public SolGrailManaEffect(final SolGrailManaEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§player.getManaPool().addMana(getMana(game, source), game, source);§}§return true;§}§@Override§public Mana getMana(Game game, Ability source) {§ObjectColor color = (ObjectColor) game.getState().getValue(source.getSourceId() + "_color");§if (color != null) {§return new Mana(ColoredManaSymbol.lookup(color.toString().charAt(0)));§} else {§return null;§}§}§@Override§public SolGrailManaEffect copy() {§return new SolGrailManaEffect(this);§}§}§
public class StormShaman1 extends CardImpl {§public StormShaman1(UUID ownerId) {§super(ownerId, 118, "Storm Shaman", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "ALL";§this.subtype.add("Human");§this.subtype.add("Cleric");§this.subtype.add("Shaman");§this.power = new MageInt(0);§this.toughness = new MageInt(4);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(1,0, Duration.EndOfTurn), new ManaCostsImpl("{R}")));§}§public StormShaman1(final StormShaman1 card) {§super(card);§}§@Override§public StormShaman1 copy() {§return new StormShaman1(this);§}§}§
public class SustainingSpirit extends CardImpl {§public SustainingSpirit(UUID ownerId) {§super(ownerId, 151, "Sustaining Spirit", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "ALL";§this.subtype.add("Angel");§this.subtype.add("Spirit");§this.power = new MageInt(0);§this.toughness = new MageInt(3);§this.addAbility(new CumulativeUpkeepAbility(new ManaCostsImpl("{1}{W}")));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new SustainingSpiritReplacementEffect()));§}§public SustainingSpirit(final SustainingSpirit card) {§super(card);§}§@Override§public SustainingSpirit copy() {§return new SustainingSpirit(this);§}§}§class SustainingSpiritReplacementEffect extends ReplacementEffectImpl {§public SustainingSpiritReplacementEffect() {§super(Duration.WhileOnBattlefield, Outcome.Benefit);§staticText = "Damage that would reduce your life total to less than 1 reduces it to 1 instead";§}§public SustainingSpiritReplacementEffect(final SustainingSpiritReplacementEffect effect) {§super(effect);§}§@Override§public SustainingSpiritReplacementEffect copy() {§return new SustainingSpiritReplacementEffect(this);§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.DAMAGE_CAUSES_LIFE_LOSS;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§Permanent permanent = game.getPermanent(source.getSourceId());§if (permanent != null) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null§&& (controller.getLife() > 0) &&(controller.getLife() - event.getAmount()) < 1§&& event.getPlayerId().equals(controller.getId())§) {§event.setAmount(controller.getLife() - 1);§}§}§return false;§}§@Override§public boolean apply(Game game, Ability source) {§return false;§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§return false;§}§}§
public class SwampMosquito1 extends CardImpl {§public SwampMosquito1(UUID ownerId) {§super(ownerId, 30, "Swamp Mosquito", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{B}");§this.expansionSetCode = "ALL";§this.subtype.add("Insect");§this.power = new MageInt(0);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§Effect effect = new AddPoisonCounterTargetEffect(1);§effect.setText("defending player gets a poison counter");§this.addAbility(new AttacksAndIsNotBlockedTriggeredAbility(effect, false, true));§}§public SwampMosquito1(final SwampMosquito1 card) {§super(card);§}§@Override§public SwampMosquito1 copy() {§return new SwampMosquito1(this);§}§}§
public class Tornado extends CardImpl {§public Tornado(UUID ownerId) {§super(ownerId, 86, "Tornado", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{4}{G}");§this.expansionSetCode = "ALL";§this.addAbility(new CumulativeUpkeepAbility(new ManaCostsImpl("{G}")));§Ability ability = new LimitedTimesPerTurnActivatedAbility(Zone.BATTLEFIELD, new DestroyTargetEffect(), new ManaCostsImpl("{2}{G}"));§DynamicValue lifeToPayAmount = new MultipliedValue(new CountersCount(CounterType.VELOCITY), 3);§ability.addCost(new PayLifeCost(lifeToPayAmount, "3 life for each velocity counter on {source}"));§ability.addTarget(new TargetPermanent());§Effect effect = new AddCountersSourceEffect(CounterType.VELOCITY.createInstance());§effect.setText("and put a velocity counter on {source}");§ability.addEffect(effect);§this.addAbility(ability);§}§public Tornado(final Tornado card) {§super(card);§}§@Override§public Tornado copy() {§return new Tornado(this);§}§}§
public class WhipVine1 extends CardImpl {§public WhipVine1(UUID ownerId) {§super(ownerId, 89, "Whip Vine", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{G}");§this.expansionSetCode = "ALL";§this.subtype.add("Plant");§this.subtype.add("Wall");§this.power = new MageInt(1);§this.toughness = new MageInt(4);§this.addAbility(DefenderAbility.getInstance());§this.addAbility(ReachAbility.getInstance());§this.addAbility(new SkipUntapOptionalAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new TapTargetEffect(), new TapSourceCost());§FilterCreaturePermanent filter = new FilterCreaturePermanent("creature with flying blocked by {this}");§filter.add(new AbilityPredicate(FlyingAbility.class));§filter.add(new BlockedByIdPredicate(this.getId()));§ability.addTarget(new TargetCreaturePermanent(filter));§ability.addEffect(new DontUntapAsLongAsSourceTappedEffect());§this.addAbility(ability);§}§public WhipVine1(final WhipVine1 card) {§super(card);§}§@Override§public WhipVine1 copy() {§return new WhipVine1(this);§}§}§
public class VoidmageApprentice extends CardImpl {§public VoidmageApprentice(UUID ownerId) {§super(ownerId, 4, "Voidmage Apprentice", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{U}");§this.expansionSetCode = "DD3D";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new MorphAbility(this, new ManaCostsImpl("{2}{U}{U}")));§Ability ability = new TurnedFaceUpSourceTriggeredAbility(new CounterTargetEffect(), false);§ability.addTarget(new TargetSpell());§this.addAbility(ability);§}§public VoidmageApprentice(final VoidmageApprentice card) {§super(card);§}§@Override§public VoidmageApprentice copy() {§return new VoidmageApprentice(this);§}§}§
public class WallOfDeceit extends CardImpl {§public WallOfDeceit(UUID ownerId) {§super(ownerId, 5, "Wall of Deceit", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{U}");§this.expansionSetCode = "DD3D";§this.subtype.add("Wall");§this.power = new MageInt(0);§this.toughness = new MageInt(5);§this.addAbility(DefenderAbility.getInstance());§Effect effect = new BecomesFaceDownCreatureEffect(Duration.Custom, BecomesFaceDownCreatureEffect.FaceDownType.MANIFESTED);§effect.setText("Turn Wall of Deceit face down. <i>(It becomes a 2/2 creature.)</i>");§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new ManaCostsImpl("{3}")));§this.addAbility(new MorphAbility(this, new ManaCostsImpl("{U}")));§}§public WallOfDeceit(final WallOfDeceit card) {§super(card);§}§@Override§public WallOfDeceit copy() {§return new WallOfDeceit(this);§}§}§
public class ArgivianArchaeologist extends CardImpl {§private static final FilterArtifactCard filter = new FilterArtifactCard("artifact card from your graveyard");§public ArgivianArchaeologist(UUID ownerId) {§super(ownerId, 94, "Argivian Archaeologist", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{W}{W}");§this.expansionSetCode = "ATQ";§this.subtype.add("Human");§this.subtype.add("Artificer");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ReturnToHandTargetEffect(), new ManaCostsImpl("{W}{W}"));§ability.addCost(new TapSourceCost());§Target target = new TargetCardInYourGraveyard(filter);§ability.addTarget(target);§this.addAbility(ability);§}§public ArgivianArchaeologist(final ArgivianArchaeologist card) {§super(card);§}§@Override§public ArgivianArchaeologist copy() {§return new ArgivianArchaeologist(this);§}§}§
public class ArgivianBlacksmith extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("artifact creature");§static {§filter.add(new CardTypePredicate(CardType.ARTIFACT));§filter.add(new CardTypePredicate(CardType.CREATURE));§}§public ArgivianBlacksmith(UUID ownerId) {§super(ownerId, 95, "Argivian Blacksmith", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{W}{W}");§this.expansionSetCode = "ATQ";§this.subtype.add("Human");§this.subtype.add("Artificer");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,§new PreventDamageToTargetEffect(Duration.EndOfTurn, 2), new TapSourceCost());§ability.addTarget(new TargetPermanent(filter));§this.addAbility(ability);§}§public ArgivianBlacksmith(final ArgivianBlacksmith card) {§super(card);§}§@Override§public ArgivianBlacksmith copy() {§return new ArgivianBlacksmith(this);§}§}§
public class ArtifactBlast extends CardImpl {§public ArtifactBlast(UUID ownerId) {§super(ownerId, 87, "Artifact Blast", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{R}");§this.expansionSetCode = "ATQ";§this.getSpellAbility().addTarget(new TargetSpell(new FilterArtifactSpell()));§this.getSpellAbility().addEffect(new CounterTargetEffect());§}§public ArtifactBlast(final ArtifactBlast card) {§super(card);§}§@Override§public ArtifactBlast copy() {§return new ArtifactBlast(this);§}§}§
public class AshnodsBattleGear extends CardImpl {§public AshnodsBattleGear(UUID ownerId) {§super(ownerId, 4, "Ashnod's Battle Gear", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{2}");§this.expansionSetCode = "ATQ";§this.addAbility(new SkipUntapOptionalAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ConditionalContinuousEffect(§new BoostTargetEffect(2, -2, Duration.Custom), SourceTappedCondition.getInstance(),§"target creature you control gets +2/-2 for as long as {this} remains tapped"), new ManaCostsImpl("{2}"));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetControlledCreaturePermanent());§this.addAbility(ability);§}§public AshnodsBattleGear(final AshnodsBattleGear card) {§super(card);§}§@Override§public AshnodsBattleGear copy() {§return new AshnodsBattleGear(this);§}§}§
public class CandelabraOfTawnos extends CardImpl {§private final UUID originalId;§public CandelabraOfTawnos(UUID ownerId) {§super(ownerId, 8, "Candelabra of Tawnos", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{1}");§this.expansionSetCode = "ATQ";§Effect effect = new UntapTargetEffect();§effect.setText("untap X target lands");§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new ManaCostsImpl("{X}"));§ability.addCost(new TapSourceCost());§originalId = ability.getOriginalId();§this.addAbility(ability);§}§@Override§public void adjustTargets(Ability ability, Game game) {§if (ability.getOriginalId().equals(originalId)){§int xValue = ability.getManaCostsToPay().getX();§ability.getTargets().clear();§ability.addTarget(new TargetLandPermanent(xValue, xValue, new FilterLandPermanent(), false));§}§}§public CandelabraOfTawnos(final CandelabraOfTawnos card) {§super(card);§this.originalId = card.originalId;§}§@Override§public CandelabraOfTawnos copy() {§return new CandelabraOfTawnos(this);§}§}§
public class CitanulDruid extends CardImpl {§private static final FilterArtifactSpell filter = new FilterArtifactSpell();§static {§filter.add(new ControllerPredicate(TargetController.OPPONENT));§}§public CitanulDruid(UUID ownerId) {§super(ownerId, 61, "Citanul Druid", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "ATQ";§this.subtype.add("Human");§this.subtype.add("Druid");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new SpellCastOpponentTriggeredAbility(new AddCountersSourceEffect(CounterType.P1P1.createInstance()), filter, false));§}§public CitanulDruid(final CitanulDruid card) {§super(card);§}§@Override§public CitanulDruid copy() {§return new CitanulDruid(this);§}§}§
public class ClayStatue extends CardImpl {§public ClayStatue(UUID ownerId) {§super(ownerId, 9, "Clay Statue", Rarity.COMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{4}");§this.expansionSetCode = "ATQ";§this.subtype.add("Golem");§this.power = new MageInt(3);§this.toughness = new MageInt(1);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new RegenerateSourceEffect(), new ManaCostsImpl("{2}")));§}§public ClayStatue(final ClayStatue card) {§super(card);§}§@Override§public ClayStatue copy() {§return new ClayStatue(this);§}§}§
public class DampingField extends CardImpl {§public DampingField(UUID ownerId) {§super(ownerId, 98, "Damping Field", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{W}");§this.expansionSetCode = "ATQ";§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new DampingFieldEffect()));§}§public DampingField(final DampingField card) {§super(card);§}§@Override§public DampingField copy() {§return new DampingField(this);§}§}§class DampingFieldEffect extends RestrictionUntapNotMoreThanEffect {§private static final FilterControlledPermanent filter = new FilterControlledArtifactPermanent("an artifact");§public DampingFieldEffect() {§super(Duration.WhileOnBattlefield, 1, filter);§staticText = "Players can't untap more than one artifact during their untap steps";§}§public DampingFieldEffect(final DampingFieldEffect effect) {§super(effect);§}§@Override§public boolean applies(Player player, Ability source, Game game) {§return true;§}§@Override§public DampingFieldEffect copy() {§return new DampingFieldEffect(this);§}§}§
public class DrafnasRestoration extends CardImpl {§public DrafnasRestoration(UUID ownerId) {§super(ownerId, 52, "Drafna's Restoration", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{U}");§this.expansionSetCode = "ATQ";§this.getSpellAbility().addEffect(new DrafnasRestorationEffect());§this.getSpellAbility().addTarget(new TargetPlayer());§this.getSpellAbility().addTarget(new DrafnasRestorationTarget());§}§public DrafnasRestoration(final DrafnasRestoration card) {§super(card);§}§@Override§public DrafnasRestoration copy() {§return new DrafnasRestoration(this);§}§}§class DrafnasRestorationTarget extends TargetCardInGraveyard {§DrafnasRestorationTarget() {§super(0, Integer.MAX_VALUE, new FilterArtifactCard("any number of artifact cards from that player's graveyard"));§}§DrafnasRestorationTarget(final DrafnasRestorationTarget target) {§super(target);§}§@Override§public boolean canTarget(UUID id, Ability source, Game game) {§Player targetPlayer = game.getPlayer(source.getFirstTarget());§return targetPlayer != null && targetPlayer.getGraveyard().contains(id) && super.canTarget(id, source, game);§}§@Override§public Set<UUID> possibleTargets(UUID sourceId, UUID sourceControllerId, Game game) {§Set<UUID> possibleTargets = new HashSet<>();§MageObject object = game.getObject(sourceId);§if (object != null && object instanceof StackObject) {§Player targetPlayer = game.getPlayer(((StackObject) object).getStackAbility().getFirstTarget());§if (targetPlayer != null) {§for (Card card : targetPlayer.getGraveyard().getCards(filter, sourceId, sourceControllerId, game)) {§if (!game.replaceEvent(GameEvent.getEvent(GameEvent.EventType.TARGET, card.getId(), sourceId, sourceControllerId))) {§possibleTargets.add(card.getId());§}§}§}§}§return possibleTargets;§}§@Override§public DrafnasRestorationTarget copy() {§return new DrafnasRestorationTarget(this);§}§}§class DrafnasRestorationEffect extends OneShotEffect {§DrafnasRestorationEffect() {§super(Outcome.Benefit);§this.staticText = "Return any number of target artifact cards from target player's graveyard to the top of his or her library in any order";§}§DrafnasRestorationEffect(final DrafnasRestorationEffect effect) {§super(effect);§}§@Override§public DrafnasRestorationEffect copy() {§return new DrafnasRestorationEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Cards cards = new CardsImpl(source.getTargets().get(1).getTargets());§controller.putCardsOnTopOfLibrary(cards, game, source, true);§return true;§}§return false;§}§}§
public class EnergyFlux extends CardImpl {§public EnergyFlux(UUID ownerId) {§super(ownerId, 53, "Energy Flux", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{U}");§this.expansionSetCode = "ATQ";§this.addAbility(new SimpleStaticAbility(§Zone.BATTLEFIELD,§new GainAbilityAllEffect(§new BeginningOfUpkeepTriggeredAbility(§new SacrificeSourceUnlessPaysEffect(new GenericManaCost(2)),§TargetController.YOU,§false),§Duration.WhileOnBattlefield,§new FilterArtifactPermanent(),§"All artifacts have \"At the beginning of your upkeep, sacrifice this artifact unless you pay {2}.\"")));§}§public EnergyFlux(final EnergyFlux card) {§super(card);§}§@Override§public EnergyFlux copy() {§return new EnergyFlux(this);§}§}§
public class GateToPhyrexia extends CardImpl {§public GateToPhyrexia(UUID ownerId) {§super(ownerId, 46, "Gate to Phyrexia", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{B}{B}");§this.expansionSetCode = "ATQ";§Ability ability = new GateToPhyrexiaAbility(new DestroyTargetEffect(), new SacrificeTargetCost(new TargetControlledCreaturePermanent()));§ability.addTarget(new TargetArtifactPermanent());§this.addAbility(ability);§}§public GateToPhyrexia(final GateToPhyrexia card) {§super(card);§}§@Override§public GateToPhyrexia copy() {§return new GateToPhyrexia(this);§}§}§class GateToPhyrexiaAbility extends LimitedTimesPerTurnActivatedAbility {§public GateToPhyrexiaAbility(Effect effect, Cost cost) {§super(Zone.BATTLEFIELD, effect, cost);§}§public GateToPhyrexiaAbility(final GateToPhyrexiaAbility ability) {§super(ability);§}§@Override§public GateToPhyrexiaAbility copy() {§return new GateToPhyrexiaAbility(this);§}§@Override§public boolean canActivate(UUID playerId, Game game) {§if (!game.getActivePlayerId().equals(controllerId) || !PhaseStep.UPKEEP.equals(game.getStep().getType())) {§return false;§}§return super.canActivate(playerId, game);§}§@Override§public String getRule() {§return "Sacrifice a creature: Destroy target artifact. Activate this ability only during your upkeep and only once each turn.";§}§}§
public class IvoryTower extends CardImpl {§public IvoryTower(UUID ownerId) {§super(ownerId, 18, "Ivory Tower", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{1}");§this.expansionSetCode = "ATQ";§this.addAbility(new BeginningOfUpkeepTriggeredAbility(new IvoryTowerEffect(), TargetController.YOU, false));§}§public IvoryTower(final IvoryTower card) {§super(card);§}§@Override§public IvoryTower copy() {§return new IvoryTower(this);§}§}§class IvoryTowerEffect extends OneShotEffect {§public IvoryTowerEffect() {§super(Outcome.GainLife);§this.staticText = "you gain X life, where X is the number of cards in your hand minus 4.";§}§public IvoryTowerEffect(IvoryTowerEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if(player != null) {§int amount = player.getHand().size() - 4;§if(amount > 0) {§player.gainLife(amount, game);§}§return true;§}§return false;§}§@Override§public IvoryTowerEffect copy() {§return new IvoryTowerEffect(this);§}§}§
public class Mightstone extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("attacking creatures");§static {§filter.add(new AttackingPredicate());§}§public Mightstone(UUID ownerId) {§super(ownerId, 20, "Mightstone", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{4}");§this.expansionSetCode = "ATQ";§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostAllEffect( 1, 0, Duration.WhileOnBattlefield, filter, false)));§}§public Mightstone(final Mightstone card) {§super(card);§}§@Override§public Mightstone copy() {§return new Mightstone(this);§}§}§
public class OrcishMechanics extends CardImpl {§public OrcishMechanics(UUID ownerId) {§super(ownerId, 92, "Orcish Mechanics", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "ATQ";§this.subtype.add("Orc");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(2), new TapSourceCost());§ability.addCost(new SacrificeTargetCost(new TargetControlledPermanent(new FilterControlledArtifactPermanent("an artifact"))));§ability.addTarget(new TargetCreatureOrPlayer());§this.addAbility(ability);§}§public OrcishMechanics(final OrcishMechanics card) {§super(card);§}§@Override§public OrcishMechanics copy() {§return new OrcishMechanics(this);§}§}§
public class PhyrexianGremlins extends CardImpl {§public PhyrexianGremlins(UUID ownerId) {§super(ownerId, 48, "Phyrexian Gremlins", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{B}");§this.expansionSetCode = "ATQ";§this.subtype.add("Gremlin");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new SkipUntapOptionalAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new TapTargetEffect(), new TapSourceCost());§ability.addTarget(new TargetArtifactPermanent());§ability.addEffect(new DontUntapAsLongAsSourceTappedEffect());§this.addAbility(ability);§}§public PhyrexianGremlins(final PhyrexianGremlins card) {§super(card);§}§@Override§public PhyrexianGremlins copy() {§return new PhyrexianGremlins(this);§}§}§
public class PowerArtifact extends CardImpl {§public PowerArtifact(UUID ownerId) {§super(ownerId, 55, "Power Artifact", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{U}{U}");§this.expansionSetCode = "ATQ";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetArtifactPermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.Benefit));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new PowerArtifactCostModificationEffect()));§}§public PowerArtifact(final PowerArtifact card) {§super(card);§}§@Override§public PowerArtifact copy() {§return new PowerArtifact(this);§}§}§class PowerArtifactCostModificationEffect extends CostModificationEffectImpl {§PowerArtifactCostModificationEffect() {§super(Duration.WhileOnBattlefield, Outcome.Benefit, CostModificationType.REDUCE_COST);§staticText = "The activation cost of target artifact is reduced by {2}. If this would reduce target artifact's activation cost below {1}, target artifact's activation cost becomes {1}. Power artifact has no effect on artifacts that have no activation cost or whose activation cost is {0}.";§}§PowerArtifactCostModificationEffect(PowerArtifactCostModificationEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source, Ability abilityToModify) {§Player controller = game.getPlayer(abilityToModify.getControllerId());§if (controller != null) {§Mana mana = abilityToModify.getManaCostsToPay().getMana();§int reduce = mana.getGeneric();§if (reduce > 0 && mana.count() == mana.getGeneric()) {§reduce--;§}§if (reduce > 2) {§reduce = 2;§}§CardUtil.reduceCost(abilityToModify, reduce);§}§return true;§}§@Override§public boolean applies(Ability abilityToModify, Ability source, Game game) {§Permanent artifact = game.getPermanent(abilityToModify.getSourceId());§if (artifact != null && artifact.getAttachments().contains(source.getSourceId())) {§if (abilityToModify.getAbilityType().equals(AbilityType.ACTIVATED)§|| (abilityToModify.getAbilityType().equals(AbilityType.MANA) && (abilityToModify instanceof ActivatedAbility))) {§return true;§}§}§return false;§}§@Override§public PowerArtifactCostModificationEffect copy() {§return new PowerArtifactCostModificationEffect(this);§}§}§
public class SageOfLatNam extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("an Artifact");§static§{§filter.add(new CardTypePredicate(CardType.ARTIFACT));§}§public SageOfLatNam(UUID ownerId) {§super(ownerId, 57, "Sage of Lat-Nam", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{U}");§this.expansionSetCode = "ATQ";§this.subtype.add("Human");§this.subtype.add("Artificer");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DrawCardSourceControllerEffect(1), new TapSourceCost());§ability.addCost(new SacrificeTargetCost(new TargetControlledPermanent(filter)));§this.addAbility(ability);§}§public SageOfLatNam(final SageOfLatNam card) {§super(card);§}§@Override§public SageOfLatNam copy() {§return new SageOfLatNam(this);§}§}§
public class TransmuteArtifact extends CardImpl {§public TransmuteArtifact(UUID ownerId) {§super(ownerId, 58, "Transmute Artifact", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{U}{U}");§this.expansionSetCode = "ATQ";§this.getSpellAbility().addEffect(new TransmuteArtifactEffect());§}§public TransmuteArtifact(final TransmuteArtifact card) {§super(card);§}§@Override§public TransmuteArtifact copy() {§return new TransmuteArtifact(this);§}§}§class TransmuteArtifactEffect extends SearchEffect {§public TransmuteArtifactEffect() {§super(new TargetCardInLibrary(new FilterArtifactCard()), Outcome.PutCardInPlay);§staticText = "Sacrifice an artifact. If you do, search your library for an artifact card. If that card's converted mana cost is less than or equal to the sacrificed artifact's converted mana cost, put it onto the battlefield. If it's greater, you may pay {X}, where X is the difference. If you do, put it onto the battlefield. If you don't, put it into its owner's graveyard. Then shuffle your library";§}§public TransmuteArtifactEffect(final TransmuteArtifactEffect effect) {§super(effect);§}§@Override§public TransmuteArtifactEffect copy() {§return new TransmuteArtifactEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller == null) {§return false;§}§int convertedManaCost = 0;§boolean sacrifice = false;§TargetControlledPermanent targetArtifact = new TargetControlledPermanent(new FilterControlledArtifactPermanent());§if (controller.chooseTarget(Outcome.Sacrifice, targetArtifact, source, game)) {§Permanent permanent = game.getPermanent(targetArtifact.getFirstTarget());§if (permanent != null) {§convertedManaCost = permanent.getManaCost().convertedManaCost();§sacrifice = permanent.sacrifice(source.getSourceId(), game);§}§} else {§return true;§}§if (sacrifice && controller.searchLibrary(target, game)) {§if (target.getTargets().size() > 0) {§for (UUID cardId : target.getTargets()) {§Card card = controller.getLibrary().getCard(cardId, game);§if (card != null) {§if (card.getManaCost().convertedManaCost() <= convertedManaCost) {§controller.moveCards(card, Zone.BATTLEFIELD, source, game);§} else {§GenericManaCost cost = new GenericManaCost(card.getManaCost().convertedManaCost() - convertedManaCost);§if (cost.pay(source, game, source.getSourceId(), source.getControllerId(), false)) {§controller.moveCards(card, Zone.BATTLEFIELD, source, game);§} else {§controller.moveCards(card, Zone.GRAVEYARD, source, game);§}§}§}§}§}§controller.shuffleLibrary(game);§return true;§}§controller.shuffleLibrary(game);§return false;§}§}§
public class Weakstone extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("attacking creatures");§static {§filter.add(new AttackingPredicate());§}§public Weakstone(UUID ownerId) {§super(ownerId, 43, "Weakstone", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{4}");§this.expansionSetCode = "ATQ";§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostAllEffect( -1, 0, Duration.WhileOnBattlefield, filter, false)));§}§public Weakstone(final Weakstone card) {§super(card);§}§@Override§public Weakstone copy() {§return new Weakstone(this);§}§}§
public class AEtherMutation extends CardImpl {§public AEtherMutation(UUID ownerId) {§super(ownerId, 91, "AEther Mutation", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{3}{G}{U}");§this.expansionSetCode = "APC";§this.getSpellAbility().addEffect(new ReturnToHandTargetEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.getSpellAbility().addEffect(new CreateTokenEffect(new SaprolingToken(), new TargetConvertedManaCost()));§}§public AEtherMutation(final AEtherMutation card) {§super(card);§}§@Override§public AEtherMutation copy() {§return new AEtherMutation(this);§}§}§
public class AnaDisciple extends CardImpl {§public AnaDisciple(UUID ownerId) {§super(ownerId, 73, "Ana Disciple", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{G}");§this.expansionSetCode = "APC";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability firstAbility = new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilityTargetEffect(FlyingAbility.getInstance(), Duration.EndOfTurn), new ColoredManaCost(ColoredManaSymbol.U));§firstAbility.addCost(new TapSourceCost());§firstAbility.addTarget(new TargetCreaturePermanent());§this.addAbility(firstAbility);§Ability secondAbility = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostTargetEffect(-2, 0, Duration.EndOfTurn), new ColoredManaCost(ColoredManaSymbol.B));§secondAbility.addCost(new TapSourceCost());§secondAbility.addTarget(new TargetCreaturePermanent());§this.addAbility(secondAbility);§}§public AnaDisciple(final AnaDisciple card) {§super(card);§}§@Override§public AnaDisciple copy() {§return new AnaDisciple(this);§}§}§
public class Anavolver extends CardImpl {§public Anavolver(UUID ownerId) {§super(ownerId, 75, "Anavolver", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{G}");§this.expansionSetCode = "APC";§this.subtype.add("Volver");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§KickerAbility kickerAbility = new KickerAbility("{1}{U}");§kickerAbility.addKickerCost("{B}");§this.addAbility(kickerAbility);§EntersBattlefieldAbility ability1 = new EntersBattlefieldAbility(§new AddCountersSourceEffect(CounterType.P1P1.createInstance(2),false),§new KickedCostCondition("{1}{U}"), "If {this} was kicked with its {1}{U} kicker, it enters the battlefield with two +1/+1 counters on it and with flying.",§"{this} enters the battlefield with two +1/+1 counters on it and with flying");§((EntersBattlefieldEffect)ability1.getEffects().get(0)).addEffect(new GainAbilitySourceEffect(FlyingAbility.getInstance(), Duration.WhileOnBattlefield));§this.addAbility(ability1);§EntersBattlefieldAbility ability2 = new EntersBattlefieldAbility(§new AddCountersSourceEffect(CounterType.P1P1.createInstance(1),false), new KickedCostCondition("{B}"),§"If {this} was kicked with its {B} kicker, it enters the battlefield with a +1/+1 counter on it and with \"Pay 3 life: Regenerate Anavolver.\"",§"{this} enters the battlefield with a +1/+1 counter on it and with \"Pay 3 life: Regenerate Anavolver.\"");§((EntersBattlefieldEffect)ability2.getEffects().get(0)).addEffect(new GainAbilitySourceEffect(new SimpleActivatedAbility(Zone.BATTLEFIELD, new RegenerateSourceEffect(), new PayLifeCost(3)), Duration.WhileOnBattlefield));§this.addAbility(ability2);§}§public Anavolver(final Anavolver card) {§super(card);§}§@Override§public Anavolver copy() {§return new Anavolver(this);§}§}§
public class AngelfireCrusader extends CardImpl {§public AngelfireCrusader(UUID ownerId) {§super(ownerId, 1, "Angelfire Crusader", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{W}");§this.expansionSetCode = "APC";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.subtype.add("Knight");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(1, 0, Duration.EndOfTurn), new ColoredManaCost(ColoredManaSymbol.R)));§}§public AngelfireCrusader(final AngelfireCrusader card) {§super(card);§}§@Override§public AngelfireCrusader copy() {§return new AngelfireCrusader(this);§}§}§
public class BattlefieldForge extends CardImpl {§public BattlefieldForge(UUID ownerId) {§super(ownerId, 139, "Battlefield Forge", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "APC";§this.addAbility(new ColorlessManaAbility());§Ability redManaAbility = new SimpleManaAbility(Zone.BATTLEFIELD, Mana.RedMana(1), new TapSourceCost());§redManaAbility.addEffect(new DamageControllerEffect(1));§this.addAbility(redManaAbility);§Ability whiteManaAbility = new SimpleManaAbility(Zone.BATTLEFIELD, Mana.WhiteMana(1), new TapSourceCost());§whiteManaAbility.addEffect(new DamageControllerEffect(1));§this.addAbility(whiteManaAbility);§}§public BattlefieldForge(final BattlefieldForge card) {§super(card);§}§@Override§public BattlefieldForge copy() {§return new BattlefieldForge(this);§}§}§
public class BloodfireColossus extends CardImpl {§public BloodfireColossus(UUID ownerId) {§super(ownerId, 55, "Bloodfire Colossus", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{6}{R}{R}");§this.expansionSetCode = "APC";§this.subtype.add("Giant");§this.power = new MageInt(6);§this.toughness = new MageInt(6);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageEverythingEffect(6), new ColoredManaCost(ColoredManaSymbol.R));§ability.addCost(new SacrificeSourceCost());§this.addAbility(ability);§}§public BloodfireColossus(final BloodfireColossus card) {§super(card);§}§@Override§public BloodfireColossus copy() {§return new BloodfireColossus(this);§}§}§
public class BloodfireDwarf extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature without flying");§static {§filter.add(Predicates.not(new AbilityPredicate(FlyingAbility.class)));§}§public BloodfireDwarf(UUID ownerId) {§super(ownerId, 56, "Bloodfire Dwarf", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{R}");§this.expansionSetCode = "APC";§this.subtype.add("Dwarf");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageAllEffect(1, filter), new ColoredManaCost(ColoredManaSymbol.R));§ability.addCost(new SacrificeSourceCost());§this.addAbility(ability);§}§public BloodfireDwarf(final BloodfireDwarf card) {§super(card);§}§@Override§public BloodfireDwarf copy() {§return new BloodfireDwarf(this);§}§}§
public class BloodfireKavu extends CardImpl {§public BloodfireKavu(UUID ownerId) {§super(ownerId, 58, "Bloodfire Kavu", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{R}{R}");§this.expansionSetCode = "APC";§this.subtype.add("Kavu");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageAllEffect(2, new FilterCreaturePermanent()), new ColoredManaCost(ColoredManaSymbol.R));§ability.addCost(new SacrificeSourceCost());§this.addAbility(ability);§}§public BloodfireKavu(final BloodfireKavu card) {§super(card);§}§@Override§public BloodfireKavu copy() {§return new BloodfireKavu(this);§}§}§
public class BogGnarr extends CardImpl {§private static final FilterSpell filter = new FilterSpell("a black spell");§static {§filter.add(new ColorPredicate(ObjectColor.BLACK));§}§public BogGnarr(UUID ownerId) {§super(ownerId, 76, "Bog Gnarr", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{G}");§this.expansionSetCode = "APC";§this.subtype.add("Beast");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new SpellCastAllTriggeredAbility(new BoostSourceEffect(2, 2, Duration.EndOfTurn), filter, false));§}§public BogGnarr(final BogGnarr card) {§super(card);§}§@Override§public BogGnarr copy() {§return new BogGnarr(this);§}§}§
public class BrassHerald extends CardImpl {§public BrassHerald(UUID ownerId) {§super(ownerId, 133, "Brass Herald", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{6}");§this.expansionSetCode = "APC";§this.subtype.add("Golem");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new AsEntersBattlefieldAbility(new ChooseCreatureTypeEffect(Outcome.BoostCreature)));§FilterCard filter = new FilterCard("creature cards of the chosen type");§filter.add(new ChosenSubtypePredicate(this.getId()));§this.addAbility(new EntersBattlefieldTriggeredAbility(new EnvoyEffect(filter, 4)));§FilterCreaturePermanent filter2 = new FilterCreaturePermanent("creatures of the chosen type");§filter2.add(new ChosenSubtypePredicate(this.getId()));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostAllEffect(1, 1, Duration.WhileOnBattlefield,§filter2, false)));§}§public BrassHerald(final BrassHerald card) {§super(card);§}§@Override§public BrassHerald copy() {§return new BrassHerald(this);§}§}§
public class CavesOfKoilos extends CardImpl {§public CavesOfKoilos(UUID ownerId) {§super(ownerId, 140, "Caves of Koilos", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "APC";§this.addAbility(new ColorlessManaAbility());§Ability whiteManaAbility = new SimpleManaAbility(Zone.BATTLEFIELD, Mana.WhiteMana(1), new TapSourceCost());§whiteManaAbility.addEffect(new DamageControllerEffect(1));§this.addAbility(whiteManaAbility);§Ability blackManaAbility = new SimpleManaAbility(Zone.BATTLEFIELD, Mana.BlackMana(1), new TapSourceCost());§blackManaAbility.addEffect(new DamageControllerEffect(1));§this.addAbility(blackManaAbility);§}§public CavesOfKoilos(final CavesOfKoilos card) {§super(card);§}§@Override§public CavesOfKoilos copy() {§return new CavesOfKoilos(this);§}§}§
public class CetaDisciple extends CardImpl {§public CetaDisciple(UUID ownerId) {§super(ownerId, 19, "Ceta Disciple", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{U}");§this.expansionSetCode = "APC";§this.subtype.add("Merfolk");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability firstAbility = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostTargetEffect(2, 0, Duration.EndOfTurn), new ColoredManaCost(ColoredManaSymbol.R));§firstAbility.addCost(new TapSourceCost());§firstAbility.addTarget(new TargetCreaturePermanent());§this.addAbility(firstAbility);§Ability secondAbility = new AnyColorManaAbility(new ColoredManaCost(ColoredManaSymbol.G));§secondAbility.addCost(new TapSourceCost());§this.addAbility(secondAbility);§}§public CetaDisciple(final CetaDisciple card) {§super(card);§}§@Override§public CetaDisciple copy() {§return new CetaDisciple(this);§}§}§
public class Cetavolver extends CardImpl {§public Cetavolver(UUID ownerId) {§super(ownerId, 21, "Cetavolver", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{U}");§this.expansionSetCode = "APC";§this.subtype.add("Volver");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§KickerAbility kickerAbility = new KickerAbility("{1}{R}");§kickerAbility.addKickerCost("{G}");§this.addAbility(kickerAbility);§EntersBattlefieldAbility ability1 = new EntersBattlefieldAbility(§new AddCountersSourceEffect(CounterType.P1P1.createInstance(2),false),§new KickedCostCondition("{1}{R}"), "If Cetavolver was kicked with its {1}{R} kicker, it enters the battlefield with two +1/+1 counters on it and with first strike.",§"{this} enters the battlefield with two +1/+1 counters on it and with first strike");§((EntersBattlefieldEffect)ability1.getEffects().get(0)).addEffect(new GainAbilitySourceEffect(FirstStrikeAbility.getInstance(), Duration.WhileOnBattlefield));§this.addAbility(ability1);§EntersBattlefieldAbility ability2 = new EntersBattlefieldAbility(§new AddCountersSourceEffect(CounterType.P1P1.createInstance(1),false), new KickedCostCondition("{G}"),§"If Cetavolver was kicked with its {G} kicker, it enters the battlefield with a +1/+1 counter on it and with trample.",§"{this} enters the battlefield with a +1/+1 counter on it and with trample");§((EntersBattlefieldEffect)ability2.getEffects().get(0)).addEffect(new GainAbilitySourceEffect(TrampleAbility.getInstance(), Duration.WhileOnBattlefield));§this.addAbility(ability2);§}§public Cetavolver(final Cetavolver card) {§super(card);§}§@Override§public Cetavolver copy() {§return new Cetavolver(this);§}§}§
public class CoastalDrake extends CardImpl {§public CoastalDrake(UUID ownerId) {§super(ownerId, 22, "Coastal Drake", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{U}");§this.expansionSetCode = "APC";§this.subtype.add("Drake");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ReturnToHandTargetEffect(true), new ManaCostsImpl("{1}{U}"));§ability.addTarget(new TargetCreaturePermanent(new FilterCreaturePermanent("Kavu", "Kavu")));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§}§public CoastalDrake(final CoastalDrake card) {§super(card);§}§@Override§public CoastalDrake copy() {§return new CoastalDrake(this);§}§}§
public class ConsumeStrength extends CardImpl {§public ConsumeStrength(UUID ownerId) {§super(ownerId, 93, "Consume Strength", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{B}{G}");§this.expansionSetCode = "APC";§this.getSpellAbility().addEffect(new ConsumeStrengthEffect());§FilterCreaturePermanent filter1 = new FilterCreaturePermanent("creature to get +2/+2");§TargetCreaturePermanent target1 = new TargetCreaturePermanent(filter1);§target1.setTargetTag(1);§this.getSpellAbility().addTarget(target1);§FilterCreaturePermanent filter2 = new FilterCreaturePermanent("another creature to get -2/-2");§filter2.add(new AnotherTargetPredicate(2));§TargetCreaturePermanent target2 = new TargetCreaturePermanent(filter2);§target2.setTargetTag(2);§this.getSpellAbility().addTarget(target2);§}§public ConsumeStrength(final ConsumeStrength card) {§super(card);§}§@Override§public ConsumeStrength copy() {§return new ConsumeStrength(this);§}§}§class ConsumeStrengthEffect extends ContinuousEffectImpl {§public ConsumeStrengthEffect() {§super(Duration.EndOfTurn, Layer.PTChangingEffects_7, SubLayer.ModifyPT_7c, Outcome.BoostCreature);§this.staticText = "Target creature gets +2/+2 until end of turn. Another target creature gets -2/-2 until end of turn";§}§public ConsumeStrengthEffect(final ConsumeStrengthEffect effect) {§super(effect);§}§@Override§public ConsumeStrengthEffect copy() {§return new ConsumeStrengthEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getPermanent(source.getFirstTarget());§if (permanent != null) {§permanent.addPower(2);§permanent.addToughness(2);§}§permanent = game.getPermanent(source.getTargets().get(1).getFirstTarget());§if (permanent != null) {§permanent.addPower(-2);§permanent.addToughness(-2);§}§return true;§}§}§
public class DeathGrasp extends CardImpl {§public DeathGrasp (UUID ownerId) {§super(ownerId, 95, "Death Grasp", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{X}{W}{B}");§this.expansionSetCode = "APC";§this.getSpellAbility().addEffect(new DamageTargetEffect(new ManacostVariableValue()));§this.getSpellAbility().addEffect(new GainLifeEffect(new ManacostVariableValue()));§this.getSpellAbility().addTarget(new TargetCreatureOrPlayer());§}§public DeathGrasp (final DeathGrasp card) {§super(card);§}§@Override§public DeathGrasp copy() {§return new DeathGrasp(this);§}§}§
public class DeathMutation extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("nonblack creature");§static {§filter.add(Predicates.not(new ColorPredicate(ObjectColor.BLACK)));§}§public DeathMutation(UUID ownerId) {§super(ownerId, 96, "Death Mutation", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{6}{B}{G}");§this.expansionSetCode = "APC";§this.getSpellAbility().addEffect(new DestroyTargetEffect(true));§this.getSpellAbility().addTarget(new TargetPermanent(filter));§this.getSpellAbility().addEffect(new CreateTokenEffect(new SaprolingToken(), new TargetConvertedManaCost()));§}§public DeathMutation(final DeathMutation card) {§super(card);§}§@Override§public DeathMutation copy() {§return new DeathMutation(this);§}§}§
public class DegaDisciple extends CardImpl {§public DegaDisciple(UUID ownerId) {§super(ownerId, 4, "Dega Disciple", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{W}");§this.expansionSetCode = "APC";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability firstAbility = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostTargetEffect(-2, 0, Duration.EndOfTurn), new ColoredManaCost(ColoredManaSymbol.B));§firstAbility.addCost(new TapSourceCost());§firstAbility.addTarget(new TargetCreaturePermanent());§this.addAbility(firstAbility);§Ability secondAbility = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostTargetEffect(2, 0, Duration.EndOfTurn), new ColoredManaCost(ColoredManaSymbol.R));§secondAbility.addCost(new TapSourceCost());§secondAbility.addTarget(new TargetCreaturePermanent());§this.addAbility(secondAbility);§}§public DegaDisciple(final DegaDisciple card) {§super(card);§}§@Override§public DegaDisciple copy() {§return new DegaDisciple(this);§}§}§
public class Degavolver extends CardImpl {§public Degavolver(UUID ownerId) {§super(ownerId, 6, "Degavolver", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "APC";§this.subtype.add("Volver");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§KickerAbility kickerAbility = new KickerAbility("{1}{B}");§kickerAbility.addKickerCost("{R}");§this.addAbility(kickerAbility);§EntersBattlefieldAbility ability1 = new EntersBattlefieldAbility(§new AddCountersSourceEffect(CounterType.P1P1.createInstance(2),false),§new KickedCostCondition("{1}{B}"), "If Degavolver was kicked with its {1}{B} kicker, it enters the battlefield with two +1/+1 counters on it and with \"Pay 3 life: Regenerate Degavolver.\"",§"{this} enters the battlefield with two +1/+1 counters on it and with \"Pay 3 life: Regenerate Degavolver.\"");§((EntersBattlefieldEffect)ability1.getEffects().get(0)).addEffect(new GainAbilitySourceEffect(new SimpleActivatedAbility(Zone.BATTLEFIELD, new RegenerateSourceEffect(), new PayLifeCost(3)), Duration.WhileOnBattlefield));§this.addAbility(ability1);§EntersBattlefieldAbility ability2 = new EntersBattlefieldAbility(§new AddCountersSourceEffect(CounterType.P1P1.createInstance(1),false), new KickedCostCondition("{R}"),§"If Degavolver was kicked with its {R} kicker, it enters the battlefield with a +1/+1 counter on it and with first strike.",§"{this} enters the battlefield with a +1/+1 counter on it and with first strike");§((EntersBattlefieldEffect)ability2.getEffects().get(0)).addEffect(new GainAbilitySourceEffect(FirstStrikeAbility.getInstance(), Duration.WhileOnBattlefield));§this.addAbility(ability2);§}§public Degavolver(final Degavolver card) {§super(card);§}§@Override§public Degavolver copy() {§return new Degavolver(this);§}§}§
public class DesolationAngel extends CardImpl {§private static final FilterLandPermanent filter = new FilterLandPermanent("lands");§private static final FilterLandPermanent filter2 = new FilterLandPermanent("lands you control");§static {§filter2.add(new ControllerPredicate(TargetController.YOU));§}§public DesolationAngel(UUID ownerId) {§super(ownerId, 38, "Desolation Angel", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{B}{B}");§this.expansionSetCode = "APC";§this.subtype.add("Angel");§this.power = new MageInt(5);§this.toughness = new MageInt(4);§this.addAbility(new KickerAbility("{W}{W}"));§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new EntersBattlefieldTriggeredAbility(new ConditionalOneShotEffect(new DestroyAllEffect(filter),§new DestroyAllEffect(filter2), KickedCondition.getInstance(), "destroy all lands you control. If it was kicked, destroy all lands instead.")));§}§public DesolationAngel(final DesolationAngel card) {§super(card);§}§@Override§public DesolationAngel copy() {§return new DesolationAngel(this);§}§}§
public class DesolationGiant extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("other creatures");§private static final FilterCreaturePermanent filter2 = new FilterCreaturePermanent("other creatures you control");§static {§filter.add(new AnotherPredicate());§filter2.add(new AnotherPredicate());§filter2.add(new ControllerPredicate(TargetController.YOU));§}§public DesolationGiant(UUID ownerId) {§super(ownerId, 59, "Desolation Giant", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{R}{R}");§this.expansionSetCode = "APC";§this.subtype.add("Giant");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new KickerAbility("{W}{W}"));§this.addAbility(new EntersBattlefieldTriggeredAbility(new ConditionalOneShotEffect(new DestroyAllEffect(filter),§new DestroyAllEffect(filter2), KickedCondition.getInstance(), "destroy all other creatures you control. If it was kicked, destroy all other creatures instead.")));§}§public DesolationGiant(final DesolationGiant card) {§super(card);§}§@Override§public DesolationGiant copy() {§return new DesolationGiant(this);§}§}§
public class DiversionaryTactics extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("untapped creatures you control");§static {§filter.add(Predicates.not(new TappedPredicate()));§}§public DiversionaryTactics(UUID ownerId) {§super(ownerId, 7, "Diversionary Tactics", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{3}{W}");§this.expansionSetCode = "APC";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new TapTargetEffect(), new TapTargetCost(new TargetControlledCreaturePermanent(2, 2, filter, false)));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public DiversionaryTactics(final DiversionaryTactics card) {§super(card);§}§@Override§public DiversionaryTactics copy() {§return new DiversionaryTactics(this);§}§}§
public class DivineLight extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creatures you control");§static {§filter.add(new ControllerPredicate(TargetController.YOU));§}§public DivineLight(UUID ownerId) {§super(ownerId, 8, "Divine Light", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{W}");§this.expansionSetCode = "APC";§this.getSpellAbility().addEffect(new PreventAllDamageToAllEffect(Duration.EndOfTurn, filter));§}§public DivineLight(final DivineLight card) {§super(card);§}§@Override§public DivineLight copy() {§return new DivineLight(this);§}§}§
public class Dodecapod extends CardImpl {§public Dodecapod(UUID ownerId) {§super(ownerId, 134, "Dodecapod", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{4}");§this.expansionSetCode = "APC";§this.subtype.add("Golem");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new SimpleStaticAbility(Zone.HAND, new DodecapodEffect()));§}§public Dodecapod(final Dodecapod card) {§super(card);§}§@Override§public Dodecapod copy() {§return new Dodecapod(this);§}§}§class DodecapodEffect extends DiscardOntoBattlefieldEffect {§public DodecapodEffect() {§super();§staticText = "If a spell or ability an opponent controls causes you to discard {this}, put it onto the battlefield with two +1/+1 counters on it instead of putting it into your graveyard";§}§public DodecapodEffect(final DodecapodEffect effect) {§super(effect);§}§@Override§public DodecapodEffect copy() {§return new DodecapodEffect(this);§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§if(super.replaceEvent(event, source, game)) {§new AddCountersSourceEffect(CounterType.P1P1.createInstance(2)).apply(game, source);§return true;§}§return false;§}§}§
public class DragonArch extends CardImpl {§private static final FilterCreatureCard filter = new FilterCreatureCard("a multicolored creature card");§static {§filter.add(new MulticoloredPredicate());§}§public DragonArch(UUID ownerId) {§super(ownerId, 135, "Dragon Arch", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{5}");§this.expansionSetCode = "APC";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new PutPermanentOnBattlefieldEffect(filter),§new ManaCostsImpl("{2}"));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§}§public DragonArch(final DragonArch card) {§super(card);§}§@Override§public DragonArch copy() {§return new DragonArch(this);§}§}§
public class DwarvenLandslide extends CardImpl {§public DwarvenLandslide(UUID ownerId) {§super(ownerId, 60, "Dwarven Landslide", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{3}{R}");§this.expansionSetCode = "APC";§Costs<Cost> kickerCosts = new CostsImpl<>();§kickerCosts.add(new ManaCostsImpl<>("{2}{R}"));§kickerCosts.add(new SacrificeTargetCost(new TargetControlledPermanent(new FilterControlledLandPermanent("a land"))));§this.addAbility(new KickerAbility(kickerCosts));§getSpellAbility().addEffect(new DestroyTargetEffect("Destroy target land. If {this} was kicked, destroy another target land"));§getSpellAbility().addTarget(new TargetLandPermanent());§}§public DwarvenLandslide(final DwarvenLandslide card) {§super(card);§}§@Override§public void adjustTargets(Ability ability, Game game) {§if (ability instanceof SpellAbility) {§if (KickedCondition.getInstance().apply(game, ability)) {§getSpellAbility().addTarget(new TargetLandPermanent(new FilterLandPermanent("land (Kicker)")));§}§}§}§@Override§public DwarvenLandslide copy() {§return new DwarvenLandslide(this);§}§}§
public class DwarvenPatrol extends CardImpl {§private static final FilterSpell filter = new FilterSpell("nonred spell");§static {§filter.add(Predicates.not(new ColorPredicate(ObjectColor.RED)));§}§public DwarvenPatrol(UUID ownerId) {§super(ownerId, 61, "Dwarven Patrol", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "APC";§this.subtype.add("Dwarf");§this.power = new MageInt(4);§this.toughness = new MageInt(2);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new DontUntapInControllersUntapStepSourceEffect()));§this.addAbility(new SpellCastControllerTriggeredAbility(new UntapSourceEffect(), filter, false));§}§public DwarvenPatrol(final DwarvenPatrol card) {§super(card);§}§@Override§public DwarvenPatrol copy() {§return new DwarvenPatrol(this);§}§}§
public class EbonyTreefolk extends CardImpl {§public EbonyTreefolk(UUID ownerId) {§super(ownerId, 97, "Ebony Treefolk", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{B}{G}");§this.expansionSetCode = "APC";§this.subtype.add("Treefolk");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(1, 1, Duration.EndOfTurn), new ManaCostsImpl("{B}{G}")));§}§public EbonyTreefolk(final EbonyTreefolk card) {§super(card);§}§@Override§public EbonyTreefolk copy() {§return new EbonyTreefolk(this);§}§}§
public class EnlistmentOfficer extends CardImpl {§private static final FilterCard filter = new FilterCard("Soldier cards");§static {§filter.add(new SubtypePredicate("Soldier"));§}§public EnlistmentOfficer(UUID ownerId) {§super(ownerId, 9, "Enlistment Officer", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{W}");§this.expansionSetCode = "APC";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(FirstStrikeAbility.getInstance());§this.addAbility(new EntersBattlefieldTriggeredAbility(new EnvoyEffect(filter, 4)));§}§public EnlistmentOfficer(final EnlistmentOfficer card) {§super(card);§}§@Override§public EnlistmentOfficer copy() {§return new EnlistmentOfficer(this);§}§}§
public class EvasiveAction extends CardImpl {§public EvasiveAction(UUID ownerId) {§super(ownerId, 23, "Evasive Action", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{1}{U}");§this.expansionSetCode = "APC";§this.getSpellAbility().addEffect(new CounterUnlessPaysEffect(new DomainValue()));§this.getSpellAbility().addTarget(new TargetSpell());§}§public EvasiveAction(final EvasiveAction card) {§super(card);§}§@Override§public EvasiveAction copy() {§return new EvasiveAction(this);§}§}§
public class FerventCharge extends CardImpl {§public FerventCharge(UUID ownerId) {§super(ownerId, 98, "Fervent Charge", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{1}{W}{B}{R}");§this.expansionSetCode = "APC";§Effect effect = new BoostTargetEffect(2, 2, Duration.EndOfTurn);§effect.setText("it gets +2/+2 until end of turn");§this.addAbility(new AttacksCreatureYouControlTriggeredAbility(effect, false, true));§}§public FerventCharge(final FerventCharge card) {§super(card);§}§@Override§public FerventCharge copy() {§return new FerventCharge(this);§}§}§
public class FlowstoneCharger extends CardImpl {§public FlowstoneCharger(UUID ownerId) {§super(ownerId, 99, "Flowstone Charger", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{R}{W}");§this.expansionSetCode = "APC";§this.subtype.add("Beast");§this.power = new MageInt(2);§this.toughness = new MageInt(5);§this.addAbility(new AttacksTriggeredAbility(new BoostSourceEffect(3, -3, Duration.EndOfTurn), false));§}§public FlowstoneCharger(final FlowstoneCharger card) {§super(card);§}§@Override§public FlowstoneCharger copy() {§return new FlowstoneCharger(this);§}§}§
public class FoulPresence extends CardImpl {§public FoulPresence(UUID ownerId) {§super(ownerId, 39, "Foul Presence", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{B}");§this.expansionSetCode = "APC";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.UnboostCreature));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(-1, -1, Duration.WhileOnBattlefield));§Ability gainedAbility = new SimpleActivatedAbility(Zone.BATTLEFIELD,§new BoostTargetEffect(-1, -1, Duration.EndOfTurn), new TapSourceCost());§gainedAbility.addTarget(new TargetCreaturePermanent());§Effect effect = new GainAbilityAttachedEffect(gainedAbility, AttachmentType.AURA, Duration.WhileOnBattlefield);§effect.setText("and has \"{T}: Target creature gets -1/-1 until end of turn.\"");§ability.addEffect(effect);§this.addAbility(ability);§}§public FoulPresence(final FoulPresence card) {§super(card);§}§@Override§public FoulPresence copy() {§return new FoulPresence(this);§}§}§
public class GerrardCapashen extends CardImpl {§public GerrardCapashen(UUID ownerId) {§super(ownerId, 11, "Gerrard Capashen", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{W}{W}");§this.expansionSetCode = "APC";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(3);§this.toughness = new MageInt(4);§Ability ability1 = new BeginningOfUpkeepTriggeredAbility(Zone.BATTLEFIELD, new GerrardCapashenEffect(),§TargetController.YOU, false, true);§ability1.addTarget(new TargetOpponent());§this.addAbility(ability1);§Ability ability2 = new ActivateIfConditionActivatedAbility(Zone.BATTLEFIELD, new TapTargetEffect(),§new ManaCostsImpl("{3}{W}"), new SourceAttackingCondition());§ability2.addTarget(new TargetCreaturePermanent());§this.addAbility(ability2);§}§public GerrardCapashen(final GerrardCapashen card) {§super(card);§}§@Override§public GerrardCapashen copy() {§return new GerrardCapashen(this);§}§}§class GerrardCapashenEffect extends OneShotEffect {§public GerrardCapashenEffect() {§super(Outcome.GainLife);§staticText = "you gain 1 life for each card in target opponent's hand.";§}§public GerrardCapashenEffect(final GerrardCapashenEffect effect) {§super(effect);§}§@Override§public GerrardCapashenEffect copy() {§return new GerrardCapashenEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§Player targetOpponent = game.getPlayer(this.getTargetPointer().getFirst(game, source));§if (controller != null && targetOpponent != null) {§int cardsInHand = targetOpponent.getHand().size();§if (cardsInHand > 0) {§controller.gainLife(cardsInHand, game);§}§return true;§}§return false;§}§}§
public class GerrardsVerdict extends CardImpl {§public GerrardsVerdict(UUID ownerId) {§super(ownerId, 102, "Gerrard's Verdict", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{W}{B}");§this.expansionSetCode = "APC";§this.getSpellAbility().addEffect(new GerrardsVerdictEffect());§this.getSpellAbility().addTarget(new TargetPlayer());§}§public GerrardsVerdict(final GerrardsVerdict card) {§super(card);§}§@Override§public GerrardsVerdict copy() {§return new GerrardsVerdict(this);§}§}§class GerrardsVerdictEffect extends OneShotEffect {§public GerrardsVerdictEffect() {§super(Outcome.Benefit);§this.staticText = "Target player discards two cards. You gain 3 life for each land card discarded this way";§}§public GerrardsVerdictEffect(final GerrardsVerdictEffect effect) {§super(effect);§}§@Override§public GerrardsVerdictEffect copy() {§return new GerrardsVerdictEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§Player targetPlayer = game.getPlayer(getTargetPointer().getFirst(game, source));§if (controller != null && targetPlayer != null) {§controller.gainLife(targetPlayer.discard(2, false, source, game).count(new FilterLandCard(), game) * 3, game);§return true;§}§return false;§}§}§
public class GladeGnarr extends CardImpl {§private static final FilterSpell filter = new FilterSpell("a blue spell");§static {§filter.add(new ColorPredicate(ObjectColor.BLUE));§}§public GladeGnarr(UUID ownerId) {§super(ownerId, 78, "Glade Gnarr", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{5}{G}");§this.expansionSetCode = "APC";§this.subtype.add("Beast");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(new SpellCastAllTriggeredAbility(new BoostSourceEffect(2, 2, Duration.EndOfTurn), filter, false));§}§public GladeGnarr(final GladeGnarr card) {§super(card);§}§@Override§public GladeGnarr copy() {§return new GladeGnarr(this);§}§}§
public class GoblinLegionnaire extends CardImpl {§public GoblinLegionnaire(UUID ownerId) {§super(ownerId, 103, "Goblin Legionnaire", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{R}{W}");§this.expansionSetCode = "APC";§this.subtype.add("Goblin");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability firstAbility = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(2), new ColoredManaCost(ColoredManaSymbol.R));§firstAbility.addCost(new SacrificeSourceCost());§firstAbility.addTarget(new TargetCreatureOrPlayer());§this.addAbility(firstAbility);§Ability secondAbility = new SimpleActivatedAbility(Zone.BATTLEFIELD, new PreventDamageToTargetEffect(Duration.EndOfTurn, 2), new ColoredManaCost(ColoredManaSymbol.W));§secondAbility.addCost(new SacrificeSourceCost());§secondAbility.addTarget(new TargetCreatureOrPlayer());§this.addAbility(secondAbility);§}§public GoblinLegionnaire(final GoblinLegionnaire card) {§super(card);§}§@Override§public GoblinLegionnaire copy() {§return new GoblinLegionnaire(this);§}§}§
public class GoblinRingleader extends CardImpl {§private static final FilterCard filter = new FilterCard("Goblin cards");§static {§filter.add(new SubtypePredicate("Goblin"));§}§public GoblinRingleader(UUID ownerId) {§super(ownerId, 62, "Goblin Ringleader", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{R}");§this.expansionSetCode = "APC";§this.subtype.add("Goblin");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(HasteAbility.getInstance());§this.addAbility(new EntersBattlefieldTriggeredAbility(new EnvoyEffect(filter, 4)));§}§public GoblinRingleader(final GoblinRingleader card) {§super(card);§}§@Override§public GoblinRingleader copy() {§return new GoblinRingleader(this);§}§}§
public class GoblinTrenches extends CardImpl {§final static FilterControlledPermanent filter = new FilterControlledLandPermanent("a land");§public GoblinTrenches(UUID ownerId) {§super(ownerId, 104, "Goblin Trenches", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{1}{R}{W}");§this.expansionSetCode = "APC";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new CreateTokenEffect(new GoblinTrenchesToken(), 2), new GenericManaCost(2));§ability.addCost(new SacrificeTargetCost(new TargetControlledPermanent(filter)));§this.addAbility(ability);§}§public GoblinTrenches(final GoblinTrenches card) {§super(card);§}§@Override§public GoblinTrenches copy() {§return new GoblinTrenches(this);§}§}§class GoblinTrenchesToken extends Token {§GoblinTrenchesToken() {§super("Goblin Soldier", "1/1 red and white Goblin Soldier creature tokens");§cardType.add(CardType.CREATURE);§color.setRed(true);§color.setWhite(true);§subtype.add("Goblin");§subtype.add("Soldier");§power = new MageInt(1);§toughness = new MageInt(1);§}§}§
public class GraveDefiler extends CardImpl {§private static final FilterCard filter = new FilterCard("Zombie cards");§static {§filter.add(new SubtypePredicate("Zombie"));§}§public GraveDefiler(UUID ownerId) {§super(ownerId, 40, "Grave Defiler", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{B}");§this.expansionSetCode = "APC";§this.subtype.add("Zombie");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new EntersBattlefieldTriggeredAbility(new EnvoyEffect(filter, 4)));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new RegenerateSourceEffect(), new ManaCostsImpl("{1}{B}"))); }§public GraveDefiler(final GraveDefiler card) {§super(card);§}§@Override§public GraveDefiler copy() {§return new GraveDefiler(this);§}§}§
public class HauntedAngel extends CardImpl {§public HauntedAngel(UUID ownerId) {§super(ownerId, 12, "Haunted Angel", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "APC";§this.subtype.add("Angel");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new DiesTriggeredAbility(new ExileSourceEffect());§ability.addEffect(new HauntedAngelEffect());§this.addAbility(ability);§}§public HauntedAngel(final HauntedAngel card) {§super(card);§}§@Override§public HauntedAngel copy() {§return new HauntedAngel(this);§}§}§class HauntedAngelEffect extends OneShotEffect {§public HauntedAngelEffect() {§super(Outcome.Detriment);§staticText = "and each other player puts a 3/3 black Angel creature token with flying onto the battlefield.";§}§public HauntedAngelEffect(HauntedAngelEffect copy) {§super(copy);§}§@Override§public HauntedAngelEffect copy() {§return new HauntedAngelEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§UUID controllerId = source.getControllerId();§HauntedAngelToken token = new HauntedAngelToken();§for(UUID playerId: game.getState().getPlayersInRange(controllerId, game)) {§if(!playerId.equals(controllerId)) {§token.putOntoBattlefield(1, game, source.getSourceId(), playerId);§}§}§return true;§}§}§class HauntedAngelToken extends Token {§public HauntedAngelToken() {§super("Angel", "3/3 black Angel creature token with flying");§cardType.add(CardType.CREATURE);§color.setBlack(true);§subtype.add("Angel");§power = new MageInt(3);§toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§}§}§
public class Helionaut extends CardImpl {§public Helionaut(UUID ownerId) {§super(ownerId, 13, "Helionaut", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "APC";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new AnyColorManaAbility(new GenericManaCost(1));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§}§public Helionaut(final Helionaut card) {§super(card);§}§@Override§public Helionaut copy() {§return new Helionaut(this);§}§}§
public class Illuminate extends CardImpl {§public Illuminate(UUID ownerId) {§super(ownerId, 63, "Illuminate", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{X}{R}");§this.expansionSetCode = "APC";§KickerAbility kickerAbility = new KickerAbility("{2}{R}");§kickerAbility.addKickerCost("{3}{U}");§this.addAbility(kickerAbility);§this.getSpellAbility().addEffect(new DamageTargetEffect(new ManacostVariableValue()));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.getSpellAbility().addEffect(new ConditionalOneShotEffect(§new DamageTargetControllerEffect(new ManacostVariableValue()),§new KickedCostCondition("{2}{R}"),§"If {this} was kicked with its {2}{R} kicker, it deals X damage to that creature's controller."));§this.getSpellAbility().addEffect(new ConditionalOneShotEffect(§new DrawCardSourceControllerEffect(new ManacostVariableValue()),§new KickedCostCondition("{3}{U}"),§"If {this} was kicked with its {3}{U} kicker, you draw X cards."));§}§public Illuminate(final Illuminate card) {§super(card);§}§@Override§public Illuminate copy() {§return new Illuminate(this);§}§}§
public class Index extends CardImpl {§public Index(UUID ownerId) {§super(ownerId, 25, "Index", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{U}");§this.expansionSetCode = "APC";§this.getSpellAbility().addEffect(new LookLibraryControllerEffect(5));§}§public Index(final Index card) {§super(card);§}§@Override§public Index copy() {§return new Index(this);§}§}§
public class Jilt extends CardImpl {§public Jilt(UUID ownerId) {§super(ownerId, 27, "Jilt", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{U}");§this.expansionSetCode = "APC";§this.addAbility(new KickerAbility("{1}{R}"));§this.getSpellAbility().addEffect(new ReturnToHandTargetEffect());§Effect effect = new ConditionalOneShotEffect(§new DamageTargetEffect(2),§KickedCondition.getInstance(),§"If {this} was kicked, it deals 2 damage to another target creature");§effect.setTargetPointer(new SecondTargetPointer());§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§@Override§public void adjustTargets(Ability ability, Game game) {§if (ability instanceof SpellAbility && KickedCondition.getInstance().apply(game, ability)) {§ability.addTarget(new TargetOtherCreaturePermanent(new FilterCreaturePermanent("another target creature")));§}§}§public Jilt(final Jilt card) {§super(card);§}§@Override§public Jilt copy() {§return new Jilt(this);§}§}§class TargetOtherCreaturePermanent extends TargetCreaturePermanent {§public TargetOtherCreaturePermanent(FilterCreaturePermanent filter) {§super(filter);§}§public TargetOtherCreaturePermanent(final TargetOtherCreaturePermanent target) {§super(target);§}§@Override§public boolean canTarget(UUID controllerId, UUID id, Ability source, Game game) {§if (source.getTargets().get(0).getTargets().contains(id)) {§return false;§}§return super.canTarget(controllerId, id, source, game);§}§@Override§public TargetOtherCreaturePermanent copy() {§return new TargetOtherCreaturePermanent(this);§}§}§
public class JungleBarrier extends CardImpl {§public JungleBarrier(UUID ownerId) {§super(ownerId, 106, "Jungle Barrier", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{G}{U}");§this.expansionSetCode = "APC";§this.subtype.add("Plant");§this.subtype.add("Wall");§this.power = new MageInt(2);§this.toughness = new MageInt(6);§this.addAbility(DefenderAbility.getInstance());§this.addAbility(new EntersBattlefieldTriggeredAbility(new DrawCardSourceControllerEffect(1), false));§}§public JungleBarrier(final JungleBarrier card) {§super(card);§}§@Override§public JungleBarrier copy() {§return new JungleBarrier(this);§}§}§
public class KavuGlider extends CardImpl {§public KavuGlider(UUID ownerId) {§super(ownerId, 64, "Kavu Glider", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "APC";§this.subtype.add("Kavu");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(0, 1, Duration.EndOfTurn), new ColoredManaCost(ColoredManaSymbol.W)));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilitySourceEffect(FlyingAbility.getInstance(), Duration.EndOfTurn), new ColoredManaCost(ColoredManaSymbol.U)));§}§public KavuGlider(final KavuGlider card) {§super(card);§}§@Override§public KavuGlider copy() {§return new KavuGlider(this);§}§}§
public class KavuHowler extends CardImpl {§private static final FilterCard filter = new FilterCard("Kavu cards");§static {§filter.add(new SubtypePredicate("Kavu"));§}§public KavuHowler(UUID ownerId) {§super(ownerId, 79, "Kavu Howler", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{G}{G}");§this.expansionSetCode = "APC";§this.subtype.add("Kavu");§this.power = new MageInt(4);§this.toughness = new MageInt(5);§this.addAbility(new EntersBattlefieldTriggeredAbility(new EnvoyEffect(filter, 4)));§}§public KavuHowler(final KavuHowler card) {§super(card);§}§@Override§public KavuHowler copy() {§return new KavuHowler(this);§}§}§
public class KavuMauler extends CardImpl {§private static final FilterAttackingCreature filter = new FilterAttackingCreature("other attacking Kavu");§static {§filter.add(new SubtypePredicate("Kavu"));§filter.add(new AnotherPredicate());§}§public KavuMauler(UUID ownerId) {§super(ownerId, 80, "Kavu Mauler", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{G}{G}");§this.expansionSetCode = "APC";§this.subtype.add("Kavu");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(TrampleAbility.getInstance());§PermanentsOnBattlefieldCount value = new PermanentsOnBattlefieldCount(filter);§this.addAbility(new AttacksTriggeredAbility(new BoostSourceEffect(value, value, Duration.EndOfTurn, true), false));§}§public KavuMauler(final KavuMauler card) {§super(card);§}§@Override§public KavuMauler copy() {§return new KavuMauler(this);§}§}§
public class LastCaress extends CardImpl {§public LastCaress(UUID ownerId) {§super(ownerId, 41, "Last Caress", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{2}{B}");§this.expansionSetCode = "APC";§this.getSpellAbility().addEffect(new LoseLifeTargetEffect(1));§this.getSpellAbility().addTarget(new TargetPlayer());§this.getSpellAbility().addEffect(new GainLifeEffect(1));§this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(1));§}§public LastCaress(final LastCaress card) {§super(card);§}§@Override§public LastCaress copy() {§return new LastCaress(this);§}§}§
public class LayOfTheLand extends CardImpl {§private static final FilterBasicLandCard filter = new FilterBasicLandCard();§public LayOfTheLand(UUID ownerId) {§super(ownerId, 81, "Lay of the Land", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{G}");§this.expansionSetCode = "APC";§this.getSpellAbility().addEffect(new SearchLibraryPutInHandEffect(new TargetCardInLibrary(1, 1, filter), true));§}§public LayOfTheLand(final LayOfTheLand card) {§super(card);§}§@Override§public LayOfTheLand copy() {§return new LayOfTheLand(this);§}§}§
public class LivingAirship extends CardImpl {§public LivingAirship(UUID ownerId) {§super(ownerId, 28, "Living Airship", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{U}");§this.expansionSetCode = "APC";§this.subtype.add("Metathran");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new RegenerateSourceEffect(), new ManaCostsImpl("{2}{G}")));§}§public LivingAirship(final LivingAirship card) {§super(card);§}§@Override§public LivingAirship copy() {§return new LivingAirship(this);§}§}§
public class LlanowarDead extends CardImpl {§public LlanowarDead(UUID ownerId) {§super(ownerId, 109, "Llanowar Dead", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{B}{G}");§this.expansionSetCode = "APC";§this.subtype.add("Zombie");§this.subtype.add("Elf");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new BlackManaAbility());§}§public LlanowarDead(final LlanowarDead card) {§super(card);§}§@Override§public LlanowarDead copy() {§return new LlanowarDead(this);§}§}§
public class LlanowarWastes extends CardImpl {§public LlanowarWastes(UUID ownerId) {§super(ownerId, 141, "Llanowar Wastes", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "APC";§this.addAbility(new ColorlessManaAbility());§Ability blackManaAbility = new SimpleManaAbility(Zone.BATTLEFIELD, Mana.BlackMana(1), new TapSourceCost());§blackManaAbility.addEffect(new DamageControllerEffect(1));§this.addAbility(blackManaAbility);§Ability greenManaAbility = new SimpleManaAbility(Zone.BATTLEFIELD, Mana.GreenMana(1), new TapSourceCost());§greenManaAbility.addEffect(new DamageControllerEffect(1));§this.addAbility(greenManaAbility);§}§public LlanowarWastes(final LlanowarWastes card) {§super(card);§}§@Override§public LlanowarWastes copy() {§return new LlanowarWastes(this);§}§}§
public class ManaclesOfDecay extends CardImpl {§public ManaclesOfDecay(UUID ownerId) {§super(ownerId, 14, "Manacles of Decay", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{W}");§this.expansionSetCode = "APC";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new CantAttackAttachedEffect(AttachmentType.AURA)));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(-1, -1, Duration.EndOfTurn), new ColoredManaCost(ColoredManaSymbol.B)));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new CantBlockAttachedEffect(AttachmentType.AURA, Duration.EndOfTurn), new ColoredManaCost(ColoredManaSymbol.R)));§}§public ManaclesOfDecay(final ManaclesOfDecay card) {§super(card);§}§@Override§public ManaclesOfDecay copy() {§return new ManaclesOfDecay(this);§}§}§
public class MartyrsTomb extends CardImpl {§public MartyrsTomb(UUID ownerId) {§super(ownerId, 110, "Martyrs' Tomb", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{W}{B}");§this.expansionSetCode = "APC";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new PreventDamageToTargetEffect(Duration.EndOfTurn, 1), new PayLifeCost(2));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public MartyrsTomb(final MartyrsTomb card) {§super(card);§}§@Override§public MartyrsTomb copy() {§return new MartyrsTomb(this);§}§}§
public class MaskOfIntolerance extends CardImpl {§public MaskOfIntolerance(UUID ownerId) {§super(ownerId, 138, "Mask of Intolerance", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{2}");§this.expansionSetCode = "APC";§TriggeredAbility ability = new BeginningOfUpkeepTriggeredAbility(Zone.BATTLEFIELD, new DamageTargetEffect(3), TargetController.ANY, false);§this.addAbility(new ConditionalTriggeredAbility(ability, new MaskOfIntoleranceCondition(),§"At the beginning of each player's upkeep, if there are four or more basic land types among lands that player controls, {this} deals 3 damage to him or her."));§}§public MaskOfIntolerance(final MaskOfIntolerance card) {§super(card);§}§@Override§public MaskOfIntolerance copy() {§return new MaskOfIntolerance(this);§}§}§class MaskOfIntoleranceCondition extends IntCompareCondition {§public MaskOfIntoleranceCondition() {§super(ComparisonType.GreaterThan, 3);§}§@Override§protected int getInputValue(Game game, Ability source) {§return new DomainValue(1, game.getActivePlayerId()).calculate(game, source, null);§}§}§
public class MinotaurIllusionist extends CardImpl {§public MinotaurIllusionist(UUID ownerId) {§super(ownerId, 111, "Minotaur Illusionist", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{U}{R}");§this.expansionSetCode = "APC";§this.subtype.add("Minotaur");§this.subtype.add("Wizard");§this.power = new MageInt(3);§this.toughness = new MageInt(4);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilitySourceEffect(ShroudAbility.getInstance(),§Duration.EndOfTurn), new ManaCostsImpl("{1}{U}")));§Effect effect = new DamageTargetEffect(new SourcePermanentPowerCount());§effect.setText("{this} deals damage equal to its power to target creature.");§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new ManaCostsImpl("{R}"));§ability.addCost(new SacrificeSourceCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public MinotaurIllusionist(final MinotaurIllusionist card) {§super(card);§}§@Override§public MinotaurIllusionist copy() {§return new MinotaurIllusionist(this);§}§}§
public class MinotaurTactician extends CardImpl {§private static final FilterControlledCreaturePermanent filterWhite = new FilterControlledCreaturePermanent();§private static final FilterControlledCreaturePermanent filterBlue = new FilterControlledCreaturePermanent();§static {§filterWhite.add(new ColorPredicate(ObjectColor.WHITE));§filterBlue.add(new ColorPredicate(ObjectColor.BLUE));§}§final private String ruleWhite = "{this} gets +1/+1 as long as you control another white creature";§final private String ruleBlue = "{this} gets +1/+1 as long as you control another white creature";§public MinotaurTactician(UUID ownerId) {§super(ownerId, 65, "Minotaur Tactician", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{R}");§this.expansionSetCode = "APC";§this.subtype.add("Minotaur");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(HasteAbility.getInstance());§Condition conditionWhite = new PermanentsOnTheBattlefieldCondition(filterWhite, CountType.MORE_THAN, 0);§Effect effectWhite = new ConditionalContinuousEffect(new BoostSourceEffect(1, 1, Duration.WhileOnBattlefield), conditionWhite, ruleWhite);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, effectWhite));§Condition conditionBlue = new PermanentsOnTheBattlefieldCondition(filterBlue, CountType.MORE_THAN, 0);§Effect effectBlue = new ConditionalContinuousEffect(new BoostSourceEffect(1, 1, Duration.WhileOnBattlefield), conditionBlue, ruleBlue);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, effectBlue));§}§public MinotaurTactician(final MinotaurTactician card) {§super(card);§}§@Override§public MinotaurTactician copy() {§return new MinotaurTactician(this);§}§}§
public class MournfulZombie extends CardImpl {§public MournfulZombie(UUID ownerId) {§super(ownerId, 43, "Mournful Zombie", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{B}");§this.expansionSetCode = "APC";§this.subtype.add("Zombie");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainLifeTargetEffect(1), new ColoredManaCost(ColoredManaSymbol.W));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetPlayer(1));§this.addAbility(ability);§}§public MournfulZombie(final MournfulZombie card) {§super(card);§}§@Override§public MournfulZombie copy() {§return new MournfulZombie(this);§}§}§
public class MysticSnake extends CardImpl {§public MysticSnake(UUID ownerId) {§super(ownerId, 112, "Mystic Snake", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{G}{U}{U}");§this.expansionSetCode = "APC";§this.subtype.add("Snake");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlashAbility.getInstance());§Ability ability = new EntersBattlefieldTriggeredAbility(new CounterTargetEffect());§ability.addTarget(new TargetSpell());§this.addAbility(ability);§}§public MysticSnake(final MysticSnake card) {§super(card);§}§@Override§public MysticSnake copy() {§return new MysticSnake(this);§}§}§
public class NecraDisciple extends CardImpl {§public NecraDisciple(UUID ownerId) {§super(ownerId, 44, "Necra Disciple", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{B}");§this.expansionSetCode = "APC";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability firstAbility = new AnyColorManaAbility(new ColoredManaCost(ColoredManaSymbol.G));§firstAbility.addCost(new TapSourceCost());§this.addAbility(firstAbility);§Ability secondAbility = new SimpleActivatedAbility(Zone.BATTLEFIELD, new PreventDamageToTargetEffect(Duration.EndOfTurn, 1), new ColoredManaCost(ColoredManaSymbol.W));§secondAbility.addCost(new TapSourceCost());§secondAbility.addTarget(new TargetCreatureOrPlayer());§this.addAbility(secondAbility);§}§public NecraDisciple(final NecraDisciple card) {§super(card);§}§@Override§public NecraDisciple copy() {§return new NecraDisciple(this);§}§}§
public class Necravolver extends CardImpl {§public Necravolver(UUID ownerId) {§super(ownerId, 46, "Necravolver", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{B}");§this.expansionSetCode = "APC";§this.subtype.add("Volver");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§KickerAbility kickerAbility = new KickerAbility("{1}{G}");§kickerAbility.addKickerCost("{W}");§this.addAbility(kickerAbility);§Ability ability = new EntersBattlefieldAbility(new AddCountersSourceEffect(CounterType.P1P1.createInstance(2)),§new KickedCostCondition("{1}{G}"), "If {this} was kicked with its {1}{G} kicker, it enters the battlefield with two +1/+1 counters on it and with trample.", "");§ability.addEffect(new GainAbilitySourceEffect(TrampleAbility.getInstance(), Duration.WhileOnBattlefield));§this.addAbility(ability);§ability = new EntersBattlefieldAbility(new AddCountersSourceEffect(CounterType.P1P1.createInstance(1)),§new KickedCostCondition("{W}"), "If {this} was kicked with its {W} kicker, it enters the battlefield with a +1/+1 counter on it and with \"Whenever {this} deals damage, you gain that much life.\"", "");§ability.addEffect(new GainAbilitySourceEffect(new DealsDamageGainLifeSourceTriggeredAbility(), Duration.WhileOnBattlefield));§this.addAbility(ability);§}§public Necravolver(final Necravolver card) {§super(card);§}§@Override§public Necravolver copy() {§return new Necravolver(this);§}§}§
public class OrimsThunder extends CardImpl {§public OrimsThunder(UUID ownerId) {§super(ownerId, 15, "Orim's Thunder", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{W}");§this.expansionSetCode = "APC";§this.addAbility(new KickerAbility("{R}"));§this.getSpellAbility().addEffect(new OrimsThunderEffect());§this.getSpellAbility().addTarget(new TargetPermanent(new FilterArtifactOrEnchantmentPermanent()));§this.getSpellAbility().addEffect(new ConditionalOneShotEffect(§new OrimsThunderEffect2(),§KickedCondition.getInstance(),§"If Orim's Thunder was kicked, it deals damage equal to that permanent's converted mana cost to target creature"));§}§@Override§public void adjustTargets(Ability ability, Game game) {§if (ability instanceof SpellAbility) {§if (KickedCondition.getInstance().apply(game, ability)) {§ability.addTarget(new TargetCreaturePermanent());§}§}§}§public OrimsThunder(final OrimsThunder card) {§super(card);§}§@Override§public OrimsThunder copy() {§return new OrimsThunder(this);§}§}§class OrimsThunderEffect2 extends OneShotEffect {§OrimsThunderEffect2() {§super(Outcome.Damage);§}§OrimsThunderEffect2(final OrimsThunderEffect2 effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§int damage = 0;§MageObject firstTarget = game.getLastKnownInformation(source.getFirstTarget(), Zone.BATTLEFIELD);§Permanent secondTarget = game.getPermanent(source.getTargets().get(1).getFirstTarget());§if (firstTarget != null) {§damage = firstTarget.getManaCost().convertedManaCost();§}§boolean kicked = KickedCondition.getInstance().apply(game, source);§if (kicked && secondTarget != null) {§secondTarget.damage(damage, source.getSourceId(), game, false, true);§return true;§}§return false;§}§@Override§public OrimsThunderEffect2 copy() {§return new OrimsThunderEffect2(this);§}§}§class OrimsThunderEffect extends OneShotEffect {§OrimsThunderEffect() {§super(Outcome.DestroyPermanent);§staticText = "Destroy target artifact or enchantment";§}§OrimsThunderEffect(final OrimsThunderEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent target = game.getPermanent(source.getFirstTarget());§if (target != null) {§return target.destroy(source.getSourceId(), game, false);§}§return false;§}§@Override§public OrimsThunderEffect copy() {§return new OrimsThunderEffect(this);§}§}§
public class OvergrownEstate extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledLandPermanent("a land");§public OvergrownEstate(UUID ownerId) {§super(ownerId, 113, "Overgrown Estate", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{B}{G}{W}");§this.expansionSetCode = "APC";§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainLifeEffect(3), new SacrificeTargetCost(new TargetControlledPermanent(filter))));§}§public OvergrownEstate(final OvergrownEstate card) {§super(card);§}§@Override§public OvergrownEstate copy() {§return new OvergrownEstate(this);§}§}§
public class PenumbraBobcat extends CardImpl {§public PenumbraBobcat(UUID ownerId) {§super(ownerId, 82, "Penumbra Bobcat", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{G}");§this.expansionSetCode = "APC";§this.subtype.add("Cat");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new DiesTriggeredAbility(new CreateTokenEffect(new PenumbraBobcatToken(), 1), false));§}§public PenumbraBobcat(final PenumbraBobcat card) {§super(card);§}§@Override§public PenumbraBobcat copy() {§return new PenumbraBobcat(this);§}§}§class PenumbraBobcatToken extends Token {§PenumbraBobcatToken() {§super("Cat", "2/1 black Cat creature token");§cardType.add(CardType.CREATURE);§color.setBlack(true);§subtype.add("Cat");§power = new MageInt(2);§toughness = new MageInt(1);§}§}§
public class PenumbraKavu extends CardImpl {§public PenumbraKavu(UUID ownerId) {§super(ownerId, 83, "Penumbra Kavu", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{G}");§this.expansionSetCode = "APC";§this.subtype.add("Kavu");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new DiesTriggeredAbility(new CreateTokenEffect(new PenumbraKavuToken(), 1), false));§}§public PenumbraKavu(final PenumbraKavu card) {§super(card);§}§@Override§public PenumbraKavu copy() {§return new PenumbraKavu(this);§}§}§class PenumbraKavuToken extends Token {§PenumbraKavuToken() {§super("Kavu", "3/3 black Kavu creature token");§cardType.add(CardType.CREATURE);§color.setBlack(true);§subtype.add("Kavu");§power = new MageInt(3);§toughness = new MageInt(3);§}§}§
public class PenumbraWurm extends CardImpl {§public PenumbraWurm(UUID ownerId) {§super(ownerId, 84, "Penumbra Wurm", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}{G}{G}");§this.expansionSetCode = "APC";§this.subtype.add("Wurm");§this.power = new MageInt(6);§this.toughness = new MageInt(6);§this.addAbility(TrampleAbility.getInstance());§this.addAbility(new DiesTriggeredAbility(new CreateTokenEffect(new PenumbraWurmToken(), 1), false));§}§public PenumbraWurm(final PenumbraWurm card) {§super(card);§}§@Override§public PenumbraWurm copy() {§return new PenumbraWurm(this);§}§}§class PenumbraWurmToken extends Token {§PenumbraWurmToken() {§super("Wurm", "6/6 black Wurm creature token with trample");§cardType.add(CardType.CREATURE);§color.setBlack(true);§subtype.add("Wurm");§power = new MageInt(6);§toughness = new MageInt(6);§this.addAbility(TrampleAbility.getInstance());§}§}§
public class PerniciousDeed extends CardImpl {§public PerniciousDeed(UUID ownerId) {§super(ownerId, 114, "Pernicious Deed", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{1}{B}{G}");§this.expansionSetCode = "APC";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new PerniciousDeedEffect(), new VariableManaCost());§ability.addCost(new SacrificeSourceCost());§this.addAbility(ability);§}§public PerniciousDeed(final PerniciousDeed card) {§super(card);§}§@Override§public PerniciousDeed copy() {§return new PerniciousDeed(this);§}§}§class PerniciousDeedEffect extends OneShotEffect {§public PerniciousDeedEffect() {§super(Outcome.DestroyPermanent);§staticText = "Destroy each artifact, creature, and enchantment with converted mana cost X or less";§}§public PerniciousDeedEffect(final PerniciousDeedEffect effect) {§super(effect);§}§@Override§public PerniciousDeedEffect copy() {§return new PerniciousDeedEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§FilterPermanent filter = new FilterPermanent("artifacts, creatures, and enchantments");§filter.add(Predicates.or(§new CardTypePredicate(CardType.ARTIFACT),§new CardTypePredicate(CardType.CREATURE),§new CardTypePredicate(CardType.ENCHANTMENT)));§filter.add(new ConvertedManaCostPredicate(Filter.ComparisonType.LessThan, source.getManaCostsToPay().getX() + 1));§for (Permanent permanent : game.getBattlefield().getActivePermanents(filter, source.getControllerId(), source.getSourceId(), game)) {§permanent.destroy(source.getSourceId(), game, false);§}§return true;§}§}§
public class PlanarDespair extends CardImpl {§public PlanarDespair(UUID ownerId) {§super(ownerId, 50, "Planar Despair", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{3}{B}{B}");§this.expansionSetCode = "APC";§DynamicValue dv = new SignInversionDynamicValue(new DomainValue());§Effect effect = new BoostAllEffect(dv, dv, Duration.EndOfTurn);§effect.setText("Domain - All creatures get -1/-1 until end of turn for each basic land type among lands you control.");§this.getSpellAbility().addEffect(effect);§}§public PlanarDespair(final PlanarDespair card) {§super(card);§}§@Override§public PlanarDespair copy() {§return new PlanarDespair(this);§}§}§
public class PutridWarrior extends CardImpl {§public PutridWarrior(UUID ownerId) {§super(ownerId, 117, "Putrid Warrior", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{W}{B}");§this.expansionSetCode = "APC";§this.subtype.add("Zombie");§this.subtype.add("Soldier");§this.subtype.add("Warrior");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new PutridWarriorDealsDamageTriggeredAbility(new LoseLifeAllPlayersEffect(1));§Mode mode = new Mode();§mode.getEffects().add(new PutridWarriorGainLifeEffect());§ability.addMode(mode);§this.addAbility(ability);§}§public PutridWarrior(final PutridWarrior card) {§super(card);§}§@Override§public PutridWarrior copy() {§return new PutridWarrior(this);§}§}§class PutridWarriorDealsDamageTriggeredAbility extends TriggeredAbilityImpl {§public PutridWarriorDealsDamageTriggeredAbility(Effect effect) {§super(Zone.BATTLEFIELD, effect, false);§}§public PutridWarriorDealsDamageTriggeredAbility(final PutridWarriorDealsDamageTriggeredAbility ability) {§super(ability);§}§@Override§public PutridWarriorDealsDamageTriggeredAbility copy() {§return new PutridWarriorDealsDamageTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.DAMAGED_PLAYER || event.getType() == EventType.DAMAGED_CREATURE§|| event.getType() == EventType.DAMAGED_PLANESWALKER;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§return event.getSourceId().equals(this.sourceId);§}§@Override§public String getRule() {§return "Whenever {this} deals damage, " + super.getRule();§}§}§class PutridWarriorGainLifeEffect extends OneShotEffect {§public PutridWarriorGainLifeEffect() {§super(Outcome.GainLife);§staticText = "Each player gains 1 life.";§}§public PutridWarriorGainLifeEffect(final PutridWarriorGainLifeEffect effect) {§super(effect);§}§@Override§public PutridWarriorGainLifeEffect copy() {§return new PutridWarriorGainLifeEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§for(UUID playerId: game.getState().getPlayersInRange(source.getControllerId(), game)) {§Player player = game.getPlayer(playerId);§if(player != null) {§player.gainLife(1, game);§}§}§return true;§}§}§
public class QuagmireDruid extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("enchantment");§static {§filter.add(new CardTypePredicate(CardType.ENCHANTMENT));§}§public QuagmireDruid(UUID ownerId) {§super(ownerId, 51, "Quagmire Druid", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{B}");§this.expansionSetCode = "APC";§this.subtype.add("Zombie");§this.subtype.add("Druid");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DestroyTargetEffect(false), new ColoredManaCost(ColoredManaSymbol.G));§ability.addCost(new TapSourceCost());§ability.addCost(new SacrificeTargetCost(new TargetControlledCreaturePermanent()));§ability.addTarget(new TargetPermanent(filter));§this.addAbility(ability);§}§public QuagmireDruid(final QuagmireDruid card) {§super(card);§}§@Override§public QuagmireDruid copy() {§return new QuagmireDruid(this);§}§}§
public class QuicksilverDagger extends CardImpl {§public QuicksilverDagger(UUID ownerId) {§super(ownerId, 118, "Quicksilver Dagger", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{U}{R}");§this.expansionSetCode = "APC";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§Ability gainAbility = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(1), new TapSourceCost());§gainAbility.addTarget(new TargetPlayer());§gainAbility.addEffect(new DrawCardSourceControllerEffect(1));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(gainAbility, AttachmentType.AURA)));§}§public QuicksilverDagger(final QuicksilverDagger card) {§super(card);§}§@Override§public QuicksilverDagger copy() {§return new QuicksilverDagger(this);§}§}§
public class RakaDisciple extends CardImpl {§public RakaDisciple(UUID ownerId) {§super(ownerId, 66, "Raka Disciple", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{R}");§this.expansionSetCode = "APC";§this.subtype.add("Minotaur");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability firstAbility = new SimpleActivatedAbility(Zone.BATTLEFIELD, new PreventDamageToTargetEffect(Duration.EndOfTurn, 1), new ColoredManaCost(ColoredManaSymbol.W));§firstAbility.addCost(new TapSourceCost());§firstAbility.addTarget(new TargetCreatureOrPlayer());§this.addAbility(firstAbility);§Ability secondAbility = new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilityTargetEffect(FlyingAbility.getInstance(), Duration.EndOfTurn), new ColoredManaCost(ColoredManaSymbol.U));§secondAbility.addCost(new TapSourceCost());§secondAbility.addTarget(new TargetCreaturePermanent());§this.addAbility(secondAbility);§}§public RakaDisciple(final RakaDisciple card) {§super(card);§}§@Override§public RakaDisciple copy() {§return new RakaDisciple(this);§}§}§
public class Rakavolver extends CardImpl {§public Rakavolver(UUID ownerId) {§super(ownerId, 68, "Rakavolver", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "APC";§this.subtype.add("Volver");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§KickerAbility kickerAbility = new KickerAbility("{1}{W}");§kickerAbility.addKickerCost("{U}");§this.addAbility(kickerAbility);§Ability ability = new EntersBattlefieldAbility(new AddCountersSourceEffect(CounterType.P1P1.createInstance(2)),§new KickedCostCondition("{1}{W}"), "If {this} was kicked with its {1}{W} kicker, it enters the battlefield with two +1/+1 counters on it and with \"Whenever {this} deals damage, you gain that much life.\"", "");§ability.addEffect(new GainAbilitySourceEffect(new DealsDamageGainLifeSourceTriggeredAbility(), Duration.WhileOnBattlefield));§this.addAbility(ability);§ability = new EntersBattlefieldAbility(new AddCountersSourceEffect(CounterType.P1P1.createInstance(1)),§new KickedCostCondition("{U}"), "If {this} was kicked with its {U} kicker, it enters the battlefield with a +1/+1 counter on it and with flying.", "");§ability.addEffect(new GainAbilitySourceEffect(FlyingAbility.getInstance(), Duration.WhileOnBattlefield));§this.addAbility(ability);§}§public Rakavolver(final Rakavolver card) {§super(card);§}§@Override§public Rakavolver copy() {§return new Rakavolver(this);§}§}§
public class RazorfinHunter extends CardImpl {§public RazorfinHunter(UUID ownerId) {§super(ownerId, 119, "Razorfin Hunter", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{U}{R}");§this.expansionSetCode = "APC";§this.subtype.add("Merfolk");§this.subtype.add("Goblin");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(1), new TapSourceCost());§ability.addTarget(new TargetCreatureOrPlayer());§this.addAbility(ability);§}§public RazorfinHunter(final RazorfinHunter card) {§super(card);§}§@Override§public RazorfinHunter copy() {§return new RazorfinHunter(this);§}§}§
public class ReefShaman extends CardImpl {§public ReefShaman(UUID ownerId) {§super(ownerId, 29, "Reef Shaman", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{U}");§this.expansionSetCode = "APC";§this.subtype.add("Merfolk");§this.subtype.add("Shaman");§this.power = new MageInt(0);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BecomesBasicLandTargetEffect(Duration.EndOfTurn), new TapSourceCost());§ability.addTarget(new TargetLandPermanent());§this.addAbility(ability);§}§public ReefShaman(final ReefShaman card) {§super(card);§}§@Override§public ReefShaman copy() {§return new ReefShaman(this);§}§}§
public class SavageGorilla extends CardImpl {§public SavageGorilla(UUID ownerId) {§super(ownerId, 85, "Savage Gorilla", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{G}");§this.expansionSetCode = "APC";§this.subtype.add("Ape");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostTargetEffect(-3, -3, Duration.EndOfTurn), new ManaCostsImpl("{U}{B}"));§ability.addCost(new TapSourceCost());§ability.addCost(new SacrificeSourceCost());§ability.addEffect(new DrawCardSourceControllerEffect(1));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public SavageGorilla(final SavageGorilla card) {§super(card);§}§@Override§public SavageGorilla copy() {§return new SavageGorilla(this);§}§}§
public class ShieldOfDutyAndReason extends CardImpl {§private static final FilterCard filter = new FilterCard("green and from blue");§static {§filter.add(Predicates.or(new ColorPredicate(ObjectColor.GREEN), new ColorPredicate(ObjectColor.BLUE)));§}§public ShieldOfDutyAndReason(UUID ownerId) {§super(ownerId, 16, "Shield of Duty and Reason", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{W}");§this.expansionSetCode = "APC";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(new ProtectionAbility(filter),§AttachmentType.AURA, Duration.WhileOnBattlefield)));§}§public ShieldOfDutyAndReason(final ShieldOfDutyAndReason card) {§super(card);§}§@Override§public ShieldOfDutyAndReason copy() {§return new ShieldOfDutyAndReason(this);§}§}§
public class ShimmeringMirage extends CardImpl {§public ShimmeringMirage(UUID ownerId) {§super(ownerId, 30, "Shimmering Mirage", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{U}");§this.expansionSetCode = "APC";§this.getSpellAbility().addEffect(new BecomesBasicLandTargetEffect(Duration.EndOfTurn));§this.getSpellAbility().addTarget(new TargetLandPermanent());§this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(1));§}§public ShimmeringMirage(final ShimmeringMirage card) {§super(card);§}§@Override§public ShimmeringMirage copy() {§return new ShimmeringMirage(this);§}§}§
public class ShivanReef extends CardImpl {§public ShivanReef(UUID ownerId) {§super(ownerId, 142, "Shivan Reef", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "APC";§this.addAbility(new ColorlessManaAbility());§Ability blueManaAbility = new SimpleManaAbility(Zone.BATTLEFIELD, Mana.BlueMana(1), new TapSourceCost());§blueManaAbility.addEffect(new DamageControllerEffect(1));§this.addAbility(blueManaAbility);§Ability redManaAbility = new SimpleManaAbility(Zone.BATTLEFIELD, Mana.RedMana(1), new TapSourceCost());§redManaAbility.addEffect(new DamageControllerEffect(1));§this.addAbility(redManaAbility);§}§public ShivanReef(final ShivanReef card) {§super(card);§}§@Override§public ShivanReef copy() {§return new ShivanReef(this);§}§}§
public class Smash extends CardImpl {§public Smash(UUID ownerId) {§super(ownerId, 69, "Smash", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{R}");§this.expansionSetCode = "APC";§this.getSpellAbility().addEffect(new DestroyTargetEffect());§this.getSpellAbility().addTarget(new TargetPermanent(new FilterArtifactPermanent()));§this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(1));§}§public Smash(final Smash card) {§super(card);§}§@Override§public Smash copy() {§return new Smash(this);§}§}§
public class SoulLink extends CardImpl {§public SoulLink(UUID ownerId) {§super(ownerId, 120, "Soul Link", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{W}{B}");§this.expansionSetCode = "APC";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new DealsDamageAttachedTriggeredAbility(Zone.BATTLEFIELD,§new GainLifeEffect(new NumericSetToEffectValues("that much", "damage")), false));§this.addAbility(new DamageDealtToAttachedTriggeredAbility(new GainLifeEffect(new NumericSetToEffectValues("that much", "damage")), false));§}§public SoulLink(final SoulLink card) {§super(card);§}§@Override§public SoulLink copy() {§return new SoulLink(this);§}§}§
public class SpectralLynx extends CardImpl {§private static final FilterCard filter = new FilterCard("green");§static {§filter.add(new ColorPredicate(ObjectColor.GREEN));§}§public SpectralLynx(UUID ownerId) {§super(ownerId, 17, "Spectral Lynx", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "APC";§this.subtype.add("Cat");§this.subtype.add("Spirit");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new ProtectionAbility(filter));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new RegenerateSourceEffect(), new ManaCostsImpl("{B}")));§}§public SpectralLynx(final SpectralLynx card) {§super(card);§}§@Override§public SpectralLynx copy() {§return new SpectralLynx(this);§}§}§
public class Spiritmonger extends CardImpl {§public Spiritmonger(UUID ownerId) {§super(ownerId, 121, "Spiritmonger", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{B}{G}");§this.expansionSetCode = "APC";§this.subtype.add("Beast");§this.power = new MageInt(6);§this.toughness = new MageInt(6);§this.addAbility(new DealsDamageToACreatureTriggeredAbility(new AddCountersSourceEffect(CounterType.P1P1.createInstance(), true), false, false, false));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new RegenerateSourceEffect(), new ManaCostsImpl("{B}")));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BecomesColorSourceEffect(Duration.EndOfTurn), new ManaCostsImpl("{G}")));§}§public Spiritmonger(final Spiritmonger card) {§super(card);§}§@Override§public Spiritmonger copy() {§return new Spiritmonger(this);§}§}§
public class SqueesEmbrace extends CardImpl {§public SqueesEmbrace(UUID ownerId) {§super(ownerId, 122, "Squee's Embrace", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{R}{W}");§this.expansionSetCode = "APC";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(2, 2, Duration.WhileOnBattlefield)));§this.addAbility(new DiesAttachedTriggeredAbility(new ReturnToHandAttachedEffect(), "enchanted creature"));§}§public SqueesEmbrace(final SqueesEmbrace card) {§super(card);§}§@Override§public SqueesEmbrace copy() {§return new SqueesEmbrace(this);§}§}§
public class SqueesRevenge extends CardImpl {§public SqueesRevenge(UUID ownerId) {§super(ownerId, 123, "Squee's Revenge", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{1}{U}{R}");§this.expansionSetCode = "APC";§this.getSpellAbility().addEffect(new SqueesRevengeEffect());§}§public SqueesRevenge(final SqueesRevenge card) {§super(card);§}§@Override§public SqueesRevenge copy() {§return new SqueesRevenge(this);§}§}§class SqueesRevengeEffect extends OneShotEffect {§public SqueesRevengeEffect() {§super(Outcome.DrawCard);§staticText = "Choose a number. Flip a coin that many times or until you lose a flip, whichever comes first. If you win all the flips, draw two cards for each flip.";§}§public SqueesRevengeEffect(final SqueesRevengeEffect effect) {§super(effect);§}§public SqueesRevengeEffect copy() {§return new SqueesRevengeEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if(player != null) {§int number = player.announceXMana(0, Integer.MAX_VALUE, "Choose how many times to flip a coin", game, source);§game.informPlayers(player.getLogName() + " chooses " + number + ".");§for(int i = 0; i < number; i++) {§if(!player.flipCoin(game)) {§return true;§}§}§player.drawCards(2 * number, game);§return true;§}§return false;§}§}§
public class SylvanMessenger extends CardImpl {§private static final FilterCard filter = new FilterCard("Elf cards");§static {§filter.add(new SubtypePredicate("Elf"));§}§public SylvanMessenger(UUID ownerId) {§super(ownerId, 87, "Sylvan Messenger", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{G}");§this.expansionSetCode = "APC";§this.subtype.add("Elf");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(TrampleAbility.getInstance());§this.addAbility(new EntersBattlefieldTriggeredAbility(new EnvoyEffect(filter, 4)));§}§public SylvanMessenger(final SylvanMessenger card) {§super(card);§}§@Override§public SylvanMessenger copy() {§return new SylvanMessenger(this);§}§}§
public class SymbioticDeployment extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("untapped creatures you control");§static {§filter.add(Predicates.not(new TappedPredicate()));§}§public SymbioticDeployment(UUID ownerId) {§super(ownerId, 88, "Symbiotic Deployment", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{2}{G}");§this.expansionSetCode = "APC";§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new SkipDrawStepEffect()));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DrawCardSourceControllerEffect(1), new ManaCostsImpl("{1}"));§ability.addCost(new TapTargetCost(new TargetControlledCreaturePermanent(2, 2, filter, false)));§this.addAbility(ability);§}§public SymbioticDeployment(final SymbioticDeployment card) {§super(card);§}§@Override§public SymbioticDeployment copy() {§return new SymbioticDeployment(this);§}§}§
public class TemporalSpring extends CardImpl {§public TemporalSpring(UUID ownerId) {§super(ownerId, 125, "Temporal Spring", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{1}{G}{U}");§this.expansionSetCode = "APC";§this.getSpellAbility().addEffect(new PutOnLibraryTargetEffect(true));§this.getSpellAbility().addTarget(new TargetPermanent());§}§public TemporalSpring(final TemporalSpring card) {§super(card);§}§@Override§public TemporalSpring copy() {§return new TemporalSpring(this);§}§}§
public class TidalCourier extends CardImpl {§private static final FilterCard filter = new FilterCard("Merfolk cards");§static {§filter.add(new SubtypePredicate("Merfolk"));§}§public TidalCourier(UUID ownerId) {§super(ownerId, 31, "Tidal Courier", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{U}");§this.expansionSetCode = "APC";§this.subtype.add("Merfolk");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§this.addAbility(new EntersBattlefieldTriggeredAbility(new EnvoyEffect(filter, 4)));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilitySourceEffect(FlyingAbility.getInstance(),§Duration.EndOfTurn), new ManaCostsImpl("{3}{U}")));§}§public TidalCourier(final TidalCourier card) {§super(card);§}§@Override§public TidalCourier copy() {§return new TidalCourier(this);§}§}§
public class TranquilPath extends CardImpl {§public TranquilPath(UUID ownerId) {§super(ownerId, 89, "Tranquil Path", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{4}{G}");§this.expansionSetCode = "APC";§this.getSpellAbility().addEffect(new TranquilPathEffect());§this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(1));§}§public TranquilPath(final TranquilPath card) {§super(card);§}§@Override§public TranquilPath copy() {§return new TranquilPath(this);§}§}§class TranquilPathEffect extends OneShotEffect {§private static final FilterPermanent filter = new FilterPermanent("");§static {§filter.add(new CardTypePredicate(CardType.ENCHANTMENT));§}§public TranquilPathEffect() {§super(Outcome.DestroyPermanent);§staticText = "Destroy all enchantments";§}§public TranquilPathEffect(final TranquilPathEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§for (Permanent permanent : game.getBattlefield().getActivePermanents(filter, source.getControllerId(), source.getSourceId(), game)) {§permanent.destroy(source.getSourceId(), game, false);§}§return true;§}§@Override§public TranquilPathEffect copy() {§return new TranquilPathEffect(this);§}§}§
public class TundraKavu extends CardImpl {§public TundraKavu(UUID ownerId) {§super(ownerId, 71, "Tundra Kavu", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "APC";§this.subtype.add("Kavu");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new TundraKavuEffect(), new TapSourceCost());§ability.addTarget(new TargetLandPermanent());§this.addAbility(ability);§}§public TundraKavu(final TundraKavu card) {§super(card);§}§@Override§public TundraKavu copy() {§return new TundraKavu(this);§}§}§class TundraKavuEffect extends BecomesBasicLandTargetEffect {§public TundraKavuEffect() {§super(Duration.EndOfTurn, false, true, "");§staticText = "Target land becomes a Plains or an Island until end of turn.";§}§public TundraKavuEffect(final TundraKavuEffect effect) {§super(effect);§}§public TundraKavuEffect copy() {§return new TundraKavuEffect(this);§}§@Override§public void init(Ability source, Game game) {§landTypes.clear();§Player controller = game.getPlayer(source.getControllerId());§if(controller != null) {§Set<String> choiceSet = new LinkedHashSet<>();§choiceSet.add("Island");§choiceSet.add("Plains");§ChoiceImpl choice = new ChoiceImpl(true);§choice.setChoices(choiceSet);§choice.setMessage("Choose a basic land type");§controller.choose(outcome, choice, game);§landTypes.add(choice.getChoice());§} else {§this.discard();§}§super.init(source, game);§}§}§
public class UnnaturalSelection extends CardImpl {§public UnnaturalSelection(UUID ownerId) {§super(ownerId, 32, "Unnatural Selection", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{1}{U}");§this.expansionSetCode = "APC";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BecomesChosenCreatureTypeTargetEffect(true), new GenericManaCost(1));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public UnnaturalSelection(final UnnaturalSelection card) {§super(card);§}§@Override§public UnnaturalSelection copy() {§return new UnnaturalSelection(this);§}§}§
public class UrborgElf extends CardImpl {§public UrborgElf(UUID ownerId) {§super(ownerId, 90, "Urborg Elf", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "APC";§this.subtype.add("Elf");§this.subtype.add("Druid");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new GreenManaAbility());§this.addAbility(new BlueManaAbility());§this.addAbility(new BlackManaAbility());§}§public UrborgElf(final UrborgElf card) {§super(card);§}§@Override§public UrborgElf copy() {§return new UrborgElf(this);§}§}§
public class UrborgUprising extends CardImpl {§public UrborgUprising(UUID ownerId) {§super(ownerId, 53, "Urborg Uprising", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{4}{B}");§this.expansionSetCode = "APC";§this.getSpellAbility().addEffect(new ReturnFromGraveyardToHandTargetEffect());§this.getSpellAbility().addTarget(new TargetCardInYourGraveyard(0, 2, new FilterCreatureCard("creature cards from your graveyard")));§this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(1));§}§public UrborgUprising(final UrborgUprising card) {§super(card);§}§@Override§public UrborgUprising copy() {§return new UrborgUprising(this);§}§}§
public class Vindicate extends CardImpl {§public Vindicate (UUID ownerId) {§super(ownerId, 126, "Vindicate", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{1}{W}{B}");§this.expansionSetCode = "APC";§this.getSpellAbility().addEffect(new DestroyTargetEffect());§this.getSpellAbility().addTarget(new TargetPermanent());§}§public Vindicate (final Vindicate card) {§super(card);§}§@Override§public Vindicate copy() {§return new Vindicate(this);§}§}§
public class VodalianMystic extends CardImpl {§private static final FilterSpell filter = new FilterSpell("instant or sorcery spell");§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.INSTANT),§new CardTypePredicate(CardType.SORCERY)));§}§public VodalianMystic(UUID ownerId) {§super(ownerId, 33, "Vodalian Mystic", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{U}");§this.expansionSetCode = "APC";§this.subtype.add("Merfolk");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BecomesColorTargetEffect(Duration.WhileOnStack), new TapSourceCost());§ability.addTarget(new TargetSpell(filter));§this.addAbility(ability);§}§public VodalianMystic(final VodalianMystic card) {§super(card);§}§@Override§public VodalianMystic copy() {§return new VodalianMystic(this);§}§}§
public class WhirlpoolDrake extends CardImpl {§public WhirlpoolDrake(UUID ownerId) {§super(ownerId, 34, "Whirlpool Drake", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{U}");§this.expansionSetCode = "APC";§this.subtype.add("Drake");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new EntersBattlefieldTriggeredAbility(new ShuffleHandIntoLibraryDrawThatManySourceEffect(), false));§this.addAbility(new DiesTriggeredAbility(new ShuffleHandIntoLibraryDrawThatManySourceEffect(), false));§}§public WhirlpoolDrake(final WhirlpoolDrake card) {§super(card);§}§@Override§public WhirlpoolDrake copy() {§return new WhirlpoolDrake(this);§}§}§
public class WhirlpoolRider extends CardImpl {§public WhirlpoolRider(UUID ownerId) {§super(ownerId, 35, "Whirlpool Rider", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{U}");§this.expansionSetCode = "APC";§this.subtype.add("Merfolk");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new EntersBattlefieldTriggeredAbility(new ShuffleHandIntoLibraryDrawThatManySourceEffect()));§}§public WhirlpoolRider(final WhirlpoolRider card) {§super(card);§}§@Override§public WhirlpoolRider copy() {§return new WhirlpoolRider(this);§}§}§
public class WildResearch extends CardImpl {§private static final FilterCard filterEnchantment = new FilterCard("enchantment card");§private static final FilterCard filterInstant = new FilterCard("instant card");§static {§filterEnchantment.add(new CardTypePredicate(CardType.ENCHANTMENT));§filterInstant.add(new CardTypePredicate(CardType.INSTANT));§}§public WildResearch(UUID ownerId) {§super(ownerId, 72, "Wild Research", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{2}{R}");§this.expansionSetCode = "APC";§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new WildResearchEffect(filterEnchantment), new ManaCostsImpl<>("{1}{W}")));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new WildResearchEffect(filterInstant), new ManaCostsImpl<>("{1}{U}")));§}§public WildResearch(final WildResearch card) {§super(card);§}§@Override§public WildResearch copy() {§return new WildResearch(this);§}§}§class WildResearchEffect extends OneShotEffect {§protected final FilterCard filter;§WildResearchEffect(FilterCard filter) {§super(Outcome.DrawCard);§this.staticText = "Search your library for an " + filter.getMessage() + " and reveal that card. Put it into your hand, then discard a card at random. Then shuffle your library.";§this.filter = filter;§}§WildResearchEffect(final WildResearchEffect effect) {§super(effect);§this.filter = effect.filter;§}§@Override§public WildResearchEffect copy() {§return new WildResearchEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§MageObject sourceObject = game.getObject(source.getSourceId());§if (controller != null && sourceObject != null) {§TargetCardInLibrary target = new TargetCardInLibrary(filter);§if (controller.searchLibrary(target, game)) {§if (target.getTargets().size() > 0) {§Card card = controller.getLibrary().remove(target.getFirstTarget(), game);§if (card != null) {§controller.moveCards(card, null, Zone.HAND, source, game);§Cards cards = new CardsImpl();§cards.add(card);§controller.revealCards(sourceObject.getIdName(), cards, game, true);§}§}§}§controller.discardOne(true, source, game);§controller.shuffleLibrary(game);§return true;§}§return false;§}§}§
public class YavimayaCoast extends CardImpl {§public YavimayaCoast(UUID ownerId) {§super(ownerId, 143, "Yavimaya Coast", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "APC";§this.addAbility(new ColorlessManaAbility());§Ability greenManaAbility = new SimpleManaAbility(Zone.BATTLEFIELD, Mana.GreenMana(1), new TapSourceCost());§greenManaAbility.addEffect(new DamageControllerEffect(1));§this.addAbility(greenManaAbility);§Ability blueManaAbility = new SimpleManaAbility(Zone.BATTLEFIELD, Mana.BlueMana(1), new TapSourceCost());§blueManaAbility.addEffect(new DamageControllerEffect(1));§this.addAbility(blueManaAbility);§}§public YavimayaCoast(final YavimayaCoast card) {§super(card);§}§@Override§public YavimayaCoast copy() {§return new YavimayaCoast(this);§}§}§
public class YavimayasEmbrace extends CardImpl {§public YavimayasEmbrace(UUID ownerId) {§super(ownerId, 127, "Yavimaya's Embrace", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{5}{G}{U}{U}");§this.expansionSetCode = "APC";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.Detriment));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new ControlEnchantedEffect()));§ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(2, 2, Duration.WhileOnBattlefield));§Effect effect = new GainAbilityAttachedEffect(TrampleAbility.getInstance(), AttachmentType.AURA);§effect.setText("and has trample");§ability.addEffect(effect);§this.addAbility(ability);§}§public YavimayasEmbrace(final YavimayasEmbrace card) {§super(card);§}§@Override§public YavimayasEmbrace copy() {§return new YavimayasEmbrace(this);§}§}§
public class AliBaba extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("Wall");§static {§filter.add(new SubtypePredicate("Wall"));§}§public AliBaba(UUID ownerId) {§super(ownerId, 43, "Ali Baba", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{R}");§this.expansionSetCode = "ARN";§this.subtype.add("Human");§this.subtype.add("Rogue");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new TapTargetEffect(), new ManaCostsImpl("{R}"));§ability.addTarget(new TargetPermanent(filter));§this.addAbility(ability);§}§public AliBaba(final AliBaba card) {§super(card);§}§@Override§public AliBaba copy() {§return new AliBaba(this);§}§}§
public class AliFromCairo extends CardImpl {§public AliFromCairo(UUID ownerId) {§super(ownerId, 44, "Ali from Cairo", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{R}{R}");§this.expansionSetCode = "ARN";§this.subtype.add("Human");§this.power = new MageInt(0);§this.toughness = new MageInt(1);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new AliFromCairoReplacementEffect()));§}§public AliFromCairo(final AliFromCairo card) {§super(card);§}§@Override§public AliFromCairo copy() {§return new AliFromCairo(this);§}§}§class AliFromCairoReplacementEffect extends ReplacementEffectImpl {§public AliFromCairoReplacementEffect() {§super(Duration.WhileOnBattlefield, Outcome.Benefit);§staticText = "Damage that would reduce your life total to less than 1 reduces it to 1 instead";§}§public AliFromCairoReplacementEffect(final AliFromCairoReplacementEffect effect) {§super(effect);§}§@Override§public AliFromCairoReplacementEffect copy() {§return new AliFromCairoReplacementEffect(this);§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.DAMAGE_CAUSES_LIFE_LOSS;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§Permanent permanent = game.getPermanent(source.getSourceId());§if (permanent != null) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null§&& (controller.getLife() > 0) &&(controller.getLife() - event.getAmount()) < 1§&& event.getPlayerId().equals(controller.getId())§) {§return true;§}§}§return false;§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§event.setAmount(controller.getLife() - 1);§}§return false;§}§}§
public class DiamondValley extends CardImpl {§public DiamondValley(UUID ownerId) {§super(ownerId, 87, "Diamond Valley", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "ARN";§Effect effect = new GainLifeEffect(new SacrificeCostCreaturesToughness());§effect.setText("You gain life equal to the sacrificed creature's toughness");§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new TapSourceCost());§ability.addCost(new SacrificeTargetCost(new TargetControlledCreaturePermanent()));§this.addAbility(ability);§}§public DiamondValley(final DiamondValley card) {§super(card);§}§@Override§public DiamondValley copy() {§return new DiamondValley(this);§}§}§
public class ElHajjaj extends CardImpl {§public ElHajjaj(UUID ownerId) {§super(ownerId, 2, "El-Hajjaj", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{B}{B}");§this.expansionSetCode = "ARN";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new DealsDamageGainLifeSourceTriggeredAbility());§}§public ElHajjaj(final ElHajjaj card) {§super(card);§}§@Override§public ElHajjaj copy() {§return new ElHajjaj(this);§}§}§
public class FishliverOil1 extends CardImpl {§public FishliverOil1(UUID ownerId) {§super(ownerId, 17, "Fishliver Oil", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{U}");§this.expansionSetCode = "ARN";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD,§new GainAbilityAttachedEffect(new IslandwalkAbility(), AttachmentType.AURA, Duration.WhileOnBattlefield)));§}§public FishliverOil1(final FishliverOil1 card) {§super(card);§}§@Override§public FishliverOil1 copy() {§return new FishliverOil1(this);§}§}§
public class IslandOfWakWak extends CardImpl {§private static final FilterCreaturePermanent filterWithFlying = new FilterCreaturePermanent("creature with flying");§static {§filterWithFlying.add(new AbilityPredicate(FlyingAbility.class));§}§public IslandOfWakWak(UUID ownerId) {§super(ownerId, 89, "Island of Wak-Wak", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "ARN";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new IslandOfWakWakEffect(), new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent(filterWithFlying));§this.addAbility(ability);§}§public IslandOfWakWak(final IslandOfWakWak card) {§super(card);§}§@Override§public IslandOfWakWak copy() {§return new IslandOfWakWak(this);§}§}§class IslandOfWakWakEffect extends OneShotEffect {§public IslandOfWakWakEffect() {§super(Outcome.Detriment);§staticText = "The power of target creature with flying becomes 0 until end of turn";§}§public IslandOfWakWakEffect(final IslandOfWakWakEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent targetCreature = game.getPermanent(source.getFirstTarget());§if (targetCreature != null) {§MageInt toughness = targetCreature.getToughness();§game.addEffect(new SetPowerToughnessTargetEffect(0, toughness.getValue(), Duration.EndOfTurn), source);§return true;§}§return false;§}§@Override§public Effect copy() {§return new IslandOfWakWakEffect(this);§}§}§
public class JuzamDjinn extends CardImpl {§public JuzamDjinn(UUID ownerId) {§super(ownerId, 9, "Juzam Djinn", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{B}{B}");§this.expansionSetCode = "ARN";§this.subtype.add("Djinn");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(new BeginningOfUpkeepTriggeredAbility(new DamageControllerEffect(1), TargetController.YOU, false));§}§public JuzamDjinn(final JuzamDjinn card) {§super(card);§}§@Override§public JuzamDjinn copy() {§return new JuzamDjinn(this);§}§}§
public class KingSuleiman extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("Djinn or Efreet");§static {§filter.add( Predicates.or(§new SubtypePredicate("Djinn"),§new SubtypePredicate("Efreet")));§}§public KingSuleiman(UUID ownerId) {§super(ownerId, 61, "King Suleiman", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "ARN";§this.subtype.add("Human");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DestroyTargetEffect(), new TapSourceCost());§ability.addTarget(new TargetPermanent(filter));§this.addAbility(ability);§}§public KingSuleiman(final KingSuleiman card) {§super(card);§}§@Override§public KingSuleiman copy() {§return new KingSuleiman(this);§}§}§
public class MerchantShip extends CardImpl {§public MerchantShip(UUID ownerId) {§super(ownerId, 23, "Merchant Ship", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{U}");§this.expansionSetCode = "ARN";§this.subtype.add("Human");§this.power = new MageInt(0);§this.toughness = new MageInt(2);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new CantAttackUnlessDefenderControllsPermanent(new FilterLandPermanent("Island", "an Island"))));§this.addAbility(new AttacksAndIsNotBlockedTriggeredAbility(new GainLifeEffect(2)));§this.addAbility(new ControlsPermanentsControllerTriggeredAbility(§new FilterLandPermanent("Island", "no Islands"), Filter.ComparisonType.Equal, 0,§new SacrificeSourceEffect()));§}§public MerchantShip(final MerchantShip card) {§super(card);§}§@Override§public MerchantShip copy() {§return new MerchantShip(this);§}§}§
public class NafsAsp extends CardImpl {§public NafsAsp(UUID ownerId) {§super(ownerId, 36, "Nafs Asp", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{G}");§this.expansionSetCode = "ARN";§this.subtype.add("Snake");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new DealsDamageToAPlayerTriggeredAbility(new UnlessPaysDelayedEffect(§new ManaCostsImpl("{1}"), new LoseLifeTargetEffect(1), PhaseStep.DRAW, true,§"that player loses 1 life at the beginning of his or her next draw step unless he or she pays {1} before that draw step."),§false, true));§}§public NafsAsp(final NafsAsp card) {§super(card);§}§@Override§public NafsAsp copy() {§return new NafsAsp(this);§}§}§
public class OldManOfTheSea extends CardImpl {§public OldManOfTheSea(UUID ownerId) {§super(ownerId, 24, "Old Man of the Sea", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{U}{U}");§this.expansionSetCode = "ARN";§this.subtype.add("Djinn");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(new SkipUntapOptionalAbility());§FilterCreaturePermanent controllableCreatures = new FilterCreaturePermanent("creature with power less than or equal to Old Man of the Sea's power");§controllableCreatures.add(new PowerLowerEqualSourcePredicate(this.getId()));§ConditionalContinuousEffect effect = new ConditionalContinuousEffect(§new OldManOfTheSeaGainControlTargetEffect(Duration.Custom, true), new CompoundCondition(SourceTappedCondition.getInstance(), new SourcePowerGreaterEqualTargetCondition()),§"Gain control of target creature with power less than or equal to {this}'s power for as long as {this} remains tapped and that creature's power remains less than or equal to {this}'s power");§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent(controllableCreatures));§this.addAbility(ability);§this.addAbility(new OldManOfTheSeaStateBasedTriggeredAbility());§}§public OldManOfTheSea(final OldManOfTheSea card) {§super(card);§}§@Override§public OldManOfTheSea copy() {§return new OldManOfTheSea(this);§}§}§class OldManOfTheSeaGainControlTargetEffect extends GainControlTargetEffect {§public OldManOfTheSeaGainControlTargetEffect(Duration duration, boolean fixedControl) {§super(duration, fixedControl);§}§public OldManOfTheSeaGainControlTargetEffect(final OldManOfTheSeaGainControlTargetEffect effect) {§super(effect);§}§@Override§public void init(Ability source, Game game) {§super.init(source, game);§game.getState().setValue("target" + source.getSourceId(), getTargetPointer().getFirst(game, source));§}§@Override§public OldManOfTheSeaGainControlTargetEffect copy() {§return new OldManOfTheSeaGainControlTargetEffect(this);§}§}§/*§used a state based triggered effect here (not going to stack, so running hidden) to compare power of the controlled§creature to Old Man of the seas power. It's not possible to do this as condition of continuous effect, because the§time the effect checks its condition, the layered effects that modify power are not applied yet.§result is save to a state value to be available for the condition of the continuous effect§*/§class OldManOfTheSeaStateBasedTriggeredAbility extends StateTriggeredAbility {§public OldManOfTheSeaStateBasedTriggeredAbility() {§super(Zone.BATTLEFIELD, new InfoEffect(""));§this.setRuleVisible(false);§this.usesStack = false;§}§public OldManOfTheSeaStateBasedTriggeredAbility(final OldManOfTheSeaStateBasedTriggeredAbility ability) {§super(ability);§}§@Override§public OldManOfTheSeaStateBasedTriggeredAbility copy() {§return new OldManOfTheSeaStateBasedTriggeredAbility(this);§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§Permanent sourcePermanent = game.getPermanent(getSourceId());§if (sourcePermanent != null && sourcePermanent.isTapped()) {§UUID controlledCreatureId = (UUID) game.getState().getValue("target" + getSourceId());§if (controlledCreatureId != null) {§Permanent controlledCreature = game.getPermanent(controlledCreatureId);§if (controlledCreature != null) {§if (controlledCreature.getPower().getValue() > sourcePermanent.getPower().getValue()) {§game.getState().setValue("powerCondition" + getSourceId(), Boolean.TRUE);§}§}§}§}§return false;§}§}§class SourcePowerGreaterEqualTargetCondition implements Condition {§@Override§public boolean apply(Game game, Ability source) {§Object object = game.getState().getValue("powerCondition" + source.getSourceId());§if (object != null && (Boolean) object) {§game.getState().setValue("powerCondition" + source.getSourceId(), Boolean.FALSE);§game.getState().setValue("target" + source.getSourceId(), null);§return false;§}§return true;§}§}§class PowerLowerEqualSourcePredicate implements ObjectPlayerPredicate<ObjectPlayer<Permanent>> {§UUID sourceId;§public PowerLowerEqualSourcePredicate(UUID sourceId) {§this.sourceId = sourceId;§}§@Override§public boolean apply(ObjectPlayer<Permanent> input, Game game) {§Permanent sourcePermanent = game.getPermanent(sourceId);§Permanent permanent = input.getObject();§if (permanent != null && sourcePermanent != null) {§if (permanent.getPower().getValue() <= sourcePermanent.getPower().getValue()) {§return true;§}§}§return false;§}§@Override§public String toString() {§return "creature with power less than or equal to {source}'s power";§}§}§
public class RukhEgg1 extends CardImpl {§public RukhEgg1(UUID ownerId) {§super(ownerId, 52, "Rukh Egg", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{R}");§this.expansionSetCode = "ARN";§this.subtype.add("Bird");§this.power = new MageInt(0);§this.toughness = new MageInt(3);§Effect effect = new CreateDelayedTriggeredAbilityEffect(new AtTheBeginOfNextEndStepDelayedTriggeredAbility(new CreateTokenEffect(new BirdToken())));§effect.setText("put a 4/4 red Bird creature token with flying onto the battlefield at the beginning of the next end step");§Ability ability = new DiesTriggeredAbility(effect);§this.addAbility(ability);§}§public RukhEgg1(final RukhEgg1 card) {§super(card);§}§@Override§public RukhEgg1 copy() {§return new RukhEgg1(this);§}§}§class BirdToken extends Token {§public BirdToken() {§this("ARN"); §
public class StoneThrowingDevils1 extends CardImpl {§public StoneThrowingDevils1(UUID ownerId) {§super(ownerId, 14, "Stone-Throwing Devils", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{B}");§this.expansionSetCode = "ARN";§this.subtype.add("Devil");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(FirstStrikeAbility.getInstance());§}§public StoneThrowingDevils1(final StoneThrowingDevils1 card) {§super(card);§}§@Override§public StoneThrowingDevils1 copy() {§return new StoneThrowingDevils1(this);§}§}§
public class UnstableMutation extends CardImpl {§public UnstableMutation(UUID ownerId) {§super(ownerId, 28, "Unstable Mutation", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{U}");§this.expansionSetCode = "ARN";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(3, 3)));§this.addAbility(new BeginningOfUpkeepTriggeredAbility(new AddCountersAttachedEffect(CounterType.M1M1.createInstance(), "that creature"),§TargetController.CONTROLLER_ATTACHED_TO, false));§}§public UnstableMutation(final UnstableMutation card) {§super(card);§}§@Override§public UnstableMutation copy() {§return new UnstableMutation(this);§}§}§
public class AvatarOfWoe extends CardImpl {§public AvatarOfWoe(UUID ownerId) {§super(ownerId, 9, "Avatar of Woe", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{6}{B}{B}");§this.expansionSetCode = "ARC";§this.subtype.add("Avatar");§this.power = new MageInt(6);§this.toughness = new MageInt(5);§this.addAbility(new SimpleStaticAbility(Zone.STACK, new AvatarOfWoeCostReductionEffect()));§this.addAbility(FearAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DestroyTargetEffect(true), new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public AvatarOfWoe(final AvatarOfWoe card) {§super(card);§}§@Override§public AvatarOfWoe copy() {§return new AvatarOfWoe(this);§}§}§class AvatarOfWoeCostReductionEffect extends CostModificationEffectImpl {§AvatarOfWoeCostReductionEffect() {§super(Duration.Custom, Outcome.Benefit, CostModificationType.REDUCE_COST);§staticText = "If there are ten or more creature cards total in all graveyards, {this} costs {6} less to cast";§}§AvatarOfWoeCostReductionEffect(final AvatarOfWoeCostReductionEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source, Ability abilityToModify) {§SpellAbility spellAbility = (SpellAbility) abilityToModify;§Mana mana = spellAbility.getManaCostsToPay().getMana();§if (mana.getGeneric() > 0) {§int newCount = mana.getGeneric() - 6;§if (newCount < 0) {§newCount = 0;§}§mana.setGeneric(newCount);§spellAbility.getManaCostsToPay().load(mana.toString());§return true;§}§return false;§}§@Override§public boolean applies(Ability abilityToModify, Ability source, Game game) {§return abilityToModify.getSourceId().equals(source.getSourceId())§&& (abilityToModify instanceof SpellAbility)§&& new CardsInAllGraveyardsCount(new FilterCreatureCard()).calculate(game, source, this) >= 10;§}§@Override§public AvatarOfWoeCostReductionEffect copy() {§return new AvatarOfWoeCostReductionEffect(this);§}§}§
public class BatteringCraghorn extends CardImpl {§public BatteringCraghorn(UUID ownerId) {§super(ownerId, 30, "Battering Craghorn", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{R}{R}");§this.expansionSetCode = "ARC";§this.subtype.add("Goat");§this.subtype.add("Beast");§this.power = new MageInt(3);§this.toughness = new MageInt(1);§this.addAbility(FirstStrikeAbility.getInstance());§this.addAbility(new MorphAbility(this, new ManaCostsImpl("{1}{R}{R}")));§}§public BatteringCraghorn(final BatteringCraghorn card) {§super(card);§}§@Override§public BatteringCraghorn copy() {§return new BatteringCraghorn(this);§}§}§
public class DragonBreath extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("a creature with converted mana cost 6 or greater");§static {§filter.add(new ConvertedManaCostPredicate(ComparisonType.GreaterThan, 5));§}§public DragonBreath(UUID ownerId) {§super(ownerId, 33, "Dragon Breath", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{R}");§this.expansionSetCode = "ARC";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(HasteAbility.getInstance(), AttachmentType.AURA)));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(1, 0, Duration.EndOfTurn), new ColoredManaCost(ColoredManaSymbol.R)));§this.addAbility(new EntersBattlefieldAllTriggeredAbility(Zone.GRAVEYARD, new DragonBreathEffect(), filter, true, SetTargetPointer.PERMANENT, null));§}§public DragonBreath(final DragonBreath card) {§super(card);§}§@Override§public DragonBreath copy() {§return new DragonBreath(this);§}§}§class DragonBreathEffect extends OneShotEffect {§DragonBreathEffect() {§super(Outcome.Benefit);§this.staticText = "return {this} from your graveyard to the battlefield attached to that creature";§}§DragonBreathEffect(final DragonBreathEffect effect) {§super(effect);§}§@Override§public DragonBreathEffect copy() {§return new DragonBreathEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Card sourceCard = (Card) source.getSourceObjectIfItStillExists(game);§Permanent permanent = game.getPermanent(this.getTargetPointer().getFirst(game, source));§Player controller = game.getPlayer(source.getControllerId());§if (sourceCard != null && permanent != null && controller != null) {§game.getState().setValue("attachTo:" + sourceCard.getId(), permanent);§if (controller.moveCards(sourceCard, Zone.BATTLEFIELD, source, game)) {§permanent.addAttachment(sourceCard.getId(), game);§}§return true;§}§return false;§}§}§
public class ImperialHellkite extends CardImpl {§public ImperialHellkite(UUID ownerId) {§super(ownerId, 42, "Imperial Hellkite", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}{R}{R}");§this.expansionSetCode = "ARC";§this.subtype.add("Dragon");§this.power = new MageInt(6);§this.toughness = new MageInt(6);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new MorphAbility(this, new ManaCostsImpl("{6}{R}{R}")));§Effect effect = new SearchLibraryPutInHandEffect(new TargetCardInLibrary(0, 1, new FilterBySubtypeCard("Dragon")), true, true);§effect.setText("you may search your library for a Dragon card, reveal it, and put it into your hand. If you do, shuffle your library");§this.addAbility(new TurnedFaceUpSourceTriggeredAbility(effect));§}§public ImperialHellkite(final ImperialHellkite card) {§super(card);§}§@Override§public ImperialHellkite copy() {§return new ImperialHellkite(this);§}§}§
public class MakeshiftMannequin extends CardImpl {§public MakeshiftMannequin(UUID ownerId) {§super(ownerId, 20, "Makeshift Mannequin", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{3}{B}");§this.expansionSetCode = "ARC";§this.getSpellAbility().addEffect(new MakeshiftMannequinEffect());§this.getSpellAbility().addTarget(new TargetCardInYourGraveyard(new FilterCreatureCard("creature card from your graveyard")));§}§public MakeshiftMannequin(final MakeshiftMannequin card) {§super(card);§}§@Override§public MakeshiftMannequin copy() {§return new MakeshiftMannequin(this);§}§}§class MakeshiftMannequinEffect extends OneShotEffect {§MakeshiftMannequinEffect() {§super(Outcome.PutCreatureInPlay);§this.staticText = "Return target creature card from your graveyard to the battlefield with a mannequin counter on it. For as long as that creature has a mannequin counter on it, it has \"When this creature becomes the target of a spell or ability, sacrifice it.\"";§}§MakeshiftMannequinEffect(final MakeshiftMannequinEffect effect) {§super(effect);§}§@Override§public MakeshiftMannequinEffect copy() {§return new MakeshiftMannequinEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§UUID cardId = this.getTargetPointer().getFirst(game, source);§Card card = controller.getGraveyard().get(cardId, game);§if (card != null) {§Counters counters = new Counters();§counters.addCounter(CounterType.MANNEQUIN.createInstance());§game.setEnterWithCounters(cardId, counters);§if (controller.moveCards(card, Zone.BATTLEFIELD, source, game)) {§Permanent permanent = game.getPermanent(cardId);§if (permanent != null) {§ContinuousEffect gainedEffect = new MakeshiftMannequinGainAbilityEffect();§gainedEffect.setTargetPointer(new FixedTarget(permanent, game));§game.addEffect(gainedEffect, source);§}§}§return true;§}§}§return false;§}§}§class MakeshiftMannequinGainAbilityEffect extends ContinuousEffectImpl {§MakeshiftMannequinGainAbilityEffect() {§super(Duration.Custom, Layer.AbilityAddingRemovingEffects_6, SubLayer.NA, Outcome.AddAbility);§}§MakeshiftMannequinGainAbilityEffect(final MakeshiftMannequinGainAbilityEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getPermanent(this.getTargetPointer().getFirst(game, source));§if (permanent != null) {§permanent.addAbility(new BecomesTargetTriggeredAbility(new SacrificeSourceEffect()), source.getSourceId(), game);§return true;§}§return false;§}§@Override§public boolean isInactive(Ability source, Game game) {§Permanent permanent = game.getPermanent(this.getTargetPointer().getFirst(game, source));§return permanent == null || permanent.getCounters().getCount(CounterType.MANNEQUIN) < 1;§}§@Override§public MakeshiftMannequinGainAbilityEffect copy() {§return new MakeshiftMannequinGainAbilityEffect(this);§}§}§
public class NantukoMonastery extends CardImpl {§public NantukoMonastery(UUID ownerId) {§super(ownerId, 131, "Nantuko Monastery", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "ARC";§this.addAbility(new ColorlessManaAbility());§Ability ability = new ConditionalActivatedAbility(Zone.BATTLEFIELD, new BecomesCreatureSourceEffect(§new NantukoMonasteryToken(), "land", Duration.EndOfTurn), new ManaCostsImpl<>("{G}{W}"),§new CardsInControllerGraveCondition(7));§ability.setAbilityWord(AbilityWord.THRESHOLD);§this.addAbility(ability);§}§public NantukoMonastery(final NantukoMonastery card) {§super(card);§}§@Override§public NantukoMonastery copy() {§return new NantukoMonastery(this);§}§}§class NantukoMonasteryToken extends Token {§public NantukoMonasteryToken() {§super("", "4/4 green and white Insect Monk creature with first strike");§cardType.add(CardType.CREATURE);§subtype.add("Insect");§subtype.add("Monk");§color.setGreen(true);§color.setWhite(true);§power = new MageInt(4);§toughness = new MageInt(4);§this.addAbility(FirstStrikeAbility.getInstance());§}§}§
public class SpinIntoMyth extends CardImpl {§public SpinIntoMyth(UUID ownerId) {§super(ownerId, 8, "Spin into Myth", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{4}{U}");§this.expansionSetCode = "ARC";§this.getSpellAbility().addEffect(new PutOnLibraryTargetEffect(true));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§Effect effect = new FatesealEffect(2);§effect.setText(", then fateseal 2. <i>(To fateseal 2, look at the top two cards of an opponent's library, then put any number of them on the bottom of that player's library and the rest on top in any order.)</i>");§this.getSpellAbility().addEffect(effect);§}§public SpinIntoMyth(final SpinIntoMyth card) {§super(card);§}§@Override§public SpinIntoMyth copy() {§return new SpinIntoMyth(this);§}§}§
public class VampiricDragon extends CardImpl {§public VampiricDragon(UUID ownerId) {§super(ownerId, 99, "Vampiric Dragon", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{6}{B}{R}");§this.expansionSetCode = "ARC";§this.subtype.add("Vampire");§this.subtype.add("Dragon");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new DiesAndDealtDamageThisTurnTriggeredAbility(new AddCountersSourceEffect(CounterType.P1P1.createInstance()), false));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(1), new ManaCostsImpl("{1}{R}"));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public VampiricDragon(final VampiricDragon card) {§super(card);§}§@Override§public VampiricDragon copy() {§return new VampiricDragon(this);§}§}§
public class YavimayaDryad extends CardImpl {§private static final FilterLandCard filter = new FilterLandCard("a Forest card");§static {§filter.add(new SubtypePredicate("Forest"));§}§public YavimayaDryad(UUID ownerId) {§super(ownerId, 75, "Yavimaya Dryad", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{G}{G}");§this.expansionSetCode = "ARC";§this.subtype.add("Dryad");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new ForestwalkAbility());§Ability ability = new EntersBattlefieldTriggeredAbility(new YavimayaDryadEffect(new TargetCardInLibrary(filter)), true);§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§}§public YavimayaDryad(final YavimayaDryad card) {§super(card);§}§@Override§public YavimayaDryad copy() {§return new YavimayaDryad(this);§}§}§class YavimayaDryadEffect extends SearchEffect {§public YavimayaDryadEffect(TargetCardInLibrary target) {§super(target, Outcome.PutLandInPlay);§staticText = "you may search your library for a Forest card and put it onto the battlefield tapped under target player's control. If you do, shuffle your library";§}§public YavimayaDryadEffect(final YavimayaDryadEffect effect) {§super(effect);§}§@Override§public YavimayaDryadEffect copy() {§return new YavimayaDryadEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§Player targetPlayer = game.getPlayer(getTargetPointer().getFirst(game, source));§if (controller == null || targetPlayer == null) {§return false;§}§if (controller.searchLibrary(target, game)) {§if (target.getTargets().size() > 0) {§targetPlayer.moveCards(new CardsImpl(target.getTargets()).getCards(game),§Zone.BATTLEFIELD, source, game, true, false, false, null);§}§controller.shuffleLibrary(game);§return true;§}§return false;§}§}§
public class AbundantGrowth extends CardImpl {§public AbundantGrowth(UUID ownerId) {§super(ownerId, 167, "Abundant Growth", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{G}");§this.expansionSetCode = "AVR";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetLandPermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.Benefit));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new EntersBattlefieldTriggeredAbility(new DrawCardSourceControllerEffect(1), false));§Ability gainedAbility = new AnyColorManaAbility(new TapSourceCost());§Effect effect = new GainAbilityAttachedEffect(gainedAbility, AttachmentType.AURA);§effect.setText("Enchanted land has \"{T}: Add one mana of any color to your mana pool.\"");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, effect));§}§public AbundantGrowth(final AbundantGrowth card) {§super(card);§}§@Override§public AbundantGrowth copy() {§return new AbundantGrowth(this);§}§}§
public class Aggravate extends CardImpl {§public Aggravate(UUID ownerId) {§super(ownerId, 125, "Aggravate", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{3}{R}{R}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new AggravateEffect());§this.getSpellAbility().addTarget(new TargetPlayer());§this.getSpellAbility().addEffect(new AggravateRequirementEffect());§this.getSpellAbility().addWatcher(new DamagedByWatcher());§}§public Aggravate(final Aggravate card) {§super(card);§}§@Override§public Aggravate copy() {§return new Aggravate(this);§}§}§class AggravateEffect extends OneShotEffect {§public AggravateEffect() {§super(Outcome.Damage);§this.staticText = "{this} deals 1 damage to each creature target player controls";§}§public AggravateEffect(final AggravateEffect effect) {§super(effect);§}§@Override§public AggravateEffect copy() {§return new AggravateEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getFirstTarget());§if (player != null) {§FilterCreaturePermanent filter = new FilterCreaturePermanent();§filter.add(new ControllerIdPredicate(player.getId()));§List<Permanent> creatures = game.getBattlefield().getActivePermanents(filter, source.getControllerId(), source.getSourceId(), game);§for (Permanent creature : creatures) {§creature.damage(1, source.getSourceId(), game, false, true);§}§return true;§}§return false;§}§}§class AggravateRequirementEffect extends RequirementEffect {§public AggravateRequirementEffect() {§super(Duration.EndOfTurn);§this.staticText = "Each creature dealt damage this way attacks this turn if able";§}§public AggravateRequirementEffect(final AggravateRequirementEffect effect) {§super(effect);§}§@Override§public AggravateRequirementEffect copy() {§return new AggravateRequirementEffect(this);§}§@Override§public boolean applies(Permanent permanent, Ability source, Game game) {§DamagedByWatcher watcher = (DamagedByWatcher) game.getState().getWatchers().get("DamagedByWatcher", source.getSourceId());§if (watcher != null) {§return watcher.wasDamaged(permanent, game);§}§return false;§}§@Override§public boolean mustAttack(Game game) {§return true;§}§@Override§public boolean mustBlock(Game game) {§return false;§}§}§
public class AlchemistsApprentice extends CardImpl {§public AlchemistsApprentice(UUID ownerId) {§super(ownerId, 42, "Alchemist's Apprentice", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{U}");§this.expansionSetCode = "AVR";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new DrawCardSourceControllerEffect(1),§new SacrificeSourceCost()));§}§public AlchemistsApprentice(final AlchemistsApprentice card) {§super(card);§}§@Override§public AlchemistsApprentice copy() {§return new AlchemistsApprentice(this);§}§}§
public class AlchemistsRefuge extends CardImpl {§private static final FilterCard filter = new FilterCard("nonland cards");§static {§filter.add(Predicates.not(new CardTypePredicate(CardType.LAND)));§}§public AlchemistsRefuge(UUID ownerId) {§super(ownerId, 225, "Alchemist's Refuge", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "AVR";§this.addAbility(new ColorlessManaAbility());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD,§new AddContinuousEffectToGame(new CastAsThoughItHadFlashAllEffect(Duration.EndOfTurn, filter)),§new CompositeCost(new ManaCostsImpl("{G}{U}"), new TapSourceCost(), "{G}{U}, {T}")));§}§public AlchemistsRefuge(final AlchemistsRefuge card) {§super(card);§}§@Override§public AlchemistsRefuge copy() {§return new AlchemistsRefuge(this);§}§}§
public class AmassTheComponents extends CardImpl {§public AmassTheComponents(UUID ownerId) {§super(ownerId, 43, "Amass the Components", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{3}{U}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new AmassTheComponentsEffect());§}§public AmassTheComponents(final AmassTheComponents card) {§super(card);§}§@Override§public AmassTheComponents copy() {§return new AmassTheComponents(this);§}§}§class AmassTheComponentsEffect extends OneShotEffect {§public AmassTheComponentsEffect() {§super(Outcome.DrawCard);§this.staticText = "Draw three cards, then put a card from your hand on the bottom of your library";§}§public AmassTheComponentsEffect(final AmassTheComponentsEffect effect) {§super(effect);§}§@Override§public AmassTheComponentsEffect copy() {§return new AmassTheComponentsEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player == null) {§return false;§}§player.drawCards(3, game);§if (player.getHand().size() > 0) {§FilterCard filter = new FilterCard("card from your hand to put on the bottom of your library");§TargetCard target = new TargetCard(Zone.HAND, filter);§if (player.choose(Outcome.Detriment, player.getHand(), target, game)) {§Card card = player.getHand().get(target.getFirstTarget(), game);§if (card != null) {§player.removeFromHand(card, game);§card.moveToZone(Zone.LIBRARY, source.getSourceId(), game, false);§}§}§}§return true;§}§}§
public class AngelicArmaments extends CardImpl {§public AngelicArmaments(UUID ownerId) {§super(ownerId, 212, "Angelic Armaments", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "AVR";§this.subtype.add("Equipment");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEquippedEffect(2, 2)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(FlyingAbility.getInstance(), AttachmentType.EQUIPMENT)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new AddCardColorAttachedEffect(ObjectColor.WHITE, Duration.WhileOnBattlefield, AttachmentType.EQUIPMENT)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new AddCardSubtypeAttachedEffect("Angel", Duration.WhileOnBattlefield, AttachmentType.EQUIPMENT)));§this.addAbility(new EquipAbility(Outcome.BoostCreature, new GenericManaCost(4)));§}§public AngelicArmaments(final AngelicArmaments card) {§super(card);§}§@Override§public AngelicArmaments copy() {§return new AngelicArmaments(this);§}§}§
public class AngelOfGlorysRise extends CardImpl {§public AngelOfGlorysRise(UUID ownerId) {§super(ownerId, 1, "Angel of Glory's Rise", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}{W}{W}");§this.expansionSetCode = "AVR";§this.subtype.add("Angel");§this.power = new MageInt(4);§this.toughness = new MageInt(6);§this.addAbility(FlyingAbility.getInstance());§EntersBattlefieldTriggeredAbility ability = new EntersBattlefieldTriggeredAbility(new AngelOfGlorysRiseEffect());§this.addAbility(ability);§}§public AngelOfGlorysRise(final AngelOfGlorysRise card) {§super(card);§}§@Override§public AngelOfGlorysRise copy() {§return new AngelOfGlorysRise(this);§}§}§class AngelOfGlorysRiseEffect extends OneShotEffect {§private static final FilterCreatureCard filterHuman = new FilterCreatureCard();§private static final FilterCreaturePermanent filterZombie = new FilterCreaturePermanent();§static {§filterZombie.add(new SubtypePredicate("Zombie"));§filterHuman.add(new SubtypePredicate("Human"));§}§public AngelOfGlorysRiseEffect() {§super(Outcome.PutCreatureInPlay);§staticText = "Exile all Zombies, then return all Human creature cards from your graveyard to the battlefield";§}§public AngelOfGlorysRiseEffect(final AngelOfGlorysRiseEffect effect) {§super(effect);§}§@Override§public AngelOfGlorysRiseEffect copy() {§return new AngelOfGlorysRiseEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§for (Permanent zombie : game.getBattlefield().getActivePermanents(filterZombie, source.getControllerId(), source.getSourceId(), game)) {§zombie.moveToExile(source.getSourceId(), zombie.getName(), source.getSourceId(), game);§}§for (Card human : player.getGraveyard().getCards(filterHuman, game)) {§human.putOntoBattlefield(game, Zone.GRAVEYARD, source.getSourceId(), source.getControllerId());§}§}§return true;§}§}§
public class AngelOfJubilation extends CardImpl {§private static final FilterCreaturePermanent filterNonBlack = new FilterCreaturePermanent("nonblack creatures");§static {§filterNonBlack.add(Predicates.not(new ColorPredicate(ObjectColor.BLACK)));§}§public AngelOfJubilation(UUID ownerId) {§super(ownerId, 2, "Angel of Jubilation", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{W}{W}{W}");§this.expansionSetCode = "AVR";§this.subtype.add("Angel");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostControlledEffect(1, 1, Duration.WhileOnBattlefield, filterNonBlack, true)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new AngelOfJubilationEffect(Duration.WhileOnBattlefield)));§}§public AngelOfJubilation(final AngelOfJubilation card) {§super(card);§}§@Override§public AngelOfJubilation copy() {§return new AngelOfJubilation(this);§}§}§class AngelOfJubilationEffect extends ContinuousEffectImpl {§public AngelOfJubilationEffect(Duration duration) {§super(duration, Layer.PlayerEffects, SubLayer.NA, Outcome.Detriment);§staticText = "Players can't pay life or sacrifice creatures to cast spells or activate abilities";§}§public AngelOfJubilationEffect(final AngelOfJubilationEffect effect) {§super(effect);§}§@Override§public AngelOfJubilationEffect copy() {§return new AngelOfJubilationEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§for (Player player : game.getPlayers().values()) {§player.setCanPayLifeCost(false);§player.setCanPaySacrificeCost(false);§}§return true;§}§}§
public class AngelsTomb extends CardImpl {§public AngelsTomb(UUID ownerId) {§super(ownerId, 211, "Angel's Tomb", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "AVR";§this.addAbility(new CreatureEntersBattlefieldTriggeredAbility(new BecomesCreatureSourceEffect(new AngelTombToken(), "", Duration.EndOfTurn), true));§}§public AngelsTomb(final AngelsTomb card) {§super(card);§}§@Override§public AngelsTomb copy() {§return new AngelsTomb(this);§}§}§class AngelTombToken extends Token {§public AngelTombToken() {§super("", "a 3/3 white Angel artifact creature with flying");§cardType.add(CardType.ARTIFACT);§cardType.add(CardType.CREATURE);§color.setWhite(true);§subtype.add("Angel");§power = new MageInt(3);§toughness = new MageInt(3);§addAbility(FlyingAbility.getInstance());§}§}§
public class AppetiteForBrains extends CardImpl {§private static final FilterCard filter = new FilterCard("a card from it with converted mana cost 4 or greater");§static {§filter.add(new ConvertedManaCostPredicate(Filter.ComparisonType.GreaterThan, 3));§}§public AppetiteForBrains(UUID ownerId) {§super(ownerId, 84, "Appetite for Brains", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{B}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new ExileCardYouChooseTargetOpponentEffect(filter));§this.getSpellAbility().addTarget(new TargetOpponent());§}§public AppetiteForBrains(final AppetiteForBrains card) {§super(card);§}§@Override§public AppetiteForBrains copy() {§return new AppetiteForBrains(this);§}§}§
public class ArcaneMelee extends CardImpl {§public ArcaneMelee(UUID ownerId) {§super(ownerId, 44, "Arcane Melee", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{4}{U}");§this.expansionSetCode = "AVR";§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new ArcaneMeleeCostReductionEffect()));§}§public ArcaneMelee(final ArcaneMelee card) {§super(card);§}§@Override§public ArcaneMelee copy() {§return new ArcaneMelee(this);§}§}§class ArcaneMeleeCostReductionEffect extends CostModificationEffectImpl {§ArcaneMeleeCostReductionEffect ( ) {§super(Duration.WhileOnBattlefield, Outcome.Benefit, CostModificationType.REDUCE_COST);§staticText = "Instant and sorcery spells cost {2} less to cast";§}§ArcaneMeleeCostReductionEffect(ArcaneMeleeCostReductionEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source, Ability abilityToModify) {§SpellAbility spellAbility = (SpellAbility) abilityToModify;§CardUtil.adjustCost(spellAbility, 2);§return true;§}§@Override§public boolean applies(Ability abilityToModify, Ability source, Game game) {§if ( abilityToModify instanceof SpellAbility || abilityToModify instanceof FlashbackAbility) {§Card sourceCard = game.getCard(((SpellAbility)abilityToModify).getSourceId());§if ( sourceCard != null && (sourceCard.getCardType().contains(CardType.INSTANT) || sourceCard.getCardType().contains(CardType.SORCERY))) {§return true;§}§}§return false;§}§@Override§public ArcaneMeleeCostReductionEffect copy() {§return new ArcaneMeleeCostReductionEffect(this);§}§}§
public class Archangel extends CardImpl {§public Archangel(UUID ownerId) {§super(ownerId, 5, "Archangel", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{5}{W}{W}");§this.expansionSetCode = "AVR";§this.subtype.add("Angel");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(VigilanceAbility.getInstance());§}§public Archangel(final Archangel card) {§super(card);§}§@Override§public Archangel copy() {§return new Archangel(this);§}§}§
public class ArchwingDragon extends CardImpl {§public ArchwingDragon(UUID ownerId) {§super(ownerId, 126, "Archwing Dragon", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{R}{R}");§this.expansionSetCode = "AVR";§this.subtype.add("Dragon");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(HasteAbility.getInstance());§this.addAbility(new OnEventTriggeredAbility(GameEvent.EventType.END_TURN_STEP_PRE, "beginning of the end step", new ReturnToHandSourceEffect(true), false));§}§public ArchwingDragon(final ArchwingDragon card) {§super(card);§}§@Override§public ArchwingDragon copy() {§return new ArchwingDragon(this);§}§}§
public class AvacynAngelOfHope extends CardImpl {§public AvacynAngelOfHope(UUID ownerId) {§super(ownerId, 6, "Avacyn, Angel of Hope", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{5}{W}{W}{W}");§this.expansionSetCode = "AVR";§this.supertype.add("Legendary");§this.subtype.add("Angel");§this.power = new MageInt(8);§this.toughness = new MageInt(8);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(VigilanceAbility.getInstance());§this.addAbility(IndestructibleAbility.getInstance());§FilterControlledPermanent filter = new FilterControlledPermanent("Other permanents you control");§Effect effect = new GainAbilityAllEffect(IndestructibleAbility.getInstance(), Duration.WhileOnBattlefield, filter, true);§effect.setText("Other permanents you control are indestructible");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, effect));§}§public AvacynAngelOfHope(final AvacynAngelOfHope card) {§super(card);§}§@Override§public AvacynAngelOfHope copy() {§return new AvacynAngelOfHope(this);§}§}§
public class BanishingStroke extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("artifact, creature, or enchantment");§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.ARTIFACT),§new CardTypePredicate(CardType.CREATURE),§new CardTypePredicate(CardType.ENCHANTMENT)));§}§public BanishingStroke(UUID ownerId) {§super(ownerId, 7, "Banishing Stroke", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{5}{W}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new PutOnLibraryTargetEffect(false));§this.getSpellAbility().addTarget(new TargetPermanent(filter));§this.addAbility(new MiracleAbility(this, new ManaCostsImpl("{W}")));§}§public BanishingStroke(final BanishingStroke card) {§super(card);§}§@Override§public BanishingStroke copy() {§return new BanishingStroke(this);§}§}§
public class BattleHymn extends CardImpl {§public BattleHymn(UUID ownerId) {§super(ownerId, 128, "Battle Hymn", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{R}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new DynamicManaEffect(Mana.RedMana(1), new PermanentsOnBattlefieldCount(new FilterControlledCreaturePermanent())));§}§public BattleHymn(final BattleHymn card) {§super(card);§}§@Override§public BattleHymn copy() {§return new BattleHymn(this);§}§}§
public class BladedBracers extends CardImpl {§private static final String ruleText = "As long as equipped creature is a Human or an Angel, it has vigilance";§public BladedBracers(UUID ownerId) {§super(ownerId, 213, "Bladed Bracers", Rarity.COMMON, new CardType[]{CardType.ARTIFACT}, "{1}");§this.expansionSetCode = "AVR";§this.subtype.add("Equipment");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEquippedEffect(1, 1)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD,§new ConditionalContinuousEffect(§new GainAbilityAttachedEffect(VigilanceAbility.getInstance(), AttachmentType.EQUIPMENT),§new EquippedHasSubtypeCondition("Human", "Angel"), ruleText)));§this.addAbility(new EquipAbility(Outcome.BoostCreature, new GenericManaCost(2)));§}§public BladedBracers(final BladedBracers card) {§super(card);§}§@Override§public BladedBracers copy() {§return new BladedBracers(this);§}§}§
public class BlessingsOfNature extends CardImpl {§public BlessingsOfNature(UUID ownerId) {§super(ownerId, 168, "Blessings of Nature", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{4}{G}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new DistributeCountersEffect(CounterType.P1P1, 4, false, "any number of target creatures"));§this.getSpellAbility().addTarget(new TargetCreaturePermanentAmount(4));§this.addAbility(new MiracleAbility(this, new ManaCostsImpl("{G}")));§}§public BlessingsOfNature(final BlessingsOfNature card) {§super(card);§}§@Override§public BlessingsOfNature copy() {§return new BlessingsOfNature(this);§}§}§
public class BloodArtist extends CardImpl {§public BloodArtist(UUID ownerId) {§super(ownerId, 86, "Blood Artist", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{B}");§this.expansionSetCode = "AVR";§this.subtype.add("Vampire");§this.power = new MageInt(0);§this.toughness = new MageInt(1);§Ability ability = new DiesThisOrAnotherCreatureTriggeredAbility(new LoseLifeTargetEffect(1), false);§ability.addEffect(new GainLifeEffect(1));§Target target = new TargetPlayer();§ability.addTarget(target);§this.addAbility(ability);§}§public BloodArtist(final BloodArtist card) {§super(card);§}§@Override§public BloodArtist copy() {§return new BloodArtist(this);§}§}§
public class BloodflowConnoisseur extends CardImpl {§public BloodflowConnoisseur(UUID ownerId) {§super(ownerId, 87, "Bloodflow Connoisseur", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{B}");§this.expansionSetCode = "AVR";§this.subtype.add("Vampire");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new AddCountersSourceEffect(CounterType.P1P1.createInstance()), new ManaCostsImpl());§ability.addCost(new SacrificeTargetCost(new TargetControlledCreaturePermanent()));§this.addAbility(ability);§}§public BloodflowConnoisseur(final BloodflowConnoisseur card) {§super(card);§}§@Override§public BloodflowConnoisseur copy() {§return new BloodflowConnoisseur(this);§}§}§
public class BonfireOfTheDamned extends CardImpl {§public BonfireOfTheDamned(UUID ownerId) {§super(ownerId, 129, "Bonfire of the Damned", Rarity.MYTHIC, new CardType[]{CardType.SORCERY}, "{X}{X}{R}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new BonfireOfTheDamnedEffect());§this.getSpellAbility().addTarget(new TargetPlayer());§this.addAbility(new MiracleAbility(this, new ManaCostsImpl("{X}{R}")));§}§public BonfireOfTheDamned(final BonfireOfTheDamned card) {§super(card);§}§@Override§public BonfireOfTheDamned copy() {§return new BonfireOfTheDamned(this);§}§}§class BonfireOfTheDamnedEffect extends OneShotEffect {§private static FilterPermanent filter = new FilterCreaturePermanent();§public BonfireOfTheDamnedEffect() {§super(Outcome.Damage);§staticText = "{this} deals X damage to target player and each creature he or she controls";§}§public BonfireOfTheDamnedEffect(final BonfireOfTheDamnedEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getFirstTarget());§if (player != null) {§int damage = source.getManaCostsToPay().getX();§if (damage > 0) {§player.damage(damage, source.getSourceId(), game, false, true);§for (Permanent perm: game.getBattlefield().getAllActivePermanents(filter, player.getId(), game)) {§perm.damage(damage, source.getSourceId(), game, false, true);§}§}§return true;§}§return false;§}§@Override§public BonfireOfTheDamnedEffect copy() {§return new BonfireOfTheDamnedEffect(this);§}§}§
public class BowerPassage extends CardImpl {§public BowerPassage(UUID ownerId) {§super(ownerId, 170, "Bower Passage", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{G}");§this.expansionSetCode = "AVR";§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BowerPassageEffect()));§}§public BowerPassage(final BowerPassage card) {§super(card);§}§@Override§public BowerPassage copy() {§return new BowerPassage(this);§}§}§class BowerPassageEffect extends RestrictionEffect {§BowerPassageEffect() {§super(Duration.WhileOnBattlefield);§staticText = "Creatures with flying can't block creatures you control";§}§BowerPassageEffect(final BowerPassageEffect effect) {§super(effect);§}§@Override§public boolean applies(Permanent permanent, Ability source, Game game) {§return true;§}§@Override§public BowerPassageEffect copy() {§return new BowerPassageEffect(this);§}§@Override§public boolean canBlock(Permanent attacker, Permanent blocker, Ability source, Game game) {§if (attacker != null && attacker.getControllerId().equals(source.getControllerId()) && blocker.getAbilities().contains(FlyingAbility.getInstance())) {§return false;§}§return true;§}§}§
public class BrunaLightOfAlabaster extends CardImpl {§public BrunaLightOfAlabaster(UUID ownerId) {§super(ownerId, 208, "Bruna, Light of Alabaster", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{3}{W}{W}{U}");§this.expansionSetCode = "AVR";§this.supertype.add("Legendary");§this.subtype.add("Angel");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(VigilanceAbility.getInstance());§this.addAbility(new AttacksOrBlocksTriggeredAbility(new BrunaLightOfAlabasterEffect(), true));§}§public BrunaLightOfAlabaster(final BrunaLightOfAlabaster card) {§super(card);§}§@Override§public BrunaLightOfAlabaster copy() {§return new BrunaLightOfAlabaster(this);§}§}§class BrunaLightOfAlabasterEffect extends OneShotEffect {§public BrunaLightOfAlabasterEffect() {§super(Outcome.Benefit);§this.staticText = "attach to it any number of Auras on the battlefield and you may put onto the battlefield attached to it any number of Aura cards that could enchant it from your graveyard and/or hand";§}§public BrunaLightOfAlabasterEffect(final BrunaLightOfAlabasterEffect effect) {§super(effect);§}§@Override§public BrunaLightOfAlabasterEffect copy() {§return new BrunaLightOfAlabasterEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§UUID bruna = source.getSourceId();§Player player = game.getPlayer(source.getControllerId());§FilterPermanent filterAura = new FilterPermanent("Aura");§FilterCard filterAuraCard = new FilterCard("Aura card");§filterAura.add(new CardTypePredicate(CardType.ENCHANTMENT));§filterAura.add(new SubtypePredicate("Aura"));§filterAura.add(new AuraPermanentCanAttachToPermanentId(bruna));§filterAuraCard.add(new CardTypePredicate(CardType.ENCHANTMENT));§filterAuraCard.add(new SubtypePredicate("Aura"));§filterAuraCard.add(new AuraCardCanAttachToPermanentId(bruna));§if (player == null) {§return false;§}§Permanent permanent = game.getPermanent(source.getSourceId());§if (permanent == null) {§return false;§}§while (player.canRespond() && player.chooseUse(Outcome.Benefit, "Attach an Aura from the battlefield?", source, game)) {§Target targetAura = new TargetPermanent(filterAura);§if (player.choose(Outcome.Benefit, targetAura, source.getSourceId(), game)) {§Permanent aura = game.getPermanent(targetAura.getFirstTarget());§if (aura != null) {§Permanent attachedTo = game.getPermanent(aura.getAttachedTo());§if (attachedTo != null) {§attachedTo.removeAttachment(aura.getId(), game);§}§permanent.addAttachment(aura.getId(), game);§}§}§}§int count = player.getHand().count(filterAuraCard, game);§while (player.canRespond() && count > 0 && player.chooseUse(Outcome.Benefit, "Attach an Aura from your hand?", source, game)) {§TargetCard targetAura = new TargetCard(Zone.HAND, filterAuraCard);§if (player.choose(Outcome.Benefit, player.getHand(), targetAura, game)) {§Card aura = game.getCard(targetAura.getFirstTarget());§if (aura != null) {§game.getState().setValue("attachTo:" + aura.getId(), permanent);§aura.putOntoBattlefield(game, Zone.HAND, source.getSourceId(), player.getId());§permanent.addAttachment(aura.getId(), game);§}§}§count = player.getHand().count(filterAuraCard, game);§}§count = player.getGraveyard().count(filterAuraCard, game);§while (player.canRespond() && count > 0 && player.chooseUse(Outcome.Benefit, "Attach an Aura from your graveyard?", source, game)) {§TargetCard targetAura = new TargetCard(Zone.GRAVEYARD, filterAuraCard);§if (player.choose(Outcome.Benefit, player.getGraveyard(), targetAura, game)) {§Card aura = game.getCard(targetAura.getFirstTarget());§if (aura != null) {§game.getState().setValue("attachTo:" + aura.getId(), permanent);§aura.putOntoBattlefield(game, Zone.GRAVEYARD, source.getSourceId(), player.getId());§permanent.addAttachment(aura.getId(), game);§}§}§count = player.getGraveyard().count(filterAuraCard, game);§}§return true;§}§}§
public class BuildersBlessing extends CardImpl {§public BuildersBlessing(UUID ownerId) {§super(ownerId, 8, "Builder's Blessing", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{3}{W}");§this.expansionSetCode = "AVR";§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostControlledEffect(0, 2, Duration.WhileOnBattlefield, new FilterUntappedCreature())));§}§public BuildersBlessing(final BuildersBlessing card) {§super(card);§}§@Override§public BuildersBlessing copy() {§return new BuildersBlessing(this);§}§}§
public class BurnAtTheStake extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("untapped creatures you control");§static {§filter.add(Predicates.not(new TappedPredicate()));§}§public BurnAtTheStake(UUID ownerId) {§super(ownerId, 130, "Burn at the Stake", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{2}{R}{R}{R}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addCost(new TapVariableTargetCost(filter, true, "any number of"));§this.getSpellAbility().addEffect(new BurnAtTheStakeEffect());§this.getSpellAbility().addTarget(new TargetCreatureOrPlayer());§}§public BurnAtTheStake(final BurnAtTheStake card) {§super(card);§}§@Override§public BurnAtTheStake copy() {§return new BurnAtTheStake(this);§}§}§class BurnAtTheStakeEffect extends OneShotEffect {§public BurnAtTheStakeEffect() {§super(Outcome.Damage);§this.staticText = "{this} deals damage to target creature or player equal to three times the number of creatures tapped this way";§}§public BurnAtTheStakeEffect(final BurnAtTheStakeEffect effect) {§super(effect);§}§@Override§public BurnAtTheStakeEffect copy() {§return new BurnAtTheStakeEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§int amount = (new GetXValue()).calculate(game, source, this) * 3;§Permanent permanent = game.getPermanent(targetPointer.getFirst(game, source));§if (permanent != null) {§permanent.damage(amount, source.getSourceId(), game, false, true);§return true;§}§Player player = game.getPlayer(targetPointer.getFirst(game, source));§if (player != null) {§player.damage(amount, source.getSourceId(), game, false, true);§return true;§}§return false;§}§}§
public class ButcherGhoul extends CardImpl {§public ButcherGhoul(UUID ownerId) {§super(ownerId, 89, "Butcher Ghoul", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{B}");§this.expansionSetCode = "AVR";§this.subtype.add("Zombie");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new UndyingAbility());§}§public ButcherGhoul(final ButcherGhoul card) {§super(card);§}§@Override§public ButcherGhoul copy() {§return new ButcherGhoul(this);§}§}§
public class CallToServe extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("nonblack creature");§static {§filter.add(Predicates.not(new ColorPredicate(ObjectColor.BLACK)));§}§public CallToServe(UUID ownerId) {§super(ownerId, 9, "Call to Serve", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{W}");§this.expansionSetCode = "AVR";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent(filter);§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(1, 2, Duration.WhileOnBattlefield));§Effect effect = new GainAbilityAttachedEffect(FlyingAbility.getInstance(), AttachmentType.AURA);§effect.setText(", has flying");§ability.addEffect(effect);§effect = new AddCardSubtypeAttachedEffect("Angel", Duration.WhileOnBattlefield, AttachmentType.AURA);§effect.setText(", and is an Angel in addition to its other types");§ability.addEffect(effect);§this.addAbility(ability);§}§public CallToServe(final CallToServe card) {§super(card);§}§@Override§public CallToServe copy() {§return new CallToServe(this);§}§}§
public class CaptainOfTheMists extends CardImpl {§private static final FilterPermanent filter = new FilterControlledCreaturePermanent("another Human");§static {§filter.add(new AnotherPredicate());§filter.add(new SubtypePredicate("Human"));§}§public CaptainOfTheMists(UUID ownerId) {§super(ownerId, 45, "Captain of the Mists", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{U}");§this.expansionSetCode = "AVR";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(new EntersBattlefieldControlledTriggeredAbility(new UntapSourceEffect(), filter));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new MayTapOrUntapTargetEffect(), new ManaCostsImpl("{1}{U}"));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetPermanent());§this.addAbility(ability);§}§public CaptainOfTheMists(final CaptainOfTheMists card) {§super(card);§}§@Override§public CaptainOfTheMists copy() {§return new CaptainOfTheMists(this);§}§}§
public class CatharsCrusade extends CardImpl {§public CatharsCrusade(UUID ownerId) {§super(ownerId, 10, "Cathars' Crusade", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{3}{W}{W}");§this.expansionSetCode = "AVR";§this.addAbility(new CreatureEntersBattlefieldTriggeredAbility(new AddCountersAllEffect(CounterType.P1P1.createInstance(), new FilterControlledCreaturePermanent())));§}§public CatharsCrusade(final CatharsCrusade card) {§super(card);§}§@Override§public CatharsCrusade copy() {§return new CatharsCrusade(this);§}§}§
public class CathedralSanctifier extends CardImpl {§public CathedralSanctifier(UUID ownerId) {§super(ownerId, 11, "Cathedral Sanctifier", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{W}");§this.expansionSetCode = "AVR";§this.subtype.add("Human");§this.subtype.add("Cleric");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new EntersBattlefieldTriggeredAbility(new GainLifeEffect(3)));§}§public CathedralSanctifier(final CathedralSanctifier card) {§super(card);§}§@Override§public CathedralSanctifier copy() {§return new CathedralSanctifier(this);§}§}§
public class CavernOfSouls extends CardImpl {§public CavernOfSouls(UUID ownerId) {§super(ownerId, 226, "Cavern of Souls", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "AVR";§this.addAbility(new AsEntersBattlefieldAbility(new ChooseCreatureTypeEffect(Outcome.BoostCreature)));§this.addAbility(new ColorlessManaAbility());§Ability ability = new ConditionalAnyColorManaAbility(new TapSourceCost(), 1, new CavernOfSoulsManaBuilder(), true);§this.addAbility(ability, new CavernOfSoulsWatcher(ability.getOriginalId()));§this.addAbility(new SimpleStaticAbility(Zone.ALL, new CavernOfSoulsCantCounterEffect()));§}§public CavernOfSouls(final CavernOfSouls card) {§super(card);§}§@Override§public CavernOfSouls copy() {§return new CavernOfSouls(this);§}§}§class CavernOfSoulsManaBuilder extends ConditionalManaBuilder {§String creatureType;§@Override§public ConditionalManaBuilder setMana(Mana mana, Ability source, Game game) {§Object value = game.getState().getValue(source.getSourceId() + "_type");§if (value != null && value instanceof String) {§creatureType = (String) value;§}§Player controller = game.getPlayer(source.getControllerId());§MageObject sourceObject = game.getObject(source.getSourceId());§if (controller != null && sourceObject != null) {§game.informPlayers(controller.getLogName() + " produces " + mana.toString() + " with " + sourceObject.getLogName()§+ " (can only be spend to cast for creatures of type " + creatureType + " and that spell can't be countered)");§}§return super.setMana(mana, source, game);§}§@Override§public ConditionalMana build(Object. options) {§return new CavernOfSoulsConditionalMana(this.mana, creatureType);§}§@Override§public String getRule() {§return "Spend this mana only to cast a creature spell of the chosen type, and that spell can't be countered";§}§}§class CavernOfSoulsConditionalMana extends ConditionalMana {§public CavernOfSoulsConditionalMana(Mana mana, String creatureType) {§super(mana);§staticText = "Spend this mana only to cast a creature spell of the chosen type, and that spell can't be countered";§addCondition(new CavernOfSoulsManaCondition(creatureType));§}§}§class CavernOfSoulsManaCondition extends CreatureCastManaCondition {§String creatureType;§CavernOfSoulsManaCondition(String creatureType) {§this.creatureType = creatureType;§}§@Override§public boolean apply(Game game, Ability source, UUID originalId, Cost costToPay) {§if (super.apply(game, source)) {§MageObject object = game.getObject(source.getSourceId());§if (creatureType != null && object.hasSubtype(creatureType)) {§return true;§}§}§return false;§}§}§class CavernOfSoulsWatcher extends Watcher {§private List<UUID> spells = new ArrayList<>();§private final String originalId;§public CavernOfSoulsWatcher(UUID originalId) {§super("ManaPaidFromCavernOfSoulsWatcher", WatcherScope.CARD);§this.originalId = originalId.toString();§}§public CavernOfSoulsWatcher(final CavernOfSoulsWatcher watcher) {§super(watcher);§this.spells.addAll(watcher.spells);§this.originalId = watcher.originalId;§}§@Override§public CavernOfSoulsWatcher copy() {§return new CavernOfSoulsWatcher(this);§}§@Override§public void watch(GameEvent event, Game game) {§if (event.getType() == GameEvent.EventType.MANA_PAYED) {§if (event.getData() != null && event.getData().equals(originalId)) {§spells.add(event.getTargetId());§}§}§}§public boolean spellCantBeCountered(UUID spellId) {§return spells.contains(spellId);§}§@Override§public void reset() {§super.reset();§spells.clear();§}§}§class CavernOfSoulsCantCounterEffect extends ContinuousRuleModifyingEffectImpl {§public CavernOfSoulsCantCounterEffect() {§super(Duration.EndOfGame, Outcome.Benefit);§staticText = null;§}§public CavernOfSoulsCantCounterEffect(final CavernOfSoulsCantCounterEffect effect) {§super(effect);§}§@Override§public CavernOfSoulsCantCounterEffect copy() {§return new CavernOfSoulsCantCounterEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public String getInfoMessage(Ability source, GameEvent event, Game game) {§MageObject sourceObject = game.getObject(source.getSourceId());§if (sourceObject != null) {§return "This spell can't be countered because a colored mana from " + sourceObject.getName() + " was spent to cast it.";§}§return null;§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.COUNTER;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§CavernOfSoulsWatcher watcher = (CavernOfSoulsWatcher) game.getState().getWatchers().get("ManaPaidFromCavernOfSoulsWatcher", source.getSourceId());§Spell spell = game.getStack().getSpell(event.getTargetId());§return spell != null && watcher != null && watcher.spellCantBeCountered(spell.getId());§}§}§
public class ChampionOfLambholt extends CardImpl {§public ChampionOfLambholt(UUID ownerId) {§super(ownerId, 171, "Champion of Lambholt", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{G}{G}");§this.expansionSetCode = "AVR";§this.subtype.add("Human");§this.subtype.add("Warrior");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new ChampionOfLambholtEffect()));§this.addAbility(new EntersAnotherCreatureYourControlTriggeredAbility(new AddCountersSourceEffect(CounterType.P1P1.createInstance())));§}§public ChampionOfLambholt(final ChampionOfLambholt card) {§super(card);§}§@Override§public ChampionOfLambholt copy() {§return new ChampionOfLambholt(this);§}§}§class ChampionOfLambholtEffect extends RestrictionEffect {§ChampionOfLambholtEffect() {§super(Duration.WhileOnBattlefield);§staticText = "Creatures with power less than {this}'s power can't block creatures you control";§}§ChampionOfLambholtEffect(final ChampionOfLambholtEffect effect) {§super(effect);§}§@Override§public boolean applies(Permanent permanent, Ability source, Game game) {§Permanent sourcePermanent = game.getPermanent(source.getSourceId());§if (sourcePermanent != null) {§return true;§}§return false;§}§@Override§public boolean canBlock(Permanent attacker, Permanent blocker, Ability source, Game game) {§if (attacker != null && blocker != null) {§Permanent sourcePermanent = game.getPermanent(source.getSourceId());§if (sourcePermanent != null && attacker.getControllerId().equals(sourcePermanent.getControllerId())) {§return blocker.getPower().getValue() >= sourcePermanent.getPower().getValue();§}§}§return true;§}§@Override§public ChampionOfLambholtEffect copy() {§return new ChampionOfLambholtEffect(this);§}§}§
public class Cloudshift extends CardImpl {§public Cloudshift(UUID ownerId) {§super(ownerId, 12, "Cloudshift", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{W}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addTarget(new TargetControlledCreaturePermanent());§Effect effect = new ExileTargetForSourceEffect();§effect.setApplyEffectsAfter();§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addEffect(new ReturnToBattlefieldUnderYourControlTargetEffect(true));§}§public Cloudshift(final Cloudshift card) {§super(card);§}§@Override§public Cloudshift copy() {§return new Cloudshift(this);§}§}§
public class CorpseTraders extends CardImpl {§public CorpseTraders(UUID ownerId) {§super(ownerId, 90, "Corpse Traders", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{B}");§this.expansionSetCode = "AVR";§this.subtype.add("Human");§this.subtype.add("Rogue");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§Ability ability = new ActivateAsSorceryActivatedAbility(Zone.BATTLEFIELD, new DiscardCardYouChooseTargetEffect(), new ManaCostsImpl("{2}{B}"));§ability.addTarget(new TargetOpponent());§ability.addCost(new SacrificeTargetCost(new TargetControlledCreaturePermanent()));§this.addAbility(ability);§}§public CorpseTraders(final CorpseTraders card) {§super(card);§}§@Override§public CorpseTraders copy() {§return new CorpseTraders(this);§}§}§
public class CraterhoofBehemoth extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent();§static {§filter.add(new ControllerPredicate(TargetController.YOU));§}§public CraterhoofBehemoth(UUID ownerId) {§super(ownerId, 172, "Craterhoof Behemoth", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{5}{G}{G}{G}");§this.expansionSetCode = "AVR";§this.subtype.add("Beast");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(HasteAbility.getInstance());§Ability ability = new EntersBattlefieldTriggeredAbility(new GainAbilityControlledEffect(TrampleAbility.getInstance(), Duration.EndOfTurn, filter));§PermanentsOnBattlefieldCount controlledCreatures = new PermanentsOnBattlefieldCount(new FilterControlledCreaturePermanent("the number of creatures you control"), null);§ability.addEffect(new BoostControlledEffect(controlledCreatures, controlledCreatures, Duration.EndOfTurn, filter, false, true));§this.addAbility(ability);§}§public CraterhoofBehemoth(final CraterhoofBehemoth card) {§super(card);§}§@Override§public CraterhoofBehemoth copy() {§return new CraterhoofBehemoth(this);§}§}§
public class CripplingChill extends CardImpl {§public CripplingChill(UUID ownerId) {§super(ownerId, 46, "Crippling Chill", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{U}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.getSpellAbility().addEffect(new TapTargetEffect());§this.getSpellAbility().addEffect(new DontUntapInControllersNextUntapStepTargetEffect());§this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(1));§}§public CripplingChill(final CripplingChill card) {§super(card);§}§@Override§public CripplingChill copy() {§return new CripplingChill(this);§}§}§
public class CryptCreeper extends CardImpl {§public CryptCreeper(UUID ownerId) {§super(ownerId, 91, "Crypt Creeper", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{B}");§this.expansionSetCode = "AVR";§this.subtype.add("Zombie");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ExileTargetEffect(), new SacrificeSourceCost());§ability.addTarget(new TargetCardInGraveyard());§this.addAbility(ability);§}§public CryptCreeper(final CryptCreeper card) {§super(card);§}§@Override§public CryptCreeper copy() {§return new CryptCreeper(this);§}§}§
public class Cursebreak extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("enchantment");§static {§filter.add(new CardTypePredicate(CardType.ENCHANTMENT));§}§public Cursebreak(UUID ownerId) {§super(ownerId, 14, "Cursebreak", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{W}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addTarget(new TargetPermanent(filter));§this.getSpellAbility().addEffect(new DestroyTargetEffect());§this.getSpellAbility().addEffect(new GainLifeEffect(2));§}§public Cursebreak(final Cursebreak card) {§super(card);§}§@Override§public Cursebreak copy() {§return new Cursebreak(this);§}§}§
public class DangerousWager extends CardImpl {§public DangerousWager(UUID ownerId) {§super(ownerId, 131, "Dangerous Wager", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{R}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new DangerousWagerEffect());§this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(2));§}§public DangerousWager(final DangerousWager card) {§super(card);§}§@Override§public DangerousWager copy() {§return new DangerousWager(this);§}§}§class DangerousWagerEffect extends OneShotEffect {§public DangerousWagerEffect() {§super(Outcome.Discard);§this.staticText = "Discard your hand";§}§public DangerousWagerEffect(final DangerousWagerEffect effect) {§super(effect);§}§@Override§public DangerousWagerEffect copy() {§return new DangerousWagerEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§for (Card card : player.getHand().getCards(game)) {§player.discard(card, source, game);§}§return true;§}§return false;§}§}§
public class DarkImpostor extends CardImpl {§public DarkImpostor(UUID ownerId) {§super(ownerId, 92, "Dark Impostor", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{B}");§this.expansionSetCode = "AVR";§this.subtype.add("Vampire");§this.subtype.add("Assassin");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ImprintTargetEffect(), new ManaCostsImpl("{4}{B}{B}"));§ability.addEffect(new ExileTargetEffect(null, this.getIdName()));§ability.addEffect(new AddCountersSourceEffect(CounterType.P1P1.createInstance()));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new DarkImpostorContinuousEffect()));§}§public DarkImpostor(final DarkImpostor card) {§super(card);§}§@Override§public DarkImpostor copy() {§return new DarkImpostor(this);§}§}§class DarkImpostorContinuousEffect extends ContinuousEffectImpl {§public DarkImpostorContinuousEffect() {§super(Duration.WhileOnBattlefield, Layer.AbilityAddingRemovingEffects_6, SubLayer.NA, Outcome.AddAbility);§staticText = "{this} has all activated abilities of all creature cards exiled with it";§}§public DarkImpostorContinuousEffect(final DarkImpostorContinuousEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent perm = game.getPermanent(source.getSourceId());§if (perm != null) {§for (UUID imprintedId : perm.getImprinted()) {§Card card = game.getCard(imprintedId);§if (card != null) {§for (Ability ability : card.getAbilities()) {§if (ability instanceof ActivatedAbility) {§perm.addAbility(ability, source.getSourceId(), game);§}§}§}§}§}§return true;§}§@Override§public DarkImpostorContinuousEffect copy() {§return new DarkImpostorContinuousEffect(this);§}§}§
public class DeadeyeNavigator extends CardImpl {§private static final String ruleText = "As long as {this} is paired with another creature, each of those creatures has \"{1}{U}: Exile this creature, then return it to the battlefield under your control.\"";§public DeadeyeNavigator(UUID ownerId) {§super(ownerId, 47, "Deadeye Navigator", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{U}{U}");§this.expansionSetCode = "AVR";§this.subtype.add("Spirit");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(SoulbondAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ExileSourceEffect(true), new ManaCostsImpl("{1}{U}"));§ability.addEffect(new ReturnToBattlefieldUnderYourControlSourceEffect());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityPairedEffect(ability, ruleText)));§}§public DeadeyeNavigator(final DeadeyeNavigator card) {§super(card);§}§@Override§public DeadeyeNavigator copy() {§return new DeadeyeNavigator(this);§}§}§
public class DeathWind extends CardImpl {§public DeathWind(UUID ownerId) {§super(ownerId, 93, "Death Wind", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{X}{B}");§this.expansionSetCode = "AVR";§DynamicValue x = new SignInversionDynamicValue(new ManacostVariableValue());§this.getSpellAbility().addEffect(new BoostTargetEffect(x, x, Duration.EndOfTurn, true));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public DeathWind(final DeathWind card) {§super(card);§}§@Override§public DeathWind copy() {§return new DeathWind(this);§}§}§
public class Defang extends CardImpl {§public Defang(UUID ownerId) {§super(ownerId, 15, "Defang", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{W}");§this.expansionSetCode = "AVR";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new PreventAllDamageByAttachedEffect(Duration.WhileOnBattlefield, "enchanted creature", false)));§}§public Defang(final Defang card) {§super(card);§}§@Override§public Defang copy() {§return new Defang(this);§}§}§
public class DefyDeath extends CardImpl {§public DefyDeath(UUID ownerId) {§super(ownerId, 16, "Defy Death", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{3}{W}{W}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new ReturnFromGraveyardToBattlefieldTargetEffect());§this.getSpellAbility().addEffect(new DefyDeathEffect());§this.getSpellAbility().addTarget(new TargetCardInYourGraveyard(new FilterCreatureCard("creature card from your graveyard")));§}§public DefyDeath(final DefyDeath card) {§super(card);§}§@Override§public DefyDeath copy() {§return new DefyDeath(this);§}§}§class DefyDeathEffect extends OneShotEffect {§public DefyDeathEffect() {§super(Outcome.BoostCreature);§this.staticText = "If it's an Angel, put two +1/+1 counters on it";§}§public DefyDeathEffect(final DefyDeathEffect effect) {§super(effect);§}§@Override§public DefyDeathEffect copy() {§return new DefyDeathEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getPermanent(source.getFirstTarget());§if (permanent != null && permanent.hasSubtype("Angel")) {§permanent.addCounters(CounterType.P1P1.createInstance(2), game);§return true;§}§return false;§}§}§
public class DemonicRising extends CardImpl {§private static final String ruleText = "At the beginning of your end step, if you control exactly one creature, put a 5/5 black Demon creature token with flying onto the battlefield";§public DemonicRising(UUID ownerId) {§super(ownerId, 94, "Demonic Rising", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{3}{B}{B}");§this.expansionSetCode = "AVR";§TriggeredAbility ability = new BeginningOfYourEndStepTriggeredAbility(new CreateTokenEffect(new DemonToken()), false);§this.addAbility(new ConditionalTriggeredAbility(ability, OneControlledCreatureCondition.getInstance(), ruleText));§}§public DemonicRising(final DemonicRising card) {§super(card);§}§@Override§public DemonicRising copy() {§return new DemonicRising(this);§}§}§
public class DemonicTaskmaster extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("a creature other than Demonic Taskmaster");§static {§filter.add(new AnotherPredicate());§}§public DemonicTaskmaster(UUID ownerId) {§super(ownerId, 95, "Demonic Taskmaster", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{B}");§this.expansionSetCode = "AVR";§this.subtype.add("Demon");§this.power = new MageInt(4);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new BeginningOfUpkeepTriggeredAbility(new SacrificeEffect(filter, 1, ""), TargetController.YOU, false);§this.addAbility(ability);§}§public DemonicTaskmaster(final DemonicTaskmaster card) {§super(card);§}§@Override§public DemonicTaskmaster copy() {§return new DemonicTaskmaster(this);§}§}§
public class DemonlordOfAshmouth extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent(" another creature");§static {§filter.add(new AnotherPredicate());§}§public DemonlordOfAshmouth(UUID ownerId) {§super(ownerId, 96, "Demonlord of Ashmouth", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{B}{B}");§this.expansionSetCode = "AVR";§this.subtype.add("Demon");§this.power = new MageInt(5);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new EntersBattlefieldTriggeredAbility(new ExileSourceUnlessPaysEffect(new SacrificeTargetCost(new TargetControlledPermanent(filter)))));§this.addAbility(new UndyingAbility());§}§public DemonlordOfAshmouth(final DemonlordOfAshmouth card) {§super(card);§}§@Override§public DemonlordOfAshmouth copy() {§return new DemonlordOfAshmouth(this);§}§}§
public class DescendantsPath extends CardImpl {§public DescendantsPath(UUID ownerId) {§super(ownerId, 173, "Descendants' Path", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{2}{G}");§this.expansionSetCode = "AVR";§Ability ability = new BeginningOfUpkeepTriggeredAbility(new DescendantsPathEffect(), TargetController.YOU, false);§this.addAbility(ability);§}§public DescendantsPath(final DescendantsPath card) {§super(card);§}§@Override§public DescendantsPath copy() {§return new DescendantsPath(this);§}§}§class DescendantsPathEffect extends OneShotEffect {§public DescendantsPathEffect() {§super(Outcome.Discard);§this.staticText = "reveal the top card of your library. If it's a creature card that shares a creature type with a creature you control, you may cast that card without paying its mana cost. Otherwise, put that card on the bottom of your library";§}§public DescendantsPathEffect(final DescendantsPathEffect effect) {§super(effect);§}§@Override§public DescendantsPathEffect copy() {§return new DescendantsPathEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§MageObject sourceObject = source.getSourceObject(game);§if (controller != null && sourceObject != null) {§if (controller.getLibrary().size() > 0) {§Card card = controller.getLibrary().getFromTop(game);§if (card == null) {§return false;§}§controller.revealCards(sourceObject.getIdName(), new CardsImpl(card), game);§if (card.getCardType().contains(CardType.CREATURE)) {§FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent();§boolean found = false;§for (Permanent permanent: game.getBattlefield().getAllActivePermanents(filter, controller.getId(), game)) {§if (CardUtil.shareSubtypes(card, permanent)) {§found = true;§break;§}§}§if (found) {§game.informPlayers(sourceObject.getLogName() + ": Found a creature that shares a creature type with the revealed card.");§if (controller.chooseUse(Outcome.Benefit, "Cast the card?", source, game)) {§controller.cast(card.getSpellAbility(), game, true);§} else {§game.informPlayers(sourceObject.getLogName() + ": " + controller.getLogName() + " canceled casting the card.");§controller.getLibrary().putOnBottom(card, game);§}§} else {§game.informPlayers(sourceObject.getLogName() + ": No creature that shares a creature type with the revealed card.");§controller.getLibrary().putOnBottom(card, game);§}§} else {§game.informPlayers(sourceObject.getLogName() + ": Put " + card.getLogName() + " on the bottom.");§controller.getLibrary().putOnBottom(card, game);§}§return true;§}§}§return false;§}§}§
public class DescentIntoMadness extends CardImpl {§public DescentIntoMadness(UUID ownerId) {§super(ownerId, 97, "Descent into Madness", Rarity.MYTHIC, new CardType[]{CardType.ENCHANTMENT}, "{3}{B}{B}");§this.expansionSetCode = "AVR";§this.addAbility(new BeginningOfUpkeepTriggeredAbility(new DescentIntoMadnessEffect(), TargetController.YOU, false));§}§public DescentIntoMadness(final DescentIntoMadness card) {§super(card);§}§@Override§public DescentIntoMadness copy() {§return new DescentIntoMadness(this);§}§}§class DescentIntoMadnessEffect extends OneShotEffect {§public DescentIntoMadnessEffect() {§super(Outcome.Sacrifice);§this.staticText = "put a despair counter on {this}, then each player exiles X permanents he or she controls and/or cards from his or her hand, where X is the number of despair counters on {this}";§}§public DescentIntoMadnessEffect(final DescentIntoMadnessEffect effect) {§super(effect);§}§@Override§public DescentIntoMadnessEffect copy() {§return new DescentIntoMadnessEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§Permanent sourcePermanent = game.getPermanent(source.getSourceId());§if (sourcePermanent != null && controller != null) {§sourcePermanent.addCounters(CounterType.DESPAIR.createInstance(), game);§}§if (sourcePermanent == null) {§sourcePermanent = (Permanent) game.getLastKnownInformation(source.getSourceId(), Zone.BATTLEFIELD);§}§if (sourcePermanent != null && controller != null) {§int count = sourcePermanent.getCounters().getCount(CounterType.DESPAIR);§if (count > 0) {§LinkedList<UUID> selectedObjects = new LinkedList<>();§PlayerList playerList = game.getState().getPlayerList(controller.getId());§Player currentPlayer = controller;§do {§selectCards(currentPlayer, selectedObjects, count, source, game);§currentPlayer = playerList.getNextInRange(controller, game);§} while (!currentPlayer.equals(controller) && controller.canRespond());§for (UUID objectId : selectedObjects) {§if (game.getState().getZone(objectId).equals(Zone.BATTLEFIELD)) {§Permanent permanent = game.getPermanent(objectId);§if (permanent != null) {§Player player = game.getPlayer(permanent.getControllerId());§if (player != null) {§player.moveCardToExileWithInfo(permanent, null, "", source.getSourceId(), game, Zone.BATTLEFIELD, true);§}§}§} else if (game.getState().getZone(objectId).equals(Zone.HAND)) {§Card card = game.getCard(objectId);§if (card != null) {§Player player = game.getPlayer(card.getOwnerId());§if (player != null) {§player.moveCardToExileWithInfo(card, null, "", source.getSourceId(), game, Zone.HAND, true);§}§}§}§}§}§return true;§}§return false;§}§private void selectCards(Player player, List<UUID> selectedObjects, int count, Ability source, Game game) {§int amount = Math.min(count, player.getHand().size() + game.getBattlefield().getAllActivePermanents(player.getId()).size());§int cardsFromHand = 0;§while (player.canRespond() && amount > 0) {§Target target;§do {§FilterControlledPermanent filter = new FilterControlledPermanent();§filter.setMessage("permanent you control (" + amount + " left in total)" );§List<PermanentIdPredicate> uuidPredicates = new ArrayList<>();§for (UUID uuid :selectedObjects) {§uuidPredicates.add(new PermanentIdPredicate(uuid));§}§filter.add(Predicates.not(Predicates.or(uuidPredicates)));§target = new TargetControlledPermanent(0, 1, filter, true);§if (target.canChoose(player.getId(), game)§&& player.choose(Outcome.Exile, target, source.getSourceId(), game)) {§for (UUID targetId : target.getTargets()) {§if (!selectedObjects.contains(targetId)) {§Permanent chosen = game.getPermanent(targetId);§if (chosen != null) {§amount--;§game.informPlayers(player.getLogName() + " selects " + chosen.getLogName() + " from battlefield");§selectedObjects.add(targetId);§}§}§}§}§} while (amount > 0 && !target.getTargets().isEmpty() && player.canRespond());§if (amount > 0) {§TargetCard targetInHand;§do {§FilterCard filterInHand = new FilterCard();§filterInHand.setMessage("card from your hand (" + amount + " left in total)");§targetInHand = new TargetCard(0, 1, Zone.HAND, filterInHand);§List<CardIdPredicate> uuidPredicates = new ArrayList<>();§for (UUID uuid :selectedObjects) {§uuidPredicates.add(new CardIdPredicate(uuid));§}§filterInHand.add(Predicates.not(Predicates.or(uuidPredicates)));§if (targetInHand.canChoose(player.getId(), game) &&§player.choose(Outcome.Exile, player.getHand(), targetInHand, game)) {§Card card = player.getHand().get(targetInHand.getFirstTarget(), game);§if (card != null) {§selectedObjects.add(targetInHand.getFirstTarget());§amount--;§cardsFromHand++;§}§}§} while (amount > 0 && !targetInHand.getTargets().isEmpty() && player.canRespond());§}§}§if (cardsFromHand > 0) {§game.informPlayers(player.getLogName() + " selects " + cardsFromHand + (cardsFromHand == 1?" card":" cards") + " from his or her hand");§}§}§}§
public class DesolateLighthouse extends CardImpl {§public DesolateLighthouse(UUID ownerId) {§super(ownerId, 227, "Desolate Lighthouse", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "AVR";§this.addAbility(new ColorlessManaAbility());§SimpleActivatedAbility ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,§new DrawDiscardControllerEffect(),§new ManaCostsImpl("{1}{U}{R}"));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§}§public DesolateLighthouse(final DesolateLighthouse card) {§super(card);§}§@Override§public DesolateLighthouse copy() {§return new DesolateLighthouse(this);§}§}§
public class DevastationTide extends CardImpl {§public DevastationTide(UUID ownerId) {§super(ownerId, 48, "Devastation Tide", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{3}{U}{U}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new DevastationTideEffect());§this.addAbility(new MiracleAbility(this, new ManaCostsImpl("{1}{U}")));§}§public DevastationTide(final DevastationTide card) {§super(card);§}§@Override§public DevastationTide copy() {§return new DevastationTide(this);§}§}§class DevastationTideEffect extends OneShotEffect {§public DevastationTideEffect() {§super(Outcome.ReturnToHand);§staticText = "Return all nonland permanents to their owners' hands";§}§public DevastationTideEffect(final DevastationTideEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Set<Card> cardsToHand = new LinkedHashSet<>();§for (Permanent permanent : game.getBattlefield().getActivePermanents(new FilterNonlandPermanent(), source.getControllerId(), source.getSourceId(), game)) {§cardsToHand.add((Card) permanent);§}§controller.moveCards(cardsToHand, Zone.HAND, source, game);§return true;§}§return false;§}§@Override§public DevastationTideEffect copy() {§return new DevastationTideEffect(this);§}§}§
public class DivineDeflection extends CardImpl {§public DivineDeflection(UUID ownerId) {§super(ownerId, 18, "Divine Deflection", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{X}{W}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new DivineDeflectionPreventDamageTargetEffect(Duration.EndOfTurn));§this.getSpellAbility().addTarget(new TargetCreatureOrPlayer());§}§public DivineDeflection(final DivineDeflection card) {§super(card);§}§@Override§public DivineDeflection copy() {§return new DivineDeflection(this);§}§}§class DivineDeflectionPreventDamageTargetEffect extends PreventionEffectImpl {§public DivineDeflectionPreventDamageTargetEffect(Duration duration) {§super(duration, Integer.MIN_VALUE, false, true);§staticText = "Prevent the next X damage that would be dealt to you and/or permanents you control this turn. If damage is prevented this way, {this} deals that much damage to target creature or player";§}§public DivineDeflectionPreventDamageTargetEffect(final DivineDeflectionPreventDamageTargetEffect effect) {§super(effect);§}§@Override§public DivineDeflectionPreventDamageTargetEffect copy() {§return new DivineDeflectionPreventDamageTargetEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§/*§If damage is dealt to multiple permanents you control, or is dealt to you and at least§one permanent you control, you choose which of that damage to prevent if the chosen value§for X won't prevent all the damage. For example, if 3 damage would be dealt to you and to§each of two creatures you control, and Divine Deflection will prevent the next 3 damage,§you might choose to prevent the next 2 damage it would deal to you and the next 1 damage§it would deal to one of the creatures, among other choices. You don't decide until the§point at which the damage would be dealt.§TODO: Support to select which damage to prevent§*/§PreventionEffectData preventionData = preventDamageAction(event, source, game);§/*§Divine Deflection's effect is not a redirection effect. If it prevents damage,§Divine Deflection (not the original source) deals damage to the targeted creature§or player as part of that prevention effect. Divine Deflection is the source of§the new damage, so the characteristics of the original source (such as its color,§or whether it had lifelink or deathtouch) don't affect this damage. The new damage§is not combat damage, even if the prevented damage was. Since you control the source§of the new damage, if you targeted an opponent with Divine Deflection, you may§have Divine Deflection deal its damage to a planeswalker that opponent controls.§*/§int prevented = preventionData.getPreventedDamage();§if (prevented > 0) {§UUID dealDamageTo = source.getFirstTarget();§/*§Whether the targeted creature or player is still a legal target is not checked after§Divine Deflection resolves. For example, if a creature targeted by Divine Deflection§gains shroud after Divine Deflection resolves, Divine Deflection can still deal damage§to that creature.§*/§Permanent permanent = game.getPermanent(dealDamageTo);§if (permanent != null) {§game.informPlayers("Dealing " + prevented + " to " + permanent.getName() + " instead");§permanent.damage(prevented, source.getSourceId(), game, false, true);§}§Player player = game.getPlayer(dealDamageTo);§if (player != null) {§game.informPlayers("Dealing " + prevented + " to " + player.getLogName() + " instead");§player.damage(prevented, source.getSourceId(), game, false, true);§}§}§return false;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§if (!this.used && super.applies(event, source, game)) {§if (amountToPrevent == Integer.MIN_VALUE) {§amountToPrevent = source.getManaCostsToPay().getX();§}§Permanent permanent = game.getPermanent(event.getTargetId());§if (permanent != null) {§if (permanent.getControllerId().equals(source.getControllerId())) {§return true;§}§}§if (source.getControllerId().equals(event.getTargetId())) {§return true;§}§}§return false;§}§}§
public class DreadSlaver extends CardImpl {§public DreadSlaver(UUID ownerId) {§super(ownerId, 98, "Dread Slaver", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{B}{B}");§this.expansionSetCode = "AVR";§this.subtype.add("Zombie");§this.subtype.add("Horror");§this.power = new MageInt(3);§this.toughness = new MageInt(5);§this.addAbility(new DiesAndDealtDamageThisTurnTriggeredAbility(new DreadSlaverEffect(), false));§}§public DreadSlaver(final DreadSlaver card) {§super(card);§}§@Override§public DreadSlaver copy() {§return new DreadSlaver(this);§}§}§class DreadSlaverEffect extends OneShotEffect {§public DreadSlaverEffect() {§super(Outcome.Benefit);§staticText = "return it to the battlefield under your control. That creature is a black Zombie in addition to its other colors and types";§}§public DreadSlaverEffect(final DreadSlaverEffect effect) {§super(effect);§}§@Override§public DreadSlaverEffect copy() {§return new DreadSlaverEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Card card = game.getCard(targetPointer.getFirst(game, source));§if (card != null) {§Zone currentZone = game.getState().getZone(card.getId());§if (card.putOntoBattlefield(game, currentZone, source.getSourceId(), source.getControllerId())) {§ContinuousEffect effect = new DreadSlaverContiniousEffect();§effect.setTargetPointer(new FixedTarget(card.getId()));§game.addEffect(effect, source);§return true;§}§}§return false;§}§}§class DreadSlaverContiniousEffect extends ContinuousEffectImpl {§public DreadSlaverContiniousEffect() {§super(Duration.Custom, Outcome.Neutral);§staticText = "That creature is a black Zombie in addition to its other colors and types";§}§public DreadSlaverContiniousEffect(final DreadSlaverContiniousEffect effect) {§super(effect);§}§@Override§public DreadSlaverContiniousEffect copy() {§return new DreadSlaverContiniousEffect(this);§}§@Override§public boolean apply(Layer layer, SubLayer sublayer, Ability source, Game game) {§Permanent creature = game.getPermanent(targetPointer.getFirst(game, source));§if (creature != null) {§switch (layer) {§case TypeChangingEffects_4:§if (sublayer == SubLayer.NA) {§creature.getSubtype().add("Zombie");§}§break;§case ColorChangingEffects_5:§if (sublayer == SubLayer.NA) {§creature.getColor(game).setBlack(true);§}§break;§}§return true;§} else {§this.used = true;§}§return false;§}§@Override§public boolean apply(Game game, Ability source) {§return false;§}§@Override§public boolean hasLayer(Layer layer) {§return layer == Layer.ColorChangingEffects_5 || layer == Layer.TypeChangingEffects_4;§}§}§
public class Dreadwaters extends CardImpl {§private static final FilterLandPermanent filter = new FilterLandPermanent("lands you control");§static {§filter.add(new ControllerPredicate(TargetController.YOU));§}§public Dreadwaters(UUID ownerId) {§super(ownerId, 49, "Dreadwaters", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{3}{U}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addTarget(new TargetPlayer());§this.getSpellAbility().addEffect(new PutLibraryIntoGraveTargetEffect(new PermanentsOnBattlefieldCount(filter)));§}§public Dreadwaters(final Dreadwaters card) {§super(card);§}§@Override§public Dreadwaters copy() {§return new Dreadwaters(this);§}§}§
public class DriverOfTheDead extends CardImpl {§private static final FilterCreatureCard filter = new FilterCreatureCard("creature card with converted mana cost 2 or less from your graveyard to the battlefield");§static {§filter.add(new ConvertedManaCostPredicate(Filter.ComparisonType.LessThan, 3));§}§public DriverOfTheDead(UUID ownerId) {§super(ownerId, 99, "Driver of the Dead", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{B}");§this.expansionSetCode = "AVR";§this.subtype.add("Vampire");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§Ability ability = new DiesTriggeredAbility(new ReturnFromGraveyardToBattlefieldTargetEffect(), false);§Target target = new TargetCardInYourGraveyard(filter);§ability.addTarget(target);§this.addAbility(ability);§}§public DriverOfTheDead(final DriverOfTheDead card) {§super(card);§}§@Override§public DriverOfTheDead copy() {§return new DriverOfTheDead(this);§}§}§
public class DruidsFamiliar extends CardImpl {§private static final String ruleText = "As long as {this} is paired with another creature, each of those creatures gets +2/+2";§public DruidsFamiliar(UUID ownerId) {§super(ownerId, 175, "Druid's Familiar", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{G}");§this.expansionSetCode = "AVR";§this.subtype.add("Bear");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(SoulbondAbility.getInstance());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostPairedEffect(2, 2, ruleText)));§}§public DruidsFamiliar(final DruidsFamiliar card) {§super(card);§}§@Override§public DruidsFamiliar copy() {§return new DruidsFamiliar(this);§}§}§
public class DruidsRepository extends CardImpl {§public DruidsRepository(UUID ownerId) {§super(ownerId, 176, "Druids' Repository", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{1}{G}{G}");§this.expansionSetCode = "AVR";§this.addAbility(new AttacksCreatureYouControlTriggeredAbility(new AddCountersSourceEffect(CounterType.CHARGE.createInstance())));§Ability ability = new SimpleManaAbility(Zone.BATTLEFIELD, new AddManaOfAnyColorEffect(), new RemoveCountersSourceCost(CounterType.CHARGE.createInstance()));§this.addAbility(ability);§}§public DruidsRepository(final DruidsRepository card) {§super(card);§}§@Override§public DruidsRepository copy() {§return new DruidsRepository(this);§}§}§
public class DualCasting extends CardImpl {§private static final FilterSpell filter = new FilterSpell("instant or sorcery spell");§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.INSTANT),§new CardTypePredicate(CardType.SORCERY)));§filter.add(new ControllerPredicate(TargetController.YOU));§}§public DualCasting(UUID ownerId) {§super(ownerId, 133, "Dual Casting", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{1}{R}");§this.expansionSetCode = "AVR";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new CopyTargetSpellEffect(), new ColoredManaCost(ColoredManaSymbol.R));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetSpell(filter));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(ability, AttachmentType.AURA)));§}§public DualCasting(final DualCasting card) {§super(card);§}§@Override§public DualCasting copy() {§return new DualCasting(this);§}§}§
public class EatenBySpiders extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature with flying");§static {§filter.add(new AbilityPredicate(FlyingAbility.class));§}§public EatenBySpiders(UUID ownerId) {§super(ownerId, 177, "Eaten by Spiders", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{2}{G}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new EatenBySpidersEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent(filter));§}§public EatenBySpiders(final EatenBySpiders card) {§super(card);§}§@Override§public EatenBySpiders copy() {§return new EatenBySpiders(this);§}§}§class EatenBySpidersEffect extends OneShotEffect {§public EatenBySpidersEffect() {§super(Outcome.DestroyPermanent);§this.staticText = "Destroy target creature with flying and all Equipment attached to that creature";§}§public EatenBySpidersEffect(final EatenBySpidersEffect effect) {§super(effect);§}§@Override§public EatenBySpidersEffect copy() {§return new EatenBySpidersEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getPermanent(source.getFirstTarget());§if (permanent != null) {§LinkedList<UUID> attachments = new LinkedList<UUID>();§attachments.addAll(permanent.getAttachments());§for (UUID attachmentId : attachments) {§Permanent attachment = game.getPermanent(attachmentId);§if (attachment.hasSubtype("Equipment")) {§attachment.destroy(source.getSourceId(), game, false);§}§}§permanent.destroy(source.getSourceId(), game, false);§return true;§}§return false;§}§}§
public class ElgaudShieldmate extends CardImpl {§private static final String ruleText = "As long as {this} is paired with another creature, both creatures have hexproof";§public ElgaudShieldmate(UUID ownerId) {§super(ownerId, 50, "Elgaud Shieldmate", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{U}");§this.expansionSetCode = "AVR";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(SoulbondAbility.getInstance());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityPairedEffect(HexproofAbility.getInstance(), ruleText)));§}§public ElgaudShieldmate(final ElgaudShieldmate card) {§super(card);§}§@Override§public ElgaudShieldmate copy() {§return new ElgaudShieldmate(this);§}§}§
public class EmancipationAngel extends CardImpl {§public EmancipationAngel(UUID ownerId) {§super(ownerId, 19, "Emancipation Angel", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{W}{W}");§this.expansionSetCode = "AVR";§this.subtype.add("Angel");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new EntersBattlefieldTriggeredAbility(new ReturnToHandChosenControlledPermanentEffect(new FilterControlledPermanent()), false));§}§public EmancipationAngel(final EmancipationAngel card) {§super(card);§}§@Override§public EmancipationAngel copy() {§return new EmancipationAngel(this);§}§}§
public class EntreatTheAngels extends CardImpl {§public EntreatTheAngels(UUID ownerId) {§super(ownerId, 20, "Entreat the Angels", Rarity.MYTHIC, new CardType[]{CardType.SORCERY}, "{X}{X}{W}{W}{W}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new CreateTokenEffect(new AngelToken(), new ManacostVariableValue()));§this.addAbility(new MiracleAbility(this, new ManaCostsImpl("{X}{W}{W}")));§}§public EntreatTheAngels(final EntreatTheAngels card) {§super(card);§}§@Override§public EntreatTheAngels copy() {§return new EntreatTheAngels(this);§}§}§
public class EssenceHarvest extends CardImpl {§public EssenceHarvest(UUID ownerId) {§super(ownerId, 100, "Essence Harvest", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{2}{B}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new EssenceHarvestEffect());§this.getSpellAbility().addTarget(new TargetPlayer());§}§public EssenceHarvest(final EssenceHarvest card) {§super(card);§}§@Override§public EssenceHarvest copy() {§return new EssenceHarvest(this);§}§}§class EssenceHarvestEffect extends OneShotEffect {§public EssenceHarvestEffect() {§super(Outcome.Damage);§this.staticText = "Target player loses X life and you gain X life, where X is the greatest power among creatures you control";§}§public EssenceHarvestEffect(final EssenceHarvestEffect effect) {§super(effect);§}§@Override§public EssenceHarvestEffect copy() {§return new EssenceHarvestEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§Player targetPlayer = game.getPlayer(source.getFirstTarget());§if (player != null && targetPlayer != null) {§List<Permanent> creatures = game.getBattlefield().getAllActivePermanents(new FilterCreaturePermanent(), player.getId(), game);§int amount = 0;§for (Permanent creature : creatures) {§int power = creature.getPower().getValue();§if (amount < power) {§amount = power;§}§}§if (amount > 0) {§targetPlayer.loseLife(amount, game);§player.gainLife(amount, game);§}§return true;§}§return false;§}§}§
public class EvernightShade extends CardImpl {§public EvernightShade(UUID ownerId) {§super(ownerId, 101, "Evernight Shade", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{B}");§this.expansionSetCode = "AVR";§this.subtype.add("Shade");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(1, 1, Duration.EndOfTurn), new ManaCostsImpl("{B}")));§this.addAbility(new UndyingAbility());§}§public EvernightShade(final EvernightShade card) {§super(card);§}§@Override§public EvernightShade copy() {§return new EvernightShade(this);§}§}§
public class ExquisiteBlood extends CardImpl {§public ExquisiteBlood(UUID ownerId) {§super(ownerId, 102, "Exquisite Blood", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{4}{B}");§this.expansionSetCode = "AVR";§ExquisiteBloodTriggeredAbility ability = new ExquisiteBloodTriggeredAbility();§this.addAbility(ability);§}§public ExquisiteBlood(final ExquisiteBlood card) {§super(card);§}§@Override§public ExquisiteBlood copy() {§return new ExquisiteBlood(this);§}§}§class ExquisiteBloodTriggeredAbility extends TriggeredAbilityImpl {§public ExquisiteBloodTriggeredAbility() {§super(Zone.BATTLEFIELD, null);§}§public ExquisiteBloodTriggeredAbility(final ExquisiteBloodTriggeredAbility ability) {§super(ability);§}§@Override§public ExquisiteBloodTriggeredAbility copy() {§return new ExquisiteBloodTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.LOST_LIFE;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (game.getOpponents(this.controllerId).contains(event.getPlayerId())) {§this.getEffects().clear();§this.addEffect(new GainLifeEffect(event.getAmount()));§return true;§}§return false;§}§@Override§public String getRule() {§return "Whenever an opponent loses life, you gain that much life.";§}§}§
public class FalkenrathExterminator extends CardImpl {§public FalkenrathExterminator(UUID ownerId) {§super(ownerId, 134, "Falkenrath Exterminator", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{R}");§this.expansionSetCode = "AVR";§this.subtype.add("Vampire");§this.subtype.add("Archer");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new DealsCombatDamageToAPlayerTriggeredAbility(new AddCountersSourceEffect(CounterType.P1P1.createInstance()), false));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(new CountersCount(CounterType.P1P1)), new ManaCostsImpl("{2}{R}"));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public FalkenrathExterminator(final FalkenrathExterminator card) {§super(card);§}§@Override§public FalkenrathExterminator copy() {§return new FalkenrathExterminator(this);§}§}§
public class FarbogExplorer extends CardImpl {§public FarbogExplorer(UUID ownerId) {§super(ownerId, 21, "Farbog Explorer", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "AVR";§this.subtype.add("Human");§this.subtype.add("Scout");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(new SwampwalkAbility());§}§public FarbogExplorer(final FarbogExplorer card) {§super(card);§}§@Override§public FarbogExplorer copy() {§return new FarbogExplorer(this);§}§}§
public class FavorableWinds extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Creatures you control with flying");§static {§filter.add(new AbilityPredicate(FlyingAbility.class));§}§public FavorableWinds(UUID ownerId) {§super(ownerId, 51, "Favorable Winds", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{U}");§this.expansionSetCode = "AVR";§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostControlledEffect(1, 1, Duration.WhileOnBattlefield, filter, false)));§}§public FavorableWinds(final FavorableWinds card) {§super(card);§}§@Override§public FavorableWinds copy() {§return new FavorableWinds(this);§}§}§
public class FerventCathar extends CardImpl {§public FerventCathar(UUID ownerId) {§super(ownerId, 135, "Fervent Cathar", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "AVR";§this.subtype.add("Human");§this.subtype.add("Knight");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(HasteAbility.getInstance());§Ability ability = new EntersBattlefieldTriggeredAbility(new CantBlockTargetEffect(Duration.EndOfTurn));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public FerventCathar(final FerventCathar card) {§super(card);§}§@Override§public FerventCathar copy() {§return new FerventCathar(this);§}§}§
public class GallowsAtWillowHill extends CardImpl {§private static final FilterControlledPermanent humanFilter = new FilterControlledPermanent("untapped Human you control");§static {§humanFilter.add(Predicates.not(new TappedPredicate()));§humanFilter.add(new SubtypePredicate("Human"));§}§public GallowsAtWillowHill(UUID ownerId) {§super(ownerId, 215, "Gallows at Willow Hill", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "AVR";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new GallowsAtWillowHillEffect(), new GenericManaCost(3));§ability.addCost(new TapSourceCost());§ability.addCost(new TapTargetCost(new TargetControlledPermanent(3, 3, humanFilter, false)));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public GallowsAtWillowHill(final GallowsAtWillowHill card) {§super(card);§}§@Override§public GallowsAtWillowHill copy() {§return new GallowsAtWillowHill(this);§}§}§class GallowsAtWillowHillEffect extends OneShotEffect {§public GallowsAtWillowHillEffect() {§super(Outcome.DestroyPermanent);§staticText = "Destroy target creature. Its controller puts a 1/1 white Spirit creature token with flying onto the battlefield";§}§public GallowsAtWillowHillEffect(final GallowsAtWillowHillEffect effect) {§super(effect);§}§@Override§public GallowsAtWillowHillEffect copy() {§return new GallowsAtWillowHillEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§int affectedTargets = 0;§if (targetPointer.getTargets(game, source).size() > 0) {§for (UUID permanentId : targetPointer.getTargets(game, source)) {§Permanent permanent = game.getPermanent(permanentId);§if (permanent != null) {§Player controller = game.getPlayer(permanent.getControllerId());§permanent.destroy(source.getSourceId(), game, false);§if (controller != null) {§new CreateTokenEffect(new SpiritWhiteToken()).apply(game, source);§}§affectedTargets++;§}§}§}§return affectedTargets > 0;§}§}§
public class GalvanicAlchemist extends CardImpl {§private static final String ruleText = "As long as {this} is paired with another creature, each of those creatures has \"{2}{U}: Untap this creature.\"";§public GalvanicAlchemist(UUID ownerId) {§super(ownerId, 54, "Galvanic Alchemist", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{U}");§this.expansionSetCode = "AVR";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(4);§this.addAbility(SoulbondAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new UntapSourceEffect(), new ManaCostsImpl("{2}{U}"));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityPairedEffect(ability, ruleText)));§}§public GalvanicAlchemist(final GalvanicAlchemist card) {§super(card);§}§@Override§public GalvanicAlchemist copy() {§return new GalvanicAlchemist(this);§}§}§
public class GangOfDevils extends CardImpl {§public GangOfDevils(UUID ownerId) {§super(ownerId, 136, "Gang of Devils", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{5}{R}");§this.expansionSetCode = "AVR";§this.subtype.add("Devil");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§Ability ability = new DiesTriggeredAbility(new DamageMultiEffect(3));§ability.addTarget(new TargetCreatureOrPlayerAmount(3));§this.addAbility(ability);§}§public GangOfDevils(final GangOfDevils card) {§super(card);§}§@Override§public GangOfDevils copy() {§return new GangOfDevils(this);§}§}§
public class GeistSnatch extends CardImpl {§private static final FilterSpell filter = new FilterSpell("creature spell");§static {§filter.add(new CardTypePredicate(CardType.CREATURE));§}§public GeistSnatch(UUID ownerId) {§super(ownerId, 55, "Geist Snatch", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{U}{U}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addTarget(new TargetSpell(filter));§this.getSpellAbility().addEffect(new GeistSnatchCounterTargetEffect());§}§public GeistSnatch(final GeistSnatch card) {§super(card);§}§@Override§public GeistSnatch copy() {§return new GeistSnatch(this);§}§}§class GeistSnatchCounterTargetEffect extends OneShotEffect {§public GeistSnatchCounterTargetEffect() {§super(Outcome.Detriment);§staticText = "Counter target creature spell. Put a 1/1 blue Spirit creature token with flying onto the battlefield";§}§public GeistSnatchCounterTargetEffect(final GeistSnatchCounterTargetEffect effect) {§super(effect);§}§@Override§public GeistSnatchCounterTargetEffect copy() {§return new GeistSnatchCounterTargetEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§game.getStack().counter(source.getFirstTarget(), source.getSourceId(), game);§Token token = new SpiritBlueToken();§token.putOntoBattlefield(1, game, source.getSourceId(), source.getControllerId());§return true;§}§}§class SpiritBlueToken extends Token {§public SpiritBlueToken() {§super("Spirit", "1/1 blue Spirit creature token with flying");§cardType.add(CardType.CREATURE);§subtype.add("Spirit");§color.setBlue(true);§power = new MageInt(1);§toughness = new MageInt(1);§setTokenType(2);§addAbility(FlyingAbility.getInstance());§}§}§
public class GeistTrappers extends CardImpl {§private static final String ruleText = "As long as {this} is paired with another creature, both creatures have reach";§public GeistTrappers(UUID ownerId) {§super(ownerId, 179, "Geist Trappers", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{G}");§this.expansionSetCode = "AVR";§this.subtype.add("Human");§this.subtype.add("Warrior");§this.power = new MageInt(3);§this.toughness = new MageInt(5);§this.addAbility(SoulbondAbility.getInstance());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityPairedEffect(ReachAbility.getInstance(), ruleText)));§}§public GeistTrappers(final GeistTrappers card) {§super(card);§}§@Override§public GeistTrappers copy() {§return new GeistTrappers(this);§}§}§
public class Ghostform extends CardImpl {§public Ghostform(UUID ownerId) {§super(ownerId, 56, "Ghostform", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{1}{U}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new CantBeBlockedTargetEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent(0, 2));§}§public Ghostform(final Ghostform card) {§super(card);§}§@Override§public Ghostform copy() {§return new Ghostform(this);§}§}§
public class GhostlyFlicker extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("artifacts, creatures, and/or lands you control");§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.CREATURE),§new CardTypePredicate(CardType.LAND),§new CardTypePredicate(CardType.ARTIFACT)));§}§public GhostlyFlicker(UUID ownerId) {§super(ownerId, 57, "Ghostly Flicker", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{U}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addTarget(new TargetControlledPermanent(2, 2, filter, false));§this.getSpellAbility().addEffect(new GhostlyFlickerEffect());§}§public GhostlyFlicker(final GhostlyFlicker card) {§super(card);§}§@Override§public GhostlyFlicker copy() {§return new GhostlyFlicker(this);§}§}§class GhostlyFlickerEffect extends OneShotEffect {§public GhostlyFlickerEffect() {§super(Outcome.Benefit);§staticText = "Exile two target artifacts, creatures, and/or lands you control, then return those cards to the battlefield under your control";§}§public GhostlyFlickerEffect(final GhostlyFlickerEffect effect) {§super(effect);§}§@Override§public GhostlyFlickerEffect copy() {§return new GhostlyFlickerEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§UUID exileId = source.getSourceId();§for (UUID permanentId : targetPointer.getTargets(game, source)) {§Permanent target = game.getPermanent(permanentId);§if (target != null) {§target.moveToExile(exileId, "Ghostly Flicker", source.getSourceId(), game);§Card card = game.getCard(target.getId());§if (card != null) {§Zone currentZone = game.getState().getZone(card.getId());§card.putOntoBattlefield(game, currentZone, source.getSourceId(), source.getControllerId());§}§}§}§return true;§}§}§
public class GhostlyTouch extends CardImpl {§public GhostlyTouch(UUID ownerId) {§super(ownerId, 58, "Ghostly Touch", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{U}");§this.expansionSetCode = "AVR";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§Ability gainedAbility = new AttacksTriggeredAbility(new MayTapOrUntapTargetEffect(), true);§gainedAbility.addTarget(new TargetPermanent());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(gainedAbility, AttachmentType.AURA)));§}§public GhostlyTouch(final GhostlyTouch card) {§super(card);§}§@Override§public GhostlyTouch copy() {§return new GhostlyTouch(this);§}§}§
public class Ghoulflesh extends CardImpl {§public Ghoulflesh(UUID ownerId) {§super(ownerId, 103, "Ghoulflesh", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{B}");§this.expansionSetCode = "AVR";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.UnboostCreature));§this.addAbility(new EnchantAbility(auraTarget.getTargetName()));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(-1, -1, Duration.WhileOnBattlefield)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new AddCardSubtypeAttachedEffect("Zombie", Duration.WhileOnBattlefield, AttachmentType.AURA)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new AddCardColorAttachedEffect(ObjectColor.BLACK, Duration.WhileOnBattlefield, AttachmentType.AURA)));§}§public Ghoulflesh(final Ghoulflesh card) {§super(card);§}§@Override§public Ghoulflesh copy() {§return new Ghoulflesh(this);§}§}§
public class GiselaBladeOfGoldnight extends CardImpl {§public GiselaBladeOfGoldnight(UUID ownerId) {§super(ownerId, 209, "Gisela, Blade of Goldnight", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{4}{R}{W}{W}");§this.expansionSetCode = "AVR";§this.supertype.add("Legendary");§this.subtype.add("Angel");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(FirstStrikeAbility.getInstance());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GiselaBladeOfGoldnightDoubleDamageEffect()));§}§public GiselaBladeOfGoldnight(final GiselaBladeOfGoldnight card) {§super(card);§}§@Override§public GiselaBladeOfGoldnight copy() {§return new GiselaBladeOfGoldnight(this);§}§}§class GiselaBladeOfGoldnightDoubleDamageEffect extends ReplacementEffectImpl {§public GiselaBladeOfGoldnightDoubleDamageEffect() {§super(Duration.WhileOnBattlefield, Outcome.Damage);§staticText = "If a source would deal damage to an opponent or a permanent an opponent controls, that source deals double that damage to that player or permanent instead."§+ "If a source would deal damage to you or a permanent you control, prevent half that damage, rounded up";§}§public GiselaBladeOfGoldnightDoubleDamageEffect(final GiselaBladeOfGoldnightDoubleDamageEffect effect) {§super(effect);§}§@Override§public GiselaBladeOfGoldnightDoubleDamageEffect copy() {§return new GiselaBladeOfGoldnightDoubleDamageEffect(this);§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType().equals(EventType.DAMAGE_CREATURE) ||§event.getType().equals(EventType.DAMAGE_PLANESWALKER) ||§event.getType().equals(EventType.DAMAGE_PLAYER);§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§return true;§}§private void preventDamage(GameEvent event, Ability source, UUID target, Game game) {§int amount = (int)Math.ceil(event.getAmount() / 2.0);§GameEvent preventEvent = new GameEvent(GameEvent.EventType.PREVENT_DAMAGE, target, source.getSourceId(), source.getControllerId(), amount, false);§if (!game.replaceEvent(preventEvent)) {§event.setAmount(event.getAmount() - amount);§game.fireEvent(GameEvent.getEvent(GameEvent.EventType.PREVENTED_DAMAGE, target, source.getSourceId(), source.getControllerId(), amount));§}§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§switch (event.getType()) {§case DAMAGE_PLAYER:§if (event.getTargetId().equals(source.getControllerId())) {§preventDamage(event, source, source.getControllerId(), game);§} else if (game.getOpponents(source.getControllerId()).contains(event.getTargetId())) {§event.setAmount(event.getAmount() * 2);§}§break;§case DAMAGE_CREATURE:§case DAMAGE_PLANESWALKER:§Permanent permanent = game.getPermanent(event.getTargetId());§if (permanent != null) {§if (permanent.getControllerId().equals(source.getControllerId())) {§preventDamage(event, source, permanent.getId(), game);§} else if (game.getOpponents(source.getControllerId()).contains(permanent.getControllerId())) {§event.setAmount(event.getAmount() * 2);§}§}§}§return false;§}§}§
public class GloomSurgeon extends CardImpl {§public GloomSurgeon(UUID ownerId) {§super(ownerId, 104, "Gloom Surgeon", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{B}");§this.expansionSetCode = "AVR";§this.subtype.add("Spirit");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GloomSurgeonEffect()));§}§public GloomSurgeon(final GloomSurgeon card) {§super(card);§}§@Override§public GloomSurgeon copy() {§return new GloomSurgeon(this);§}§}§class GloomSurgeonEffect extends ReplacementEffectImpl {§GloomSurgeonEffect() {§super(Duration.WhileOnBattlefield, Outcome.Exile);§staticText = "If combat damage would be dealt to {this}, prevent that damage and exile that many cards from the top of your library";§}§GloomSurgeonEffect(final GloomSurgeonEffect effect) {§super(effect);§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§GameEvent preventEvent = new GameEvent(GameEvent.EventType.PREVENT_DAMAGE, source.getFirstTarget(), source.getSourceId(), source.getControllerId(), event.getAmount(), false);§if (!game.replaceEvent(preventEvent)) {§int preventedDamage = event.getAmount();§game.fireEvent(GameEvent.getEvent(GameEvent.EventType.PREVENTED_DAMAGE, source.getFirstTarget(), source.getSourceId(), source.getControllerId(), preventedDamage));§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§player.moveCards(player.getLibrary().getTopCards(game, preventedDamage), Zone.EXILED, source, game);§}§return true;§}§return false;§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.DAMAGE_CREATURE;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§if (event.getTargetId().equals(source.getSourceId())) {§DamageCreatureEvent damageEvent = (DamageCreatureEvent) event;§if (damageEvent.isCombatDamage()) {§return true;§}§}§return false;§}§@Override§public GloomSurgeonEffect copy() {§return new GloomSurgeonEffect(this);§}§}§
public class Gloomwidow extends CardImpl {§public Gloomwidow(UUID ownerId) {§super(ownerId, 180, "Gloomwidow", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{G}");§this.expansionSetCode = "AVR";§this.subtype.add("Spider");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(ReachAbility.getInstance());§this.addAbility(new CanBlockOnlyFlyingAbility());§}§public Gloomwidow(final Gloomwidow card) {§super(card);§}§@Override§public Gloomwidow copy() {§return new Gloomwidow(this);§}§}§
public class GoldnightCommander extends CardImpl {§public GoldnightCommander(UUID ownerId) {§super(ownerId, 22, "Goldnight Commander", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{W}");§this.expansionSetCode = "AVR";§this.subtype.add("Human");§this.subtype.add("Cleric");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new EntersAnotherCreatureYourControlTriggeredAbility(new BoostControlledEffect(1, 1, Duration.EndOfTurn)));§}§public GoldnightCommander(final GoldnightCommander card) {§super(card);§}§@Override§public GoldnightCommander copy() {§return new GoldnightCommander(this);§}§}§
public class GoldnightRedeemer extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("other creature you control");§static {§filter.add(new AnotherPredicate());§}§public GoldnightRedeemer(UUID ownerId) {§super(ownerId, 23, "Goldnight Redeemer", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{W}{W}");§this.expansionSetCode = "AVR";§this.subtype.add("Angel");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new EntersBattlefieldTriggeredAbility(new GainLifeEffect(new PermanentsOnBattlefieldCount(filter, 2)), false));§}§public GoldnightRedeemer(final GoldnightRedeemer card) {§super(card);§}§@Override§public GoldnightRedeemer copy() {§return new GoldnightRedeemer(this);§}§}§
public class GraveExchange extends CardImpl {§private static final FilterCreatureCard filter = new FilterCreatureCard("creature card from your graveyard");§public GraveExchange(UUID ownerId) {§super(ownerId, 105, "Grave Exchange", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{4}{B}{B}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new ReturnToHandTargetEffect());§this.getSpellAbility().addTarget(new TargetCardInYourGraveyard(filter));§this.getSpellAbility().addEffect(new GraveExchangeEffect());§this.getSpellAbility().addTarget(new TargetPlayer());§}§public GraveExchange(final GraveExchange card) {§super(card);§}§@Override§public GraveExchange copy() {§return new GraveExchange(this);§}§}§class GraveExchangeEffect extends OneShotEffect {§public GraveExchangeEffect() {§super(Outcome.Sacrifice);§this.staticText = "Target player sacrifices a creature";§}§public GraveExchangeEffect(final GraveExchangeEffect effect) {§super(effect);§}§@Override§public GraveExchangeEffect copy() {§return new GraveExchangeEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getTargets().get(1).getFirstTarget());§if (player == null) {§return false;§}§Target target = new TargetControlledPermanent(new FilterControlledCreaturePermanent());§if (target.canChoose(player.getId(), game) && player.choose(Outcome.Sacrifice, target, source.getSourceId(), game)) {§Permanent permanent = game.getPermanent(target.getFirstTarget());§if (permanent != null) {§return permanent.sacrifice(source.getSourceId(), game);§}§}§return false;§}§}§
public class Griselbrand extends CardImpl {§public Griselbrand(UUID ownerId) {§super(ownerId, 106, "Griselbrand", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{4}{B}{B}{B}{B}");§this.expansionSetCode = "AVR";§this.supertype.add("Legendary");§this.subtype.add("Demon");§this.power = new MageInt(7);§this.toughness = new MageInt(7);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(LifelinkAbility.getInstance());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new DrawCardSourceControllerEffect(7), new PayLifeCost(7)));§}§public Griselbrand(final Griselbrand card) {§super(card);§}§@Override§public Griselbrand copy() {§return new Griselbrand(this);§}§}§
public class Grounded extends CardImpl {§public Grounded(UUID ownerId) {§super(ownerId, 181, "Grounded", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{G}");§this.expansionSetCode = "AVR";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.LoseAbility));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new LoseAbilityAttachedEffect(FlyingAbility.getInstance(), AttachmentType.AURA)));§}§public Grounded(final Grounded card) {§super(card);§}§@Override§public Grounded copy() {§return new Grounded(this);§}§}§
public class GryffVanguard extends CardImpl {§public GryffVanguard(UUID ownerId) {§super(ownerId, 59, "Gryff Vanguard", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{U}");§this.expansionSetCode = "AVR";§this.subtype.add("Human");§this.subtype.add("Knight");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new EntersBattlefieldTriggeredAbility(new DrawCardSourceControllerEffect(1)));§}§public GryffVanguard(final GryffVanguard card) {§super(card);§}§@Override§public GryffVanguard copy() {§return new GryffVanguard(this);§}§}§
public class HarvesterOfSouls extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("another nontoken creature");§static {§filter.add(Predicates.not(new TokenPredicate()));§filter.add(new AnotherPredicate());§}§public HarvesterOfSouls(UUID ownerId) {§super(ownerId, 107, "Harvester of Souls", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{B}{B}");§this.expansionSetCode = "AVR";§this.subtype.add("Demon");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(DeathtouchAbility.getInstance());§this.addAbility(new DiesCreatureTriggeredAbility(new DrawCardSourceControllerEffect(1), true, filter));§}§public HarvesterOfSouls(final HarvesterOfSouls card) {§super(card);§}§@Override§public HarvesterOfSouls copy() {§return new HarvesterOfSouls(this);§}§}§
public class HauntedGuardian extends CardImpl {§public HauntedGuardian(UUID ownerId) {§super(ownerId, 216, "Haunted Guardian", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{2}");§this.expansionSetCode = "AVR";§this.subtype.add("Construct");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(DefenderAbility.getInstance());§this.addAbility(FirstStrikeAbility.getInstance());§}§public HauntedGuardian(final HauntedGuardian card) {§super(card);§}§@Override§public HauntedGuardian copy() {§return new HauntedGuardian(this);§}§}§
public class HavengulSkaab extends CardImpl {§public HavengulSkaab(UUID ownerId) {§super(ownerId, 60, "Havengul Skaab", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{5}{U}");§this.expansionSetCode = "AVR";§this.subtype.add("Zombie");§this.subtype.add("Horror");§this.power = new MageInt(4);§this.toughness = new MageInt(5);§this.addAbility(new HavengulSkaabAbility());§}§public HavengulSkaab(final HavengulSkaab card) {§super(card);§}§@Override§public HavengulSkaab copy() {§return new HavengulSkaab(this);§}§}§class HavengulSkaabAbility extends TriggeredAbilityImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("another creature you control");§static {§filter.add(new AnotherPredicate());§}§public HavengulSkaabAbility() {§super(Zone.BATTLEFIELD, new DestroyTargetEffect());§this.addEffect(new ReturnToHandTargetEffect());§}§public HavengulSkaabAbility(final HavengulSkaabAbility ability) {§super(ability);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.ATTACKER_DECLARED;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (event.getSourceId().equals(this.getSourceId())) {§TargetControlledCreaturePermanent target = new TargetControlledCreaturePermanent(1, 1, filter, false);§this.addTarget(target);§return true;§}§return false;§}§@Override§public String getRule() {§return "Whenever {this} attacks, return another creature you control to its owner's hand.";§}§@Override§public HavengulSkaabAbility copy() {§return new HavengulSkaabAbility(this);§}§}§
public class HavengulVampire extends CardImpl {§public HavengulVampire(UUID ownerId) {§super(ownerId, 139, "Havengul Vampire", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{R}");§this.expansionSetCode = "AVR";§this.subtype.add("Vampire");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new DealsCombatDamageToAPlayerTriggeredAbility(new AddCountersSourceEffect(CounterType.P1P1.createInstance()), false));§this.addAbility(new DiesCreatureTriggeredAbility(new AddCountersSourceEffect(CounterType.P1P1.createInstance()), false, true));§}§public HavengulVampire(final HavengulVampire card) {§super(card);§}§@Override§public HavengulVampire copy() {§return new HavengulVampire(this);§}§}§
public class HeirsOfStromkirk extends CardImpl {§public HeirsOfStromkirk(UUID ownerId) {§super(ownerId, 140, "Heirs of Stromkirk", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{R}{R}");§this.expansionSetCode = "AVR";§this.subtype.add("Vampire");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(IntimidateAbility.getInstance());§this.addAbility(new DealsCombatDamageToAPlayerTriggeredAbility(new AddCountersSourceEffect(CounterType.P1P1.createInstance()), false));§}§public HeirsOfStromkirk(final HeirsOfStromkirk card) {§super(card);§}§@Override§public HeirsOfStromkirk copy() {§return new HeirsOfStromkirk(this);§}§}§
public class HeraldOfWar extends CardImpl {§public HeraldOfWar(UUID ownerId) {§super(ownerId, 24, "Herald of War", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{W}{W}");§this.expansionSetCode = "AVR";§this.subtype.add("Angel");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new AttacksTriggeredAbility(new AddCountersSourceEffect(CounterType.P1P1.createInstance()), false));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new HeraldOfWarCostReductionEffect()));§}§public HeraldOfWar(final HeraldOfWar card) {§super(card);§}§@Override§public HeraldOfWar copy() {§return new HeraldOfWar(this);§}§}§class HeraldOfWarCostReductionEffect extends CostModificationEffectImpl {§HeraldOfWarCostReductionEffect() {§super(Duration.WhileOnBattlefield, Outcome.Benefit, CostModificationType.REDUCE_COST);§staticText = "Angel spells and Human spells you cast cost {1} less to cast for each +1/+1 counter on Herald of War";§}§HeraldOfWarCostReductionEffect(HeraldOfWarCostReductionEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source, Ability abilityToModify) {§SpellAbility spellAbility = (SpellAbility) abilityToModify;§Permanent sourcePermanent = game.getPermanent(source.getSourceId());§if (sourcePermanent != null) {§int amount = sourcePermanent.getCounters().getCount(CounterType.P1P1);§if (amount > 0) {§CardUtil.adjustCost(spellAbility, amount);§return true;§}§}§return false;§}§@Override§public boolean applies(Ability abilityToModify, Ability source, Game game) {§if (abilityToModify instanceof SpellAbility || abilityToModify instanceof FlashbackAbility) {§Card sourceCard = game.getCard(abilityToModify.getSourceId());§if (sourceCard != null && abilityToModify.getControllerId().equals(source.getControllerId()) && (sourceCard.hasSubtype("Angel") || sourceCard.hasSubtype("Human"))) {§return true;§}§}§return false;§}§@Override§public HeraldOfWarCostReductionEffect copy() {§return new HeraldOfWarCostReductionEffect(this);§}§}§
public class HolyJusticiar extends CardImpl {§public HolyJusticiar(UUID ownerId) {§super(ownerId, 25, "Holy Justiciar", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{W}");§this.expansionSetCode = "AVR";§this.subtype.add("Human");§this.subtype.add("Cleric");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new HolyJusticiarEffect(), new ManaCostsImpl("{2}{W}"));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public HolyJusticiar(final HolyJusticiar card) {§super(card);§}§@Override§public HolyJusticiar copy() {§return new HolyJusticiar(this);§}§}§class HolyJusticiarEffect extends OneShotEffect {§public HolyJusticiarEffect() {§super(Outcome.Detriment);§staticText = "Tap target creature. If that creature is a Zombie, exile it";§}§public HolyJusticiarEffect(final HolyJusticiarEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent creature = game.getPermanent(source.getFirstTarget());§if (creature != null) {§if (creature.hasSubtype("Zombie")) {§creature.tap(game);§creature.moveToExile(source.getSourceId(), creature.getName(), source.getSourceId(), game);§} else {§creature.tap(game);§}§return true;§}§return false;§}§@Override§public HolyJusticiarEffect copy() {§return new HolyJusticiarEffect(this);§}§}§
public class HomicidalSeclusion extends CardImpl {§private static final String rule = "As long as you control exactly one creature, that creature gets +3/+1";§public HomicidalSeclusion(UUID ownerId) {§super(ownerId, 108, "Homicidal Seclusion", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{4}{B}");§this.expansionSetCode = "AVR";§ContinuousEffect boostEffect = new BoostControlledEffect(3, 1, Duration.WhileOnBattlefield);§Effect effect = new ConditionalContinuousEffect(boostEffect, new OneControlledCreatureCondition(), rule);§Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, effect);§ContinuousEffect lifelinkEffect = new GainAbilityControlledEffect(LifelinkAbility.getInstance(), Duration.WhileOnBattlefield);§effect = new ConditionalContinuousEffect(lifelinkEffect, new OneControlledCreatureCondition(), "and has lifelink");§ability.addEffect(effect);§this.addAbility(ability);§}§public HomicidalSeclusion(final HomicidalSeclusion card) {§super(card);§}§@Override§public HomicidalSeclusion copy() {§return new HomicidalSeclusion(this);§}§}§
public class HoundOfGriselbrand extends CardImpl {§public HoundOfGriselbrand(UUID ownerId) {§super(ownerId, 141, "Hound of Griselbrand", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{R}{R}");§this.expansionSetCode = "AVR";§this.subtype.add("Elemental");§this.subtype.add("Hound");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(DoubleStrikeAbility.getInstance());§this.addAbility(new UndyingAbility());§}§public HoundOfGriselbrand(final HoundOfGriselbrand card) {§super(card);§}§@Override§public HoundOfGriselbrand copy() {§return new HoundOfGriselbrand(this);§}§}§
public class Howlgeist extends CardImpl {§public Howlgeist(UUID ownerId) {§super(ownerId, 182, "Howlgeist", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{5}{G}");§this.expansionSetCode = "AVR";§this.subtype.add("Spirit");§this.subtype.add("Wolf");§this.power = new MageInt(4);§this.toughness = new MageInt(2);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new CantBeBlockedByCreaturesWithLessPowerEffect()));§this.addAbility(new UndyingAbility());§}§public Howlgeist(final Howlgeist card) {§super(card);§}§@Override§public Howlgeist copy() {§return new Howlgeist(this);§}§}§
public class HumanFrailty extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Human creature");§static {§filter.add(new SubtypePredicate("Human"));§}§public HumanFrailty(UUID ownerId) {§super(ownerId, 109, "Human Frailty", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{B}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addTarget(new TargetPermanent(filter));§this.getSpellAbility().addEffect(new DestroyTargetEffect());§}§public HumanFrailty(final HumanFrailty card) {§super(card);§}§@Override§public HumanFrailty copy() {§return new HumanFrailty(this);§}§}§
public class HuntedGhoul extends CardImpl {§public HuntedGhoul(UUID ownerId) {§super(ownerId, 110, "Hunted Ghoul", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{B}");§this.expansionSetCode = "AVR";§this.subtype.add("Zombie");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§this.addAbility(new SimpleEvasionAbility(new CantBlockCreaturesSourceEffect(new FilterCreaturePermanent("Human", "Humans"))));§}§public HuntedGhoul(final HuntedGhoul card) {§super(card);§}§@Override§public HuntedGhoul copy() {§return new HuntedGhoul(this);§}§}§
public class InfiniteReflection extends CardImpl {§public InfiniteReflection(UUID ownerId) {§super(ownerId, 61, "Infinite Reflection", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{5}{U}");§this.expansionSetCode = "AVR";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.Copy));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new EntersBattlefieldTriggeredAbility(new InfiniteReflectionTriggeredEffect()));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new InfiniteReflectionEntersBattlefieldEffect()));§}§public InfiniteReflection(final InfiniteReflection card) {§super(card);§}§@Override§public InfiniteReflection copy() {§return new InfiniteReflection(this);§}§}§class InfiniteReflectionTriggeredEffect extends OneShotEffect {§private static final FilterPermanent filter = new FilterControlledCreaturePermanent();§public InfiniteReflectionTriggeredEffect() {§super(Outcome.Sacrifice);§this.staticText = " attached to a creature, each other nontoken creature you control becomes a copy of that creature";§}§public InfiniteReflectionTriggeredEffect(final InfiniteReflectionTriggeredEffect effect) {§super(effect);§}§@Override§public InfiniteReflectionTriggeredEffect copy() {§return new InfiniteReflectionTriggeredEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent sourcePermanent = game.getPermanent(source.getSourceId());§if (sourcePermanent != null && sourcePermanent.getAttachedTo() != null) {§Permanent toCopyFromPermanent = game.getPermanent(sourcePermanent.getAttachedTo());§if (toCopyFromPermanent != null) {§for (Permanent toCopyToPermanent : game.getBattlefield().getAllActivePermanents(filter, source.getControllerId(), game)) {§if (!toCopyToPermanent.equals(toCopyFromPermanent) && !(toCopyToPermanent instanceof PermanentToken)) {§game.copyPermanent(toCopyFromPermanent, toCopyToPermanent.getId(), source, new EmptyApplyToPermanent());§}§}§return true;§}§}§return false;§}§}§class InfiniteReflectionEntersBattlefieldEffect extends ReplacementEffectImpl {§public InfiniteReflectionEntersBattlefieldEffect() {§super(Duration.WhileOnBattlefield, Outcome.Benefit);§}§public InfiniteReflectionEntersBattlefieldEffect(InfiniteReflectionEntersBattlefieldEffect effect) {§super(effect);§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.ENTERS_THE_BATTLEFIELD;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§Permanent permanent = ((EntersTheBattlefieldEvent) event).getTarget();§return permanent != null && permanent.getControllerId().equals(source.getControllerId())§&& permanent.getCardType().contains(CardType.CREATURE)§&& !(permanent instanceof PermanentToken);§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§MageObject toCopyToObject = ((EntersTheBattlefieldEvent) event).getTarget();§Permanent sourcePermanent = game.getPermanent(source.getSourceId());§if (sourcePermanent != null && toCopyToObject != null && sourcePermanent.getAttachedTo() != null) {§Permanent toCopyFromPermanent = game.getPermanent(sourcePermanent.getAttachedTo());§if (toCopyFromPermanent != null) {§game.copyPermanent(toCopyFromPermanent, toCopyToObject.getId(), source, new EmptyApplyToPermanent());§}§}§return false;§}§@Override§public String getText(Mode mode) {§return "Nontoken creatures you control enter the battlefield as a copy of enchanted creature";§}§@Override§public InfiniteReflectionEntersBattlefieldEffect copy() {§return new InfiniteReflectionEntersBattlefieldEffect(this);§}§}§
public class IntoTheVoid extends CardImpl {§public IntoTheVoid(UUID ownerId) {§super(ownerId, 62, "Into the Void", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{3}{U}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new ReturnToHandTargetEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent(0, 2));§}§public IntoTheVoid(final IntoTheVoid card) {§super(card);§}§@Override§public IntoTheVoid copy() {§return new IntoTheVoid(this);§}§}§
public class JointAssault extends CardImpl {§public JointAssault(UUID ownerId) {§super(ownerId, 183, "Joint Assault", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{G}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new JointAssaultBoostTargetEffect(2, 2, Duration.EndOfTurn));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public JointAssault(final JointAssault card) {§super(card);§}§@Override§public JointAssault copy() {§return new JointAssault(this);§}§}§class JointAssaultBoostTargetEffect extends ContinuousEffectImpl {§private int power;§private int toughness;§private UUID paired;§public JointAssaultBoostTargetEffect(int power, int toughness, Duration duration) {§super(duration, Layer.PTChangingEffects_7, SubLayer.ModifyPT_7c, Outcome.BoostCreature);§this.power = power;§this.toughness = toughness;§staticText = "Target creature gets +2/+2 until end of turn. If it's paired with a creature, that creature also gets +2/+2 until end of turn";§}§public JointAssaultBoostTargetEffect(final JointAssaultBoostTargetEffect effect) {§super(effect);§this.power = effect.power;§this.toughness = effect.toughness;§}§@Override§public JointAssaultBoostTargetEffect copy() {§return new JointAssaultBoostTargetEffect(this);§}§@Override§public void init(Ability source, Game game) {§super.init(source, game);§UUID permanentId = targetPointer.getFirst(game, source);§Permanent target = game.getPermanent(permanentId);§if (target != null) {§if (target.getPairedCard() != null) {§this.paired = target.getPairedCard();§}§}§}§@Override§public boolean apply(Game game, Ability source) {§int affectedTargets = 0;§UUID permanentId = targetPointer.getFirst(game, source);§Permanent target = game.getPermanent(permanentId);§if (target != null) {§target.addPower(power);§target.addToughness(toughness);§affectedTargets++;§}§if (this.paired != null) {§Permanent paired = game.getPermanent(this.paired);§if (paired != null) {§paired.addPower(power);§paired.addToughness(toughness);§affectedTargets++;§}§}§return affectedTargets > 0;§}§}§
public class KessigMalcontents extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("Humans you control");§static {§filter.add(new SubtypePredicate("Human"));§}§public KessigMalcontents(UUID ownerId) {§super(ownerId, 142, "Kessig Malcontents", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "AVR";§this.subtype.add("Human");§this.subtype.add("Warrior");§this.power = new MageInt(3);§this.toughness = new MageInt(1);§Ability ability = new EntersBattlefieldTriggeredAbility(new DamageTargetEffect(new PermanentsOnBattlefieldCount(filter)));§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§}§public KessigMalcontents(final KessigMalcontents card) {§super(card);§}§@Override§public KessigMalcontents copy() {§return new KessigMalcontents(this);§}§}§
public class KillingWave extends CardImpl {§public KillingWave(UUID ownerId) {§super(ownerId, 111, "Killing Wave", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{X}{B}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new KillingWaveEffect());§}§public KillingWave(final KillingWave card) {§super(card);§}§@Override§public KillingWave copy() {§return new KillingWave(this);§}§}§class KillingWaveEffect extends OneShotEffect {§public KillingWaveEffect() {§super(Outcome.Sacrifice);§this.staticText = "For each creature, its controller sacrifices it unless he or she pays X life";§}§public KillingWaveEffect(final KillingWaveEffect effect) {§super(effect);§}§@Override§public KillingWaveEffect copy() {§return new KillingWaveEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller == null) {§return false;§}§int amount = (new ManacostVariableValue()).calculate(game, source, this);§if (amount > 0) {§LinkedList<Permanent> sacrifices = new LinkedList<Permanent>();§HashMap<UUID, Integer> lifePaidAmounts = new HashMap<UUID, Integer>();§FilterCreaturePermanent filter = new FilterCreaturePermanent();§for (UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {§Player player = game.getPlayer(playerId);§List<Permanent> creatures = game.getBattlefield().getAllActivePermanents(filter, playerId, game);§int lifePaid = 0;§int playerLife = player.getLife();§for (Permanent creature : creatures) {§String message = "Pay " + amount + " life? If you don't, " + creature.getName() + " will be sacrificed.";§if (playerLife - amount - lifePaid >= 0 && player != null && player.chooseUse(Outcome.Neutral, message, source, game)) {§game.informPlayers(player.getLogName() + " pays " + amount + " life. He will not sacrifice " + creature.getName());§lifePaid += amount;§} else {§game.informPlayers(player.getLogName() + " will sacrifice " + creature.getName());§sacrifices.add(creature);§}§}§lifePaidAmounts.put(playerId, lifePaid);§}§for (UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {§int lifePaid = lifePaidAmounts.get(playerId);§if (lifePaid > 0) {§Player player = game.getPlayer(playerId);§if (player != null) {§player.loseLife(lifePaid, game);§}§}§}§for (Permanent creature : sacrifices) {§creature.sacrifice(source.getSourceId(), game);§}§}§return true;§}§}§
public class KruinStriker extends CardImpl {§private static final FilterPermanent filter = new FilterControlledCreaturePermanent("another creature");§static {§filter.add(new AnotherPredicate());§}§public KruinStriker(UUID ownerId) {§super(ownerId, 143, "Kruin Striker", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{R}");§this.expansionSetCode = "AVR";§this.subtype.add("Human");§this.subtype.add("Warrior");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§Ability ability = new EntersBattlefieldAllTriggeredAbility(new BoostSourceEffect(1, 0, Duration.EndOfTurn), filter,§"Whenever another creature enters the battlefield under your control, Kruin Striker gets +1/+0 and gains trample until end of turn.");§ability.addEffect(new GainAbilitySourceEffect(TrampleAbility.getInstance(), Duration.EndOfTurn));§this.addAbility(ability);§}§public KruinStriker(final KruinStriker card) {§super(card);§}§@Override§public KruinStriker copy() {§return new KruinStriker(this);§}§}§
public class LeapOfFaith extends CardImpl {§public LeapOfFaith(UUID ownerId) {§super(ownerId, 26, "Leap of Faith", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{W}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new GainAbilityTargetEffect(FlyingAbility.getInstance(), Duration.EndOfTurn));§this.getSpellAbility().addEffect(new PreventDamageToTargetEffect(Duration.EndOfTurn, Integer.MAX_VALUE));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public LeapOfFaith(final LeapOfFaith card) {§super(card);§}§@Override§public LeapOfFaith copy() {§return new LeapOfFaith(this);§}§}§
public class LightningMauler extends CardImpl {§private static final String ruleText = "As long as {this} is paired with another creature, both creatures have haste";§public LightningMauler(UUID ownerId) {§super(ownerId, 144, "Lightning Mauler", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{R}");§this.expansionSetCode = "AVR";§this.subtype.add("Human");§this.subtype.add("Berserker");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(SoulbondAbility.getInstance());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityPairedEffect(HasteAbility.getInstance(), ruleText)));§}§public LightningMauler(final LightningMauler card) {§super(card);§}§@Override§public LightningMauler copy() {§return new LightningMauler(this);§}§}§
public class LightningProwess extends CardImpl {§public LightningProwess(UUID ownerId) {§super(ownerId, 145, "Lightning Prowess", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{R}");§this.expansionSetCode = "AVR";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(HasteAbility.getInstance(), AttachmentType.AURA)));§ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(1), new TapSourceCost());§ability.addTarget(new TargetCreatureOrPlayer());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(ability, AttachmentType.AURA)));§}§public LightningProwess(final LightningProwess card) {§super(card);§}§@Override§public LightningProwess copy() {§return new LightningProwess(this);§}§}§
public class LoneRevenant extends CardImpl {§public LoneRevenant(UUID ownerId) {§super(ownerId, 64, "Lone Revenant", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{U}{U}");§this.expansionSetCode = "AVR";§this.subtype.add("Spirit");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(HexproofAbility.getInstance());§this.addAbility(new LoneRevenantTriggeredAbility());§}§public LoneRevenant(final LoneRevenant card) {§super(card);§}§@Override§public LoneRevenant copy() {§return new LoneRevenant(this);§}§}§class LoneRevenantTriggeredAbility extends TriggeredAbilityImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent();§public LoneRevenantTriggeredAbility() {§super(Zone.BATTLEFIELD, new LookLibraryAndPickControllerEffect(new StaticValue(4), false, new StaticValue(1), new FilterCard(), Zone.LIBRARY, false, false));§}§public LoneRevenantTriggeredAbility(final LoneRevenantTriggeredAbility ability) {§super(ability);§}§@Override§public LoneRevenantTriggeredAbility copy() {§return new LoneRevenantTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.DAMAGED_PLAYER;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (event.getSourceId().equals(this.sourceId) && ((DamagedPlayerEvent) event).isCombatDamage()) {§Permanent permanent = game.getPermanent(event.getSourceId());§int number = game.getBattlefield().countAll(filter, controllerId, game);§if (permanent != null && number != 1) {§return false;§}§return permanent != null || number == 0;§}§return false;§}§@Override§public String getRule() {§return "Whenever {this} deals combat damage to a player, if you control no other creatures, " + super.getRule();§}§}§
public class LunarMystic extends CardImpl {§private static final FilterSpell filter = new FilterSpell("an instant spell");§static {§filter.add(new CardTypePredicate(CardType.INSTANT));§}§public LunarMystic(UUID ownerId) {§super(ownerId, 65, "Lunar Mystic", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{U}{U}");§this.expansionSetCode = "AVR";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new SpellCastControllerTriggeredAbility(new DoIfCostPaid(new DrawCardSourceControllerEffect(1), new GenericManaCost(1)), filter, false));§}§public LunarMystic(final LunarMystic card) {§super(card);§}§@Override§public LunarMystic copy() {§return new LunarMystic(this);§}§}§
public class MaalfeldTwins extends CardImpl {§public MaalfeldTwins(UUID ownerId) {§super(ownerId, 112, "Maalfeld Twins", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{5}{B}");§this.expansionSetCode = "AVR";§this.subtype.add("Zombie");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(new DiesTriggeredAbility(new CreateTokenEffect(new ZombieToken(), 2)));§}§public MaalfeldTwins(final MaalfeldTwins card) {§super(card);§}§@Override§public MaalfeldTwins copy() {§return new MaalfeldTwins(this);§}§}§
public class MadProphet extends CardImpl {§public MadProphet(UUID ownerId) {§super(ownerId, 146, "Mad Prophet", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{R}");§this.expansionSetCode = "AVR";§this.subtype.add("Human");§this.subtype.add("Shaman");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(HasteAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DrawCardSourceControllerEffect(1), new TapSourceCost());§ability.addCost(new DiscardTargetCost(new TargetCardInHand()));§this.addAbility(ability);§}§public MadProphet(final MadProphet card) {§super(card);§}§@Override§public MadProphet copy() {§return new MadProphet(this);§}§}§
public class MaliciousIntent extends CardImpl {§public MaliciousIntent(UUID ownerId) {§super(ownerId, 147, "Malicious Intent", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{R}");§this.expansionSetCode = "AVR";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§Ability gainedAbility = new SimpleActivatedAbility(Zone.BATTLEFIELD, new CantBlockTargetEffect(Duration.EndOfTurn), new TapSourceCost());§gainedAbility.addTarget(new TargetCreaturePermanent());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(gainedAbility, AttachmentType.AURA)));§}§public MaliciousIntent(final MaliciousIntent card) {§super(card);§}§@Override§public MaliciousIntent copy() {§return new MaliciousIntent(this);§}§}§
public class Malignus extends CardImpl {§public Malignus(UUID ownerId) {§super(ownerId, 148, "Malignus", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{3}{R}{R}");§this.expansionSetCode = "AVR";§this.subtype.add("Elemental");§this.subtype.add("Spirit");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§this.addAbility(new SimpleStaticAbility(Zone.ALL, new SetPowerToughnessSourceEffect(new HighestLifeTotalAmongOpponentsCount(), Duration.EndOfGame)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new MalignusEffect()));§}§public Malignus(final Malignus card) {§super(card);§}§@Override§public Malignus copy() {§return new Malignus(this);§}§}§class HighestLifeTotalAmongOpponentsCount implements DynamicValue {§@Override§public int calculate(Game game, Ability sourceAbility, Effect effect) {§if (sourceAbility != null) {§Player controller = game.getPlayer(sourceAbility.getControllerId());§if (controller != null) {§int max = 0;§for (UUID uuid : game.getOpponents(controller.getId())) {§Player opponent = game.getPlayer(uuid);§if (opponent != null) {§if (opponent.getLife() > max) {§max = opponent.getLife();§}§}§}§return (int)Math.ceil(max / 2.0);§}§}§return 0;§}§@Override§public DynamicValue copy() {§return new CardsInControllerHandCount();§}§@Override§public String getMessage() {§return "half the highest life total among your opponents, rounded up";§}§@Override§public String toString() {§return "1";§}§}§class MalignusEffect extends ContinuousRuleModifyingEffectImpl {§public MalignusEffect() {§super(Duration.WhileOnBattlefield, Outcome.Benefit);§staticText = "Damage that would be dealt by {this} can't be prevented";§}§public MalignusEffect(final MalignusEffect effect) {§super(effect);§}§@Override§public MalignusEffect copy() {§return new MalignusEffect(this);§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.PREVENT_DAMAGE;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§return event.getSourceId().equals(source.getSourceId());§}§}§
public class MarrowBats extends CardImpl {§public MarrowBats(UUID ownerId) {§super(ownerId, 113, "Marrow Bats", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{B}");§this.expansionSetCode = "AVR";§this.subtype.add("Bat");§this.subtype.add("Skeleton");§this.power = new MageInt(4);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new RegenerateSourceEffect(), new PayLifeCost(4)));§}§public MarrowBats(final MarrowBats card) {§super(card);§}§@Override§public MarrowBats copy() {§return new MarrowBats(this);§}§}§
public class MassAppeal extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("Human you control");§static {§filter.add(new SubtypePredicate("Human"));§}§public MassAppeal(UUID ownerId) {§super(ownerId, 66, "Mass Appeal", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{2}{U}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(new PermanentsOnBattlefieldCount(filter)));§}§public MassAppeal(final MassAppeal card) {§super(card);§}§@Override§public MassAppeal copy() {§return new MassAppeal(this);§}§}§
public class MentalAgony extends CardImpl {§public MentalAgony(UUID ownerId) {§super(ownerId, 114, "Mental Agony", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{3}{B}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new DiscardTargetEffect(2));§this.getSpellAbility().addEffect(new LoseLifeTargetEffect(2));§this.getSpellAbility().addTarget(new TargetPlayer());§}§public MentalAgony(final MentalAgony card) {§super(card);§}§@Override§public MentalAgony copy() {§return new MentalAgony(this);§}§}§
public class MidnightDuelist extends CardImpl {§private static final FilterPermanent filter = new FilterCreaturePermanent("Vampires");§static {§filter.add(new SubtypePredicate("Vampire"));§}§public MidnightDuelist(UUID ownerId) {§super(ownerId, 27, "Midnight Duelist", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{W}");§this.expansionSetCode = "AVR";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§this.addAbility(new ProtectionAbility(filter));§}§public MidnightDuelist(final MidnightDuelist card) {§super(card);§}§@Override§public MidnightDuelist copy() {§return new MidnightDuelist(this);§}§}§
public class MidvastProtector extends CardImpl {§public MidvastProtector(UUID ownerId) {§super(ownerId, 28, "Midvast Protector", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{W}");§this.expansionSetCode = "AVR";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§EntersBattlefieldTriggeredAbility ability = new EntersBattlefieldTriggeredAbility(new GainProtectionFromColorTargetEffect(Duration.EndOfTurn), false);§ability.addTarget(new TargetControlledCreaturePermanent());§this.addAbility(ability);§}§public MidvastProtector(final MidvastProtector card) {§super(card);§}§@Override§public MidvastProtector copy() {§return new MidvastProtector(this);§}§}§
public class MisthollowGriffin extends CardImpl {§public MisthollowGriffin(UUID ownerId) {§super(ownerId, 68, "Misthollow Griffin", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{2}{U}{U}");§this.expansionSetCode = "AVR";§this.subtype.add("Griffin");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new SimpleStaticAbility(Zone.EXILED, new MisthollowGriffinPlayEffect()));§}§public MisthollowGriffin(final MisthollowGriffin card) {§super(card);§}§@Override§public MisthollowGriffin copy() {§return new MisthollowGriffin(this);§}§}§class MisthollowGriffinPlayEffect extends AsThoughEffectImpl {§public MisthollowGriffinPlayEffect() {§super(AsThoughEffectType.PLAY_FROM_NOT_OWN_HAND_ZONE, Duration.EndOfGame, Outcome.Benefit);§staticText = "You may cast {this} from exile";§}§public MisthollowGriffinPlayEffect(final MisthollowGriffinPlayEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public MisthollowGriffinPlayEffect copy() {§return new MisthollowGriffinPlayEffect(this);§}§@Override§public boolean applies(UUID sourceId, Ability source, UUID affectedControllerId, Game game) {§if (sourceId.equals(source.getSourceId())) {§Card card = game.getCard(source.getSourceId());§if (card != null && card.getOwnerId().equals(source.getControllerId()) && game.getState().getZone(source.getSourceId()) == Zone.EXILED) {§return true;§}§}§return false;§}§}§
public class MistRaven extends CardImpl {§public MistRaven(UUID ownerId) {§super(ownerId, 67, "Mist Raven", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{U}{U}");§this.expansionSetCode = "AVR";§this.subtype.add("Bird");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new EntersBattlefieldTriggeredAbility(new ReturnToHandTargetEffect());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public MistRaven(final MistRaven card) {§super(card);§}§@Override§public MistRaven copy() {§return new MistRaven(this);§}§}§
public class MoonlightGeist extends CardImpl {§public MoonlightGeist(UUID ownerId) {§super(ownerId, 29, "Moonlight Geist", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "AVR";§this.subtype.add("Spirit");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new PreventCombatDamageToSourceEffect(Duration.EndOfTurn), new ManaCostsImpl("{3}{W}"));§ability.addEffect(new PreventCombatDamageBySourceEffect(Duration.EndOfTurn));§this.addAbility(ability);§}§public MoonlightGeist(final MoonlightGeist card) {§super(card);§}§@Override§public MoonlightGeist copy() {§return new MoonlightGeist(this);§}§}§
public class MoonsilverSpear extends CardImpl {§public MoonsilverSpear(UUID ownerId) {§super(ownerId, 217, "Moonsilver Spear", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{4}");§this.expansionSetCode = "AVR";§this.subtype.add("Equipment");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(FirstStrikeAbility.getInstance(), AttachmentType.EQUIPMENT)));§this.addAbility(new AttacksAttachedTriggeredAbility(new CreateTokenEffect(new AngelToken())));§this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(4)));§}§public MoonsilverSpear(final MoonsilverSpear card) {§super(card);§}§@Override§public MoonsilverSpear copy() {§return new MoonsilverSpear(this);§}§}§
public class NaturalEnd extends CardImpl {§public NaturalEnd(UUID ownerId) {§super(ownerId, 185, "Natural End", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{G}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new DestroyTargetEffect());§this.getSpellAbility().addEffect(new GainLifeEffect(3));§this.getSpellAbility().addTarget(new TargetPermanent(new FilterArtifactOrEnchantmentPermanent()));§}§public NaturalEnd(final NaturalEnd card) {§super(card);§}§@Override§public NaturalEnd copy() {§return new NaturalEnd(this);§}§}§
public class NearheathPilgrim extends CardImpl {§private static final String ruleText = "As long as {this} is paired with another creature, both creatures have lifelink";§public NearheathPilgrim(UUID ownerId) {§super(ownerId, 31, "Nearheath Pilgrim", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "AVR";§this.subtype.add("Human");§this.subtype.add("Cleric");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(SoulbondAbility.getInstance());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityPairedEffect(LifelinkAbility.getInstance(), ruleText)));§}§public NearheathPilgrim(final NearheathPilgrim card) {§super(card);§}§@Override§public NearheathPilgrim copy() {§return new NearheathPilgrim(this);§}§}§
public class Necrobite extends CardImpl {§public Necrobite(UUID ownerId) {§super(ownerId, 115, "Necrobite", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{B}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new GainAbilityTargetEffect(DeathtouchAbility.getInstance(), Duration.EndOfTurn));§this.getSpellAbility().addEffect(new RegenerateTargetEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public Necrobite(final Necrobite card) {§super(card);§}§@Override§public Necrobite copy() {§return new Necrobite(this);§}§}§
public class NephaliaSmuggler extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("another target creature you control");§static {§filter.add(new AnotherPredicate());§}§public NephaliaSmuggler(UUID ownerId) {§super(ownerId, 69, "Nephalia Smuggler", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{U}");§this.expansionSetCode = "AVR";§this.subtype.add("Human");§this.subtype.add("Rogue");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ExileTargetForSourceEffect(), new ManaCostsImpl("{3}{U}"));§ability.addCost(new TapSourceCost());§ability.addEffect(new ReturnToBattlefieldUnderYourControlTargetEffect(true));§ability.addTarget(new TargetControlledCreaturePermanent(filter));§this.addAbility(ability);§}§public NephaliaSmuggler(final NephaliaSmuggler card) {§super(card);§}§@Override§public NephaliaSmuggler copy() {§return new NephaliaSmuggler(this);§}§}§
public class NettleSwine extends CardImpl {§public NettleSwine(UUID ownerId) {§super(ownerId, 186, "Nettle Swine", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{G}");§this.expansionSetCode = "AVR";§this.subtype.add("Boar");§this.power = new MageInt(4);§this.toughness = new MageInt(3);§}§public NettleSwine(final NettleSwine card) {§super(card);§}§@Override§public NettleSwine copy() {§return new NettleSwine(this);§}§}§
public class NightshadePeddler extends CardImpl {§private static final String ruleText = "As long as {this} is paired with another creature, both creatures have deathtouch";§public NightshadePeddler(UUID ownerId) {§super(ownerId, 187, "Nightshade Peddler", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "AVR";§this.subtype.add("Human");§this.subtype.add("Druid");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(SoulbondAbility.getInstance());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityPairedEffect(DeathtouchAbility.getInstance(), ruleText)));§}§public NightshadePeddler(final NightshadePeddler card) {§super(card);§}§@Override§public NightshadePeddler copy() {§return new NightshadePeddler(this);§}§}§
public class OtherworldAtlas extends CardImpl {§public OtherworldAtlas(UUID ownerId) {§super(ownerId, 219, "Otherworld Atlas", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{4}");§this.expansionSetCode = "AVR";§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new AddCountersSourceEffect(CounterType.CHARGE.createInstance()), new TapSourceCost()));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new OtherworldAtlasDrawEffect(), new TapSourceCost()));§}§public OtherworldAtlas(final OtherworldAtlas card) {§super(card);§}§@Override§public OtherworldAtlas copy() {§return new OtherworldAtlas(this);§}§}§class OtherworldAtlasDrawEffect extends OneShotEffect {§public OtherworldAtlasDrawEffect() {§super(Outcome.DrawCard);§staticText = "Each player draws a card for each charge counter on {this}";§}§public OtherworldAtlasDrawEffect(final OtherworldAtlasDrawEffect effect) {§super(effect);§}§@Override§public OtherworldAtlasDrawEffect copy() {§return new OtherworldAtlasDrawEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player sourcePlayer = game.getPlayer(source.getControllerId());§Permanent permanent = game.getPermanent(source.getSourceId());§if (permanent != null) {§int amount = permanent.getCounters().getCount(CounterType.CHARGE);§if (amount > 0) {§for (UUID playerId : game.getState().getPlayersInRange(sourcePlayer.getId(), game)) {§Player player = game.getPlayer(playerId);§if (player != null) {§player.drawCards(amount, game);§}§}§}§}§return true;§}§}§
public class Outwit extends CardImpl {§private static FilterSpell filter = new FilterSpell("spell that targets a player");§public Outwit(UUID ownerId) {§super(ownerId, 70, "Outwit", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{U}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new CounterTargetEffect());§this.getSpellAbility().addTarget(new CustomTargetSpell(filter));§}§public Outwit(final Outwit card) {§super(card);§}§@Override§public Outwit copy() {§return new Outwit(this);§}§private class CustomTargetSpell extends TargetObject {§protected FilterSpell filter;§public CustomTargetSpell() {§this(1, 1, new FilterSpell());§}§public CustomTargetSpell(FilterSpell filter) {§this(1, 1, filter);§}§public CustomTargetSpell(int numTargets, FilterSpell filter) {§this(numTargets, numTargets, filter);§}§public CustomTargetSpell(int minNumTargets, int maxNumTargets, FilterSpell filter) {§this.minNumberOfTargets = minNumTargets;§this.maxNumberOfTargets = maxNumTargets;§this.zone = Zone.STACK;§this.filter = filter;§this.targetName = filter.getMessage();§}§public CustomTargetSpell(final CustomTargetSpell target) {§super(target);§this.filter = target.filter.copy();§}§@Override§public boolean canChoose(UUID sourceId, UUID sourceControllerId, Game game) {§return canChoose(sourceControllerId, game);§}§@Override§public Set<UUID> possibleTargets(UUID sourceId, UUID sourceControllerId, Game game) {§return possibleTargets(sourceControllerId, game);§}§@Override§public boolean canTarget(UUID id, Ability source, Game game) {§if (super.canTarget(id, source, game)) {§if (targetsPlayer(id, game)) {§return true;§}§}§return false;§}§@Override§public boolean canChoose(UUID sourceControllerId, Game game) {§int count = 0;§for (StackObject stackObject : game.getStack()) {§if (stackObject instanceof Spell && filter.match((Spell) stackObject, game)) {§if (targetsPlayer(stackObject.getId(), game)) {§count++;§if (count >= this.minNumberOfTargets) {§return true;§}§}§}§}§return false;§}§@Override§public Set<UUID> possibleTargets(UUID sourceControllerId, Game game) {§Set<UUID> possibleTargets = new HashSet<UUID>();§for (StackObject stackObject : game.getStack()) {§if (stackObject instanceof Spell && filter.match((Spell) stackObject, game)) {§if (targetsPlayer(stackObject.getId(), game)) {§possibleTargets.add(stackObject.getId());§}§}§}§return possibleTargets;§}§@Override§public Filter getFilter() {§return filter;§}§private boolean targetsPlayer(UUID id, Game game) {§StackObject spell = game.getStack().getStackObject(id);§if (spell != null) {§Ability ability = spell.getStackAbility();§if (ability != null && !ability.getTargets().isEmpty()) {§for (Target target : ability.getTargets()) {§for (UUID playerId : target.getTargets()) {§Player player = game.getPlayer(playerId);§if (player != null) {§return true;§}§}§}§}§}§return false;§}§@Override§public CustomTargetSpell copy() {§return new CustomTargetSpell(this);§}§}§}§
public class PathbreakerWurm extends CardImpl {§private static final String ruleText = "As long as {this} is paired with another creature, both creatures have trample";§public PathbreakerWurm(UUID ownerId) {§super(ownerId, 188, "Pathbreaker Wurm", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{G}{G}");§this.expansionSetCode = "AVR";§this.subtype.add("Wurm");§this.power = new MageInt(6);§this.toughness = new MageInt(4);§this.addAbility(SoulbondAbility.getInstance());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityPairedEffect(TrampleAbility.getInstance(), ruleText)));§}§public PathbreakerWurm(final PathbreakerWurm card) {§super(card);§}§@Override§public PathbreakerWurm copy() {§return new PathbreakerWurm(this);§}§}§
public class PeelFromReality extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature you don't control");§static {§filter.add(new ControllerPredicate(TargetController.NOT_YOU));§}§public PeelFromReality(UUID ownerId) {§super(ownerId, 71, "Peel from Reality", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{U}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new PeelFromRealityEffect());§this.getSpellAbility().addTarget(new TargetControlledCreaturePermanent());§this.getSpellAbility().addTarget(new TargetCreaturePermanent(filter));§}§public PeelFromReality(final PeelFromReality card) {§super(card);§}§@Override§public PeelFromReality copy() {§return new PeelFromReality(this);§}§}§class PeelFromRealityEffect extends OneShotEffect {§public PeelFromRealityEffect() {§super(Outcome.ReturnToHand);§this.staticText = "Return target creature you control and target creature you don't control to their owners' hands";§}§public PeelFromRealityEffect(final PeelFromRealityEffect effect) {§super(effect);§}§@Override§public PeelFromRealityEffect copy() {§return new PeelFromRealityEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§boolean result = false;§Permanent permanent = game.getPermanent(source.getFirstTarget());§if (permanent != null) {§result |= permanent.moveToZone(Zone.HAND, source.getSourceId(), game, false);§}§permanent = game.getPermanent(source.getTargets().get(1).getFirstTarget());§if (permanent != null) {§result |= permanent.moveToZone(Zone.HAND, source.getSourceId(), game, false);§}§return result;§}§}§
public class PillarOfFlame extends CardImpl {§public PillarOfFlame(UUID ownerId) {§super(ownerId, 149, "Pillar of Flame", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{R}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new DamageTargetEffect(2));§this.getSpellAbility().addTarget(new TargetCreatureOrPlayer());§this.getSpellAbility().addEffect(new DealtDamageToCreatureBySourceDies(this, Duration.EndOfTurn));§this.getSpellAbility().addWatcher(new DamagedByWatcher());§}§public PillarOfFlame(final PillarOfFlame card) {§super(card);§}§@Override§public PillarOfFlame copy() {§return new PillarOfFlame(this);§}§}§
public class PollutedDead extends CardImpl {§public PollutedDead(UUID ownerId) {§super(ownerId, 116, "Polluted Dead", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{B}");§this.expansionSetCode = "AVR";§this.subtype.add("Zombie");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§Ability ability = new DiesTriggeredAbility(new DestroyTargetEffect());§Target target = new TargetLandPermanent();§ability.addTarget(target);§this.addAbility(ability);§}§public PollutedDead(final PollutedDead card) {§super(card);§}§@Override§public PollutedDead copy() {§return new PollutedDead(this);§}§}§
public class PredatorsGambit extends CardImpl {§private static final String rule = "Enchanted creature has intimidate as long as its controller controls no other creatures";§public PredatorsGambit(UUID ownerId) {§super(ownerId, 117, "Predator's Gambit", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{B}");§this.expansionSetCode = "AVR";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(2, 1, Duration.WhileOnBattlefield)));§ContinuousEffect effect = new GainAbilityAttachedEffect(IntimidateAbility.getInstance(), AttachmentType.AURA);§ConditionalContinuousEffect intimidate = new ConditionalContinuousEffect(effect, new OneControlledCreatureCondition(), rule);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, intimidate));§}§public PredatorsGambit(final PredatorsGambit card) {§super(card);§}§@Override§public PredatorsGambit copy() {§return new PredatorsGambit(this);§}§}§
public class PrimalSurge extends CardImpl {§public PrimalSurge(UUID ownerId) {§super(ownerId, 189, "Primal Surge", Rarity.MYTHIC, new CardType[]{CardType.SORCERY}, "{8}{G}{G}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new PrimalSurgeEffect());§}§public PrimalSurge(final PrimalSurge card) {§super(card);§}§@Override§public PrimalSurge copy() {§return new PrimalSurge(this);§}§}§class PrimalSurgeEffect extends OneShotEffect {§public PrimalSurgeEffect() {§super(Outcome.PutCardInPlay);§this.staticText = "Exile the top card of your library. If it's a permanent card, you may put it onto the battlefield. If you do, repeat this process";§}§public PrimalSurgeEffect(final PrimalSurgeEffect effect) {§super(effect);§}§@Override§public PrimalSurgeEffect copy() {§return new PrimalSurgeEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player == null) {§return false;§}§boolean repeat;§do {§repeat = false;§if (player.getLibrary().size() > 0) {§Card card = player.getLibrary().removeFromTop(game);§if (card != null) {§card.moveToExile(null, "", source.getSourceId(), game);§List<CardType> cardType = card.getCardType();§if ((cardType.contains(CardType.ARTIFACT) || cardType.contains(CardType.CREATURE)§|| cardType.contains(CardType.ENCHANTMENT) || cardType.contains(CardType.LAND)§|| cardType.contains(CardType.PLANESWALKER))§&& player.chooseUse(Outcome.PutCardInPlay, "Put " + card.getName() + " onto the battlefield?", source, game)) {§card.moveToZone(Zone.BATTLEFIELD, source.getSourceId(), game, false);§Permanent permanent = game.getPermanent(card.getId());§if (permanent == null) {§permanent = (Permanent) game.getLastKnownInformation(card.getId(), Zone.BATTLEFIELD);§}§if (permanent != null) {§repeat = true;§}§}§}§}§} while (player.canRespond() && repeat);§return true;§}§}§
public class RagingPoltergeist extends CardImpl {§public RagingPoltergeist(UUID ownerId) {§super(ownerId, 150, "Raging Poltergeist", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{R}");§this.expansionSetCode = "AVR";§this.subtype.add("Spirit");§this.power = new MageInt(6);§this.toughness = new MageInt(1);§}§public RagingPoltergeist(final RagingPoltergeist card) {§super(card);§}§@Override§public RagingPoltergeist copy() {§return new RagingPoltergeist(this);§}§}§
public class RainOfThorns extends CardImpl {§public RainOfThorns(UUID ownerId) {§super(ownerId, 190, "Rain of Thorns", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{4}{G}{G}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new DestroyTargetEffect());§this.getSpellAbility().addTarget(new TargetArtifactPermanent());§this.getSpellAbility().getModes().setMaxModes(1);§this.getSpellAbility().getModes().setMaxModes(3);§Mode mode1 = new Mode();§mode1.getEffects().add(new DestroyTargetEffect());§mode1.getTargets().add(new TargetPermanent(new FilterEnchantmentPermanent()));§this.getSpellAbility().addMode(mode1);§Mode mode2 = new Mode();§mode2.getEffects().add(new DestroyTargetEffect());§mode2.getTargets().add(new TargetPermanent(new FilterLandPermanent()));§this.getSpellAbility().addMode(mode2);§}§public RainOfThorns(final RainOfThorns card) {§super(card);§}§@Override§public RainOfThorns copy() {§return new RainOfThorns(this);§}§}§
public class ReforgeTheSoul extends CardImpl {§public ReforgeTheSoul(UUID ownerId) {§super(ownerId, 151, "Reforge the Soul", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{3}{R}{R}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new DiscardHandAllEffect());§Effect effect = new DrawCardAllEffect(7);§effect.setText(", then draws seven cards");§this.getSpellAbility().addEffect(effect);§this.addAbility(new MiracleAbility(this, new ManaCostsImpl("{1}{R}")));§}§public ReforgeTheSoul(final ReforgeTheSoul card) {§super(card);§}§@Override§public ReforgeTheSoul copy() {§return new ReforgeTheSoul(this);§}§}§
public class RenegadeDemon extends CardImpl {§public RenegadeDemon(UUID ownerId) {§super(ownerId, 118, "Renegade Demon", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{B}{B}");§this.expansionSetCode = "AVR";§this.subtype.add("Demon");§this.power = new MageInt(5);§this.toughness = new MageInt(3);§}§public RenegadeDemon(final RenegadeDemon card) {§super(card);§}§@Override§public RenegadeDemon copy() {§return new RenegadeDemon(this);§}§}§
public class RidersOfGavony extends CardImpl {§public RidersOfGavony(UUID ownerId) {§super(ownerId, 33, "Riders of Gavony", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{W}{W}");§this.expansionSetCode = "AVR";§this.subtype.add("Human");§this.subtype.add("Knight");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(VigilanceAbility.getInstance());§this.addAbility(new AsEntersBattlefieldAbility(new ChooseCreatureTypeEffect(Outcome.Protect)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new RidersOfGavonyGainAbilityControlledEffect()));§}§public RidersOfGavony(final RidersOfGavony card) {§super(card);§}§@Override§public RidersOfGavony copy() {§return new RidersOfGavony(this);§}§}§class RidersOfGavonyGainAbilityControlledEffect extends ContinuousEffectImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("Human creatures you control");§static {§filter.add(new SubtypePredicate("Human"));§}§protected FilterPermanent protectionFilter;§public RidersOfGavonyGainAbilityControlledEffect() {§super(Duration.WhileOnBattlefield, Layer.AbilityAddingRemovingEffects_6, SubLayer.NA, Outcome.AddAbility);§staticText = "Human creatures you control have protection from creatures of the chosen type";§}§public RidersOfGavonyGainAbilityControlledEffect(final RidersOfGavonyGainAbilityControlledEffect effect) {§super(effect);§protectionFilter = effect.protectionFilter;§}§@Override§public RidersOfGavonyGainAbilityControlledEffect copy() {§return new RidersOfGavonyGainAbilityControlledEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§if (protectionFilter == null) {§Permanent permanent = game.getPermanent(source.getSourceId());§if (permanent != null) {§String subtype = (String) game.getState().getValue(permanent.getId() + "_type");§if (subtype != null) {§protectionFilter = new FilterPermanent(subtype + "s");§protectionFilter.add(new SubtypePredicate(subtype));§}§}§}§if (protectionFilter != null) {§for (Permanent perm : game.getBattlefield().getAllActivePermanents(filter, source.getControllerId(), game)) {§perm.addAbility(new ProtectionAbility(protectionFilter), source.getSourceId(), game);§}§return true;§}§return false;§}§}§
public class RighteousBlow extends CardImpl {§public RighteousBlow(UUID ownerId) {§super(ownerId, 34, "Righteous Blow", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{W}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addTarget(new TargetAttackingOrBlockingCreature());§this.getSpellAbility().addEffect(new DamageTargetEffect(2));§}§public RighteousBlow(final RighteousBlow card) {§super(card);§}§@Override§public RighteousBlow copy() {§return new RighteousBlow(this);§}§}§
public class RiotRingleader extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Human creatures");§static {§filter.add(new SubtypePredicate("Human"));§}§public RiotRingleader(UUID ownerId) {§super(ownerId, 152, "Riot Ringleader", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "AVR";§this.subtype.add("Human");§this.subtype.add("Warrior");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new AttacksTriggeredAbility(new BoostControlledEffect(1, 0, Duration.EndOfTurn, filter), false));§}§public RiotRingleader(final RiotRingleader card) {§super(card);§}§@Override§public RiotRingleader copy() {§return new RiotRingleader(this);§}§}§
public class RiteOfRuin extends CardImpl {§public RiteOfRuin(UUID ownerId) {§super(ownerId, 153, "Rite of Ruin", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{5}{R}{R}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new RiteOfRuinEffect());§}§public RiteOfRuin(final RiteOfRuin card) {§super(card);§}§@Override§public RiteOfRuin copy() {§return new RiteOfRuin(this);§}§}§class RiteOfRuinEffect extends OneShotEffect {§public RiteOfRuinEffect() {§super(Outcome.Sacrifice);§this.staticText = "Choose an order for artifacts, creatures, and lands. Each player sacrifices one permanent of the first type, sacrifices two of the second type, then sacrifices three of the third type";§}§public RiteOfRuinEffect(final RiteOfRuinEffect effect) {§super(effect);§}§@Override§public RiteOfRuinEffect copy() {§return new RiteOfRuinEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller == null) {§return false;§}§HashSet<String> choices = new HashSet<>();§choices.add("Artifacts");§choices.add("Creatures");§choices.add("Lands");§LinkedList<CardType> order = new LinkedList<>();§ChoiceImpl choice = new ChoiceImpl(true);§choice.setChoices(choices);§while (controller.canRespond() && controller.choose(Outcome.Sacrifice, choice, game) && choices.size() > 1) {§order.add(getCardType(choice.getChoice()));§choices.remove(choice.getChoice());§choice.clearChoice();§}§order.add(getCardType(choices.iterator().next()));§LinkedList<UUID> sacrifices = new LinkedList<>();§int count = 1;§for (CardType cardType : order) {§FilterControlledPermanent filter = new FilterControlledPermanent(cardType + " permanent you control");§filter.add(new CardTypePredicate(cardType));§for (UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {§int amount = Math.min(count, game.getBattlefield().countAll(filter, playerId, game));§TargetControlledPermanent target = new TargetControlledPermanent(amount, amount, filter, false);§Player player = game.getPlayer(playerId);§if (player != null && player.choose(Outcome.Sacrifice, target, source.getSourceId(), game)) {§sacrifices.addAll(target.getTargets());§}§}§for (UUID targetId : sacrifices) {§Permanent permanent = game.getPermanent(targetId);§if (permanent != null) {§permanent.sacrifice(source.getSourceId(), game);§}§}§sacrifices.clear();§count++;§}§return true;§}§private CardType getCardType(String type) {§if ("Artifacts".equals(type)) {§return CardType.ARTIFACT;§}§if ("Creatures".equals(type)) {§return CardType.CREATURE;§}§if ("Lands".equals(type)) {§return CardType.LAND;§}§return null;§}§}§
public class RotcrownGhoul extends CardImpl {§public RotcrownGhoul(UUID ownerId) {§super(ownerId, 72, "Rotcrown Ghoul", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{U}");§this.expansionSetCode = "AVR";§this.subtype.add("Zombie");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§Ability ability = new DiesTriggeredAbility(new PutLibraryIntoGraveTargetEffect(5));§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§}§public RotcrownGhoul(final RotcrownGhoul card) {§super(card);§}§@Override§public RotcrownGhoul copy() {§return new RotcrownGhoul(this);§}§}§
public class RushOfBlood extends CardImpl {§public RushOfBlood(UUID ownerId) {§super(ownerId, 154, "Rush of Blood", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{2}{R}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new BoostTargetEffect(new TargetPermanentPowerCount(), new StaticValue(0), Duration.EndOfTurn, true));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public RushOfBlood(final RushOfBlood card) {§super(card);§}§@Override§public RushOfBlood copy() {§return new RushOfBlood(this);§}§}§
public class ScaldingDevil extends CardImpl {§public ScaldingDevil(UUID ownerId) {§super(ownerId, 155, "Scalding Devil", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{R}");§this.expansionSetCode = "AVR";§this.subtype.add("Devil");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(1), new ManaCostsImpl("{2}{R}"));§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§}§public ScaldingDevil(final ScaldingDevil card) {§super(card);§}§@Override§public ScaldingDevil copy() {§return new ScaldingDevil(this);§}§}§
public class ScrapskinDrake extends CardImpl {§public ScrapskinDrake(UUID ownerId) {§super(ownerId, 73, "Scrapskin Drake", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{U}");§this.expansionSetCode = "AVR";§this.subtype.add("Zombie");§this.subtype.add("Drake");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new CanBlockOnlyFlyingAbility());§}§public ScrapskinDrake(final ScrapskinDrake card) {§super(card);§}§@Override§public ScrapskinDrake copy() {§return new ScrapskinDrake(this);§}§}§
public class ScrollOfAvacyn extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent();§static {§filter.add(new SubtypePredicate("Angel"));§}§public ScrollOfAvacyn(UUID ownerId) {§super(ownerId, 220, "Scroll of Avacyn", Rarity.COMMON, new CardType[]{CardType.ARTIFACT}, "{1}");§this.expansionSetCode = "AVR";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DrawCardSourceControllerEffect(1), new GenericManaCost(1));§ability.addCost(new SacrificeSourceCost());§ability.addEffect(new ConditionalOneShotEffect(new GainLifeEffect(5), new PermanentsOnTheBattlefieldCondition(filter), "If you control an Angel, you gain 5 life"));§this.addAbility(ability);§}§public ScrollOfAvacyn(final ScrollOfAvacyn card) {§super(card);§}§@Override§public ScrollOfAvacyn copy() {§return new ScrollOfAvacyn(this);§}§}§
public class ScrollOfGriselbrand extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent();§static {§filter.add(new SubtypePredicate("Demon"));§}§public ScrollOfGriselbrand(UUID ownerId) {§super(ownerId, 221, "Scroll of Griselbrand", Rarity.COMMON, new CardType[]{CardType.ARTIFACT}, "{1}");§this.expansionSetCode = "AVR";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DiscardTargetEffect(1), new GenericManaCost(1));§ability.addCost(new SacrificeSourceCost());§ability.addEffect(new ConditionalOneShotEffect(new LoseLifeTargetEffect(3), new PermanentsOnTheBattlefieldCondition(filter), "If you control a Demon, that player loses 3 life"));§ability.addTarget(new TargetOpponent());§this.addAbility(ability);§}§public ScrollOfGriselbrand(final ScrollOfGriselbrand card) {§super(card);§}§@Override§public ScrollOfGriselbrand copy() {§return new ScrollOfGriselbrand(this);§}§}§
public class SearchlightGeist extends CardImpl {§public SearchlightGeist(UUID ownerId) {§super(ownerId, 119, "Searchlight Geist", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{B}");§this.expansionSetCode = "AVR";§this.subtype.add("Spirit");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD,§new GainAbilitySourceEffect(DeathtouchAbility.getInstance(), Duration.EndOfTurn),§new ManaCostsImpl("{3}{B}")));§}§public SearchlightGeist(final SearchlightGeist card) {§super(card);§}§@Override§public SearchlightGeist copy() {§return new SearchlightGeist(this);§}§}§
public class SecondGuess extends CardImpl {§private static final FilterSpell filter = new FilterSpell("spell that's the second spell cast this turn");§static {§filter.add(new SecondSpellPredicate());§}§public SecondGuess(UUID ownerId) {§super(ownerId, 74, "Second Guess", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{1}{U}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new CounterTargetEffect());§this.getSpellAbility().addTarget(new TargetSpell(filter));§}§public SecondGuess(final SecondGuess card) {§super(card);§}§@Override§public SecondGuess copy() {§return new SecondGuess(this);§}§}§class SecondSpellPredicate implements Predicate<Spell> {§@Override§public boolean apply(Spell input, Game game) {§CastSpellLastTurnWatcher watcher = (CastSpellLastTurnWatcher) game.getState().getWatchers().get("CastSpellLastTurnWatcher");§if (watcher.getSpellOrder(new MageObjectReference(input.getId(), game), game) == 2) {§return true;§}§return false;§}§@Override§public String toString() {§return "SecondSpellThisTurn";§}§}§
public class SeraphOfDawn extends CardImpl {§public SeraphOfDawn(UUID ownerId) {§super(ownerId, 35, "Seraph of Dawn", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{W}{W}");§this.expansionSetCode = "AVR";§this.subtype.add("Angel");§this.power = new MageInt(2);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(LifelinkAbility.getInstance());§}§public SeraphOfDawn(final SeraphOfDawn card) {§super(card);§}§@Override§public SeraphOfDawn copy() {§return new SeraphOfDawn(this);§}§}§
public class SeraphSanctuary extends CardImpl {§private static final FilterPermanent filter = new FilterControlledCreaturePermanent("an Angel");§static {§filter.add(new SubtypePredicate("Angel"));§}§public SeraphSanctuary(UUID ownerId) {§super(ownerId, 228, "Seraph Sanctuary", Rarity.COMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "AVR";§this.addAbility(new EntersBattlefieldTriggeredAbility(new GainLifeEffect(1)));§this.addAbility(new EntersBattlefieldControlledTriggeredAbility(new GainLifeEffect(1), filter));§this.addAbility(new ColorlessManaAbility());§}§public SeraphSanctuary(final SeraphSanctuary card) {§super(card);§}§@Override§public SeraphSanctuary copy() {§return new SeraphSanctuary(this);§}§}§
public class ShelteringWord extends CardImpl {§public ShelteringWord(UUID ownerId) {§super(ownerId, 192, "Sheltering Word", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{G}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new GainAbilityTargetEffect(HexproofAbility.getInstance(), Duration.EndOfTurn));§this.getSpellAbility().addEffect(new ShelteringWordEffect());§this.getSpellAbility().addTarget(new TargetControlledCreaturePermanent());§}§public ShelteringWord(final ShelteringWord card) {§super(card);§}§@Override§public ShelteringWord copy() {§return new ShelteringWord(this);§}§}§class ShelteringWordEffect extends OneShotEffect {§public ShelteringWordEffect() {§super(Outcome.GainLife);§this.staticText = "You gain life equal to that creature's toughness";§}§public ShelteringWordEffect(final ShelteringWordEffect effect) {§super(effect);§}§@Override§public ShelteringWordEffect copy() {§return new ShelteringWordEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§Permanent permanent = game.getPermanent(source.getFirstTarget());§if (player != null && permanent != null) {§int amount = permanent.getToughness().getValue();§if (amount > 0) {§player.gainLife(amount, game);§return true;§}§}§return false;§}§}§
public class SigardaHostOfHerons extends CardImpl {§public SigardaHostOfHerons(UUID ownerId) {§super(ownerId, 210, "Sigarda, Host of Herons", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{2}{G}{W}{W}");§this.expansionSetCode = "AVR";§this.supertype.add("Legendary");§this.subtype.add("Angel");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(HexproofAbility.getInstance());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new SigardaHostOfHeronsEffect()));§}§public SigardaHostOfHerons(final SigardaHostOfHerons card) {§super(card);§}§@Override§public SigardaHostOfHerons copy() {§return new SigardaHostOfHerons(this);§}§}§class SigardaHostOfHeronsEffect extends ContinuousRuleModifyingEffectImpl {§public SigardaHostOfHeronsEffect() {§super(Duration.WhileOnBattlefield, Outcome.Benefit);§staticText = "Spells and abilities your opponents control can't cause you to sacrifice permanents";§}§public SigardaHostOfHeronsEffect(final SigardaHostOfHeronsEffect effect) {§super(effect);§}§@Override§public SigardaHostOfHeronsEffect copy() {§return new SigardaHostOfHeronsEffect(this);§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.SACRIFICE_PERMANENT;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§if (event.getPlayerId().equals(source.getControllerId())) {§MageObject object = game.getObject(event.getSourceId());§if (object instanceof PermanentCard) {§if (game.getOpponents(source.getControllerId()).contains(((PermanentCard) object).getControllerId())) {§return true;§}§}§if (object instanceof Spell) {§if (game.getOpponents(source.getControllerId()).contains(((Spell) object).getControllerId())) {§return true;§}§}§}§return false;§}§}§
public class SilverbladePaladin extends CardImpl {§private static final String ruleText = "As long as {this} is paired with another creature, both creatures have double strike";§public SilverbladePaladin(UUID ownerId) {§super(ownerId, 36, "Silverblade Paladin", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{W}{W}");§this.expansionSetCode = "AVR";§this.subtype.add("Human");§this.subtype.add("Knight");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(SoulbondAbility.getInstance());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityPairedEffect(DoubleStrikeAbility.getInstance(), ruleText)));§}§public SilverbladePaladin(final SilverbladePaladin card) {§super(card);§}§@Override§public SilverbladePaladin copy() {§return new SilverbladePaladin(this);§}§}§
public class SlayersStronghold extends CardImpl {§public SlayersStronghold(UUID ownerId) {§super(ownerId, 229, "Slayers' Stronghold", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "AVR";§this.addAbility(new ColorlessManaAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostTargetEffect(2, 0, Duration.EndOfTurn), new ManaCostsImpl("{R}{W}"));§ability.addEffect(new GainAbilityTargetEffect(VigilanceAbility.getInstance(), Duration.EndOfTurn));§ability.addEffect(new GainAbilityTargetEffect(HasteAbility.getInstance(), Duration.EndOfTurn));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public SlayersStronghold(final SlayersStronghold card) {§super(card);§}§@Override§public SlayersStronghold copy() {§return new SlayersStronghold(this);§}§}§
public class SomberwaldVigilante extends CardImpl {§public SomberwaldVigilante(UUID ownerId) {§super(ownerId, 156, "Somberwald Vigilante", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{R}");§this.expansionSetCode = "AVR";§this.subtype.add("Human");§this.subtype.add("Warrior");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new BecomesBlockedByCreatureTriggeredAbility(new DamageTargetEffect(1, true, "that creature"), false));§}§public SomberwaldVigilante(final SomberwaldVigilante card) {§super(card);§}§@Override§public SomberwaldVigilante copy() {§return new SomberwaldVigilante(this);§}§}§
public class SoulcageFiend extends CardImpl {§public SoulcageFiend(UUID ownerId) {§super(ownerId, 120, "Soulcage Fiend", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{B}{B}");§this.expansionSetCode = "AVR";§this.subtype.add("Demon");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§this.addAbility(new DiesTriggeredAbility(new LoseLifeAllPlayersEffect(3)));§}§public SoulcageFiend(final SoulcageFiend card) {§super(card);§}§@Override§public SoulcageFiend copy() {§return new SoulcageFiend(this);§}§}§
public class SoulOfTheHarvest extends CardImpl {§private static final FilterPermanent filter = new FilterControlledCreaturePermanent("another nontoken creature");§static {§filter.add(new AnotherPredicate());§filter.add(Predicates.not(new TokenPredicate()));§}§public SoulOfTheHarvest(UUID ownerId) {§super(ownerId, 195, "Soul of the Harvest", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{G}{G}");§this.expansionSetCode = "AVR";§this.subtype.add("Elemental");§this.power = new MageInt(6);§this.toughness = new MageInt(6);§this.addAbility(TrampleAbility.getInstance());§this.addAbility(new EntersBattlefieldControlledTriggeredAbility(Zone.BATTLEFIELD, new DrawCardSourceControllerEffect(1), filter, true));§}§public SoulOfTheHarvest(final SoulOfTheHarvest card) {§super(card);§}§@Override§public SoulOfTheHarvest copy() {§return new SoulOfTheHarvest(this);§}§}§
public class SpectralGateguards extends CardImpl {§private static final String ruleText = "As long as {this} is paired with another creature, both creatures have vigilance";§public SpectralGateguards(UUID ownerId) {§super(ownerId, 37, "Spectral Gateguards", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{W}");§this.expansionSetCode = "AVR";§this.subtype.add("Spirit");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(5);§this.addAbility(SoulbondAbility.getInstance());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityPairedEffect(VigilanceAbility.getInstance(), ruleText)));§}§public SpectralGateguards(final SpectralGateguards card) {§super(card);§}§@Override§public SpectralGateguards copy() {§return new SpectralGateguards(this);§}§}§
public class SpectralPrison extends CardImpl {§public SpectralPrison(UUID ownerId) {§super(ownerId, 75, "Spectral Prison", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{U}");§this.expansionSetCode = "AVR";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.Detriment));§this.addAbility(new EnchantAbility(auraTarget.getTargetName()));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new DontUntapInControllersUntapStepEnchantedEffect()));§this.addAbility(new SpectralPrisonAbility());§}§public SpectralPrison(final SpectralPrison card) {§super(card);§}§@Override§public SpectralPrison copy() {§return new SpectralPrison(this);§}§}§class SpectralPrisonAbility extends TriggeredAbilityImpl {§public SpectralPrisonAbility() {§super(Zone.BATTLEFIELD, new DestroySourceEffect());§}§public SpectralPrisonAbility(final SpectralPrisonAbility ability) {§super(ability);§}§@Override§public SpectralPrisonAbility copy() {§return new SpectralPrisonAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.TARGETED;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§MageObject eventSourceObject = game.getObject(event.getSourceId());§if (eventSourceObject != null && eventSourceObject instanceof Spell) {§Permanent enchantment = game.getPermanent(sourceId);§if (enchantment != null && enchantment.getAttachedTo() != null) {§if (event.getTargetId().equals(enchantment.getAttachedTo())) {§return true;§}§}§}§return false;§}§@Override§public String getRule() {§return "When enchanted creature becomes the target of a spell or ability, destroy {this}.";§}§}§
public class SpiritAway extends CardImpl {§public SpiritAway(UUID ownerId) {§super(ownerId, 76, "Spirit Away", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{5}{U}{U}");§this.expansionSetCode = "AVR";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.GainControl));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new ControlEnchantedEffect()));§SimpleStaticAbility ability2 = new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(2, 2, Duration.WhileOnBattlefield));§ability2.addEffect(new GainAbilityAttachedEffect(FlyingAbility.getInstance(), AttachmentType.AURA));§this.addAbility(ability2);§}§public SpiritAway(final SpiritAway card) {§super(card);§}§@Override§public SpiritAway copy() {§return new SpiritAway(this);§}§}§
public class SternMentor extends CardImpl {§private static final String ruleText = "As long as {this} is paired with another creature, each of those creatures has \"{T}: Target player puts the top two cards of his or her library into his or her graveyard.\"";§public SternMentor(UUID ownerId) {§super(ownerId, 77, "Stern Mentor", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{U}");§this.expansionSetCode = "AVR";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(SoulbondAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new PutLibraryIntoGraveTargetEffect(2), new TapSourceCost());§ability.addTarget(new TargetPlayer());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityPairedEffect(ability, ruleText)));§}§public SternMentor(final SternMentor card) {§super(card);§}§@Override§public SternMentor copy() {§return new SternMentor(this);§}§}§
public class StolenGoods extends CardImpl {§public StolenGoods(UUID ownerId) {§super(ownerId, 78, "Stolen Goods", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{3}{U}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new StolenGoodsEffect());§this.getSpellAbility().addTarget(new TargetOpponent());§}§public StolenGoods(final StolenGoods card) {§super(card);§}§@Override§public StolenGoods copy() {§return new StolenGoods(this);§}§}§class StolenGoodsEffect extends OneShotEffect {§public StolenGoodsEffect() {§super(Outcome.Detriment);§this.staticText = "Target opponent exiles cards from the top of his or her library until he or she exiles a nonland card. Until end of turn, you may cast that card without paying its mana cost";§}§public StolenGoodsEffect(final StolenGoodsEffect effect) {§super(effect);§}§@Override§public StolenGoodsEffect copy() {§return new StolenGoodsEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player opponent = game.getPlayer(targetPointer.getFirst(game, source));§MageObject sourceObject = source.getSourceObject(game);§if (opponent != null && opponent.getLibrary().size() > 0 && sourceObject != null) {§Library library = opponent.getLibrary();§Card card;§do {§card = library.removeFromTop(game);§if (card != null) {§opponent.moveCardsToExile(card, source, game, true, source.getSourceId(), sourceObject.getIdName());§}§} while (library.size() > 0 && card != null && card.getCardType().contains(CardType.LAND));§if (card != null) {§ContinuousEffect effect = new StolenGoodsCastFromExileEffect();§effect.setTargetPointer(new FixedTarget(card.getId(), card.getZoneChangeCounter(game)));§game.addEffect(effect, source);§}§return true;§}§return false;§}§}§class StolenGoodsCastFromExileEffect extends AsThoughEffectImpl {§public StolenGoodsCastFromExileEffect() {§super(AsThoughEffectType.PLAY_FROM_NOT_OWN_HAND_ZONE, Duration.EndOfTurn, Outcome.Benefit);§staticText = "You may cast card from exile";§}§public StolenGoodsCastFromExileEffect(final StolenGoodsCastFromExileEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public StolenGoodsCastFromExileEffect copy() {§return new StolenGoodsCastFromExileEffect(this);§}§@Override§public boolean applies(UUID sourceId, Ability source, UUID affectedControllerId, Game game) {§if (sourceId != null && sourceId.equals(getTargetPointer().getFirst(game, source))§&& affectedControllerId.equals(source.getControllerId())) {§Card card = game.getCard(sourceId);§if (card != null && game.getState().getZone(sourceId) == Zone.EXILED) {§Player player = game.getPlayer(affectedControllerId);§player.setCastSourceIdWithAlternateMana(sourceId, null, null);§return true;§}§}§return false;§}§}§
public class Stonewright extends CardImpl {§private static final String ruleText = "As long as {this} is paired with another creature, each of those creatures has \"{R}: This creature gets +1/+0 until end of turn.\"";§public Stonewright(UUID ownerId) {§super(ownerId, 157, "Stonewright", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{R}");§this.expansionSetCode = "AVR";§this.subtype.add("Human");§this.subtype.add("Shaman");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(SoulbondAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(1, 0, Duration.EndOfTurn), new ManaCostsImpl("{R}"));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityPairedEffect(ability, ruleText)));§}§public Stonewright(final Stonewright card) {§super(card);§}§@Override§public Stonewright copy() {§return new Stonewright(this);§}§}§
public class TamiyoTheMoonSage extends CardImpl {§public TamiyoTheMoonSage(UUID ownerId) {§super(ownerId, 79, "Tamiyo, the Moon Sage", Rarity.MYTHIC, new CardType[]{CardType.PLANESWALKER}, "{3}{U}{U}");§this.expansionSetCode = "AVR";§this.subtype.add("Tamiyo");§this.addAbility(new PlanswalkerEntersWithLoyalityCountersAbility(4));§LoyaltyAbility ability = new LoyaltyAbility(new TapTargetEffect(), 1);§ability.addEffect(new DontUntapInControllersNextUntapStepTargetEffect());§Target target = new TargetPermanent();§ability.addTarget(target);§this.addAbility(ability);§ability = new LoyaltyAbility(new DrawCardSourceControllerEffect(new TappedCreaturesControlledByTargetCount()), -2);§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§this.addAbility(new LoyaltyAbility(new GetEmblemEffect(new TamiyoTheMoonSageEmblem()), -8));§}§public TamiyoTheMoonSage(final TamiyoTheMoonSage card) {§super(card);§}§@Override§public TamiyoTheMoonSage copy() {§return new TamiyoTheMoonSage(this);§}§}§class TappedCreaturesControlledByTargetCount implements DynamicValue {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent();§static {§filter.add(new TappedPredicate());§}§@Override§public int calculate(Game game, Ability sourceAbility, Effect effect) {§return game.getBattlefield().countAll(filter, sourceAbility.getFirstTarget(), game);§}§@Override§public DynamicValue copy() {§return new TappedCreaturesControlledByTargetCount();§}§@Override§public String toString() {§return "a";§}§@Override§public String getMessage() {§return "tapped creature target player controls";§}§}§/**§* Emblem with "You have no maximum hand size" and "Whenever a card is put into§* your graveyard from anywhere, you may return it to your hand."§*/§class TamiyoTheMoonSageEmblem extends Emblem {§public TamiyoTheMoonSageEmblem() {§this.setName("EMBLEM: Tamiyo, the Moon Sage");§Ability ability = new SimpleStaticAbility(Zone.COMMAND, new MaximumHandSizeControllerEffect(Integer.MAX_VALUE, Duration.EndOfGame, HandSizeModification.SET));§this.getAbilities().add(ability);§Effect effect = new ReturnToHandTargetEffect();§effect.setText("return it to your hand");§this.getAbilities().add(new PutCardIntoGraveFromAnywhereAllTriggeredAbility(§Zone.COMMAND, effect, true, new FilterCard("a card"), TargetController.YOU, SetTargetPointer.CARD));§}§}§
public class TandemLookout extends CardImpl {§private static final String ruleText = "As long as {this} is paired with another creature, each of those creatures has \"Whenever this creature deals damage to an opponent, draw a card.\"";§public TandemLookout(UUID ownerId) {§super(ownerId, 80, "Tandem Lookout", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{U}");§this.expansionSetCode = "AVR";§this.subtype.add("Human");§this.subtype.add("Scout");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(SoulbondAbility.getInstance());§Ability ability = new DealsDamageToOpponentTriggeredAbility(new DrawCardSourceControllerEffect(1));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityPairedEffect(ability, ruleText)));§}§public TandemLookout(final TandemLookout card) {§super(card);§}§@Override§public TandemLookout copy() {§return new TandemLookout(this);§}§}§
public class TemporalMastery extends CardImpl {§public TemporalMastery(UUID ownerId) {§super(ownerId, 81, "Temporal Mastery", Rarity.MYTHIC, new CardType[]{CardType.SORCERY}, "{5}{U}{U}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new AddExtraTurnControllerEffect());§this.getSpellAbility().addEffect(ExileSpellEffect.getInstance());§this.addAbility(new MiracleAbility(this, new ManaCostsImpl("{1}{U}")));§}§public TemporalMastery(final TemporalMastery card) {§super(card);§}§@Override§public TemporalMastery copy() {§return new TemporalMastery(this);§}§}§
public class Terminus extends CardImpl {§public Terminus(UUID ownerId) {§super(ownerId, 38, "Terminus", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{4}{W}{W}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new TerminusEffect());§this.addAbility(new MiracleAbility(this, new ManaCostsImpl("{W}")));§}§public Terminus(final Terminus card) {§super(card);§}§@Override§public Terminus copy() {§return new Terminus(this);§}§}§class TerminusEffect extends OneShotEffect {§public TerminusEffect() {§super(Outcome.Removal);§this.staticText = "Put all creatures on the bottom of their owners' libraries";§}§public TerminusEffect(final TerminusEffect effect) {§super(effect);§}§@Override§public TerminusEffect copy() {§return new TerminusEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§List<Permanent> permanents = game.getBattlefield().getActivePermanents(§new FilterCreaturePermanent(), source.getControllerId(), source.getSourceId(), game);§for (Permanent permanent : permanents) {§permanent.moveToZone(Zone.LIBRARY, source.getSourceId(), game, false);§}§return true;§}§}§
public class TerrifyingPresence extends CardImpl {§public TerrifyingPresence(UUID ownerId) {§super(ownerId, 196, "Terrifying Presence", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{G}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new TerrifyingPresenceEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public TerrifyingPresence(final TerrifyingPresence card) {§super(card);§}§@Override§public TerrifyingPresence copy() {§return new TerrifyingPresence(this);§}§}§class TerrifyingPresenceEffect extends PreventionEffectImpl {§public TerrifyingPresenceEffect() {§super(Duration.EndOfTurn, Integer.MAX_VALUE, true);§this.staticText = "Prevent all combat damage that would be dealt by creatures other than target creature this turn";§}§public TerrifyingPresenceEffect(final TerrifyingPresenceEffect effect) {§super(effect);§}§@Override§public TerrifyingPresenceEffect copy() {§return new TerrifyingPresenceEffect(this);§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§return super.applies(event, source, game) && !event.getSourceId().equals(getTargetPointer().getFirst(game, source));§}§}§
public class ThatcherRevolt extends CardImpl {§public ThatcherRevolt(UUID ownerId) {§super(ownerId, 158, "Thatcher Revolt", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{2}{R}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new ThatcherRevoltEffect());§}§public ThatcherRevolt(final ThatcherRevolt card) {§super(card);§}§@Override§public ThatcherRevolt copy() {§return new ThatcherRevolt(this);§}§}§class ThatcherRevoltEffect extends OneShotEffect {§public ThatcherRevoltEffect() {§super(Outcome.PutCreatureInPlay);§this.staticText = "Put three 1/1 red Human creature tokens with haste onto the battlefield. Sacrifice those tokens at the beginning of the next end step";§}§public ThatcherRevoltEffect(final ThatcherRevoltEffect effect) {§super(effect);§}§@Override§public ThatcherRevoltEffect copy() {§return new ThatcherRevoltEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§RedHumanToken token = new RedHumanToken();§token.putOntoBattlefield(3, game, source.getSourceId(), source.getControllerId());§ArrayList<Permanent> toSacrifice = new ArrayList<>();§for (UUID tokenId : token.getLastAddedTokenIds()) {§Permanent tokenPermanent = game.getPermanent(tokenId);§if (tokenPermanent != null) {§toSacrifice.add(tokenPermanent);§}§}§SacrificeTargetEffect sacrificeEffect = new SacrificeTargetEffect();§sacrificeEffect.setTargetPointer(new FixedTargets(toSacrifice, game));§game.addDelayedTriggeredAbility(new AtTheBeginOfNextEndStepDelayedTriggeredAbility(sacrificeEffect), source);§return true;§}§}§class RedHumanToken extends Token {§public RedHumanToken() {§super("Human", "1/1 red Human creature token with haste");§this.cardType.add(CardType.CREATURE);§this.subtype.add("Human");§this.color = ObjectColor.RED;§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(HasteAbility.getInstance());§}§}§
public class ThrabenValiant extends CardImpl {§public ThrabenValiant(UUID ownerId) {§super(ownerId, 39, "Thraben Valiant", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "AVR";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(VigilanceAbility.getInstance());§}§public ThrabenValiant(final ThrabenValiant card) {§super(card);§}§@Override§public ThrabenValiant copy() {§return new ThrabenValiant(this);§}§}§
public class Thunderbolt extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature with flying");§static {§filter.add(new AbilityPredicate(FlyingAbility.class));§}§public Thunderbolt(UUID ownerId) {§super(ownerId, 159, "Thunderbolt", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{R}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new DamageTargetEffect(3));§this.getSpellAbility().addTarget(new TargetPlayer());§Mode mode = new Mode();§mode.getEffects().add(new DamageTargetEffect(4));§mode.getTargets().add(new TargetCreaturePermanent(filter));§this.getSpellAbility().addMode(mode);§}§public Thunderbolt(final Thunderbolt card) {§super(card);§}§@Override§public Thunderbolt copy() {§return new Thunderbolt(this);§}§}§
public class ThunderousWrath extends CardImpl {§public ThunderousWrath(UUID ownerId) {§super(ownerId, 160, "Thunderous Wrath", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{4}{R}{R}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new DamageTargetEffect(5));§this.getSpellAbility().addTarget(new TargetCreatureOrPlayer());§this.addAbility(new MiracleAbility(this, new ManaCostsImpl("{R}")));§}§public ThunderousWrath(final ThunderousWrath card) {§super(card);§}§@Override§public ThunderousWrath copy() {§return new ThunderousWrath(this);§}§}§
public class TormentorsTrident extends CardImpl {§public TormentorsTrident(UUID ownerId) {§super(ownerId, 222, "Tormentor's Trident", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{2}");§this.expansionSetCode = "AVR";§this.subtype.add("Equipment");§Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEquippedEffect(3, 0));§Effect effect = new AttacksIfAbleAttachedEffect(Duration.WhileOnBattlefield, AttachmentType.EQUIPMENT);§effect.setText("and attacks each turn if able");§ability.addEffect(effect);§this.addAbility(ability);§this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(3)));§}§public TormentorsTrident(final TormentorsTrident card) {§super(card);§}§@Override§public TormentorsTrident copy() {§return new TormentorsTrident(this);§}§}§
public class TreacherousPitDweller extends CardImpl {§public TreacherousPitDweller(UUID ownerId) {§super(ownerId, 121, "Treacherous Pit-Dweller", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{B}{B}");§this.expansionSetCode = "AVR";§this.subtype.add("Demon");§this.power = new MageInt(4);§this.toughness = new MageInt(3);§this.addAbility(new UndyingAbility());§this.addAbility(new TreacherousPitDwellerTriggeredAbility());§}§public TreacherousPitDweller(final TreacherousPitDweller card) {§super(card);§}§@Override§public TreacherousPitDweller copy() {§return new TreacherousPitDweller(this);§}§}§class TreacherousPitDwellerTriggeredAbility extends TriggeredAbilityImpl {§private static final String ruleText = "When {this} enters the battlefield from a graveyard, ";§public TreacherousPitDwellerTriggeredAbility() {§super(Zone.BATTLEFIELD, new TreacherousPitDwellerEffect(),false);§addTarget(new TargetOpponent());§}§public TreacherousPitDwellerTriggeredAbility(final TreacherousPitDwellerTriggeredAbility ability) {§super(ability);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.ENTERS_THE_BATTLEFIELD;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§return event.getTargetId().equals(getSourceId()) && ((EntersTheBattlefieldEvent) event).getFromZone().equals(Zone.GRAVEYARD);§}§@Override§public TreacherousPitDwellerTriggeredAbility copy() {§return new TreacherousPitDwellerTriggeredAbility(this);§}§@Override§public String getRule() {§return ruleText + super.getRule();§}§}§class TreacherousPitDwellerEffect extends ContinuousEffectImpl {§public TreacherousPitDwellerEffect() {§super(Duration.Custom, Layer.ControlChangingEffects_2, SubLayer.NA, Outcome.GainControl);§staticText = "target opponent gains control of {this}";§}§public TreacherousPitDwellerEffect(final TreacherousPitDwellerEffect effect) {§super(effect);§}§@Override§public TreacherousPitDwellerEffect copy() {§return new TreacherousPitDwellerEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = (Permanent) source.getSourceObjectIfItStillExists(game);§Player targetOpponent = game.getPlayer(source.getFirstTarget());§if (permanent != null && targetOpponent != null) {§return permanent.changeControllerId(targetOpponent.getId(), game);§} else {§discard();§}§return false;§}§}§
public class TriumphOfCruelty extends CardImpl {§private static final String ruleText = "target opponent discards a card if you control the creature with the greatest power or tied for the greatest power";§public TriumphOfCruelty(UUID ownerId) {§super(ownerId, 122, "Triumph of Cruelty", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{B}");§this.expansionSetCode = "AVR";§TriggeredAbility ability = new BeginningOfUpkeepTriggeredAbility(new DiscardTargetEffect(1), TargetController.YOU, false);§Target target = new TargetOpponent();§ability.addTarget(target);§this.addAbility(new ConditionalTriggeredAbility(ability, ControlsCreatureGreatestPowerCondition.getInstance(), ruleText));§}§public TriumphOfCruelty(final TriumphOfCruelty card) {§super(card);§}§@Override§public TriumphOfCruelty copy() {§return new TriumphOfCruelty(this);§}§}§
public class TriumphOfFerocity extends CardImpl {§private static final String ruleText = "draw a card if you control the creature with the greatest power or tied for the greatest power";§public TriumphOfFerocity(UUID ownerId) {§super(ownerId, 198, "Triumph of Ferocity", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{G}");§this.expansionSetCode = "AVR";§TriggeredAbility ability = new BeginningOfUpkeepTriggeredAbility(new DrawCardSourceControllerEffect(1), TargetController.YOU, false);§this.addAbility(new ConditionalTriggeredAbility(ability, ControlsCreatureGreatestPowerCondition.getInstance(), ruleText));§}§public TriumphOfFerocity(final TriumphOfFerocity card) {§super(card);§}§@Override§public TriumphOfFerocity copy() {§return new TriumphOfFerocity(this);§}§}§
public class TrustedForcemage extends CardImpl {§private static final String ruleText = "As long as {this} is paired with another creature, each of those creatures gets +1/+1";§public TrustedForcemage(UUID ownerId) {§super(ownerId, 199, "Trusted Forcemage", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{G}");§this.expansionSetCode = "AVR";§this.subtype.add("Human");§this.subtype.add("Shaman");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(SoulbondAbility.getInstance());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostPairedEffect(1, 1, ruleText)));§}§public TrustedForcemage(final TrustedForcemage card) {§super(card);§}§@Override§public TrustedForcemage copy() {§return new TrustedForcemage(this);§}§}§
public class TyrantOfDiscord extends CardImpl {§public TyrantOfDiscord(UUID ownerId) {§super(ownerId, 162, "Tyrant of Discord", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{R}{R}{R}");§this.expansionSetCode = "AVR";§this.subtype.add("Elemental");§this.power = new MageInt(7);§this.toughness = new MageInt(7);§Ability ability = new EntersBattlefieldTriggeredAbility(new TyrantOfDiscordEffect());§ability.addTarget(new TargetOpponent());§this.addAbility(ability);§}§public TyrantOfDiscord(final TyrantOfDiscord card) {§super(card);§}§@Override§public TyrantOfDiscord copy() {§return new TyrantOfDiscord(this);§}§}§class TyrantOfDiscordEffect extends OneShotEffect {§public TyrantOfDiscordEffect() {§super(Outcome.Benefit);§this.staticText = "target opponent chooses a permanent he or she controls at random and sacrifices it. If a nonland permanent is sacrificed this way, repeat this process";§}§public TyrantOfDiscordEffect(final TyrantOfDiscordEffect effect) {§super(effect);§}§@Override§public TyrantOfDiscordEffect copy() {§return new TyrantOfDiscordEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§UUID target = source.getFirstTarget();§Player opponent = game.getPlayer(target);§if (opponent != null) {§boolean stop = false;§while (!stop) {§int count = game.getBattlefield().countAll(new FilterPermanent(), opponent.getId(), game);§if (count > 0) {§int random = (int)(Math.random()*count);§int index = 0;§for (Permanent permanent : game.getBattlefield().getAllActivePermanents(opponent.getId())) {§if (index == random) {§if (permanent.sacrifice(source.getSourceId(), game)) {§if (permanent.getCardType().contains(CardType.LAND)) {§stop = true;§game.informPlayers("Land permanent has been sacrificed: " + permanent.getName() + ". Stopping process.");§} else {§game.informPlayers("Nonland permanent has been sacrificed: " + permanent.getName() + ". Repeating process.");§}§} else {§game.informPlayers("Couldn't sacrifice a permanent. Stopping the process.");§stop = true;§}§break;§}§index++;§}§} else {§game.informPlayers("There is no permanent to sacrifice");§stop = true;§}§}§}§return true;§}§}§
public class UlvenwaldTracker extends CardImpl {§public UlvenwaldTracker(UUID ownerId) {§super(ownerId, 200, "Ulvenwald Tracker", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{G}");§this.expansionSetCode = "AVR";§this.subtype.add("Human");§this.subtype.add("Shaman");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new FightTargetsEffect(), new ManaCostsImpl("{1}{G}"));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetControlledCreaturePermanent());§ability.addTarget(new TargetOtherCreaturePermanent());§this.addAbility(ability);§}§public UlvenwaldTracker(final UlvenwaldTracker card) {§super(card);§}§@Override§public UlvenwaldTracker copy() {§return new UlvenwaldTracker(this);§}§}§class TargetOtherCreaturePermanent extends TargetCreaturePermanent {§public TargetOtherCreaturePermanent() {§super();§}§public TargetOtherCreaturePermanent(final TargetOtherCreaturePermanent target) {§super(target);§}§@Override§public boolean canTarget(UUID controllerId, UUID id, Ability source, Game game) {§if (source.getTargets().get(0).getTargets().contains(id)) {§return false;§}§return super.canTarget(controllerId, id, source, game);§}§@Override§public TargetOtherCreaturePermanent copy() {§return new TargetOtherCreaturePermanent(this);§}§}§
public class UncannySpeed extends CardImpl {§public UncannySpeed(UUID ownerId) {§super(ownerId, 163, "Uncanny Speed", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{R}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new BoostTargetEffect(3, 0, Duration.EndOfTurn));§this.getSpellAbility().addEffect(new GainAbilityTargetEffect(HasteAbility.getInstance(), Duration.EndOfTurn));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public UncannySpeed(final UncannySpeed card) {§super(card);§}§@Override§public UncannySpeed copy() {§return new UncannySpeed(this);§}§}§
public class UndeadExecutioner extends CardImpl {§public UndeadExecutioner(UUID ownerId) {§super(ownerId, 123, "Undead Executioner", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{B}");§this.expansionSetCode = "AVR";§this.subtype.add("Zombie");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new DiesTriggeredAbility(new BoostTargetEffect(-2, -2, Duration.EndOfTurn), true);§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public UndeadExecutioner(final UndeadExecutioner card) {§super(card);§}§@Override§public UndeadExecutioner copy() {§return new UndeadExecutioner(this);§}§}§
public class UnhallowedPact extends CardImpl {§public UnhallowedPact(UUID ownerId) {§super(ownerId, 124, "Unhallowed Pact", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{B}");§this.expansionSetCode = "AVR";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.Detriment));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new DiesAttachedTriggeredAbility(new ReturnToBattlefieldUnderYourControlAttachedEffect(), "enchanted creature"));§}§public UnhallowedPact(final UnhallowedPact card) {§super(card);§}§@Override§public UnhallowedPact copy() {§return new UnhallowedPact(this);§}§}§
public class VanguardsShield extends CardImpl {§public VanguardsShield(UUID ownerId) {§super(ownerId, 223, "Vanguard's Shield", Rarity.COMMON, new CardType[]{CardType.ARTIFACT}, "{2}");§this.expansionSetCode = "AVR";§this.subtype.add("Equipment");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEquippedEffect(0, 3)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new VanguardsShieldEffect()));§this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(3)));§}§public VanguardsShield(final VanguardsShield card) {§super(card);§}§@Override§public VanguardsShield copy() {§return new VanguardsShield(this);§}§}§class VanguardsShieldEffect extends ContinuousEffectImpl {§public VanguardsShieldEffect() {§super(Duration.WhileOnBattlefield, Outcome.AddAbility);§staticText = "Equipped creature can block an additional creature each combat";§}§public VanguardsShieldEffect(final VanguardsShieldEffect effect) {§super(effect);§}§@Override§public VanguardsShieldEffect copy() {§return new VanguardsShieldEffect(this);§}§@Override§public boolean apply(Layer layer, SubLayer sublayer, Ability source, Game game) {§Permanent perm = game.getPermanent(source.getSourceId());§if (perm != null && perm.getAttachedTo() != null) {§Permanent equipped = game.getPermanent(perm.getAttachedTo());§if (equipped != null) {§switch (layer) {§case RulesEffects:§if (equipped.getMaxBlocks() > 0) {§equipped.setMaxBlocks(equipped.getMaxBlocks() + 1);§}§break;§}§return true;§}§}§return false;§}§@Override§public boolean apply(Game game, Ability source) {§return false;§}§@Override§public boolean hasLayer(Layer layer) {§return layer == Layer.RulesEffects;§}§}§
public class Vanishment extends CardImpl {§public Vanishment(UUID ownerId) {§super(ownerId, 82, "Vanishment", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{4}{U}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new PutOnLibraryTargetEffect(true));§this.getSpellAbility().addTarget(new TargetNonlandPermanent());§this.addAbility(new MiracleAbility(this, new ManaCostsImpl("{U}")));§}§public Vanishment(final Vanishment card) {§super(card);§}§@Override§public Vanishment copy() {§return new Vanishment(this);§}§}§
public class VesselOfEndlessRest extends CardImpl {§public VesselOfEndlessRest(UUID ownerId) {§super(ownerId, 224, "Vessel of Endless Rest", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "AVR";§Ability ability = new EntersBattlefieldTriggeredAbility(new PutOnLibraryTargetEffect(false), false);§ability.addTarget(new TargetCardInGraveyard());§this.addAbility(ability);§this.addAbility(new AnyColorManaAbility());§}§public VesselOfEndlessRest(final VesselOfEndlessRest card) {§super(card);§}§@Override§public VesselOfEndlessRest copy() {§return new VesselOfEndlessRest(this);§}§}§
public class VexingDevil extends CardImpl {§public VexingDevil(UUID ownerId) {§super(ownerId, 164, "Vexing Devil", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{R}");§this.expansionSetCode = "AVR";§this.subtype.add("Devil");§this.power = new MageInt(4);§this.toughness = new MageInt(3);§this.addAbility(new EntersBattlefieldTriggeredAbility(new VexingDevilEffect(), false));§}§public VexingDevil(final VexingDevil card) {§super(card);§}§@Override§public VexingDevil copy() {§return new VexingDevil(this);§}§}§class VexingDevilEffect extends OneShotEffect {§public VexingDevilEffect() {§super(Outcome.Neutral);§staticText = "any opponent may have it deal 4 damage to him or her. If a player does, sacrifice {this}";§}§VexingDevilEffect(final VexingDevilEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§Permanent permanent = game.getPermanent(source.getSourceId());§if (controller != null && permanent != null) {§for (UUID opponentUuid : game.getOpponents(source.getControllerId())) {§Player opponent = game.getPlayer(opponentUuid);§if (opponent != null && opponent.chooseUse(Outcome.LoseLife, "Make " + permanent.getLogName() + " deal 4 damage to you?", source, game)) {§game.informPlayers(opponent.getLogName() + " has chosen to receive 4 damage from " + permanent.getLogName());§opponent.damage(4, permanent.getId(), game, false, true);§permanent.sacrifice(source.getSourceId(), game);§return true;§}§}§game.informPlayers("4 damage wasn't dealt so " + permanent.getLogName() + " won't be sacrificed.");§return true;§}§return false;§}§@Override§public VexingDevilEffect copy() {§return new VexingDevilEffect(this);§}§}§
public class VigilanteJustice extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Human");§static {§filter.add(new SubtypePredicate("Human"));§}§public VigilanteJustice(UUID ownerId) {§super(ownerId, 165, "Vigilante Justice", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{3}{R}");§this.expansionSetCode = "AVR";§Ability ability = new CreatureEntersBattlefieldTriggeredAbility(Zone.BATTLEFIELD, new DamageTargetEffect(1), filter, false, false);§ability.addTarget(new TargetCreatureOrPlayer());§this.addAbility(ability);§}§public VigilanteJustice(final VigilanteJustice card) {§super(card);§}§@Override§public VigilanteJustice copy() {§return new VigilanteJustice(this);§}§}§
public class VoiceOfTheProvinces extends CardImpl {§public VoiceOfTheProvinces(UUID ownerId) {§super(ownerId, 40, "Voice of the Provinces", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{W}{W}");§this.expansionSetCode = "AVR";§this.subtype.add("Angel");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new EntersBattlefieldTriggeredAbility(new CreateTokenEffect(new HumanToken())));§}§public VoiceOfTheProvinces(final VoiceOfTheProvinces card) {§super(card);§}§@Override§public VoiceOfTheProvinces copy() {§return new VoiceOfTheProvinces(this);§}§}§
public class Vorstclaw extends CardImpl {§public Vorstclaw(UUID ownerId) {§super(ownerId, 201, "Vorstclaw", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{G}{G}");§this.expansionSetCode = "AVR";§this.subtype.add("Elemental");§this.subtype.add("Horror");§this.power = new MageInt(7);§this.toughness = new MageInt(7);§}§public Vorstclaw(final Vorstclaw card) {§super(card);§}§@Override§public Vorstclaw copy() {§return new Vorstclaw(this);§}§}§
public class WanderingWolf extends CardImpl {§public WanderingWolf(UUID ownerId) {§super(ownerId, 202, "Wandering Wolf", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "AVR";§this.subtype.add("Wolf");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new CantBeBlockedByCreaturesWithLessPowerEffect()));§}§public WanderingWolf(final WanderingWolf card) {§super(card);§}§@Override§public WanderingWolf copy() {§return new WanderingWolf(this);§}§}§
public class Wingcrafter extends CardImpl {§private static final String ruleText = "As long as {this} is paired with another creature, both creatures have flying";§public Wingcrafter(UUID ownerId) {§super(ownerId, 83, "Wingcrafter", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{U}");§this.expansionSetCode = "AVR";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(SoulbondAbility.getInstance());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityPairedEffect(FlyingAbility.getInstance(), ruleText)));§}§public Wingcrafter(final Wingcrafter card) {§super(card);§}§@Override§public Wingcrafter copy() {§return new Wingcrafter(this);§}§}§
public class WolfirAvenger extends CardImpl {§public WolfirAvenger(UUID ownerId) {§super(ownerId, 205, "Wolfir Avenger", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{G}{G}");§this.expansionSetCode = "AVR";§this.subtype.add("Wolf");§this.subtype.add("Warrior");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(FlashAbility.getInstance());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new RegenerateSourceEffect(), new ManaCostsImpl("{1}{G}")));§}§public WolfirAvenger(final WolfirAvenger card) {§super(card);§}§@Override§public WolfirAvenger copy() {§return new WolfirAvenger(this);§}§}§
public class WolfirSilverheart extends CardImpl {§private static final String ruleText = "As long as {this} is paired with another creature, each of those creatures gets +4/+4";§public WolfirSilverheart(UUID ownerId) {§super(ownerId, 206, "Wolfir Silverheart", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{G}{G}");§this.expansionSetCode = "AVR";§this.subtype.add("Wolf");§this.subtype.add("Warrior");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(SoulbondAbility.getInstance());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostPairedEffect(4, 4, ruleText)));§}§public WolfirSilverheart(final WolfirSilverheart card) {§super(card);§}§@Override§public WolfirSilverheart copy() {§return new WolfirSilverheart(this);§}§}§
public class YewSpirit extends CardImpl {§public YewSpirit(UUID ownerId) {§super(ownerId, 207, "Yew Spirit", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{G}");§this.expansionSetCode = "AVR";§this.subtype.add("Spirit");§this.subtype.add("Treefolk");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§SourcePermanentPowerCount x = new SourcePermanentPowerCount();§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD,§new BoostSourceEffect(x, x, Duration.EndOfTurn, true),§new ManaCostsImpl("{2}{G}{G}")));§}§public YewSpirit(final YewSpirit card) {§super(card);§}§@Override§public YewSpirit copy() {§return new YewSpirit(this);§}§}§
public class ZealousConscripts extends CardImpl {§public ZealousConscripts(UUID ownerId) {§super(ownerId, 166, "Zealous Conscripts", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{R}");§this.expansionSetCode = "AVR";§this.subtype.add("Human");§this.subtype.add("Warrior");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(HasteAbility.getInstance());§Ability ability = new EntersBattlefieldTriggeredAbility(new GainControlTargetEffect(Duration.EndOfTurn));§ability.addTarget(new TargetPermanent());§ability.addEffect(new UntapTargetEffect());§ability.addEffect(new GainAbilityTargetEffect(HasteAbility.getInstance(), Duration.EndOfTurn, "It gains haste until end of turn"));§this.addAbility(ability);§}§public ZealousConscripts(final ZealousConscripts card) {§super(card);§}§@Override§public ZealousConscripts copy() {§return new ZealousConscripts(this);§}§}§
public class ZealousStrike extends CardImpl {§public ZealousStrike(UUID ownerId) {§super(ownerId, 41, "Zealous Strike", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{W}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new BoostTargetEffect(2, 2, Duration.EndOfTurn));§this.getSpellAbility().addEffect(new GainAbilityTargetEffect(FirstStrikeAbility.getInstance(), Duration.EndOfTurn));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public ZealousStrike(final ZealousStrike card) {§super(card);§}§@Override§public ZealousStrike copy() {§return new ZealousStrike(this);§}§}§
public class AdverseConditions extends CardImpl {§public AdverseConditions(UUID ownerId) {§super(ownerId, 54, "Adverse Conditions", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{3}{U}");§this.expansionSetCode = "BFZ";§Ability ability = new DevoidAbility(this.color);§ability.setRuleAtTheTop(true);§this.addAbility(ability);§this.getSpellAbility().addEffect(new TapTargetEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent(0, 2));§this.getSpellAbility().addEffect(new DontUntapInControllersNextUntapStepTargetEffect());§Effect effect = new CreateTokenEffect(new EldraziScionToken());§effect.setText("put a 1/1 colorless Eldrazi Scion creature token onto the battlefield. It has \"Sacrifice this creature: Add {C} to your mana pool.\"");§this.getSpellAbility().addEffect(effect);§}§public AdverseConditions(final AdverseConditions card) {§super(card);§}§@Override§public AdverseConditions copy() {§return new AdverseConditions(this);§}§}§
public class AkoumFirebird extends CardImpl {§public AkoumFirebird(UUID ownerId) {§super(ownerId, 138, "Akoum Firebird", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{2}{R}{R}");§this.expansionSetCode = "BFZ";§this.subtype.add("Phoenix");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(HasteAbility.getInstance());§this.addAbility(new AttacksEachTurnStaticAbility());§this.addAbility(new AkoumFirebirdLandfallAbility(new DoIfCostPaid(§new ReturnSourceFromGraveyardToBattlefieldEffect(), new ManaCostsImpl("{4}{R}{R}")), false));§}§public AkoumFirebird(final AkoumFirebird card) {§super(card);§}§@Override§public AkoumFirebird copy() {§return new AkoumFirebird(this);§}§}§class AkoumFirebirdLandfallAbility extends TriggeredAbilityImpl {§public AkoumFirebirdLandfallAbility(Effect effect, boolean optional) {§this(Zone.GRAVEYARD, effect, optional);§}§public AkoumFirebirdLandfallAbility (Zone zone, Effect effect, Boolean optional ) {§super(zone, effect, optional);§}§public AkoumFirebirdLandfallAbility(final AkoumFirebirdLandfallAbility ability) {§super(ability);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.ENTERS_THE_BATTLEFIELD;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§Permanent permanent = game.getPermanent(event.getTargetId());§return permanent != null && permanent.getCardType().contains(CardType.LAND) && permanent.getControllerId().equals(this.controllerId);§}§@Override§public String getRule() {§return "<i>Landfall</i> &mdash; Whenever a land enters the battlefield under your control, " + super.getRule();§}§@Override§public AkoumFirebirdLandfallAbility copy() {§return new AkoumFirebirdLandfallAbility(this);§}§}§
public class AkoumHellkite extends CardImpl {§public AkoumHellkite(UUID ownerId) {§super(ownerId, 139, "Akoum Hellkite", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{R}{R}");§this.expansionSetCode = "BFZ";§this.subtype.add("Dragon");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new AkoumHellkiteTriggeredAbility();§ability.addTarget(new TargetCreatureOrPlayer());§this.addAbility(ability);§}§public AkoumHellkite(final AkoumHellkite card) {§super(card);§}§@Override§public AkoumHellkite copy() {§return new AkoumHellkite(this);§}§}§class AkoumHellkiteTriggeredAbility extends TriggeredAbilityImpl {§private static final String text = "<i>Landfall</i> - Whenever a land enters the battlefield under your control, {this} deals 1 damage to target creature or player. "§+ "If that land is a Mountain, Akoum Hellkite deals 2 damage to that creature or player instead.";§public AkoumHellkiteTriggeredAbility() {§super(Zone.BATTLEFIELD, new AkoumHellkiteDamageEffect());§}§public AkoumHellkiteTriggeredAbility(final AkoumHellkiteTriggeredAbility ability) {§super(ability);§}§@Override§public AkoumHellkiteTriggeredAbility copy() {§return new AkoumHellkiteTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.ENTERS_THE_BATTLEFIELD;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§Permanent permanent = game.getPermanent(event.getTargetId());§if (permanent != null§&& permanent.getCardType().contains(CardType.LAND)§&& permanent.getControllerId().equals(getControllerId())) {§Permanent sourcePermanent = game.getPermanent(getSourceId());§if (sourcePermanent != null)§for (Effect effect : getEffects()) {§if (effect instanceof AkoumHellkiteDamageEffect) {§effect.setTargetPointer(new FixedTarget(permanent, game));§}§return true;§}§}§return false;§}§@Override§public String getRule() {§return text;§}§}§class AkoumHellkiteDamageEffect extends OneShotEffect {§public AkoumHellkiteDamageEffect() {§super(Outcome.Damage);§}§public AkoumHellkiteDamageEffect(final AkoumHellkiteDamageEffect effect) {§super(effect);§}§@Override§public AkoumHellkiteDamageEffect copy() {§return new AkoumHellkiteDamageEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent land = game.getPermanentOrLKIBattlefield(getTargetPointer().getFirst(game, source));§Player player = game.getPlayer(source.getFirstTarget());§if (land != null && player != null) {§if (land.hasSubtype("Mountain")) {§player.damage(2, source.getSourceId(), game, false, true);§} else {§player.damage(1, source.getSourceId(), game, false, true);§}§return true;§}§Permanent permanent = game.getPermanent(source.getFirstTarget());§if (land != null && permanent != null) {§if (land.hasSubtype("Mountain")) {§permanent.damage(2, source.getSourceId(), game, false, true);§} else {§permanent.damage(1, source.getSourceId(), game, false, true);§}§return true;§}§return false;§}§}§
public class AkoumStonewaker extends CardImpl {§public AkoumStonewaker(UUID ownerId) {§super(ownerId, 140, "Akoum Stonewaker", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{R}");§this.expansionSetCode = "BFZ";§this.subtype.add("Human");§this.subtype.add("Shaman");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new LandfallAbility(new DoIfCostPaid(new AkoumStonewakerEffect(), new ManaCostsImpl("{2}{R}")), false));§}§public AkoumStonewaker(final AkoumStonewaker card) {§super(card);§}§@Override§public AkoumStonewaker copy() {§return new AkoumStonewaker(this);§}§}§class AkoumStonewakerEffect extends OneShotEffect {§public AkoumStonewakerEffect() {§super(Outcome.PutCreatureInPlay);§this.staticText = "put a 3/1 red Elemental creature token with trample and haste onto the battlefield. Exile that token at the beginning of the next end step";§}§public AkoumStonewakerEffect(final AkoumStonewakerEffect effect) {§super(effect);§}§@Override§public AkoumStonewakerEffect copy() {§return new AkoumStonewakerEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Token token = new AkoumStonewakerElementalToken();§if (token.putOntoBattlefield(1, game, source.getSourceId(), source.getControllerId())) {§for (UUID tokenId : token.getLastAddedTokenIds()) {§Permanent tokenPermanent = game.getPermanent(tokenId);§if (tokenPermanent != null) {§ExileTargetEffect exileEffect = new ExileTargetEffect();§exileEffect.setTargetPointer(new FixedTarget(tokenPermanent, game));§game.addDelayedTriggeredAbility(new AtTheBeginOfNextEndStepDelayedTriggeredAbility(exileEffect), source);§}§}§return true;§}§return false;§}§}§class AkoumStonewakerElementalToken extends Token {§public AkoumStonewakerElementalToken() {§super("Elemental", "3/1 red Elemental creature token with trample and haste");§cardType.add(CardType.CREATURE);§color.setRed(true);§subtype.add("Elemental");§power = new MageInt(3);§toughness = new MageInt(1);§this.addAbility(TrampleAbility.getInstance());§this.addAbility(HasteAbility.getInstance());§this.setOriginalExpansionSetCode("BFZ");§this.setTokenType(1);§}§}§
public class AlignedHedronNetwork extends CardImpl {§public AlignedHedronNetwork(UUID ownerId) {§super(ownerId, 222, "Aligned Hedron Network", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{4}");§this.expansionSetCode = "BFZ";§this.addAbility(new EntersBattlefieldTriggeredAbility(new AlignedHedronNetworkExileEffect(), false));§}§public AlignedHedronNetwork(final AlignedHedronNetwork card) {§super(card);§}§@Override§public AlignedHedronNetwork copy() {§return new AlignedHedronNetwork(this);§}§}§class AlignedHedronNetworkExileEffect extends OneShotEffect {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creatures with power 5 or greater");§static {§filter.add(new PowerPredicate(Filter.ComparisonType.GreaterThan, 4));§}§public AlignedHedronNetworkExileEffect() {§super(Outcome.Benefit);§this.staticText = "exile all creatures with power 5 or greater until {this} leaves the battlefield";§}§public AlignedHedronNetworkExileEffect(final AlignedHedronNetworkExileEffect effect) {§super(effect);§}§@Override§public AlignedHedronNetworkExileEffect copy() {§return new AlignedHedronNetworkExileEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§Permanent permanent = game.getPermanent(source.getSourceId());§if (controller != null && permanent != null) {§Set<Card> toExile = new LinkedHashSet<>();§for (Permanent creature : game.getBattlefield().getActivePermanents(filter, controller.getId(), source.getSourceId(), game)) {§toExile.add(creature);§}§if (!toExile.isEmpty()) {§controller.moveCardsToExile(toExile, source, game, true, CardUtil.getCardExileZoneId(game, source), permanent.getIdName());§new CreateDelayedTriggeredAbilityEffect(new OnLeaveReturnExiledToBattlefieldAbility()).apply(game, source);§}§return true;§}§return false;§}§}§
public class AllyEncampment extends CardImpl {§private static final FilterSpell FILTER = new FilterSpell("an Ally spell");§static {§FILTER.add(new SubtypePredicate("Ally"));§}§public AllyEncampment(UUID ownerId) {§super(ownerId, 228, "Ally Encampment", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "BFZ";§this.addAbility(new ColorlessManaAbility());§this.addAbility(new ConditionalAnyColorManaAbility(new TapSourceCost(), 1, new ConditionalSpellManaBuilder(FILTER), true));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ReturnToHandTargetEffect(), new GenericManaCost(1));§ability.addCost(new TapSourceCost());§ability.addCost(new SacrificeSourceCost());§ability.addTarget(new TargetControlledCreaturePermanent(new FilterControlledCreaturePermanent("Ally", "Ally you control")));§this.addAbility(ability);§}§public AllyEncampment(final AllyEncampment card) {§super(card);§}§@Override§public AllyEncampment copy() {§return new AllyEncampment(this);§}§}§
public class AngelicCaptain extends CardImpl {§private static final FilterAttackingCreature filter = new FilterAttackingCreature("other attacking Ally");§static {§filter.add(new SubtypePredicate("Ally"));§filter.add(new AnotherPredicate());§}§public AngelicCaptain(UUID ownerId) {§super(ownerId, 208, "Angelic Captain", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{R}{W}");§this.expansionSetCode = "BFZ";§this.subtype.add("Angel");§this.subtype.add("Ally");§this.power = new MageInt(4);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§PermanentsOnBattlefieldCount value = new PermanentsOnBattlefieldCount(filter);§this.addAbility(new AttacksTriggeredAbility(new BoostSourceEffect(value, value, Duration.EndOfTurn, true), false));§}§public AngelicCaptain(final AngelicCaptain card) {§super(card);§}§@Override§public AngelicCaptain copy() {§return new AngelicCaptain(this);§}§}§
public class AngelicGift extends CardImpl {§public AngelicGift(UUID ownerId) {§super(ownerId, 19, "Angelic Gift", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{W}");§this.expansionSetCode = "BFZ";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new EntersBattlefieldTriggeredAbility(new DrawCardSourceControllerEffect(1), false));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(FlyingAbility.getInstance(), AttachmentType.AURA)));§}§public AngelicGift(final AngelicGift card) {§super(card);§}§@Override§public AngelicGift copy() {§return new AngelicGift(this);§}§}§
public class AngelOfRenewal extends CardImpl {§public AngelOfRenewal(UUID ownerId) {§super(ownerId, 18, "Angel of Renewal", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{5}{W}");§this.expansionSetCode = "BFZ";§this.subtype.add("Angel");§this.subtype.add("Ally");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new EntersBattlefieldTriggeredAbility(new GainLifeEffect(§new PermanentsOnBattlefieldCount(new FilterControlledCreaturePermanent()))));§}§public AngelOfRenewal(final AngelOfRenewal card) {§super(card);§}§@Override§public AngelOfRenewal copy() {§return new AngelOfRenewal(this);§}§}§
public class BaneOfBalaGed extends CardImpl {§public BaneOfBalaGed(UUID ownerId) {§super(ownerId, 1, "Bane of Bala Ged", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{7}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.power = new MageInt(7);§this.toughness = new MageInt(5);§this.addAbility(new AttacksTriggeredAbility(new BaneOfBalaGedEffect(), false, "", SetTargetPointer.PLAYER));§}§public BaneOfBalaGed(final BaneOfBalaGed card) {§super(card);§}§@Override§public BaneOfBalaGed copy() {§return new BaneOfBalaGed(this);§}§}§class BaneOfBalaGedEffect extends OneShotEffect {§public BaneOfBalaGedEffect() {§super(Outcome.Benefit);§this.staticText = "defending player exiles two permanents he or she controls";§}§public BaneOfBalaGedEffect(final BaneOfBalaGedEffect effect) {§super(effect);§}§@Override§public BaneOfBalaGedEffect copy() {§return new BaneOfBalaGedEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player defendingPlayer = game.getPlayer(getTargetPointer().getFirst(game, source));§if (defendingPlayer != null) {§Target target = new TargetControlledPermanent(2);§defendingPlayer.chooseTarget(outcome, target, source, game);§defendingPlayer.moveCards(new CardsImpl(target.getTargets()), null, Zone.EXILED, source, game);§return true;§}§return false;§}§}§
public class BarrageTyrant extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("another colorless creature");§static {§filter.add(new AnotherPredicate());§filter.add(new ColorlessPredicate());§}§public BarrageTyrant(UUID ownerId) {§super(ownerId, 127, "Barrage Tyrant", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{R}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.power = new MageInt(5);§this.toughness = new MageInt(3);§this.addAbility(new DevoidAbility(this.color));§Effect effect = new DamageTargetEffect(new SacrificeCostCreaturesPower());§effect.setText("{this} deals damage equal to the sacrificed creature's power to target creature or player");§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new ManaCostsImpl("{2}{R}"));§ability.addCost(new SacrificeTargetCost(new TargetControlledCreaturePermanent(filter)));§ability.addTarget(new TargetCreatureOrPlayer());§this.addAbility(ability);§}§public BarrageTyrant(final BarrageTyrant card) {§super(card);§}§@Override§public BarrageTyrant copy() {§return new BarrageTyrant(this);§}§}§
public class BeastcallerSavant extends CardImpl {§public BeastcallerSavant(UUID ownerId) {§super(ownerId, 170, "Beastcaller Savant", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "BFZ";§this.subtype.add("Elf");§this.subtype.add("Shaman");§this.subtype.add("Ally");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(HasteAbility.getInstance());§this.addAbility(new ConditionalAnyColorManaAbility(1, new ConditionalSpellManaBuilder(new FilterCreatureSpell("creature spells"))));§}§public BeastcallerSavant(final BeastcallerSavant card) {§super(card);§}§@Override§public BeastcallerSavant copy() {§return new BeastcallerSavant(this);§}§}§
public class BlightedCataract extends CardImpl {§public BlightedCataract(UUID ownerId) {§super(ownerId, 229, "Blighted Cataract", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "BFZ";§this.addAbility(new ColorlessManaAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DrawCardSourceControllerEffect(2), new ManaCostsImpl("{5}{U}"));§ability.addCost(new TapSourceCost());§ability.addCost(new SacrificeSourceCost());§this.addAbility(ability);§}§public BlightedCataract(final BlightedCataract card) {§super(card);§}§@Override§public BlightedCataract copy() {§return new BlightedCataract(this);§}§}§
public class BlightedFen extends CardImpl {§public BlightedFen(UUID ownerId) {§super(ownerId, 230, "Blighted Fen", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "BFZ";§this.addAbility(new ColorlessManaAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,§new SacrificeEffect(new FilterCreaturePermanent(), 1, "Target opponent"),§new ManaCostsImpl<>("{4}{B}"));§ability.addCost(new TapSourceCost());§ability.addCost(new SacrificeSourceCost());§ability.addTarget(new TargetOpponent());§this.addAbility(ability);§}§public BlightedFen(final BlightedFen card) {§super(card);§}§@Override§public BlightedFen copy() {§return new BlightedFen(this);§}§}§
public class BlightedGorge extends CardImpl {§public BlightedGorge(UUID ownerId) {§super(ownerId, 231, "Blighted Gorge", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "BFZ";§this.addAbility(new ColorlessManaAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,§new DamageTargetEffect(2),§new ManaCostsImpl<>("{4}{R}"));§ability.addCost(new TapSourceCost());§ability.addCost(new SacrificeSourceCost());§ability.addTarget(new TargetCreatureOrPlayer());§this.addAbility(ability);§}§public BlightedGorge(final BlightedGorge card) {§super(card);§}§@Override§public BlightedGorge copy() {§return new BlightedGorge(this);§}§}§
public class BlightedSteppe extends CardImpl {§public BlightedSteppe(UUID ownerId) {§super(ownerId, 232, "Blighted Steppe", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "BFZ";§this.addAbility(new ColorlessManaAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,§new GainLifeEffect(new PermanentsOnBattlefieldCount(new FilterControlledCreaturePermanent("creature you control"), 2)),§new ManaCostsImpl<>("{3}{W}"));§ability.addCost(new TapSourceCost());§ability.addCost(new SacrificeSourceCost());§this.addAbility(ability);§}§public BlightedSteppe(final BlightedSteppe card) {§super(card);§}§@Override§public BlightedSteppe copy() {§return new BlightedSteppe(this);§}§}§
public class BlightedWoodland extends CardImpl {§public BlightedWoodland(UUID ownerId) {§super(ownerId, 233, "Blighted Woodland", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "BFZ";§this.addAbility(new ColorlessManaAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,§new SearchLibraryPutInPlayEffect(new TargetCardInLibrary(0, 2, new FilterBasicLandCard()), true, true),§new ManaCostsImpl<>("{3}{G}"));§ability.addCost(new TapSourceCost());§ability.addCost(new SacrificeSourceCost());§this.addAbility(ability);§}§public BlightedWoodland(final BlightedWoodland card) {§super(card);§}§@Override§public BlightedWoodland copy() {§return new BlightedWoodland(this);§}§}§
public class BlightHerder extends CardImpl {§public BlightHerder(UUID ownerId) {§super(ownerId, 2, "Blight Herder", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.subtype.add("Processor");§this.power = new MageInt(4);§this.toughness = new MageInt(5);§this.addAbility(new CastSourceTriggeredAbility(new BlightHerderEffect(), true));§}§public BlightHerder(final BlightHerder card) {§super(card);§}§@Override§public BlightHerder copy() {§return new BlightHerder(this);§}§}§class BlightHerderEffect extends OneShotEffect {§private final static FilterCard filter = new FilterCard("cards your opponents own from exile");§static {§filter.add(new OwnerPredicate(TargetController.OPPONENT));§}§public BlightHerderEffect() {§super(Outcome.PutCreatureInPlay);§this.staticText = "you may put two cards your opponents own from exile into their owners' graveyards. If you do, put three 1/1 colorless Eldrazi Scion creature tokens onto the battlefield. They have \"Sacrifice this creature: Add {C} to your mana pool.";§}§public BlightHerderEffect(final BlightHerderEffect effect) {§super(effect);§}§@Override§public BlightHerderEffect copy() {§return new BlightHerderEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Target target = new TargetCardInExile(2, 2, filter, null);§if (target.canChoose(source.getSourceId(), source.getControllerId(), game)) {§if (controller.chooseTarget(outcome, target, source, game)) {§Cards cardsToGraveyard = new CardsImpl(target.getTargets());§controller.moveCards(cardsToGraveyard, null, Zone.GRAVEYARD, source, game);§return new CreateTokenEffect(new EldraziScionToken(), 3).apply(game, source);§}§}§return true;§}§return false;§}§}§
public class Blisterpod extends CardImpl {§public Blisterpod(UUID ownerId) {§super(ownerId, 163, "Blisterpod", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{G}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.subtype.add("Drone");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new DevoidAbility(this.color));§Effect effect = new CreateTokenEffect(new EldraziScionToken());§effect.setText("put a 1/1 colorless Eldrazi Scion creature token onto the battlefield. It has \"Sacrifice this creature: Add {C} to your mana pool.\"");§this.addAbility(new DiesTriggeredAbility(effect, false));§}§public Blisterpod(final Blisterpod card) {§super(card);§}§@Override§public Blisterpod copy() {§return new Blisterpod(this);§}§}§
public class BloodbondVampire extends CardImpl {§public BloodbondVampire(UUID ownerId) {§super(ownerId, 104, "Bloodbond Vampire", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{B}{B}");§this.expansionSetCode = "BFZ";§this.subtype.add("Vampire");§this.subtype.add("Shaman");§this.subtype.add("Ally");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new GainLifeControllerTriggeredAbility(new AddCountersSourceEffect(CounterType.P1P1.createInstance()), false));§}§public BloodbondVampire(final BloodbondVampire card) {§super(card);§}§@Override§public BloodbondVampire copy() {§return new BloodbondVampire(this);§}§}§
public class BoilingEarth extends CardImpl {§private final static FilterCreaturePermanent filter = new FilterCreaturePermanent("creature your opponents control");§static {§filter.add(new ControllerPredicate(TargetController.OPPONENT));§}§public BoilingEarth(UUID ownerId) {§super(ownerId, 142, "Boiling Earth", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{1}{R}");§this.expansionSetCode = "BFZ";§this.getSpellAbility().addEffect(new DamageAllEffect(1, filter));§this.addAbility(new AwakenAbility(this, 4, "{6}{R}"));§}§public BoilingEarth(final BoilingEarth card) {§super(card);§}§@Override§public BoilingEarth copy() {§return new BoilingEarth(this);§}§}§
public class BreakerOfArmies extends CardImpl {§public BreakerOfArmies(UUID ownerId) {§super(ownerId, 3, "Breaker of Armies", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{8}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.power = new MageInt(10);§this.toughness = new MageInt(8);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new MustBeBlockedByAllSourceEffect(Duration.WhileOnBattlefield)));§}§public BreakerOfArmies(final BreakerOfArmies card) {§super(card);§}§@Override§public BreakerOfArmies copy() {§return new BreakerOfArmies(this);§}§}§
public class BrilliantSpectrum extends CardImpl {§public BrilliantSpectrum(UUID ownerId) {§super(ownerId, 70, "Brilliant Spectrum", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{3}{U}");§this.expansionSetCode = "BFZ";§this.getSpellAbility().setAbilityWord(AbilityWord.CONVERGE);§Effect effect = new DrawCardSourceControllerEffect(ColorsOfManaSpentToCastCount.getInstance());§effect.setText("Draw X cards, where X is the number of colors of mana spent to cast {this}");§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addEffect(new DiscardControllerEffect(2));§}§public BrilliantSpectrum(final BrilliantSpectrum card) {§super(card);§}§@Override§public BrilliantSpectrum copy() {§return new BrilliantSpectrum(this);§}§}§
public class BringToLight extends CardImpl {§public BringToLight(UUID ownerId) {§super(ownerId, 209, "Bring to Light", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{3}{G}{U}");§this.expansionSetCode = "BFZ";§this.getSpellAbility().addEffect(new BringToLightEffect());§}§public BringToLight(final BringToLight card) {§super(card);§}§@Override§public BringToLight copy() {§return new BringToLight(this);§}§}§class BringToLightEffect extends OneShotEffect {§public BringToLightEffect() {§super(Outcome.PlayForFree);§this.staticText = "<i>Converge</i> &mdash; Search your library for a creature, instant, or sorcery card with converted mana "§+ "cost less than or equal to the number of colors of mana spent to cast {this}, exile that card, "§+ "then shuffle your library. You may cast that card without paying its mana cost";§}§public BringToLightEffect(final BringToLightEffect effect) {§super(effect);§}§@Override§public BringToLightEffect copy() {§return new BringToLightEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§int numberColors = ColorsOfManaSpentToCastCount.getInstance().calculate(game, source, this);§FilterCard filter = new FilterCard();§filter.add(Predicates.or(new CardTypePredicate(CardType.CREATURE), new CardTypePredicate(CardType.INSTANT), new CardTypePredicate(CardType.SORCERY)));§filter.add(new ConvertedManaCostPredicate(Filter.ComparisonType.LessThan, numberColors + 1));§TargetCardInLibrary target = new TargetCardInLibrary(filter);§controller.searchLibrary(target, game);§Card card = controller.getLibrary().getCard(target.getFirstTarget(), game);§if (card != null) {§controller.moveCards(card, Zone.EXILED, source, game);§}§controller.shuffleLibrary(game);§if (card != null) {§if (controller.chooseUse(outcome, "Cast " + card.getName() + " without paying its mana cost?", source, game)) {§if (card.getSpellAbility() != null) {§controller.cast(card.getSpellAbility(), game, true);§} else {§Logger.getLogger(BringToLightEffect.class).error("Bring to Light: spellAbility == null " + card.getName());§}§}§}§return true;§}§return false;§}§}§
public class BroodButcher extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("a creature");§public BroodButcher(UUID ownerId) {§super(ownerId, 199, "Brood Butcher", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{B}{G}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.subtype.add("Drone");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new DevoidAbility(this.color));§this.addAbility(new EntersBattlefieldTriggeredAbility(new CreateTokenEffect(new EldraziScionToken()), false));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostTargetEffect(-2, -2, Duration.EndOfTurn), new ManaCostsImpl("{B}{G}"));§ability.addCost(new SacrificeTargetCost(new TargetControlledCreaturePermanent(filter)));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public BroodButcher(final BroodButcher card) {§super(card);§}§@Override§public BroodButcher copy() {§return new BroodButcher(this);§}§}§
public class BroodhunterWurm extends CardImpl {§public BroodhunterWurm(UUID ownerId) {§super(ownerId, 171, "Broodhunter Wurm", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{G}");§this.expansionSetCode = "BFZ";§this.subtype.add("Wurm");§this.power = new MageInt(4);§this.toughness = new MageInt(3);§}§public BroodhunterWurm(final BroodhunterWurm card) {§super(card);§}§@Override§public BroodhunterWurm copy() {§return new BroodhunterWurm(this);§}§}§
public class BroodMonitor extends CardImpl {§public BroodMonitor(UUID ownerId) {§super(ownerId, 164, "Brood Monitor", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{G}{G}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.subtype.add("Drone");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new DevoidAbility(this.color));§Effect effect = new CreateTokenEffect(new EldraziScionToken(), 3);§effect.setText("put three 1/1 colorless Eldrazi Scion creature tokens onto the battlefield. They have \"Sacrifice this creature: Add {C} to your mana pool.\"");§this.addAbility(new EntersBattlefieldTriggeredAbility(effect, false));§}§public BroodMonitor(final BroodMonitor card) {§super(card);§}§@Override§public BroodMonitor copy() {§return new BroodMonitor(this);§}§}§
public class BrutalExpulsion extends CardImpl {§private static final FilterSpellOrPermanent filter = new FilterSpellOrPermanent("spell or creature");§static {§filter.setPermanentFilter(new FilterCreaturePermanent());§}§public BrutalExpulsion(UUID ownerId) {§super(ownerId, 200, "Brutal Expulsion", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{2}{U}{R}");§this.expansionSetCode = "BFZ";§Ability ability = new DevoidAbility(this.color);§ability.setRuleAtTheTop(true);§this.addAbility(ability);§this.getSpellAbility().getModes().setMinModes(1);§this.getSpellAbility().getModes().setMaxModes(2);§this.getSpellAbility().addTarget(new TargetSpellOrPermanent(1, 1, filter, false));§this.getSpellAbility().addEffect(new ReturnToHandTargetEffect());§Mode mode = new Mode();§mode.getEffects().add(new DamageTargetEffect(2));§mode.getTargets().add(new TargetCreatureOrPlaneswalker());§Effect effect = new DealtDamageToCreatureBySourceDies(this, Duration.EndOfTurn);§effect.setText("If that permanent would be put into a graveyard this turn, exile it instead");§mode.getEffects().add(effect);§this.getSpellAbility().addMode(mode);§this.getSpellAbility().addWatcher(new DamagedByWatcher(true));§}§public BrutalExpulsion(final BrutalExpulsion card) {§super(card);§}§@Override§public BrutalExpulsion copy() {§return new BrutalExpulsion(this);§}§}§
public class CallTheScions extends CardImpl {§public CallTheScions(UUID ownerId) {§super(ownerId, 165, "Call the Scions", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{2}{G}");§this.expansionSetCode = "BFZ";§Ability ability = new DevoidAbility(this.color);§ability.setRuleAtTheTop(true);§this.addAbility(ability);§Effect effect = new CreateTokenEffect(new EldraziScionToken(), 2);§effect.setText("put two 1/1 colorless Eldrazi Scion creature tokens onto the battlefield. They have \"Sacrifice this creature: Add {C} to your mana pool.\"");§this.getSpellAbility().addEffect(effect);§}§public CallTheScions(final CallTheScions card) {§super(card);§}§@Override§public CallTheScions copy() {§return new CallTheScions(this);§}§}§
public class CanopyVista extends CardImpl {§private static final FilterLandPermanent filter = new FilterLandPermanent();§static {§filter.add(new SupertypePredicate("Basic"));§}§public CanopyVista(UUID ownerId) {§super(ownerId, 234, "Canopy Vista", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "BFZ";§this.subtype.add("Forest");§this.subtype.add("Plains");§Condition controls = new InvertCondition(new PermanentsOnTheBattlefieldCondition(filter, PermanentsOnTheBattlefieldCondition.CountType.MORE_THAN, 1));§String abilityText = "tapped unless you control two or more basic lands";§this.addAbility(new EntersBattlefieldAbility(new ConditionalOneShotEffect(new TapSourceEffect(), controls, abilityText), abilityText));§this.addAbility(new GreenManaAbility());§this.addAbility(new WhiteManaAbility());§}§public CanopyVista(final CanopyVista card) {§super(card);§}§@Override§public CanopyVista copy() {§return new CanopyVista(this);§}§}§
public class ChasmGuide extends CardImpl {§public ChasmGuide(UUID ownerId) {§super(ownerId, 143, "Chasm Guide", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{R}");§this.expansionSetCode = "BFZ";§this.subtype.add("Goblin");§this.subtype.add("Scout");§this.subtype.add("Ally");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§this.addAbility(new AllyEntersBattlefieldTriggeredAbility(§new GainAbilityControlledEffect(HasteAbility.getInstance(), Duration.EndOfTurn, new FilterControlledCreaturePermanent("creatures you control")), false));§}§public ChasmGuide(final ChasmGuide card) {§super(card);§}§@Override§public ChasmGuide copy() {§return new ChasmGuide(this);§}§}§
public class CinderGlade extends CardImpl {§private static final FilterLandPermanent filter = new FilterLandPermanent();§static {§filter.add(new SupertypePredicate("Basic"));§}§public CinderGlade(UUID ownerId) {§super(ownerId, 235, "Cinder Glade", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "BFZ";§this.subtype.add("Mountain");§this.subtype.add("Forest");§Condition controls = new InvertCondition(new PermanentsOnTheBattlefieldCondition(filter, PermanentsOnTheBattlefieldCondition.CountType.MORE_THAN, 1));§String abilityText = "tapped unless you control two or more basic lands";§this.addAbility(new EntersBattlefieldAbility(new ConditionalOneShotEffect(new TapSourceEffect(), controls, abilityText), abilityText));§this.addAbility(new RedManaAbility());§this.addAbility(new GreenManaAbility());§}§public CinderGlade(final CinderGlade card) {§super(card);§}§@Override§public CinderGlade copy() {§return new CinderGlade(this);§}§}§
public class CliffsideLookout extends CardImpl {§public CliffsideLookout(UUID ownerId) {§super(ownerId, 20, "Cliffside Lookout", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{W}");§this.expansionSetCode = "BFZ";§this.subtype.add("Kor");§this.subtype.add("Scout");§this.subtype.add("Ally");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostControlledEffect(1, 1, Duration.EndOfTurn), new ManaCostsImpl<>("{4}{W}")));§}§public CliffsideLookout(final CliffsideLookout card) {§super(card);§}§@Override§public CliffsideLookout copy() {§return new CliffsideLookout(this);§}§}§
public class CloudManta extends CardImpl {§public CloudManta(UUID ownerId) {§super(ownerId, 71, "Cloud Manta", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{U}");§this.expansionSetCode = "BFZ";§this.subtype.add("Fish");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§}§public CloudManta(final CloudManta card) {§super(card);§}§@Override§public CloudManta copy() {§return new CloudManta(this);§}§}§
public class ClutchOfCurrents extends CardImpl {§public ClutchOfCurrents(UUID ownerId) {§super(ownerId, 72, "Clutch of Currents", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{U}");§this.expansionSetCode = "BFZ";§this.getSpellAbility().addEffect(new ReturnToHandTargetEffect(true, false));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.addAbility(new AwakenAbility(this, 3, "{4}{U}"));§}§public ClutchOfCurrents(final ClutchOfCurrents card) {§super(card);§}§@Override§public ClutchOfCurrents copy() {§return new ClutchOfCurrents(this);§}§}§
public class CoastalDiscovery extends CardImpl {§public CoastalDiscovery(UUID ownerId) {§super(ownerId, 73, "Coastal Discovery", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{3}{U}");§this.expansionSetCode = "BFZ";§this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(2));§this.addAbility(new AwakenAbility(this, 4, "{5}{U}"));§}§public CoastalDiscovery(final CoastalDiscovery card) {§super(card);§}§@Override§public CoastalDiscovery copy() {§return new CoastalDiscovery(this);§}§}§
public class CompleteDisregard extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature with power 3 or less");§static {§filter.add(new PowerPredicate(Filter.ComparisonType.LessThan, 4));§}§public CompleteDisregard(UUID ownerId) {§super(ownerId, 90, "Complete Disregard", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{B}");§this.expansionSetCode = "BFZ";§Ability ability = new DevoidAbility(this.color);§ability.setRuleAtTheTop(true);§this.addAbility(ability);§this.getSpellAbility().addEffect(new ExileTargetEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent(filter));§}§public CompleteDisregard(final CompleteDisregard card) {§super(card);§}§@Override§public CompleteDisregard copy() {§return new CompleteDisregard(this);§}§}§
public class ConduitOfRuin extends CardImpl {§private static final FilterCreatureCard filter = new FilterCreatureCard("a colorless creature card with converted mana cost 7 or greater");§private static final FilterCreatureCard filterCost = new FilterCreatureCard("The first creature spell");§static {§filter.add(new ColorlessPredicate());§filter.add(new ConvertedManaCostPredicate(Filter.ComparisonType.GreaterThan, 6));§filterCost.add(new FirstCastCreatureSpellPredicate());§}§public ConduitOfRuin(UUID ownerId) {§super(ownerId, 4, "Conduit of Ruin", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{6}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§TargetCardInLibrary target = new TargetCardInLibrary(filter);§this.addAbility(new CastSourceTriggeredAbility(new SearchLibraryPutOnLibraryEffect(target, true, true), true));§Effect effect = new SpellsCostReductionControllerEffect(filterCost, 2);§effect.setText("The first creature spell you cast each turn costs {2} less to cast");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, effect), new ConduitOfRuinWatcher());§}§public ConduitOfRuin(final ConduitOfRuin card) {§super(card);§}§@Override§public ConduitOfRuin copy() {§return new ConduitOfRuin(this);§}§}§class ConduitOfRuinWatcher extends Watcher {§Map<UUID, Integer> playerCreatureSpells;§int spellCount = 0;§public ConduitOfRuinWatcher() {§super("FirstCreatureSpellCastThisTurn", WatcherScope.GAME);§playerCreatureSpells = new HashMap<>();§}§public ConduitOfRuinWatcher(final ConduitOfRuinWatcher watcher) {§super(watcher);§this.playerCreatureSpells = new HashMap<>();§playerCreatureSpells.putAll(watcher.playerCreatureSpells);§}§@Override§public void watch(GameEvent event, Game game) {§if (event.getType() == GameEvent.EventType.SPELL_CAST) {§Spell spell = (Spell) game.getObject(event.getTargetId());§if (spell != null && spell.getCardType().contains(CardType.CREATURE)) {§if (playerCreatureSpells.containsKey(event.getPlayerId())) {§playerCreatureSpells.put(event.getPlayerId(), playerCreatureSpells.get(event.getPlayerId()) + 1);§} else {§playerCreatureSpells.put(event.getPlayerId(), 1);§}§}§}§}§public int creatureSpellsCastThisTurn(UUID playerId) {§if (playerCreatureSpells.containsKey(playerId)) {§return playerCreatureSpells.get(playerId);§}§return 0;§}§@Override§public ConduitOfRuinWatcher copy() {§return new ConduitOfRuinWatcher(this);§}§@Override§public void reset() {§super.reset();§playerCreatureSpells.clear();§}§}§class FirstCastCreatureSpellPredicate implements ObjectPlayerPredicate<ObjectPlayer<Controllable>> {§@Override§public boolean apply(ObjectPlayer<Controllable> input, Game game) {§if (input.getObject() instanceof Spell§&& ((Spell) input.getObject()).getCardType().contains(CardType.CREATURE)) {§ConduitOfRuinWatcher watcher = (ConduitOfRuinWatcher) game.getState().getWatchers().get("FirstCreatureSpellCastThisTurn");§return watcher != null && watcher.creatureSpellsCastThisTurn(input.getPlayerId()) == 0;§}§return false;§}§@Override§public String toString() {§return "The first creature spell you cast each turn";§}§}§
public class CoralhelmGuide extends CardImpl {§public CoralhelmGuide(UUID ownerId) {§super(ownerId, 74, "Coralhelm Guide", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{U}");§this.expansionSetCode = "BFZ";§this.subtype.add("Merfolk");§this.subtype.add("Scout");§this.subtype.add("Ally");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new CantBeBlockedTargetEffect(Duration.EndOfTurn), new ManaCostsImpl<>("{4}{U}"));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public CoralhelmGuide(final CoralhelmGuide card) {§super(card);§}§@Override§public CoralhelmGuide copy() {§return new CoralhelmGuide(this);§}§}§
public class CourierGriffin extends CardImpl {§public CourierGriffin(UUID ownerId) {§super(ownerId, 21, "Courier Griffin", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{W}");§this.expansionSetCode = "BFZ";§this.subtype.add("Griffin");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new EntersBattlefieldTriggeredAbility(new GainLifeEffect(2), false));§}§public CourierGriffin(final CourierGriffin card) {§super(card);§}§@Override§public CourierGriffin copy() {§return new CourierGriffin(this);§}§}§
public class CrumbleToDust extends CardImpl {§public CrumbleToDust(UUID ownerId) {§super(ownerId, 128, "Crumble to Dust", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{3}{R}");§this.expansionSetCode = "BFZ";§Ability ability = new DevoidAbility(this.color);§ability.setRuleAtTheTop(true);§this.addAbility(ability);§this.getSpellAbility().addTarget(new TargetNonBasicLandPermanent());§this.getSpellAbility().addEffect(new ExileTargetAndSearchGraveyardHandLibraryEffect(false, "its controller's", "any number of cards with the same name as that land"));§}§public CrumbleToDust(final CrumbleToDust card) {§super(card);§}§@Override§public CrumbleToDust copy() {§return new CrumbleToDust(this);§}§}§
public class CrypticCruiser extends CardImpl {§public CrypticCruiser(UUID ownerId) {§super(ownerId, 56, "Cryptic Cruiser", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{U}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.subtype.add("Processor");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new DevoidAbility(this.color));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new TapTargetEffect(), new ManaCostsImpl<>("{2}{U}"));§ability.addCost(new ExileOpponentsCardFromExileToGraveyardCost(true));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public CrypticCruiser(final CrypticCruiser card) {§super(card);§}§@Override§public CrypticCruiser copy() {§return new CrypticCruiser(this);§}§}§
public class CullingDrone extends CardImpl {§public CullingDrone(UUID ownerId) {§super(ownerId, 91, "Culling Drone", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{B}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.subtype.add("Drone");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new DevoidAbility(this.color));§this.addAbility(new IngestAbility());§}§public CullingDrone(final CullingDrone card) {§super(card);§}§@Override§public CullingDrone copy() {§return new CullingDrone(this);§}§}§
public class DampeningPulse extends CardImpl {§private final static FilterCreaturePermanent filter = new FilterCreaturePermanent("Creatures your opponents control");§static {§filter.add(new ControllerPredicate(TargetController.OPPONENT));§}§public DampeningPulse(UUID ownerId) {§super(ownerId, 75, "Dampening Pulse", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{3}{U}");§this.expansionSetCode = "BFZ";§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostAllEffect(-1, -0, Duration.WhileOnBattlefield, filter, false)));§}§public DampeningPulse(final DampeningPulse card) {§super(card);§}§@Override§public DampeningPulse copy() {§return new DampeningPulse(this);§}§}§
public class DeathlessBehemoth extends CardImpl {§private final static FilterControlledPermanent filter = new FilterControlledPermanent("two Eldrazi Scions");§static {§filter.add(Predicates.and(§new SubtypePredicate("Eldrazi"),§new SubtypePredicate("Scion")));§}§public DeathlessBehemoth(UUID ownerId) {§super(ownerId, 5, "Deathless Behemoth", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{6}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.power = new MageInt(6);§this.toughness = new MageInt(6);§this.addAbility(VigilanceAbility.getInstance());§this.addAbility(new ActivateAsSorceryActivatedAbility(Zone.GRAVEYARD,§new ReturnToHandSourceEffect(), new SacrificeTargetCost(new TargetControlledPermanent(2, 2, filter, true))));§}§public DeathlessBehemoth(final DeathlessBehemoth card) {§super(card);§}§@Override§public DeathlessBehemoth copy() {§return new DeathlessBehemoth(this);§}§}§
public class DefiantBloodlord extends CardImpl {§public DefiantBloodlord(UUID ownerId) {§super(ownerId, 107, "Defiant Bloodlord", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}{B}{B}");§this.expansionSetCode = "BFZ";§this.subtype.add("Vampire");§this.power = new MageInt(4);§this.toughness = new MageInt(5);§this.addAbility(FlyingAbility.getInstance());§DefiantBloodlordTriggeredAbility ability = new DefiantBloodlordTriggeredAbility();§ability.addTarget(new TargetOpponent());§this.addAbility(ability);§}§public DefiantBloodlord(final DefiantBloodlord card) {§super(card);§}§@Override§public DefiantBloodlord copy() {§return new DefiantBloodlord(this);§}§}§class DefiantBloodlordTriggeredAbility extends TriggeredAbilityImpl {§public DefiantBloodlordTriggeredAbility() {§super(Zone.BATTLEFIELD, null);§}§public DefiantBloodlordTriggeredAbility(final DefiantBloodlordTriggeredAbility ability) {§super(ability);§}§@Override§public DefiantBloodlordTriggeredAbility copy() {§return new DefiantBloodlordTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.GAINED_LIFE;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (event.getPlayerId().equals(this.controllerId)) {§this.getEffects().clear();§this.addEffect(new LoseLifeTargetEffect(event.getAmount()));§return true;§}§return false;§}§@Override§public String getRule() {§return "Whenever you gain life, target opponent loses that much life.";§}§}§
public class DemonsGrasp extends CardImpl {§public DemonsGrasp(UUID ownerId) {§super(ownerId, 108, "Demon's Grasp", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{4}{B}");§this.expansionSetCode = "BFZ";§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.getSpellAbility().addEffect(new BoostTargetEffect(-5, -5, Duration.EndOfTurn));§}§public DemonsGrasp(final DemonsGrasp card) {§super(card);§}§@Override§public DemonsGrasp copy() {§return new DemonsGrasp(this);§}§}§
public class DesolationTwin extends CardImpl {§public DesolationTwin(UUID ownerId) {§super(ownerId, 6, "Desolation Twin", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{10}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.power = new MageInt(10);§this.toughness = new MageInt(10);§this.addAbility(new DesolationTwinOnCastAbility());§}§public DesolationTwin(final DesolationTwin card) {§super(card);§}§@Override§public DesolationTwin copy() {§return new DesolationTwin(this);§}§}§class DesolationTwinOnCastAbility extends TriggeredAbilityImpl {§DesolationTwinOnCastAbility() {§super(Zone.STACK, new CreateTokenEffect(new EldraziToken()));§}§DesolationTwinOnCastAbility(DesolationTwinOnCastAbility ability) {§super(ability);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.SPELL_CAST;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§Spell spell = (Spell) game.getObject(event.getTargetId());§return this.getSourceId().equals(spell.getSourceId());§}§@Override§public DesolationTwinOnCastAbility copy() {§return new DesolationTwinOnCastAbility(this);§}§@Override§public String getRule() {§return "When you cast {this}, " + super.getRule();§}§}§class EldraziToken extends Token {§public EldraziToken() {§super("Eldrazi", "10/10 colorless Eldrazi creature token");§cardType.add(CardType.CREATURE);§subtype.add("Eldrazi");§power = new MageInt(10);§toughness = new MageInt(10);§}§}§
public class DranasEmissary extends CardImpl {§public DranasEmissary(UUID ownerId) {§super(ownerId, 210, "Drana's Emissary", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{W}{B}");§this.expansionSetCode = "BFZ";§this.subtype.add("Vampire");§this.subtype.add("Cleric");§this.subtype.add("Ally");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§Effect effect = new GainLifeEffect(1);§effect.setText("and you gain 1 life");§Ability ability = new BeginningOfUpkeepTriggeredAbility(new LoseLifeOpponentsEffect(1), TargetController.YOU, false);§ability.addEffect(effect);§this.addAbility(ability);§}§public DranasEmissary(final DranasEmissary card) {§super(card);§}§@Override§public DranasEmissary copy() {§return new DranasEmissary(this);§}§}§
public class DrownerOfHope extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("an Eldrazi Scion");§static {§filter.add(Predicates.and(§new SubtypePredicate("Eldrazi"),§new SubtypePredicate("Scion")));§}§public DrownerOfHope(UUID ownerId) {§super(ownerId, 57, "Drowner of Hope", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}{U}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(new DevoidAbility(this.color));§Effect effect = new CreateTokenEffect(new EldraziScionToken(), 2);§effect.setText("put two 1/1 colorless Eldrazi Scion creature tokens onto the battlefield. They have \"Sacrifice this creature: Add {C} to your mana pool");§this.addAbility(new EntersBattlefieldTriggeredAbility(effect, false));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new TapTargetEffect(), new SacrificeTargetCost(new TargetControlledPermanent(filter)));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public DrownerOfHope(final DrownerOfHope card) {§super(card);§}§@Override§public DrownerOfHope copy() {§return new DrownerOfHope(this);§}§}§
public class DustStalker extends CardImpl {§private final static FilterCreaturePermanent filter = new FilterCreaturePermanent("if you control no other colorless creatures");§static {§filter.add(new AnotherPredicate());§filter.add(new ColorlessPredicate());§}§public DustStalker(UUID ownerId) {§super(ownerId, 202, "Dust Stalker", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{B}{R}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.power = new MageInt(5);§this.toughness = new MageInt(3);§this.addAbility(new DevoidAbility(this.color));§this.addAbility(HasteAbility.getInstance());§this.addAbility(new BeginningOfEndStepTriggeredAbility(Zone.BATTLEFIELD, new ReturnToHandSourceEffect(), TargetController.ANY,§new PermanentsOnTheBattlefieldCondition(filter, PermanentsOnTheBattlefieldCondition.CountType.EQUAL_TO, 0), false));§}§public DustStalker(final DustStalker card) {§super(card);§}§@Override§public DustStalker copy() {§return new DustStalker(this);§}§}§
public class EarthenArms extends CardImpl {§public EarthenArms(UUID ownerId) {§super(ownerId, 172, "Earthen Arms", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{1}{G}");§this.expansionSetCode = "BFZ";§this.getSpellAbility().addEffect(new AddCountersTargetEffect(CounterType.P1P1.createInstance(2)));§this.getSpellAbility().addTarget(new TargetPermanent());§this.addAbility(new AwakenAbility(this, 4, "{6}{G}"));§}§public EarthenArms(final EarthenArms card) {§super(card);§}§@Override§public EarthenArms copy() {§return new EarthenArms(this);§}§}§
public class EldraziDevastator extends CardImpl {§public EldraziDevastator(UUID ownerId) {§super(ownerId, 7, "Eldrazi Devastator", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{8}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.power = new MageInt(8);§this.toughness = new MageInt(9);§this.addAbility(TrampleAbility.getInstance());§}§public EldraziDevastator(final EldraziDevastator card) {§super(card);§}§@Override§public EldraziDevastator copy() {§return new EldraziDevastator(this);§}§}§
public class EldraziSkyspawner extends CardImpl {§public EldraziSkyspawner(UUID ownerId) {§super(ownerId, 58, "Eldrazi Skyspawner", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{U}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.subtype.add("Drone");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new DevoidAbility(this.color));§this.addAbility(FlyingAbility.getInstance());§Effect effect = new CreateTokenEffect(new EldraziScionToken());§effect.setText("put a 1/1 colorless Eldrazi Scion creature token onto the battlefield. It has \"Sacrifice this creature: Add {C} to your mana pool.\"");§this.addAbility(new EntersBattlefieldTriggeredAbility(effect, false));§}§public EldraziSkyspawner(final EldraziSkyspawner card) {§super(card);§}§@Override§public EldraziSkyspawner copy() {§return new EldraziSkyspawner(this);§}§}§
public class EmeriaShepherd extends CardImpl {§private static final FilterPermanentCard filter = new FilterPermanentCard("nonland permanent card from your graveyard");§static {§filter.add(Predicates.not(new CardTypePredicate(CardType.LAND)));§}§public EmeriaShepherd(UUID ownerId) {§super(ownerId, 22, "Emeria Shepherd", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}{W}{W}");§this.expansionSetCode = "BFZ";§this.subtype.add("Angel");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new LandfallAbility(Zone.BATTLEFIELD, new EmeriaShepherdReturnToHandTargetEffect(), true);§ability.addTarget(new TargetCardInYourGraveyard(new FilterPermanentCard(filter)));§this.addAbility(ability);§}§public EmeriaShepherd(final EmeriaShepherd card) {§super(card);§}§@Override§public EmeriaShepherd copy() {§return new EmeriaShepherd(this);§}§}§class EmeriaShepherdReturnToHandTargetEffect extends OneShotEffect {§public EmeriaShepherdReturnToHandTargetEffect() {§super(Outcome.ReturnToHand);§staticText = "you may return target nonland permanent card from your graveyard to your hand. If that land is a Plains, you may return that nonland permanent card to the battlefield instead";§}§public EmeriaShepherdReturnToHandTargetEffect(final EmeriaShepherdReturnToHandTargetEffect effect) {§super(effect);§}§@Override§public EmeriaShepherdReturnToHandTargetEffect copy() {§return new EmeriaShepherdReturnToHandTargetEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§Permanent triggeringLand = ((LandfallAbility) source).getTriggeringPermanent();§if (controller == null || triggeringLand == null) {§return false;§}§Zone toZone = Zone.HAND;§if (triggeringLand.getSubtype().contains("Plains")§&& controller.chooseUse(Outcome.PutCardInPlay, "Put the card to battlefield instead?", source, game)) {§toZone = Zone.BATTLEFIELD;§}§return controller.moveCards(new CardsImpl(targetPointer.getTargets(game, source)), toZone, source, game);§}§}§
public class EncirclingFissure extends CardImpl {§public EncirclingFissure(UUID ownerId) {§super(ownerId, 23, "Encircling Fissure", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{2}{W}");§this.expansionSetCode = "BFZ";§this.getSpellAbility().addEffect(new EncirclingFissurePreventEffect());§this.getSpellAbility().addTarget(new TargetOpponent());§this.addAbility(new AwakenAbility(this, 2, "{4}{W}"));§}§public EncirclingFissure(final EncirclingFissure card) {§super(card);§}§@Override§public EncirclingFissure copy() {§return new EncirclingFissure(this);§}§}§class EncirclingFissurePreventEffect extends PreventionEffectImpl {§public EncirclingFissurePreventEffect() {§super(Duration.EndOfTurn, Integer.MAX_VALUE, true, false);§staticText = "Prevent all combat damage that would be dealt this turn by creatures target opponent controls";§}§public EncirclingFissurePreventEffect(final EncirclingFissurePreventEffect effect) {§super(effect);§}§@Override§public EncirclingFissurePreventEffect copy() {§return new EncirclingFissurePreventEffect(this);§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§if (super.applies(event, source, game) && event instanceof DamageEvent && event.getAmount() > 0) {§DamageEvent damageEvent = (DamageEvent) event;§if (damageEvent.isCombatDamage()) {§Permanent permanent = game.getPermanent(damageEvent.getSourceId());§if (permanent != null§&& permanent.getCardType().contains(CardType.CREATURE)§&& permanent.getControllerId().equals(getTargetPointer().getFirst(game, source))) {§return true;§}§}§}§return false;§}§}§
public class EndlessOne extends CardImpl {§public EndlessOne(UUID ownerId) {§super(ownerId, 8, "Endless One", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{X}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§this.addAbility(new EntersBattlefieldAbility(new EntersBattlefieldWithXCountersEffect(CounterType.P1P1.createInstance())));§}§public EndlessOne(final EndlessOne card) {§super(card);§}§@Override§public EndlessOne copy() {§return new EndlessOne(this);§}§}§
public class ExertInfluence extends CardImpl {§public ExertInfluence(UUID ownerId) {§super(ownerId, 77, "Exert Influence", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{4}{U}");§this.expansionSetCode = "BFZ";§getSpellAbility().setAbilityWord(AbilityWord.CONVERGE);§getSpellAbility().addEffect(new ExertInfluenceEffect());§getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public ExertInfluence(final ExertInfluence card) {§super(card);§}§@Override§public ExertInfluence copy() {§return new ExertInfluence(this);§}§}§class ExertInfluenceEffect extends OneShotEffect {§public ExertInfluenceEffect() {§super(Outcome.GainControl);§this.staticText = "Gain control of target creature if its power is less than or equal to the number of colors spent to cast {this}";§}§public ExertInfluenceEffect(final ExertInfluenceEffect effect) {§super(effect);§}§@Override§public ExertInfluenceEffect copy() {§return new ExertInfluenceEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§MageObject sourceObject = game.getObject(source.getSourceId());§Player controller = game.getPlayer(source.getControllerId());§Permanent targetCreature = game.getPermanent(getTargetPointer().getFirst(game, source));§if (controller != null && sourceObject != null) {§int colors = new ColorsOfManaSpentToCastCount().calculate(game, source, this);§if (targetCreature.getPower().getValue() <= colors) {§game.addEffect(new GainControlTargetEffect(Duration.Custom, true), source);§}§return true;§}§return false;§}§}§
public class ExpeditionEnvoy extends CardImpl {§public ExpeditionEnvoy(UUID ownerId) {§super(ownerId, 24, "Expedition Envoy", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{W}");§this.expansionSetCode = "BFZ";§this.subtype.add("Human");§this.subtype.add("Scout");§this.subtype.add("Ally");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§}§public ExpeditionEnvoy(final ExpeditionEnvoy card) {§super(card);§}§@Override§public ExpeditionEnvoy copy() {§return new ExpeditionEnvoy(this);§}§}§
public class EyelessWatcher extends CardImpl {§public EyelessWatcher(UUID ownerId) {§super(ownerId, 166, "Eyeless Watcher", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{G}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.subtype.add("Drone");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new DevoidAbility(this.color));§Effect effect = new CreateTokenEffect(new EldraziScionToken(), 2);§effect.setText("put two 1/1 colorless Eldrazi Scion creature tokens onto the battlefield. They have \"Sacrifice this creature: Add {C} to your mana pool.\"");§this.addAbility(new EntersBattlefieldTriggeredAbility(effect, false));§}§public EyelessWatcher(final EyelessWatcher card) {§super(card);§}§@Override§public EyelessWatcher copy() {§return new EyelessWatcher(this);§}§}§
public class FathomFeeder extends CardImpl {§public FathomFeeder(UUID ownerId) {§super(ownerId, 203, "Fathom Feeder", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{U}{B}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.subtype.add("Drone");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new DevoidAbility(this.color));§this.addAbility(DeathtouchAbility.getInstance());§this.addAbility(new IngestAbility());§Effect effect = new FathomFeederEffect();§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DrawCardSourceControllerEffect(1), new ManaCostsImpl("{3}{U}{B}"));§ability.addEffect(effect);§this.addAbility(ability);§}§public FathomFeeder(final FathomFeeder card) {§super(card);§}§@Override§public FathomFeeder copy() {§return new FathomFeeder(this);§}§}§class FathomFeederEffect extends OneShotEffect {§public FathomFeederEffect() {§super(Outcome.Exile);§this.staticText = "Each opponent exiles the top card of his or her library";§}§public FathomFeederEffect(final FathomFeederEffect effect) {§super(effect);§}§@Override§public FathomFeederEffect copy() {§return new FathomFeederEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§for (UUID opponentId: game.getOpponents(source.getControllerId())) {§Player player = game.getPlayer(opponentId);§if (player != null) {§Card card = player.getLibrary().getFromTop(game);§if (card != null) {§player.moveCards(card, Zone.LIBRARY, Zone.EXILED, source, game);§}§}§}§return true;§}§}§
public class FelidarCub extends CardImpl {§public FelidarCub(UUID ownerId) {§super(ownerId, 25, "Felidar Cub", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "BFZ";§this.subtype.add("Cat");§this.subtype.add("Beast");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DestroyTargetEffect(), new SacrificeSourceCost());§ability.addTarget(new TargetEnchantmentPermanent());§this.addAbility(ability);§}§public FelidarCub(final FelidarCub card) {§super(card);§}§@Override§public FelidarCub copy() {§return new FelidarCub(this);§}§}§
public class FertileThicket extends CardImpl {§public FertileThicket(UUID ownerId) {§super(ownerId, 237, "Fertile Thicket", Rarity.COMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "BFZ";§this.addAbility(new EntersBattlefieldTappedAbility());§this.addAbility(new EntersBattlefieldTriggeredAbility(new FertileThicketEffect(), true));§this.addAbility(new GreenManaAbility());§}§public FertileThicket(final FertileThicket card) {§super(card);§}§@Override§public FertileThicket copy() {§return new FertileThicket(this);§}§}§class FertileThicketEffect extends OneShotEffect {§public FertileThicketEffect() {§super(Outcome.Benefit);§this.staticText = "you may look at the top five cards of your library. If you do, reveal up to one basic land card from among them, then put that card on top of your library and the rest on the bottom in any order";§}§public FertileThicketEffect(final FertileThicketEffect effect) {§super(effect);§}§@Override§public FertileThicketEffect copy() {§return new FertileThicketEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§MageObject sourceObject = game.getObject(source.getSourceId());§if (controller != null && sourceObject != null) {§Cards cards = new CardsImpl();§cards.addAll(controller.getLibrary().getTopCards(game, 5));§controller.lookAtCards(sourceObject.getIdName(), cards, game);§TargetCard target = new TargetCard(0, 1, Zone.LIBRARY, new FilterBasicLandCard());§controller.chooseTarget(outcome, cards, target, source, game);§Cards cardsRevealed = new CardsImpl(target.getTargets());§if (!cardsRevealed.isEmpty()) {§controller.revealCards(sourceObject.getIdName(), cardsRevealed, game);§cards.removeAll(cardsRevealed);§controller.putCardsOnTopOfLibrary(cardsRevealed, game, source, true);§}§controller.putCardsOnBottomOfLibrary(cards, game, source, true);§return true;§}§return false;§}§}§
public class FiremantleMage extends CardImpl {§public FiremantleMage(UUID ownerId) {§super(ownerId, 145, "Firemantle Mage", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "BFZ";§this.subtype.add("Human");§this.subtype.add("Shaman");§this.subtype.add("Ally");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new AllyEntersBattlefieldTriggeredAbility(§new GainAbilityControlledEffect(new MenaceAbility(), Duration.EndOfTurn, new FilterControlledCreaturePermanent("creatures you control")), false));§}§public FiremantleMage(final FiremantleMage card) {§super(card);§}§@Override§public FiremantleMage copy() {§return new FiremantleMage(this);§}§}§
public class FortifiedRampart extends CardImpl {§public FortifiedRampart(UUID ownerId) {§super(ownerId, 27, "Fortified Rampart", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "BFZ";§this.subtype.add("Wall");§this.power = new MageInt(0);§this.toughness = new MageInt(6);§this.addAbility(DefenderAbility.getInstance());§}§public FortifiedRampart(final FortifiedRampart card) {§super(card);§}§@Override§public FortifiedRampart copy() {§return new FortifiedRampart(this);§}§}§
public class FromBeyond extends CardImpl {§private static final FilterCard filter = new FilterCard("Eldrazi card");§static {§filter.add(new SubtypePredicate("Eldrazi"));§}§public FromBeyond(UUID ownerId) {§super(ownerId, 167, "From Beyond", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{3}{G}");§this.expansionSetCode = "BFZ";§this.addAbility(new DevoidAbility(this.color));§this.addAbility(new BeginningOfUpkeepTriggeredAbility(new CreateTokenEffect(new EldraziScionToken()), TargetController.YOU, false));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,§new SearchLibraryPutInHandEffect(new TargetCardInLibrary(filter), true, true),§new ManaCostsImpl("{1}{G}"));§ability.addCost(new SacrificeSourceCost());§this.addAbility(ability);§}§public FromBeyond(final FromBeyond card) {§super(card);§}§@Override§public FromBeyond copy() {§return new FromBeyond(this);§}§}§
public class GideonAllyOfZendikar extends CardImpl {§public GideonAllyOfZendikar(UUID ownerId) {§super(ownerId, 29, "Gideon, Ally of Zendikar", Rarity.MYTHIC, new CardType[]{CardType.PLANESWALKER}, "{2}{W}{W}");§this.expansionSetCode = "BFZ";§this.subtype.add("Gideon");§this.addAbility(new PlanswalkerEntersWithLoyalityCountersAbility(4));§LoyaltyAbility ability = new LoyaltyAbility(new BecomesCreatureSourceEffect(new GideonAllyOfZendikarToken(), "planeswalker", Duration.EndOfTurn), 1);§Effect effect = new PreventAllDamageToSourceEffect(Duration.EndOfTurn);§effect.setText("Prevent all damage that would be dealt to him this turn");§ability.addEffect(effect);§this.addAbility(ability);§this.addAbility(new LoyaltyAbility(new CreateTokenEffect(new KnightAllyToken()), 0));§this.addAbility(new LoyaltyAbility(new GetEmblemEffect(new GideonAllyOfZendikarEmblem()), -4));§}§public GideonAllyOfZendikar(final GideonAllyOfZendikar card) {§super(card);§}§@Override§public GideonAllyOfZendikar copy() {§return new GideonAllyOfZendikar(this);§}§}§class GideonAllyOfZendikarEmblem extends Emblem {§public GideonAllyOfZendikarEmblem() {§this.setName("EMBLEM: Gideon, Ally of Zendikar");§BoostControlledEffect effect = new BoostControlledEffect(1, 1, Duration.EndOfGame);§Ability ability = new SimpleStaticAbility(Zone.COMMAND, effect);§this.getAbilities().add(ability);§this.setExpansionSetCodeForImage("BFZ");§}§}§class GideonAllyOfZendikarToken extends Token {§public GideonAllyOfZendikarToken() {§super("", "5/5 Human Soldier Ally creature with indestructible");§cardType.add(CardType.CREATURE);§subtype.add("Human");§subtype.add("Soldier");§subtype.add("Ally");§power = new MageInt(5);§toughness = new MageInt(5);§addAbility(IndestructibleAbility.getInstance());§}§}§class KnightAllyToken extends Token {§public KnightAllyToken() {§super("Knight Ally", "2/2 white Knight Ally creature token");§cardType.add(CardType.CREATURE);§subtype.add("Knight");§subtype.add("Ally");§color.setWhite(true);§power = new MageInt(2);§toughness = new MageInt(2);§}§}§
public class GideonsReproach extends CardImpl {§public GideonsReproach(UUID ownerId) {§super(ownerId, 30, "Gideon's Reproach", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{W}");§this.expansionSetCode = "BFZ";§getSpellAbility().addEffect(new DamageTargetEffect(4));§getSpellAbility().addTarget(new TargetAttackingOrBlockingCreature());§}§public GideonsReproach(final GideonsReproach card) {§super(card);§}§@Override§public GideonsReproach copy() {§return new GideonsReproach(this);§}§}§
public class GraveBirthing extends CardImpl {§public GraveBirthing(UUID ownerId) {§super(ownerId, 93, "Grave Birthing", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{B}");§this.expansionSetCode = "BFZ";§Ability ability = new DevoidAbility(this.color);§ability.setRuleAtTheTop(true);§this.addAbility(ability);§this.getSpellAbility().addEffect(new GraveBirthingEffect());§this.getSpellAbility().addTarget(new TargetOpponent());§Effect effect = new CreateTokenEffect(new EldraziScionToken());§effect.setText("You put a 1/1 colorless Eldrazi Scion creature token onto the battlefield. It has \"Sacrifice this creature: Add {C} to your mana pool.\"<br>");§this.getSpellAbility().addEffect(effect); §
public class GreenwardenOfMurasa extends CardImpl {§public GreenwardenOfMurasa(UUID ownerId) {§super(ownerId, 174, "Greenwarden of Murasa", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{4}{G}{G}");§this.expansionSetCode = "BFZ";§this.subtype.add("Elemental");§this.power = new MageInt(5);§this.toughness = new MageInt(4);§Ability ability = new EntersBattlefieldTriggeredAbility(new ReturnFromGraveyardToHandTargetEffect(), true);§ability.addTarget(new TargetCardInYourGraveyard());§this.addAbility(ability);§ability = new DiesTriggeredAbility(new GreenwardenOfMurasaEffect(), false);§ability.addTarget(new TargetCardInYourGraveyard());§this.addAbility(ability);§}§public GreenwardenOfMurasa(final GreenwardenOfMurasa card) {§super(card);§}§@Override§public GreenwardenOfMurasa copy() {§return new GreenwardenOfMurasa(this);§}§}§class GreenwardenOfMurasaEffect extends OneShotEffect {§public GreenwardenOfMurasaEffect() {§super(Outcome.Benefit);§this.staticText = "you may exile it. If you do, return target card from your graveyard to your hand";§}§public GreenwardenOfMurasaEffect(final GreenwardenOfMurasaEffect effect) {§super(effect);§}§@Override§public GreenwardenOfMurasaEffect copy() {§return new GreenwardenOfMurasaEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§MageObject sourceObject = game.getObject(source.getSourceId());§Card targetCard = game.getCard(getTargetPointer().getFirst(game, source));§if (controller != null && sourceObject != null && targetCard != null) {§if (controller.chooseUse(outcome, "Exile " + sourceObject.getLogName() + " to return card from your graveyard to your hand?", source, game)) {§Effect effect = new ReturnToHandTargetEffect();§effect.setTargetPointer(new FixedTarget(targetCard.getId(), targetCard.getZoneChangeCounter(game)));§new ExileSourceEffect().apply(game, source);§return effect.apply(game, source);§}§return true;§}§return false;§}§}§
public class GripOfDesolation extends CardImpl {§public GripOfDesolation(UUID ownerId) {§super(ownerId, 94, "Grip of Desolation", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{4}{B}{B}");§this.expansionSetCode = "BFZ";§Ability ability = new DevoidAbility(this.color);§ability.setRuleAtTheTop(true);§this.addAbility(ability);§this.getSpellAbility().addEffect(new ExileTargetEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§Effect effect = new ExileTargetEffect();§effect.setTargetPointer(new SecondTargetPointer());§effect.setText("and target land");§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addTarget(new TargetLandPermanent());§}§public GripOfDesolation(final GripOfDesolation card) {§super(card);§}§@Override§public GripOfDesolation copy() {§return new GripOfDesolation(this);§}§}§
public class GroveRumbler extends CardImpl {§public GroveRumbler(UUID ownerId) {§super(ownerId, 211, "Grove Rumbler", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{R}{G}");§this.expansionSetCode = "BFZ";§this.subtype.add("Elemental");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(TrampleAbility.getInstance());§this.addAbility(new LandfallAbility(new BoostSourceEffect(2, 2, Duration.EndOfTurn), false));§}§public GroveRumbler(final GroveRumbler card) {§super(card);§}§@Override§public GroveRumbler copy() {§return new GroveRumbler(this);§}§}§
public class GrovetenderDruids extends CardImpl {§public GrovetenderDruids(UUID ownerId) {§super(ownerId, 212, "Grovetender Druids", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{G}{W}");§this.expansionSetCode = "BFZ";§this.subtype.add("Elf");§this.subtype.add("Druid");§this.subtype.add("Ally");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new AllyEntersBattlefieldTriggeredAbility(new GrovetenderDruidsEffect(), false));§}§public GrovetenderDruids(final GrovetenderDruids card) {§super(card);§}§@Override§public GrovetenderDruids copy() {§return new GrovetenderDruids(this);§}§}§class GrovetenderDruidsEffect extends OneShotEffect {§GrovetenderDruidsEffect() {§super(Outcome.Benefit);§this.staticText = "you may pay {1}. If you do, put a 1/1 green Plant creature token onto the battlefield";§}§GrovetenderDruidsEffect(final GrovetenderDruidsEffect effect) {§super(effect);§}§@Override§public GrovetenderDruidsEffect copy() {§return new GrovetenderDruidsEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if(player != null) {§if(player.chooseUse(Outcome.BoostCreature, "Do you want to to pay {1}?", source, game)) {§Cost cost = new ManaCostsImpl("{1}");§if(cost.pay(source, game, source.getSourceId(), source.getControllerId(), false, null)) {§new CreateTokenEffect(new GrovetenderDruidsPlantToken()).apply(game, source);§}§return true;§}§}§return false;§}§}§class GrovetenderDruidsPlantToken extends Token {§public GrovetenderDruidsPlantToken() {§super("Plant", "1/1 green Plant creature");§cardType.add(CardType.CREATURE);§color.setGreen(true);§subtype.add("Plant");§power = new MageInt(1);§toughness = new MageInt(1);§this.setOriginalExpansionSetCode("BFZ");§}§}§
public class GruesomeSlaughter extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("colorless creatures you control");§static {§filter.add(new ColorlessPredicate());§}§public GruesomeSlaughter(UUID ownerId) {§super(ownerId, 9, "Gruesome Slaughter", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{6}");§this.expansionSetCode = "BFZ";§Effect effect = new DamageTargetEffect(new SourcePermanentPowerCount());§effect.setText("{this} deals damage equal to its power to target creature.");§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent());§effect = new GainAbilityControlledEffect(ability, Duration.EndOfTurn, filter);§effect.setText("Until end of turn, colorless creatures you control gain \"{T}: This creature deals damage equal to its power to target creature.\"");§this.getSpellAbility().addEffect(effect);§}§public GruesomeSlaughter(final GruesomeSlaughter card) {§super(card);§}§@Override§public GruesomeSlaughter copy() {§return new GruesomeSlaughter(this);§}§}§
public class GuardianOfTazeem extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature an opponent controls");§static {§filter.add(new ControllerPredicate(TargetController.OPPONENT));§}§public GuardianOfTazeem(UUID ownerId) {§super(ownerId, 78, "Guardian of Tazeem", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{U}{U}");§this.expansionSetCode = "BFZ";§this.subtype.add("Sphinx");§this.power = new MageInt(4);§this.toughness = new MageInt(5);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new GuardianOfTazeemTriggeredAbility();§ability.addTarget(new TargetCreaturePermanent(filter));§this.addAbility(ability);§}§public GuardianOfTazeem(final GuardianOfTazeem card) {§super(card);§}§@Override§public GuardianOfTazeem copy() {§return new GuardianOfTazeem(this);§}§}§class GuardianOfTazeemTriggeredAbility extends TriggeredAbilityImpl {§public GuardianOfTazeemTriggeredAbility() {§super(Zone.BATTLEFIELD, new TapTargetEffect(), false);§addEffect(new GuardianOfTazeemEffect());§}§public GuardianOfTazeemTriggeredAbility(final GuardianOfTazeemTriggeredAbility ability) {§super(ability);§}§@Override§public GuardianOfTazeemTriggeredAbility copy() {§return new GuardianOfTazeemTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.ENTERS_THE_BATTLEFIELD;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§Permanent permanent = game.getPermanent(event.getTargetId());§if (permanent != null§&& permanent.getCardType().contains(CardType.LAND)§&& permanent.getControllerId().equals(getControllerId())) {§for (Effect effect : getEffects()) {§if (effect instanceof GuardianOfTazeemEffect) {§effect.setTargetPointer(new FixedTarget(permanent, game));§}§}§return true;§}§return false;§}§@Override§public String getRule() {§return "<i>Landfall</i> - Whenever a land enters the battlefield under your control, " + super.getRule();§}§}§class GuardianOfTazeemEffect extends OneShotEffect {§public GuardianOfTazeemEffect() {§super(Outcome.Benefit);§this.staticText = "If that land is an Island, that creature doesn't untap during its controller's next untap step";§}§public GuardianOfTazeemEffect(final GuardianOfTazeemEffect effect) {§super(effect);§}§@Override§public GuardianOfTazeemEffect copy() {§return new GuardianOfTazeemEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent land = game.getPermanentOrLKIBattlefield(getTargetPointer().getFirst(game, source));§Permanent targetCreature = game.getPermanent(source.getFirstTarget());§if (land != null && targetCreature != null) {§if (land.hasSubtype("Island")) {§ContinuousEffect effect = new DontUntapInControllersNextUntapStepTargetEffect("that creature");§effect.setTargetPointer(new FixedTarget(targetCreature, game));§game.addEffect(effect, source);§}§}§return true;§}§}§
public class GuulDrazOverseer extends CardImpl {§public GuulDrazOverseer(UUID ownerId) {§super(ownerId, 112, "Guul Draz Overseer", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{B}{B}");§this.expansionSetCode = "BFZ";§this.subtype.add("Vampire");§this.power = new MageInt(3);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new LandfallAbility(Zone.BATTLEFIELD, new GuulDrazOverseerEffect(), false, SetTargetPointer.PERMANENT));§}§public GuulDrazOverseer(final GuulDrazOverseer card) {§super(card);§}§@Override§public GuulDrazOverseer copy() {§return new GuulDrazOverseer(this);§}§}§class GuulDrazOverseerEffect extends OneShotEffect {§public GuulDrazOverseerEffect() {§super(Outcome.BoostCreature);§this.staticText = "other creatures you control get +1/+0 until end of turn. If that land is a Swamp, those creatures get +2/+0 until end of turn instead";§}§public GuulDrazOverseerEffect(final GuulDrazOverseerEffect effect) {§super(effect);§}§@Override§public GuulDrazOverseerEffect copy() {§return new GuulDrazOverseerEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§Permanent land = game.getPermanentOrLKIBattlefield(getTargetPointer().getFirst(game, source));§if (controller != null && land != null) {§int boost = 1;§if (land.getSubtype().contains("Swamp")) {§boost = 2;§}§game.addEffect(new BoostControlledEffect(boost, 0, Duration.EndOfTurn, true), source);§return true;§}§return false;§}§}§
public class HagraSharpshooter extends CardImpl {§public HagraSharpshooter(UUID ownerId) {§super(ownerId, 113, "Hagra Sharpshooter", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{B}");§this.expansionSetCode = "BFZ";§this.subtype.add("Human");§this.subtype.add("Assassin");§this.subtype.add("Ally");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostTargetEffect(-1, -1, Duration.EndOfTurn), new ManaCostsImpl("{4}{B}"));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public HagraSharpshooter(final HagraSharpshooter card) {§super(card);§}§@Override§public HagraSharpshooter copy() {§return new HagraSharpshooter(this);§}§}§
public class HalimarTidecaller extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("Land creatures");§private static final FilterCard filterCard = new FilterCard("card with awaken from your graveyard");§static {§filter.add(new CardTypePredicate(CardType.LAND));§filter.add(new CardTypePredicate(CardType.CREATURE));§filterCard.add(new AbilityPredicate(AwakenAbility.class));§}§public HalimarTidecaller(UUID ownerId) {§super(ownerId, 79, "Halimar Tidecaller", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{U}");§this.expansionSetCode = "BFZ";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.subtype.add("Ally");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§Ability ability = new EntersBattlefieldTriggeredAbility(new ReturnToHandTargetEffect(), true);§ability.addTarget(new TargetCardInYourGraveyard(filterCard));§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityControlledEffect(FlyingAbility.getInstance(), Duration.WhileOnBattlefield, filter)));§}§public HalimarTidecaller(final HalimarTidecaller card) {§super(card);§}§@Override§public HalimarTidecaller copy() {§return new HalimarTidecaller(this);§}§}§
public class HedronArchive extends CardImpl {§public HedronArchive(UUID ownerId) {§super(ownerId, 223, "Hedron Archive", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{4}");§this.expansionSetCode = "BFZ";§this.addAbility(new SimpleManaAbility(Zone.BATTLEFIELD, Mana.ColorlessMana(2), new TapSourceCost()));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DrawCardSourceControllerEffect(2), new GenericManaCost(2));§ability.addCost(new TapSourceCost());§ability.addCost(new SacrificeSourceCost());§this.addAbility(ability);§}§public HedronArchive(final HedronArchive card) {§super(card);§}§@Override§public HedronArchive copy() {§return new HedronArchive(this);§}§}§
public class HedronBlade extends CardImpl {§public HedronBlade(UUID ownerId) {§super(ownerId, 224, "Hedron Blade", Rarity.COMMON, new CardType[]{CardType.ARTIFACT}, "{1}");§this.expansionSetCode = "BFZ";§this.subtype.add("Equipment");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEquippedEffect(1, 1)));§this.addAbility(new HedronBladeTriggeredAbility(§new GainAbilityAttachedEffect(DeathtouchAbility.getInstance(), AttachmentType.EQUIPMENT, Duration.EndOfTurn)));§this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(2)));§}§public HedronBlade(final HedronBlade card) {§super(card);§}§@Override§public HedronBlade copy() {§return new HedronBlade(this);§}§}§class HedronBladeTriggeredAbility extends TriggeredAbilityImpl {§HedronBladeTriggeredAbility(Effect effect) {§super(Zone.BATTLEFIELD, effect, false);§}§HedronBladeTriggeredAbility(final HedronBladeTriggeredAbility ability) {§super(ability);§}§@Override§public HedronBladeTriggeredAbility copy() {§return new HedronBladeTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.DECLARED_BLOCKERS;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§Permanent equipment = game.getPermanentOrLKIBattlefield((this.getSourceId()));§if (equipment != null && equipment.getAttachedTo() != null) {§Permanent equippedPermanent = game.getPermanentOrLKIBattlefield((equipment.getAttachedTo()));§if (equippedPermanent != null) {§if (equippedPermanent.isAttacking()) {§for (CombatGroup group : game.getCombat().getGroups()) {§if (group.getAttackers().contains(equippedPermanent.getId())) {§for (UUID blockerId : group.getBlockers()) {§Permanent blocker = game.getPermanent(blockerId);§if (blocker != null && blocker.getColor(game).isColorless()) {§return true;§}§}§}§}§}§}§}§return false;§}§@Override§public String getRule() {§return "Whenever equipped creature becomes blocked by one or more colorless creatures, " + super.getRule();§}§}§
public class HeraldOfKozilek extends CardImpl {§private static final FilterCard filter = new FilterCard("Colorless spells");§static {§filter.add(new ColorlessPredicate());§}§public HeraldOfKozilek(UUID ownerId) {§super(ownerId, 205, "Herald of Kozilek", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{U}{R}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.subtype.add("Drone");§this.power = new MageInt(2);§this.toughness = new MageInt(4);§this.addAbility(new DevoidAbility(this.color));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new SpellsCostReductionControllerEffect(filter, 1)));§}§public HeraldOfKozilek(final HeraldOfKozilek card) {§super(card);§}§@Override§public HeraldOfKozilek copy() {§return new HeraldOfKozilek(this);§}§}§
public class HeroOfGomaFada extends CardImpl {§public HeroOfGomaFada(UUID ownerId) {§super(ownerId, 31, "Hero of Goma Fada", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{W}");§this.expansionSetCode = "BFZ";§this.subtype.add("Human");§this.subtype.add("Knight");§this.subtype.add("Ally");§this.power = new MageInt(4);§this.toughness = new MageInt(3);§Ability ability = new AllyEntersBattlefieldTriggeredAbility(§new GainAbilityAllEffect(IndestructibleAbility.getInstance(), Duration.EndOfTurn,§new FilterControlledCreaturePermanent("creatures you control")), false);§this.addAbility(ability);§}§public HeroOfGomaFada(final HeroOfGomaFada card) {§super(card);§}§@Override§public HeroOfGomaFada copy() {§return new HeroOfGomaFada(this);§}§}§
public class HorriblyAwry extends CardImpl {§private static final FilterCreatureSpell filter = new FilterCreatureSpell("creature spell with converted mana cost 4 or less");§static {§filter.add(new ConvertedManaCostPredicate(Filter.ComparisonType.LessThan, 5));§}§public HorriblyAwry(UUID ownerId) {§super(ownerId, 59, "Horribly Awry", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{1}{U}");§this.expansionSetCode = "BFZ";§Ability ability = new DevoidAbility(this.color);§ability.setRuleAtTheTop(true);§this.addAbility(ability);§this.getSpellAbility().addEffect(new CounterTargetWithReplacementEffect(Zone.EXILED));§this.getSpellAbility().addTarget(new TargetSpell(filter));§}§public HorriblyAwry(final HorriblyAwry card) {§super(card);§}§@Override§public HorriblyAwry copy() {§return new HorriblyAwry(this);§}§}§
public class IncubatorDrone extends CardImpl {§public IncubatorDrone(UUID ownerId) {§super(ownerId, 60, "Incubator Drone", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{U}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.subtype.add("Drone");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(new DevoidAbility(this.color));§Effect effect = new CreateTokenEffect(new EldraziScionToken());§effect.setText("put a 1/1 colorless Eldrazi Scion creature token onto the battlefield. It has \"Sacrifice this creature: Add {C} to your mana pool.\"");§this.addAbility(new EntersBattlefieldTriggeredAbility(effect, false));§}§public IncubatorDrone(final IncubatorDrone card) {§super(card);§}§@Override§public IncubatorDrone copy() {§return new IncubatorDrone(this);§}§}§
public class KalastriaHealer extends CardImpl {§public KalastriaHealer(UUID ownerId) {§super(ownerId, 114, "Kalastria Healer", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{B}");§this.expansionSetCode = "BFZ";§this.subtype.add("Vampire");§this.subtype.add("Cleric");§this.subtype.add("Ally");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§Ability ability = new AllyEntersBattlefieldTriggeredAbility(new LoseLifeOpponentsEffect(1), false);§Effect effect = new GainLifeEffect(1);§effect.setText("and you gain 1 life");§ability.addEffect(effect);§this.addAbility(ability);§}§public KalastriaHealer(final KalastriaHealer card) {§super(card);§}§@Override§public KalastriaHealer copy() {§return new KalastriaHealer(this);§}§}§
public class KalastriaNightwatch extends CardImpl {§public KalastriaNightwatch(UUID ownerId) {§super(ownerId, 115, "Kalastria Nightwatch", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{B}");§this.expansionSetCode = "BFZ";§this.subtype.add("Vampire");§this.subtype.add("Warrior");§this.subtype.add("Ally");§this.power = new MageInt(4);§this.toughness = new MageInt(5);§this.addAbility(new GainLifeControllerTriggeredAbility(new GainAbilitySourceEffect(FlyingAbility.getInstance(), Duration.EndOfTurn), false));§}§public KalastriaNightwatch(final KalastriaNightwatch card) {§super(card);§}§@Override§public KalastriaNightwatch copy() {§return new KalastriaNightwatch(this);§}§}§
public class KioraMasterOfTheDepths extends CardImpl {§public KioraMasterOfTheDepths(UUID ownerId) {§super(ownerId, 213, "Kiora, Master of the Depths", Rarity.MYTHIC, new CardType[]{CardType.PLANESWALKER}, "{2}{G}{U}");§this.expansionSetCode = "BFZ";§this.subtype.add("Kiora");§this.addAbility(new PlanswalkerEntersWithLoyalityCountersAbility(4));§LoyaltyAbility ability1 = new LoyaltyAbility(new KioraUntapEffect(), 1);§ability1.addTarget(new TargetCreaturePermanent(0, 1, new FilterCreaturePermanent(), false));§ability1.addTarget(new TargetLandPermanent(0, 1, new FilterLandPermanent(), false));§this.addAbility(ability1);§this.addAbility(new LoyaltyAbility(new KioraRevealEffect(), -2));§Effect effect = new CreateTokenEffect(new OctopusToken(), 3);§effect.setText("Then put three 8/8 blue Octopus creature tokens onto the battlefield");§LoyaltyAbility ability3 = new LoyaltyAbility(new GetEmblemEffect(new KioraMasterOfTheDepthsEmblem()), -8);§ability3.addEffect(effect);§this.addAbility(ability3);§}§public KioraMasterOfTheDepths(final KioraMasterOfTheDepths card) {§super(card);§}§@Override§public KioraMasterOfTheDepths copy() {§return new KioraMasterOfTheDepths(this);§}§}§class KioraUntapEffect extends OneShotEffect {§public KioraUntapEffect() {§super(Outcome.Untap);§this.staticText = "Untap up to one target creature and up to one target land";§}§public KioraUntapEffect(final KioraUntapEffect effect) {§super(effect);§}§@Override§public KioraUntapEffect copy() {§return new KioraUntapEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent firstTarget = game.getPermanent(source.getTargets().get(0).getFirstTarget());§Permanent secondTarget = game.getPermanent(source.getTargets().get(1).getFirstTarget());§if (firstTarget != null) {§firstTarget.untap(game);§}§if (secondTarget != null) {§return secondTarget.untap(game);§}§return true;§}§}§class KioraRevealEffect extends OneShotEffect {§public KioraRevealEffect() {§super(Outcome.DrawCard);§this.staticText = "Reveal the top four cards of your library. You may put a creature card and/or a land card from among them into your hand. Put the rest into your graveyard";§}§public KioraRevealEffect(final KioraRevealEffect effect) {§super(effect);§}§@Override§public KioraRevealEffect copy() {§return new KioraRevealEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§MageObject sourceObject = game.getObject(source.getSourceId());§if (sourceObject != null && controller != null) {§Cards cards = new CardsImpl();§cards.addAll(controller.getLibrary().getTopCards(game, 4));§boolean creatureCardFound = false;§boolean landCardFound = false;§for (UUID cardId : cards) {§Card card = game.getCard(cardId);§if (card != null) {§cards.add(card);§if (card.getCardType().contains(CardType.CREATURE)) {§creatureCardFound = true;§}§if (card.getCardType().contains(CardType.LAND)) {§landCardFound = true;§}§}§}§if (!cards.isEmpty()) {§controller.revealCards(sourceObject.getName(), cards, game);§if ((creatureCardFound || landCardFound)§&& controller.chooseUse(Outcome.DrawCard,§"Put a creature card and/or a land card into your hand?", source, game)) {§TargetCard target = new TargetCard(Zone.LIBRARY, new FilterCreatureCard("creature card to put into your hand"));§if (creatureCardFound && controller.chooseTarget(Outcome.DrawCard, cards, target, source, game)) {§Card card = cards.get(target.getFirstTarget(), game);§if (card != null) {§cards.remove(card);§controller.moveCards(card, null, Zone.HAND, source, game);§}§}§target = new TargetCard(Zone.LIBRARY, new FilterLandCard("land card to put into your hand"));§if (landCardFound && controller.chooseTarget(Outcome.DrawCard, cards, target, source, game)) {§Card card = cards.get(target.getFirstTarget(), game);§if (card != null) {§cards.remove(card);§controller.moveCards(card, null, Zone.HAND, source, game);§}§}§}§}§controller.moveCards(cards, null, Zone.GRAVEYARD, source, game);§return true;§}§return false;§}§}§class KioraMasterOfTheDepthsEmblem extends Emblem {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Creatures");§public KioraMasterOfTheDepthsEmblem() {§this.setName("EMBLEM: Kiora, Master of the Depths");§Ability ability = new EntersBattlefieldControlledTriggeredAbility(Zone.COMMAND,§new KioraFightEffect(), filter, true, SetTargetPointer.PERMANENT,§"Whenever a creature enters the battlefield under your control, you may have it fight target creature.");§ability.addTarget(new TargetCreaturePermanent());§this.getAbilities().add(ability);§this.setExpansionSetCodeForImage("BFZ");§}§}§class KioraFightEffect extends OneShotEffect {§KioraFightEffect() {§super(Outcome.Damage);§}§KioraFightEffect(final KioraFightEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent triggeredCreature = game.getPermanent(getTargetPointer().getFirst(game, source));§Permanent target = game.getPermanent(source.getFirstTarget());§if (triggeredCreature != null§&& target != null§&& triggeredCreature.getCardType().contains(CardType.CREATURE)§&& target.getCardType().contains(CardType.CREATURE)) {§triggeredCreature.fight(target, source, game);§return true;§}§return false;§}§@Override§public KioraFightEffect copy() {§return new KioraFightEffect(this);§}§}§class OctopusToken extends Token {§public OctopusToken() {§super("Octopus", "8/8 blue Octopus creature token");§cardType.add(CardType.CREATURE);§color.setBlue(true);§subtype.add("Octopus");§power = new MageInt(8);§toughness = new MageInt(8);§this.setOriginalExpansionSetCode("BFZ");§}§}§
public class KitesailScout extends CardImpl {§public KitesailScout(UUID ownerId) {§super(ownerId, 33, "Kitesail Scout", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{W}");§this.expansionSetCode = "BFZ";§this.subtype.add("Kor");§this.subtype.add("Scout");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§}§public KitesailScout(final KitesailScout card) {§super(card);§}§@Override§public KitesailScout copy() {§return new KitesailScout(this);§}§}§
public class KorBladewhirl extends CardImpl {§public KorBladewhirl(UUID ownerId) {§super(ownerId, 34, "Kor Bladewhirl", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "BFZ";§this.subtype.add("Kor");§this.subtype.add("Soldier");§this.subtype.add("Ally");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new AllyEntersBattlefieldTriggeredAbility(§new GainAbilityControlledEffect(FirstStrikeAbility.getInstance(), Duration.EndOfTurn, new FilterControlledCreaturePermanent("creatures you control")), false));§}§public KorBladewhirl(final KorBladewhirl card) {§super(card);§}§@Override§public KorBladewhirl copy() {§return new KorBladewhirl(this);§}§}§
public class KorCastigator extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Eldrazi Scions");§static {§filter.add(new SubtypePredicate("Eldrazi"));§filter.add(new SubtypePredicate("Scion"));§}§public KorCastigator(UUID ownerId) {§super(ownerId, 35, "Kor Castigator", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "BFZ";§this.subtype.add("Kor");§this.subtype.add("Wizard");§this.subtype.add("Ally");§this.power = new MageInt(3);§this.toughness = new MageInt(1);§this.addAbility(new SimpleEvasionAbility(new CantBeBlockedByCreaturesSourceEffect(filter, Duration.WhileOnBattlefield)));§}§public KorCastigator(final KorCastigator card) {§super(card);§}§@Override§public KorCastigator copy() {§return new KorCastigator(this);§}§}§
public class KorEntanglers extends CardImpl {§private final static FilterCreaturePermanent filter = new FilterCreaturePermanent("creature an opponent controls");§static {§filter.add(new ControllerPredicate(TargetController.OPPONENT));§}§public KorEntanglers(UUID ownerId) {§super(ownerId, 36, "Kor Entanglers", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{W}");§this.expansionSetCode = "BFZ";§this.subtype.add("Kor");§this.subtype.add("Soldier");§this.subtype.add("Ally");§this.power = new MageInt(3);§this.toughness = new MageInt(4);§Ability ability = new AllyEntersBattlefieldTriggeredAbility(new TapTargetEffect(), false);§ability.addTarget(new TargetCreaturePermanent(filter));§this.addAbility(ability);§}§public KorEntanglers(final KorEntanglers card) {§super(card);§}§@Override§public KorEntanglers copy() {§return new KorEntanglers(this);§}§}§
public class KozileksChanneler extends CardImpl {§public KozileksChanneler(UUID ownerId) {§super(ownerId, 10, "Kozilek's Channeler", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{5}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(new SimpleManaAbility(Zone.BATTLEFIELD, Mana.ColorlessMana(2), new TapSourceCost()));§}§public KozileksChanneler(final KozileksChanneler card) {§super(card);§}§@Override§public KozileksChanneler copy() {§return new KozileksChanneler(this);§}§}§
public class KozileksSentinel extends CardImpl {§private static final FilterSpell filterSpell = new FilterSpell("a colorless spell");§static {§filterSpell.add(new ColorlessPredicate());§}§public KozileksSentinel(UUID ownerId) {§super(ownerId, 129, "Kozilek's Sentinel", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{R}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.subtype.add("Drone");§this.power = new MageInt(1);§this.toughness = new MageInt(4);§this.addAbility(new DevoidAbility(this.color));§this.addAbility(new SpellCastControllerTriggeredAbility(new BoostSourceEffect(1, 0, Duration.EndOfTurn), filterSpell, false));§}§public KozileksSentinel(final KozileksSentinel card) {§super(card);§}§@Override§public KozileksSentinel copy() {§return new KozileksSentinel(this);§}§}§
public class LanternScout extends CardImpl {§public LanternScout(UUID ownerId) {§super(ownerId, 37, "Lantern Scout", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "BFZ";§this.subtype.add("Human");§this.subtype.add("Scout");§this.subtype.add("Ally");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§FilterPermanent filter = new FilterPermanent("{this} or another Ally");§filter.add(Predicates.or(§new CardIdPredicate(this.getId()),§new SubtypePredicate("Ally")));§Effect effect = new GainAbilityAllEffect(LifelinkAbility.getInstance(), Duration.EndOfTurn, new FilterControlledCreaturePermanent());§effect.setText("creatures you control gain lifelink until end of turn");§Ability ability = new AllyEntersBattlefieldTriggeredAbility(§effect, false);§this.addAbility(ability);§}§public LanternScout(final LanternScout card) {§super(card);§}§@Override§public LanternScout copy() {§return new LanternScout(this);§}§}§
public class LavastepRaider extends CardImpl {§public LavastepRaider(UUID ownerId) {§super(ownerId, 147, "Lavastep Raider", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{R}");§this.expansionSetCode = "BFZ";§this.subtype.add("Goblin");§this.subtype.add("Warrior");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(2, 0, Duration.EndOfTurn), new ManaCostsImpl<>("{2}{R}")));§}§public LavastepRaider(final LavastepRaider card) {§super(card);§}§@Override§public LavastepRaider copy() {§return new LavastepRaider(this);§}§}§
public class LifespringDruid extends CardImpl {§public LifespringDruid(UUID ownerId) {§super(ownerId, 177, "Lifespring Druid", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{G}");§this.expansionSetCode = "BFZ";§this.subtype.add("Elf");§this.subtype.add("Druid");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new AnyColorManaAbility());§}§public LifespringDruid(final LifespringDruid card) {§super(card);§}§@Override§public LifespringDruid copy() {§return new LifespringDruid(this);§}§}§
public class LithomancersFocus extends CardImpl {§public LithomancersFocus(UUID ownerId) {§super(ownerId, 38, "Lithomancer's Focus", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{W}");§this.expansionSetCode = "BFZ";§this.getSpellAbility().addEffect(new BoostTargetEffect(2, 2, Duration.EndOfTurn));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.getSpellAbility().addEffect(new LithomancersFocusPreventDamageToTargetEffect());§}§public LithomancersFocus(final LithomancersFocus card) {§super(card);§}§@Override§public LithomancersFocus copy() {§return new LithomancersFocus(this);§}§}§class LithomancersFocusPreventDamageToTargetEffect extends PreventionEffectImpl {§public LithomancersFocusPreventDamageToTargetEffect() {§super(Duration.EndOfTurn, Integer.MAX_VALUE, false);§staticText = "Prevent all damage that would be dealt to that creature this turn by colorless sources";§}§public LithomancersFocusPreventDamageToTargetEffect(final LithomancersFocusPreventDamageToTargetEffect effect) {§super(effect);§}§@Override§public LithomancersFocusPreventDamageToTargetEffect copy() {§return new LithomancersFocusPreventDamageToTargetEffect(this);§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§if (super.applies(event, source, game) && event.getTargetId().equals(targetPointer.getFirst(game, source))) {§MageObject object = game.getObject(event.getSourceId());§return object != null && object.getColor(game).isColorless();§}§return false;§}§}§
public class LoomingSpires extends CardImpl {§public LoomingSpires(UUID ownerId) {§super(ownerId, 238, "Looming Spires", Rarity.COMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "BFZ";§this.addAbility(new EntersBattlefieldTappedAbility());§Effect effect = new GainAbilityTargetEffect(FirstStrikeAbility.getInstance(), Duration.EndOfTurn);§effect.setText("and gains first strike");§Ability ability = new EntersBattlefieldTriggeredAbility(new BoostTargetEffect(1, 1, Duration.EndOfTurn), false);§ability.addEffect(effect);§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§this.addAbility(new RedManaAbility());§}§public LoomingSpires(final LoomingSpires card) {§super(card);§}§@Override§public LoomingSpires copy() {§return new LoomingSpires(this);§}§}§
public class LumberingFalls extends CardImpl {§public LumberingFalls(UUID ownerId) {§super(ownerId, 239, "Lumbering Falls", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "BFZ";§this.addAbility(new EntersBattlefieldTappedAbility());§this.addAbility(new BlueManaAbility());§this.addAbility(new GreenManaAbility());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BecomesCreatureSourceEffect(new LumberingFallsToken(), "land", Duration.EndOfTurn), new ManaCostsImpl("{2}{G}{U}")));§}§public LumberingFalls(final LumberingFalls card) {§super(card);§}§@Override§public LumberingFalls copy() {§return new LumberingFalls(this);§}§}§class LumberingFallsToken extends Token {§public LumberingFallsToken() {§super("", "3/3 green and blue Elemental creature with hexproof");§cardType.add(CardType.CREATURE);§subtype.add("Elemental");§color.setBlue(true);§color.setGreen(true);§power = new MageInt(3);§toughness = new MageInt(3);§addAbility(HexproofAbility.getInstance());§}§}§
public class MakindiPatrol extends CardImpl {§public MakindiPatrol(UUID ownerId) {§super(ownerId, 39, "Makindi Patrol", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "BFZ";§this.subtype.add("Human");§this.subtype.add("Knight");§this.subtype.add("Ally");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(new AllyEntersBattlefieldTriggeredAbility(§new GainAbilityControlledEffect(VigilanceAbility.getInstance(), Duration.EndOfTurn, new FilterControlledCreaturePermanent("creatures")), false));§}§public MakindiPatrol(final MakindiPatrol card) {§super(card);§}§@Override§public MakindiPatrol copy() {§return new MakindiPatrol(this);§}§}§
public class MakindiSliderunner extends CardImpl {§public MakindiSliderunner(UUID ownerId) {§super(ownerId, 148, "Makindi Sliderunner", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{R}");§this.expansionSetCode = "BFZ";§this.subtype.add("Beast");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(TrampleAbility.getInstance());§this.addAbility(new LandfallAbility(new BoostSourceEffect(1, 1, Duration.EndOfTurn), false));§}§public MakindiSliderunner(final MakindiSliderunner card) {§super(card);§}§@Override§public MakindiSliderunner copy() {§return new MakindiSliderunner(this);§}§}§
public class MalakirFamiliar extends CardImpl {§public MalakirFamiliar(UUID ownerId) {§super(ownerId, 116, "Malakir Familiar", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{B}");§this.expansionSetCode = "BFZ";§this.subtype.add("Bat");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(DeathtouchAbility.getInstance());§this.addAbility(new GainLifeControllerTriggeredAbility(new BoostSourceEffect(1, 1, Duration.EndOfTurn), false));§}§public MalakirFamiliar(final MalakirFamiliar card) {§super(card);§}§@Override§public MalakirFamiliar copy() {§return new MalakirFamiliar(this);§}§}§
public class MiresMalice extends CardImpl {§public MiresMalice(UUID ownerId) {§super(ownerId, 117, "Mire's Malice", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{3}{B}");§this.expansionSetCode = "BFZ";§this.getSpellAbility().addEffect(new DiscardTargetEffect(2));§this.getSpellAbility().addTarget(new TargetOpponent());§this.addAbility(new AwakenAbility(this, 3, "{5}{B}"));§}§public MiresMalice(final MiresMalice card) {§super(card);§}§@Override§public MiresMalice copy() {§return new MiresMalice(this);§}§}§
public class MistIntruder extends CardImpl {§public MistIntruder(UUID ownerId) {§super(ownerId, 61, "Mist Intruder", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{U}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.subtype.add("Drone");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§this.addAbility(new DevoidAbility(this.color));§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new IngestAbility());§}§public MistIntruder(final MistIntruder card) {§super(card);§}§@Override§public MistIntruder copy() {§return new MistIntruder(this);§}§}§
public class MoltenNursery extends CardImpl {§private static final FilterSpell filter = new FilterSpell("a colorless spell");§static {§filter.add(new ColorlessPredicate());§}§public MoltenNursery(UUID ownerId) {§super(ownerId, 130, "Molten Nursery", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{R}");§this.expansionSetCode = "BFZ";§this.addAbility(new DevoidAbility(this.color));§Ability ability = new SpellCastControllerTriggeredAbility(new DamageTargetEffect(1), filter, false);§ability.addTarget(new TargetCreatureOrPlayer());§this.addAbility(ability);§}§public MoltenNursery(final MoltenNursery card) {§super(card);§}§@Override§public MoltenNursery copy() {§return new MoltenNursery(this);§}§}§
public class MortuaryMire extends CardImpl {§public MortuaryMire(UUID ownerId) {§super(ownerId, 240, "Mortuary Mire", Rarity.COMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "BFZ";§this.addAbility(new EntersBattlefieldTappedAbility());§Ability ability = new EntersBattlefieldTriggeredAbility(new PutOnLibraryTargetEffect(true), true);§ability.addTarget(new TargetCardInYourGraveyard(new FilterCreatureCard("creature card from your graveyard")));§this.addAbility(ability);§this.addAbility(new BlackManaAbility());§}§public MortuaryMire(final MortuaryMire card) {§super(card);§}§@Override§public MortuaryMire copy() {§return new MortuaryMire(this);§}§}§
public class MundaAmbushLeader extends CardImpl {§public MundaAmbushLeader(UUID ownerId) {§super(ownerId, 215, "Munda, Ambush Leader", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{R}{W}");§this.expansionSetCode = "BFZ";§this.supertype.add("Legendary");§this.subtype.add("Kor");§this.subtype.add("Ally");§this.power = new MageInt(3);§this.toughness = new MageInt(4);§this.addAbility(HasteAbility.getInstance());§this.addAbility(new AllyEntersBattlefieldTriggeredAbility(new MundaAmbushLeaderEffect(), true));§}§public MundaAmbushLeader(final MundaAmbushLeader card) {§super(card);§}§@Override§public MundaAmbushLeader copy() {§return new MundaAmbushLeader(this);§}§}§class MundaAmbushLeaderEffect extends OneShotEffect {§private static final FilterCard filter = new FilterCard("Ally cards to reveal and put on top of your library");§static {§filter.add(new SubtypePredicate("Ally"));§}§public MundaAmbushLeaderEffect() {§super(Outcome.Benefit);§this.staticText = "you may look at the top four cards of your library. If you do, reveal any number of Ally cards from among them, then put those cards on top of your library in any order and the rest on the bottom in any order";§}§public MundaAmbushLeaderEffect(final MundaAmbushLeaderEffect effect) {§super(effect);§}§@Override§public MundaAmbushLeaderEffect copy() {§return new MundaAmbushLeaderEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§MageObject sourceObject = game.getObject(source.getSourceId());§if (controller != null && sourceObject != null) {§Cards allCards = new CardsImpl();§allCards.addAll(controller.getLibrary().getTopCards(game, 4));§controller.lookAtCards(sourceObject.getIdName(), allCards, game);§if (!allCards.isEmpty()) {§Cards cardsToReveal = new CardsImpl();§TargetCard target = new TargetCard(0, Integer.MAX_VALUE, Zone.LIBRARY, filter);§controller.chooseTarget(outcome, allCards, target, source, game);§cardsToReveal.addAll(target.getTargets());§if (!cardsToReveal.isEmpty()) {§controller.revealCards(sourceObject.getIdName(), cardsToReveal, game, true);§allCards.removeAll(cardsToReveal);§}§controller.putCardsOnTopOfLibrary(cardsToReveal, game, source, true);§}§if (!allCards.isEmpty()) {§controller.putCardsOnBottomOfLibrary(allCards, game, source, true);§}§return true;§}§return false;§}§}§
public class MurasaRanger extends CardImpl {§public MurasaRanger(UUID ownerId) {§super(ownerId, 178, "Murasa Ranger", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{G}");§this.expansionSetCode = "BFZ";§this.subtype.add("Human");§this.subtype.add("Warrior");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new LandfallAbility(new DoIfCostPaid(new AddCountersSourceEffect(CounterType.P1P1.createInstance(2)), new ManaCostsImpl("{3}{G}")), false));§}§public MurasaRanger(final MurasaRanger card) {§super(card);§}§@Override§public MurasaRanger copy() {§return new MurasaRanger(this);§}§}§
public class MurkStrider extends CardImpl {§public MurkStrider(UUID ownerId) {§super(ownerId, 62, "Murk Strider", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{U}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.subtype.add("Processor");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§this.addAbility(new DevoidAbility(this.color));§Ability ability = new EntersBattlefieldTriggeredAbility(§new DoIfCostPaid(new ReturnToHandTargetEffect(), new ExileOpponentsCardFromExileToGraveyardCost(true)), false);§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public MurkStrider(final MurkStrider card) {§super(card);§}§@Override§public MurkStrider copy() {§return new MurkStrider(this);§}§}§
public class NaturalConnection extends CardImpl {§public NaturalConnection(UUID ownerId) {§super(ownerId, 179, "Natural Connection", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{G}");§this.expansionSetCode = "BFZ";§TargetCardInLibrary target = new TargetCardInLibrary(new FilterBasicLandCard());§this.getSpellAbility().addEffect(new SearchLibraryPutInPlayEffect(target, true));§}§public NaturalConnection(final NaturalConnection card) {§super(card);§}§@Override§public NaturalConnection copy() {§return new NaturalConnection(this);§}§}§
public class NettleDrone extends CardImpl {§private static final FilterSpell filterSpell = new FilterSpell("a colorless spell");§static {§filterSpell.add(new ColorlessPredicate());§}§public NettleDrone(UUID ownerId) {§super(ownerId, 131, "Nettle Drone", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.subtype.add("Drone");§this.power = new MageInt(3);§this.toughness = new MageInt(1);§this.addAbility(new DevoidAbility(this.color));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamagePlayersEffect(1, TargetController.OPPONENT), new TapSourceCost()));§this.addAbility(new SpellCastControllerTriggeredAbility(new UntapSourceEffect(), filterSpell, false));§}§public NettleDrone(final NettleDrone card) {§super(card);§}§@Override§public NettleDrone copy() {§return new NettleDrone(this);§}§}§
public class NirkanaAssassin extends CardImpl {§public NirkanaAssassin(UUID ownerId) {§super(ownerId, 118, "Nirkana Assassin", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{B}");§this.expansionSetCode = "BFZ";§this.subtype.add("Vampire");§this.subtype.add("Assassin");§this.subtype.add("Ally");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(new GainLifeControllerTriggeredAbility(new GainAbilitySourceEffect(DeathtouchAbility.getInstance(), Duration.EndOfTurn), false));§}§public NirkanaAssassin(final NirkanaAssassin card) {§super(card);§}§@Override§public NirkanaAssassin copy() {§return new NirkanaAssassin(this);§}§}§
public class NissasRenewal extends CardImpl {§public NissasRenewal(UUID ownerId) {§super(ownerId, 180, "Nissa's Renewal", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{5}{G}");§this.expansionSetCode = "BFZ";§this.getSpellAbility().addEffect(new SearchLibraryPutInPlayEffect(new TargetCardInLibrary(0, 3, new FilterBasicLandCard()), true));§this.getSpellAbility().addEffect(new GainLifeEffect(7));§}§public NissasRenewal(final NissasRenewal card) {§super(card);§}§@Override§public NissasRenewal copy() {§return new NissasRenewal(this);§}§}§
public class NoyanDarRoilShaper extends CardImpl {§private static final FilterSpell filter = new FilterSpell("instant or sorcery card");§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.INSTANT),§new CardTypePredicate(CardType.SORCERY)));§}§public NoyanDarRoilShaper(UUID ownerId) {§super(ownerId, 216, "Noyan Dar, Roil Shaper", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{W}{U}");§this.expansionSetCode = "BFZ";§this.supertype.add("Legendary");§this.subtype.add("Merfolk");§this.subtype.add("Ally");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§Ability ability = new SpellCastControllerTriggeredAbility(new NoyanDarEffect(), filter, false);§ability.addTarget(new TargetControlledPermanent(new FilterControlledLandPermanent()));§this.addAbility(ability);§}§public NoyanDarRoilShaper(final NoyanDarRoilShaper card) {§super(card);§}§@Override§public NoyanDarRoilShaper copy() {§return new NoyanDarRoilShaper(this);§}§}§class NoyanDarEffect extends OneShotEffect {§public NoyanDarEffect() {§super(Outcome.BoostCreature);§this.staticText = "put three +1/+1 counters on target land you control. If you do, that land becomes a 0/0 Elemental creature with haste that's still a land.";§}§public NoyanDarEffect(final NoyanDarEffect effect) {§super(effect);§}§@Override§public NoyanDarEffect copy() {§return new NoyanDarEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§UUID targetId = null;§for (Target target : source.getTargets()) {§targetId = target.getFirstTarget();§}§if (targetId != null) {§FixedTarget fixedTarget = new FixedTarget(targetId);§ContinuousEffect continuousEffect = new BecomesCreatureTargetEffect(new AwakenElementalToken(), false, true, Duration.Custom);§continuousEffect.setTargetPointer(fixedTarget);§game.addEffect(continuousEffect, source);§Effect effect = new AddCountersTargetEffect(CounterType.P1P1.createInstance(3));§effect.setTargetPointer(fixedTarget);§return effect.apply(game, source);§}§return true;§}§}§class AwakenElementalToken extends Token {§public AwakenElementalToken() {§super("", "0/0 Elemental creature with haste");§this.cardType.add(CardType.CREATURE);§this.subtype.add("Elemental");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§this.addAbility(HasteAbility.getInstance());§}§}§
public class OblivionSower extends CardImpl {§public OblivionSower(UUID ownerId) {§super(ownerId, 11, "Oblivion Sower", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{6}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.power = new MageInt(5);§this.toughness = new MageInt(8);§Ability ability = new CastSourceTriggeredAbility(new ExileCardsFromTopOfLibraryTargetEffect(4, "target opponent"), false);§ability.addEffect(new OblivionSowerEffect());§ability.addTarget(new TargetOpponent());§this.addAbility(ability);§}§public OblivionSower(final OblivionSower card) {§super(card);§}§@Override§public OblivionSower copy() {§return new OblivionSower(this);§}§}§class OblivionSowerEffect extends OneShotEffect {§public OblivionSowerEffect() {§super(Outcome.PutLandInPlay);§this.staticText = ", then you may put any number of land cards that player owns from exile onto the battlefield under your control";§}§public OblivionSowerEffect(final OblivionSowerEffect effect) {§super(effect);§}§@Override§public OblivionSowerEffect copy() {§return new OblivionSowerEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§Player targetPlayer = game.getPlayer(getTargetPointer().getFirst(game, source));§if (controller != null && targetPlayer != null) {§FilterLandCard filter = new FilterLandCard();§filter.add(new OwnerIdPredicate(targetPlayer.getId()));§Cards exiledCards = new CardsImpl();§exiledCards.addAll(game.getExile().getAllCards(game));§Cards exiledLands = new CardsImpl();§exiledLands.addAll(exiledCards.getCards(filter, source.getSourceId(), controller.getId(), game));§if (!exiledLands.isEmpty() && controller.chooseUse(outcome, "Put lands into play?", source, game)) {§FilterCard filterToPlay = new FilterCard("land"§+ (exiledLands.size() > 1 ? "s" : "") + " from exile owned by "§+ targetPlayer.getName() + " to put into play under your control");§TargetCard targetCards = new TargetCard(0, exiledLands.size(), Zone.EXILED, filterToPlay);§if (controller.chooseTarget(outcome, exiledLands, targetCards, source, game)) {§controller.moveCards(new CardsImpl(targetCards.getTargets()), Zone.BATTLEFIELD, source, game);§}§}§return true;§}§return false;§}§}§
public class ObNixilisReignited extends CardImpl {§public ObNixilisReignited(UUID ownerId) {§super(ownerId, 119, "Ob Nixilis Reignited", Rarity.MYTHIC, new CardType[]{CardType.PLANESWALKER}, "{3}{B}{B}");§this.expansionSetCode = "BFZ";§this.subtype.add("Nixilis");§this.addAbility(new PlanswalkerEntersWithLoyalityCountersAbility(5));§Effect effect = new DrawCardSourceControllerEffect(1);§effect.setText("You draw a card");§LoyaltyAbility ability1 = new LoyaltyAbility(effect, 1);§effect = new LoseLifeSourceControllerEffect(1);§effect.setText("and you lose 1 life");§ability1.addEffect(effect);§this.addAbility(ability1);§LoyaltyAbility ability2 = new LoyaltyAbility(new DestroyTargetEffect(), -3);§ability2.addTarget(new TargetCreaturePermanent());§this.addAbility(ability2);§effect = new GetEmblemTargetPlayerEffect(new ObNixilisReignitedEmblem());§effect.setText("Target opponent gets an emblem with \"Whenever a player draws a card, you lose 2 life.\"");§LoyaltyAbility ability3 = new LoyaltyAbility(effect, -8);§ability3.addTarget(new TargetOpponent());§this.addAbility(ability3);§}§public ObNixilisReignited(final ObNixilisReignited card) {§super(card);§}§@Override§public ObNixilisReignited copy() {§return new ObNixilisReignited(this);§}§}§class ObNixilisReignitedEmblem extends Emblem {§public ObNixilisReignitedEmblem() {§setName("EMBLEM: Ob Nixilis Reignited");§this.getAbilities().add(new ObNixilisEmblemTriggeredAbility(new LoseLifeSourceControllerEffect(2), false));§this.setExpansionSetCodeForImage("BFZ");§}§}§class ObNixilisEmblemTriggeredAbility extends TriggeredAbilityImpl {§public ObNixilisEmblemTriggeredAbility(Effect effect, boolean optional) {§super(Zone.COMMAND, effect, optional);§}§public ObNixilisEmblemTriggeredAbility(final ObNixilisEmblemTriggeredAbility ability) {§super(ability);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.DREW_CARD;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§return event.getPlayerId() != null;§}§@Override§public String getRule() {§return "Whenever a player draws a card, you lose 2 life.";§}§@Override§public ObNixilisEmblemTriggeredAbility copy() {§return new ObNixilisEmblemTriggeredAbility(this);§}§}§
public class OmnathLocusOfRage extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Elemental you control");§static {§filter.add(new SubtypePredicate("Elemental"));§filter.add(new ControllerPredicate(TargetController.YOU));§}§public OmnathLocusOfRage(UUID ownerId) {§super(ownerId, 217, "Omnath, Locus of Rage", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{3}{R}{R}{G}{G}");§this.expansionSetCode = "BFZ";§this.supertype.add("Legendary");§this.subtype.add("Elemental");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(new LandfallAbility(new CreateTokenEffect(new OmnathElementalToken()), false));§Ability ability = new DiesThisOrAnotherCreatureTriggeredAbility(new DamageTargetEffect(3), false, filter);§ability.addTarget(new TargetCreatureOrPlayer());§this.addAbility(ability);§}§public OmnathLocusOfRage(final OmnathLocusOfRage card) {§super(card);§}§@Override§public OmnathLocusOfRage copy() {§return new OmnathLocusOfRage(this);§}§}§class OmnathElementalToken extends Token {§OmnathElementalToken() {§super("Elemental", "5/5 red and green Elemental creature token");§setTokenType(2);§setOriginalExpansionSetCode("BFZ");§cardType.add(CardType.CREATURE);§subtype.add("Elemental");§color.setRed(true);§color.setGreen(true);§power = new MageInt(5);§toughness = new MageInt(5);§}§}§
public class OnduChampion extends CardImpl {§public OnduChampion(UUID ownerId) {§super(ownerId, 149, "Ondu Champion", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{R}{R}");§this.expansionSetCode = "BFZ";§this.subtype.add("Minotaur");§this.subtype.add("Warrior");§this.subtype.add("Ally");§this.power = new MageInt(4);§this.toughness = new MageInt(3);§this.addAbility(new AllyEntersBattlefieldTriggeredAbility(§new GainAbilityControlledEffect(TrampleAbility.getInstance(), Duration.EndOfTurn, new FilterControlledCreaturePermanent("creatures you control")), false));§}§public OnduChampion(final OnduChampion card) {§super(card);§}§@Override§public OnduChampion copy() {§return new OnduChampion(this);§}§}§
public class OnduGreathorn extends CardImpl {§public OnduGreathorn(UUID ownerId) {§super(ownerId, 40, "Ondu Greathorn", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{W}");§this.expansionSetCode = "BFZ";§this.subtype.add("Beast");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(FirstStrikeAbility.getInstance());§this.addAbility(new LandfallAbility(new BoostSourceEffect(2, 2, Duration.EndOfTurn), false));§}§public OnduGreathorn(final OnduGreathorn card) {§super(card);§}§@Override§public OnduGreathorn copy() {§return new OnduGreathorn(this);§}§}§
public class OnduRising extends CardImpl {§public OnduRising(UUID ownerId) {§super(ownerId, 41, "Ondu Rising", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{1}{W}");§this.expansionSetCode = "BFZ";§this.getSpellAbility().addEffect(new CreateDelayedTriggeredAbilityEffect(new OnduRisingTriggeredAbility()));§this.addAbility(new AwakenAbility(this, 4, "{4}{W}"));§}§public OnduRising(final OnduRising card) {§super(card);§}§@Override§public OnduRising copy() {§return new OnduRising(this);§}§}§class OnduRisingTriggeredAbility extends DelayedTriggeredAbility {§public OnduRisingTriggeredAbility() {§super(new GainAbilityTargetEffect(LifelinkAbility.getInstance(), Duration.EndOfTurn), Duration.EndOfTurn, false);§}§public OnduRisingTriggeredAbility(OnduRisingTriggeredAbility ability) {§super(ability);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.ATTACKER_DECLARED;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§Permanent permanent = game.getPermanent(event.getSourceId());§if (permanent != null) {§for (Effect effect : getEffects()) {§effect.setTargetPointer(new FixedTarget(permanent, game));§}§return true;§}§return false;§}§@Override§public OnduRisingTriggeredAbility copy() {§return new OnduRisingTriggeredAbility(this);§}§@Override§public String getRule() {§return "Whenever a creature attacks this turn, it gains lifelink until end of turn.";§}§}§
public class OranRiefInvoker extends CardImpl {§public OranRiefInvoker(UUID ownerId) {§super(ownerId, 182, "Oran-Rief Invoker", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "BFZ";§this.subtype.add("Human");§this.subtype.add("Shaman");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Effect effect = new BoostSourceEffect(5, 5, Duration.EndOfTurn);§effect.setText("{source} gets +5/+5");§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new GenericManaCost(8));§effect = new GainAbilitySourceEffect(TrampleAbility.getInstance(), Duration.EndOfTurn);§effect.setText("and gains trample until end of turn");§ability.addEffect(effect);§this.addAbility(ability);§}§public OranRiefInvoker(final OranRiefInvoker card) {§super(card);§}§@Override§public OranRiefInvoker copy() {§return new OranRiefInvoker(this);§}§}§
public class Outnumber extends CardImpl {§public Outnumber(UUID ownerId) {§super(ownerId, 150, "Outnumber", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{R}");§this.expansionSetCode = "BFZ";§Effect effect = new DamageTargetEffect(new PermanentsOnBattlefieldCount(new FilterControlledCreaturePermanent("the number of creatures you control")));§effect.setText("{this} deals damage to target creature equal to the number of creatures you control");§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public Outnumber(final Outnumber card) {§super(card);§}§@Override§public Outnumber copy() {§return new Outnumber(this);§}§}§
public class PainfulTruths extends CardImpl {§public PainfulTruths(UUID ownerId) {§super(ownerId, 120, "Painful Truths", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{2}{B}");§this.expansionSetCode = "BFZ";§getSpellAbility().setAbilityWord(AbilityWord.CONVERGE);§Effect effect = new DrawCardSourceControllerEffect(ColorsOfManaSpentToCastCount.getInstance());§effect.setText("You draw X cards");§getSpellAbility().addEffect(effect);§effect = new LoseLifeSourceControllerEffect(ColorsOfManaSpentToCastCount.getInstance());§effect.setText("and lose X life, where X is the number of colors of mana spent to cast {this}");§getSpellAbility().addEffect(effect);§}§public PainfulTruths(final PainfulTruths card) {§super(card);§}§@Override§public PainfulTruths copy() {§return new PainfulTruths(this);§}§}§
public class PartTheWaterveil extends CardImpl {§public PartTheWaterveil(UUID ownerId) {§super(ownerId, 80, "Part the Waterveil", Rarity.MYTHIC, new CardType[]{CardType.SORCERY}, "{4}{U}{U}");§this.expansionSetCode = "BFZ";§this.getSpellAbility().addEffect(new AddExtraTurnControllerEffect());§this.getSpellAbility().addEffect(ExileSpellEffect.getInstance());§this.addAbility(new AwakenAbility(this, 6, "{6}{U}{U}{U}"));§}§public PartTheWaterveil(final PartTheWaterveil card) {§super(card);§}§@Override§public PartTheWaterveil copy() {§return new PartTheWaterveil(this);§}§}§
public class PathwayArrows extends CardImpl {§public PathwayArrows(UUID ownerId) {§super(ownerId, 225, "Pathway Arrows", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{1}");§this.expansionSetCode = "BFZ";§this.subtype.add("Equipment");§SimpleActivatedAbility ability2 = new SimpleActivatedAbility(Zone.BATTLEFIELD, new PathwayArrowsEffect(), new GenericManaCost(2));§ability2.addCost(new TapSourceCost());§ability2.addTarget(new TargetCreaturePermanent());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(ability2, AttachmentType.EQUIPMENT)));§this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(2)));§}§public PathwayArrows(final PathwayArrows card) {§super(card);§}§@Override§public PathwayArrows copy() {§return new PathwayArrows(this);§}§}§class PathwayArrowsEffect extends OneShotEffect {§public PathwayArrowsEffect() {§super(Outcome.Benefit);§this.staticText = "This creature deals 1 damage to target creature. If a colorless creature is dealt damage this way, tap it";§}§public PathwayArrowsEffect(final PathwayArrowsEffect effect) {§super(effect);§}§@Override§public PathwayArrowsEffect copy() {§return new PathwayArrowsEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Permanent targetCreature = game.getPermanent(getTargetPointer().getFirst(game, source));§if (targetCreature != null) {§int damageDealt = targetCreature.damage(1, source.getSourceId(), game, false, true);§if (damageDealt > 0 && targetCreature.getColor(game).isColorless()) {§targetCreature.tap(game);§}§}§return true;§}§return false;§}§}§
public class PlanarOutburst extends CardImpl {§private final static FilterCreaturePermanent filter = new FilterCreaturePermanent("nonland creatures");§static {§filter.add(Predicates.not(new CardTypePredicate(CardType.LAND)));§}§public PlanarOutburst(UUID ownerId) {§super(ownerId, 42, "Planar Outburst", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{3}{W}{W}");§this.expansionSetCode = "BFZ";§this.getSpellAbility().addEffect(new DestroyAllEffect(filter, false));§this.addAbility(new AwakenAbility(this, 4, "{5}{W}{W}{W}"));§}§public PlanarOutburst(final PlanarOutburst card) {§super(card);§}§@Override§public PlanarOutburst copy() {§return new PlanarOutburst(this);§}§}§
public class PlatedCrusher extends CardImpl {§public PlatedCrusher(UUID ownerId) {§super(ownerId, 183, "Plated Crusher", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{G}{G}{G}");§this.expansionSetCode = "BFZ";§this.subtype.add("Beast");§this.power = new MageInt(7);§this.toughness = new MageInt(6);§this.addAbility(TrampleAbility.getInstance());§this.addAbility(HexproofAbility.getInstance());§}§public PlatedCrusher(final PlatedCrusher card) {§super(card);§}§@Override§public PlatedCrusher copy() {§return new PlatedCrusher(this);§}§}§
public class PrairieStream extends CardImpl {§private static final FilterLandPermanent filter = new FilterLandPermanent();§static {§filter.add(new SupertypePredicate("Basic"));§}§public PrairieStream(UUID ownerId) {§super(ownerId, 241, "Prairie Stream", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "BFZ";§this.subtype.add("Plains");§this.subtype.add("Island");§Condition controls = new InvertCondition(new PermanentsOnTheBattlefieldCondition(filter, PermanentsOnTheBattlefieldCondition.CountType.MORE_THAN, 1));§String abilityText = "tapped unless you control two or more basic lands";§this.addAbility(new EntersBattlefieldAbility(new ConditionalOneShotEffect(new TapSourceEffect(), controls, abilityText), abilityText));§this.addAbility(new WhiteManaAbility());§this.addAbility(new BlueManaAbility());§}§public PrairieStream(final PrairieStream card) {§super(card);§}§@Override§public PrairieStream copy() {§return new PrairieStream(this);§}§}§
public class PrismArray extends CardImpl {§public PrismArray(UUID ownerId) {§super(ownerId, 81, "Prism Array", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{4}{U}");§this.expansionSetCode = "BFZ";§this.addAbility(new EntersBattlefieldAbility(§new AddCountersSourceEffect(CounterType.CRYSTAL.createInstance(), ColorsOfManaSpentToCastCount.getInstance(), true),§null, "<i>Converge</i> &mdash; {this} enters the battlefield with a +1/+1 counter on it for each color of mana spent to cast it.", null));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,§new TapTargetEffect(),§new RemoveCountersSourceCost(CounterType.CRYSTAL.createInstance(1)));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new ScryEffect(3), new ManaCostsImpl("{W}{U}{B}{R}{G}")));§}§public PrismArray(final PrismArray card) {§super(card);§}§@Override§public PrismArray copy() {§return new PrismArray(this);§}§}§
public class ProcessorAssault extends CardImpl {§public ProcessorAssault(UUID ownerId) {§super(ownerId, 132, "Processor Assault", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{1}{R}");§this.expansionSetCode = "BFZ";§Ability ability = new DevoidAbility(this.color);§ability.setRuleAtTheTop(true);§this.addAbility(ability);§this.getSpellAbility().addCost(new ExileOpponentsCardFromExileToGraveyardCost(false));§this.getSpellAbility().addEffect(new DamageTargetEffect(5));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public ProcessorAssault(final ProcessorAssault card) {§super(card);§}§@Override§public ProcessorAssault copy() {§return new ProcessorAssault(this);§}§}§
public class QuarantineField extends CardImpl {§public QuarantineField(UUID ownerId) {§super(ownerId, 43, "Quarantine Field", Rarity.MYTHIC, new CardType[]{CardType.ENCHANTMENT}, "{X}{X}{W}{W}");§this.expansionSetCode = "BFZ";§this.addAbility(new EntersBattlefieldAbility(new EntersBattlefieldWithXCountersEffect(new Counter("isolation"))));§Ability ability = new EntersBattlefieldTriggeredAbility(new QuarantineFieldEffect(), false);§ability.addEffect(new CreateDelayedTriggeredAbilityEffect(new OnLeaveReturnExiledToBattlefieldAbility()));§this.addAbility(ability);§}§public QuarantineField(final QuarantineField card) {§super(card);§}§@Override§public void adjustTargets(Ability ability, Game game) {§if (ability instanceof EntersBattlefieldTriggeredAbility) {§Permanent sourceObject = game.getPermanent(ability.getSourceId());§if (sourceObject != null) {§int isolationCounters = sourceObject.getCounters(game).getCount("isolation");§FilterNonlandPermanent filter = new FilterNonlandPermanent("up to " + isolationCounters + " nonland permanents controlled by any opponents");§filter.add(new ControllerPredicate(TargetController.OPPONENT));§ability.addTarget(new TargetPermanent(0, isolationCounters, filter, false));§}§}§}§@Override§public QuarantineField copy() {§return new QuarantineField(this);§}§}§class QuarantineFieldEffect extends OneShotEffect {§public QuarantineFieldEffect() {§super(Outcome.Exile);§this.staticText = "for each isolation counter on it, exile up to one target nonland permanent an opponenet controls until {this} leaves the battlefield";§}§public QuarantineFieldEffect(final QuarantineFieldEffect effect) {§super(effect);§}§@Override§public QuarantineFieldEffect copy() {§return new QuarantineFieldEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getPermanent(source.getSourceId());§if (permanent != null) {§return new ExileTargetEffect(CardUtil.getCardExileZoneId(game, source), permanent.getIdName()).apply(game, source);§}§return false;§}§}§
public class RadiantFlames extends CardImpl {§public RadiantFlames(UUID ownerId) {§super(ownerId, 151, "Radiant Flames", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{2}{R}");§this.expansionSetCode = "BFZ";§getSpellAbility().setAbilityWord(AbilityWord.CONVERGE);§getSpellAbility().addEffect(new DamageAllEffect(ColorsOfManaSpentToCastCount.getInstance(), new FilterCreaturePermanent()));§}§public RadiantFlames(final RadiantFlames card) {§super(card);§}§@Override§public RadiantFlames copy() {§return new RadiantFlames(this);§}§}§
public class RecklessCohort extends CardImpl {§private final static FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("another Ally");§static {§filter.add(new AnotherPredicate());§filter.add(new SubtypePredicate("Ally"));§}§public RecklessCohort(UUID ownerId) {§super(ownerId, 152, "Reckless Cohort", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{R}");§this.expansionSetCode = "BFZ";§this.subtype.add("Human");§this.subtype.add("Warrior");§this.subtype.add("Ally");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Effect effect = new ConditionalRequirementEffect(§new AttacksIfAbleSourceEffect(Duration.WhileOnBattlefield, true),§new PermanentsOnTheBattlefieldCondition(filter, PermanentsOnTheBattlefieldCondition.CountType.FEWER_THAN, 1));§effect.setText("{this} attacks each combat if able unless you control another Ally");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, effect));§}§public RecklessCohort(final RecklessCohort card) {§super(card);§}§@Override§public RecklessCohort copy() {§return new RecklessCohort(this);§}§}§
public class ReclaimingVines extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("artifact, enchantment, or land");§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.ARTIFACT),§new CardTypePredicate(CardType.ENCHANTMENT),§new CardTypePredicate(CardType.LAND)));§}§public ReclaimingVines(UUID ownerId) {§super(ownerId, 185, "Reclaiming Vines", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{2}{G}{G}");§this.expansionSetCode = "BFZ";§this.getSpellAbility().addEffect(new DestroyTargetEffect());§this.getSpellAbility().addTarget(new TargetPermanent(filter));§}§public ReclaimingVines(final ReclaimingVines card) {§super(card);§}§@Override§public ReclaimingVines copy() {§return new ReclaimingVines(this);§}§}§
public class ResoluteBlademaster extends CardImpl {§public ResoluteBlademaster(UUID ownerId) {§super(ownerId, 218, "Resolute Blademaster", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{R}{W}");§this.expansionSetCode = "BFZ";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.subtype.add("Ally");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new AllyEntersBattlefieldTriggeredAbility(§new GainAbilityAllEffect(DoubleStrikeAbility.getInstance(), Duration.EndOfTurn,§new FilterControlledCreaturePermanent("creatures you control")), false);§this.addAbility(ability);§}§public ResoluteBlademaster(final ResoluteBlademaster card) {§super(card);§}§@Override§public ResoluteBlademaster copy() {§return new ResoluteBlademaster(this);§}§}§
public class RetreatToCoralhelm extends CardImpl {§public RetreatToCoralhelm(UUID ownerId) {§super(ownerId, 82, "Retreat to Coralhelm", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{U}");§this.expansionSetCode = "BFZ";§LandfallAbility ability = new LandfallAbility(new MayTapOrUntapTargetEffect(), false);§ability.addTarget(new TargetCreaturePermanent());§Mode mode = new Mode();§mode.getEffects().add(new ScryEffect(1));§ability.addMode(mode);§this.addAbility(ability);§}§public RetreatToCoralhelm(final RetreatToCoralhelm card) {§super(card);§}§@Override§public RetreatToCoralhelm copy() {§return new RetreatToCoralhelm(this);§}§}§
public class RetreatToEmeria extends CardImpl {§public RetreatToEmeria(UUID ownerId) {§super(ownerId, 44, "Retreat to Emeria", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{3}{W}");§this.expansionSetCode = "BFZ";§LandfallAbility ability = new LandfallAbility(new CreateTokenEffect(new KorAllyToken()), false);§Mode mode = new Mode();§mode.getEffects().add(new BoostControlledEffect(1, 1, Duration.EndOfTurn));§ability.addMode(mode);§this.addAbility(ability);§}§public RetreatToEmeria(final RetreatToEmeria card) {§super(card);§}§@Override§public RetreatToEmeria copy() {§return new RetreatToEmeria(this);§}§}§class KorAllyToken extends Token {§public KorAllyToken() {§super("Kor Ally", "1/1 white Kor Ally creature token");§cardType.add(CardType.CREATURE);§subtype.add("Kor");§subtype.add("Ally");§color.setWhite(true);§power = new MageInt(1);§toughness = new MageInt(1);§}§}§
public class RetreatToHagra extends CardImpl {§public RetreatToHagra(UUID ownerId) {§super(ownerId, 121, "Retreat to Hagra", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{B}");§this.expansionSetCode = "BFZ";§LandfallAbility ability = new LandfallAbility(new BoostTargetEffect(1, 0, Duration.EndOfTurn), false);§ability.addEffect(new GainAbilityTargetEffect(DeathtouchAbility.getInstance(), Duration.EndOfTurn));§ability.addTarget(new TargetCreaturePermanent());§Mode mode = new Mode();§mode.getEffects().add(new LoseLifeOpponentsEffect(1));§Effect effect = new GainLifeEffect(1);§effect.setText("and you gain 1 life");§mode.getEffects().add(effect);§ability.addMode(mode);§this.addAbility(ability);§}§public RetreatToHagra(final RetreatToHagra card) {§super(card);§}§@Override§public RetreatToHagra copy() {§return new RetreatToHagra(this);§}§}§
public class RoilmagesTrick extends CardImpl {§private final static FilterCreaturePermanent filter = new FilterCreaturePermanent("Creatures your opponents control");§static {§filter.add(new ControllerPredicate(TargetController.OPPONENT));§}§public RoilmagesTrick(UUID ownerId) {§super(ownerId, 83, "Roilmage's Trick", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{3}{U}");§this.expansionSetCode = "BFZ";§this.getSpellAbility().setAbilityWord(AbilityWord.CONVERGE);§this.getSpellAbility().addEffect(new BoostAllEffect(§new SignInversionDynamicValue(ColorsOfManaSpentToCastCount.getInstance()), new StaticValue(-0), Duration.EndOfTurn, filter, false,§"Creatures your opponents control get -X/-0 until end of turn, where X is the number of colors of mana spent to cast {this}.<br>", true));§this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(1));§}§public RoilmagesTrick(final RoilmagesTrick card) {§super(card);§}§@Override§public RoilmagesTrick copy() {§return new RoilmagesTrick(this);§}§}§
public class RoilSpout extends CardImpl {§public RoilSpout(UUID ownerId) {§super(ownerId, 219, "Roil Spout", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{1}{W}{U}");§this.expansionSetCode = "BFZ";§this.getSpellAbility().addEffect(new PutOnLibraryTargetEffect(true));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.addAbility(new AwakenAbility(this, 4, "{4}{W}{U}"));§}§public RoilSpout(final RoilSpout card) {§super(card);§}§@Override§public RoilSpout copy() {§return new RoilSpout(this);§}§}§
public class RoilsRetribution extends CardImpl {§public RoilsRetribution(UUID ownerId) {§super(ownerId, 45, "Roil's Retribution", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{3}{W}{W}");§this.expansionSetCode = "BFZ";§this.getSpellAbility().addEffect(new DamageMultiEffect(5));§this.getSpellAbility().addTarget(new TargetCreaturePermanentAmount(5, new FilterAttackingOrBlockingCreature("attacking or blocking creatures")));§}§public RoilsRetribution(final RoilsRetribution card) {§super(card);§}§@Override§public RoilsRetribution copy() {§return new RoilsRetribution(this);§}§}§
public class RotShambler extends CardImpl {§private final static FilterCreaturePermanent filter = new FilterCreaturePermanent("another creature you control");§static {§filter.add(new AnotherPredicate());§filter.add(new ControllerPredicate(TargetController.YOU));§}§public RotShambler(UUID ownerId) {§super(ownerId, 187, "Rot Shambler", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "BFZ";§this.subtype.add("Fungus");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new DiesCreatureTriggeredAbility(new AddCountersSourceEffect(CounterType.P1P1.createInstance()), false, filter));§}§public RotShambler(final RotShambler card) {§super(card);§}§@Override§public RotShambler copy() {§return new RotShambler(this);§}§}§
public class RuinationGuide extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Other colorless creatures you control");§static {§filter.add(new ColorlessPredicate());§}§public RuinationGuide(UUID ownerId) {§super(ownerId, 64, "Ruination Guide", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{U}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.subtype.add("Drone");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§this.addAbility(new DevoidAbility(this.color));§this.addAbility(new IngestAbility());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostControlledEffect(1, 0, Duration.WhileOnBattlefield, filter, true)));§}§public RuinationGuide(final RuinationGuide card) {§super(card);§}§@Override§public RuinationGuide copy() {§return new RuinationGuide(this);§}§}§
public class RuinousPath extends CardImpl {§public RuinousPath(UUID ownerId) {§super(ownerId, 123, "Ruinous Path", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{1}{B}{B}");§this.expansionSetCode = "BFZ";§this.getSpellAbility().addEffect(new DestroyTargetEffect());§this.getSpellAbility().addTarget(new TargetCreatureOrPlaneswalker());§this.addAbility(new AwakenAbility(this, 4, "{5}{B}{B}"));§}§public RuinousPath(final RuinousPath card) {§super(card);§}§@Override§public RuinousPath copy() {§return new RuinousPath(this);§}§}§
public class RuinProcessor extends CardImpl {§public RuinProcessor(UUID ownerId) {§super(ownerId, 12, "Ruin Processor", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{7}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.subtype.add("Processor");§this.power = new MageInt(7);§this.toughness = new MageInt(8);§this.addAbility(new CastSourceTriggeredAbility(§new DoIfCostPaid(new GainLifeEffect(5), new ExileOpponentsCardFromExileToGraveyardCost(true)), false));§}§public RuinProcessor(final RuinProcessor card) {§super(card);§}§@Override§public RuinProcessor copy() {§return new RuinProcessor(this);§}§}§
public class RushOfIce extends CardImpl {§public RushOfIce(UUID ownerId) {§super(ownerId, 84, "Rush of Ice", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{U}");§this.expansionSetCode = "BFZ";§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.getSpellAbility().addEffect(new TapTargetEffect());§this.getSpellAbility().addEffect(new DontUntapInControllersNextUntapStepTargetEffect("It"));§this.addAbility(new AwakenAbility(this, 3, "{4}{U}"));§}§public RushOfIce(final RushOfIce card) {§super(card);§}§@Override§public RushOfIce copy() {§return new RushOfIce(this);§}§}§
public class SalvageDrone extends CardImpl {§public SalvageDrone(UUID ownerId) {§super(ownerId, 65, "Salvage Drone", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{U}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.subtype.add("Drone");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new DevoidAbility(this.color));§this.addAbility(new IngestAbility());§this.addAbility(new DiesTriggeredAbility(new DrawDiscardControllerEffect(1, 1, true), false));§}§public SalvageDrone(final SalvageDrone card) {§super(card);§}§@Override§public SalvageDrone copy() {§return new SalvageDrone(this);§}§}§
public class SanctumOfUgin extends CardImpl {§private static final FilterCreatureCard filter = new FilterCreatureCard("colorless creature card");§private static final FilterSpell filterSpells = new FilterSpell("colorless spell with converted mana cost 7 or greater");§static {§filter.add(new ColorlessPredicate());§filterSpells.add(new ColorlessPredicate());§filterSpells.add(new ConvertedManaCostPredicate(ComparisonType.GreaterThan, 6));§}§public SanctumOfUgin(UUID ownerId) {§super(ownerId, 242, "Sanctum of Ugin", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "BFZ";§this.addAbility(new ColorlessManaAbility());§Effect effect = new SearchLibraryPutInHandEffect(new TargetCardInLibrary(filter), true);§effect.setText("search your library for a colorless creature card, reveal it, put it into your hand, then shuffle your library");§this.addAbility(new SpellCastControllerTriggeredAbility(new DoIfCostPaid(effect, new SacrificeSourceCost()), filterSpells, false));§}§public SanctumOfUgin(final SanctumOfUgin card) {§super(card);§}§@Override§public SanctumOfUgin copy() {§return new SanctumOfUgin(this);§}§}§
public class SandstoneBridge extends CardImpl {§public SandstoneBridge(UUID ownerId) {§super(ownerId, 243, "Sandstone Bridge", Rarity.COMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "BFZ";§this.addAbility(new EntersBattlefieldTappedAbility());§Effect effect = new GainAbilityTargetEffect(VigilanceAbility.getInstance(), Duration.EndOfTurn);§effect.setText("and gains vigilance");§Ability ability = new EntersBattlefieldTriggeredAbility(new BoostTargetEffect(1, 1, Duration.EndOfTurn), false);§ability.addEffect(effect);§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§this.addAbility(new WhiteManaAbility());§}§public SandstoneBridge(final SandstoneBridge card) {§super(card);§}§@Override§public SandstoneBridge copy() {§return new SandstoneBridge(this);§}§}§
public class ScatterToTheWinds extends CardImpl {§public ScatterToTheWinds(UUID ownerId) {§super(ownerId, 85, "Scatter to the Winds", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{1}{U}{U}");§this.expansionSetCode = "BFZ";§this.getSpellAbility().addEffect(new CounterTargetEffect());§this.getSpellAbility().addTarget(new TargetSpell());§this.addAbility(new AwakenAbility(this, 3, "{4}{U}{U}"));§}§public ScatterToTheWinds(final ScatterToTheWinds card) {§super(card);§}§@Override§public ScatterToTheWinds copy() {§return new ScatterToTheWinds(this);§}§}§
public class ScourFromExistence extends CardImpl {§public ScourFromExistence(UUID ownerId) {§super(ownerId, 13, "Scour from Existence", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{7}");§this.expansionSetCode = "BFZ";§this.getSpellAbility().addEffect(new ExileTargetEffect());§this.getSpellAbility().addTarget(new TargetPermanent());§}§public ScourFromExistence(final ScourFromExistence card) {§super(card);§}§@Override§public ScourFromExistence copy() {§return new ScourFromExistence(this);§}§}§
public class ScytheLeopard extends CardImpl {§public ScytheLeopard(UUID ownerId) {§super(ownerId, 188, "Scythe Leopard", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{G}");§this.expansionSetCode = "BFZ";§this.subtype.add("Cat");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new LandfallAbility(new BoostSourceEffect(1, 1, Duration.EndOfTurn), false));§}§public ScytheLeopard(final ScytheLeopard card) {§super(card);§}§@Override§public ScytheLeopard copy() {§return new ScytheLeopard(this);§}§}§
public class SeekTheWilds extends CardImpl {§private static final FilterCard filter = new FilterCard("a creature or land card");§static {§filter.add(Predicates.or(new CardTypePredicate(CardType.CREATURE), new CardTypePredicate(CardType.LAND)));§}§public SeekTheWilds(UUID ownerId) {§super(ownerId, 189, "Seek the Wilds", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{1}{G}");§this.expansionSetCode = "BFZ";§this.getSpellAbility().addEffect(new LookLibraryAndPickControllerEffect(new StaticValue(4), false, new StaticValue(1), filter, false));§}§public SeekTheWilds(final SeekTheWilds card) {§super(card);§}§@Override§public SeekTheWilds copy() {§return new SeekTheWilds(this);§}§}§
public class SereneSteward extends CardImpl {§public SereneSteward(UUID ownerId) {§super(ownerId, 46, "Serene Steward", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "BFZ";§this.subtype.add("Human");§this.subtype.add("Cleric");§this.subtype.add("Ally");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new GainLifeControllerTriggeredAbility(§new DoIfCostPaid(new AddCountersTargetEffect(CounterType.P1P1.createInstance()), new ManaCostsImpl("{W}")),§false);§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public SereneSteward(final SereneSteward card) {§super(card);§}§@Override§public SereneSteward copy() {§return new SereneSteward(this);§}§}§
public class SerpentineSpike extends CardImpl {§public SerpentineSpike(UUID ownerId) {§super(ownerId, 133, "Serpentine Spike", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{5}{R}{R}");§this.expansionSetCode = "BFZ";§Ability ability = new DevoidAbility(this.color);§ability.setRuleAtTheTop(true);§this.addAbility(ability);§this.getSpellAbility().addEffect(new SerpentineSpikeEffect());§TargetCreaturePermanent target = new TargetCreaturePermanent(new FilterCreaturePermanent("creature (2 damage)"));§target.setTargetTag(1);§this.getSpellAbility().addTarget(target);§FilterCreaturePermanent filter = new FilterCreaturePermanent("another target creature (3 damage)");§filter.add(new AnotherTargetPredicate(2));§target = new TargetCreaturePermanent(filter);§target.setTargetTag(2);§this.getSpellAbility().addTarget(target);§filter = new FilterCreaturePermanent("another target creature (4 damage)");§filter.add(new AnotherTargetPredicate(3));§target = new TargetCreaturePermanent(filter);§target.setTargetTag(3);§this.getSpellAbility().addTarget(target);§Effect effect = new DealtDamageToCreatureBySourceDies(this, Duration.EndOfTurn);§effect.setText("If a creature dealt damage this way would die this turn, exile it instead");§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addWatcher(new DamagedByWatcher());§}§public SerpentineSpike(final SerpentineSpike card) {§super(card);§}§@Override§public SerpentineSpike copy() {§return new SerpentineSpike(this);§}§}§class SerpentineSpikeEffect extends OneShotEffect {§public SerpentineSpikeEffect() {§super(Outcome.Damage);§this.staticText = "{this} deals 2 damage to target creature, 3 damage to another target creature, and 4 damage to a third target creature";§}§public SerpentineSpikeEffect(final SerpentineSpikeEffect effect) {§super(effect);§}§@Override§public SerpentineSpikeEffect copy() {§return new SerpentineSpikeEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getPermanent(source.getTargets().get(0).getFirstTarget());§if (permanent != null) {§permanent.damage(2, source.getSourceId(), game, false, true);§}§permanent = game.getPermanent(source.getTargets().get(1).getFirstTarget());§if (permanent != null) {§permanent.damage(3, source.getSourceId(), game, false, true);§}§permanent = game.getPermanent(source.getTargets().get(2).getFirstTarget());§if (permanent != null) {§permanent.damage(4, source.getSourceId(), game, false, true);§}§return true;§}§}§
public class ShadowGlider extends CardImpl {§public ShadowGlider(UUID ownerId) {§super(ownerId, 47, "Shadow Glider", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "BFZ";§this.subtype.add("Kor");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§}§public ShadowGlider(final ShadowGlider card) {§super(card);§}§@Override§public ShadowGlider copy() {§return new ShadowGlider(this);§}§}§
public class ShrineOfTheForsakenGods extends CardImpl {§private static final FilterSpell filter = new FilterSpell("colorless spells");§static {§filter.add(new ColorlessPredicate());§}§public ShrineOfTheForsakenGods(UUID ownerId) {§super(ownerId, 245, "Shrine of the Forsaken Gods", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "BFZ";§this.addAbility(new ColorlessManaAbility());§this.addAbility(new ActivateIfConditionManaAbility(§Zone.BATTLEFIELD,§new AddConditionalColorlessManaEffect(2, new ConditionalSpellManaBuilder(filter)),§new TapSourceCost(),§new PermanentsOnTheBattlefieldCondition(new FilterControlledLandPermanent("you control seven or more lands"), PermanentsOnTheBattlefieldCondition.CountType.MORE_THAN, 6)));§}§public ShrineOfTheForsakenGods(final ShrineOfTheForsakenGods card) {§super(card);§}§@Override§public ShrineOfTheForsakenGods copy() {§return new ShrineOfTheForsakenGods(this);§}§}§
public class SilentSkimmer extends CardImpl {§public SilentSkimmer(UUID ownerId) {§super(ownerId, 96, "Silent Skimmer", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{B}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.subtype.add("Drone");§this.power = new MageInt(0);§this.toughness = new MageInt(4);§Ability ability = new DevoidAbility(this.color);§ability.setRuleAtTheTop(true);§this.addAbility(ability);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new AttacksTriggeredAbility(new LoseLifeTargetEffect(2), false,§"Whenever {this} attacks, defending player loses 2 life", SetTargetPointer.PLAYER));§}§public SilentSkimmer(final SilentSkimmer card) {§super(card);§}§@Override§public SilentSkimmer copy() {§return new SilentSkimmer(this);§}§}§
public class SireOfStagnation extends CardImpl {§private static final FilterLandPermanent filter = new FilterLandPermanent();§private static final String rule = "Whenever a land enters the battlefield under an opponent's control, that player exiles the top two cards of his or her library and you draw two cards.";§static {§filter.add(new ControllerPredicate(TargetController.OPPONENT));§}§public SireOfStagnation(UUID ownerId) {§super(ownerId, 206, "Sire of Stagnation", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{4}{U}{B}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.power = new MageInt(5);§this.toughness = new MageInt(7);§this.addAbility(new DevoidAbility(this.color));§Ability ability = new EntersBattlefieldAllTriggeredAbility(Zone.BATTLEFIELD,§new ExileCardsFromTopOfLibraryTargetEffect(2, "that player"), filter, false, SetTargetPointer.PLAYER, rule, false);§ability.addEffect(new DrawCardSourceControllerEffect(2));§this.addAbility(ability);§}§public SireOfStagnation(final SireOfStagnation card) {§super(card);§}§@Override§public SireOfStagnation copy() {§return new SireOfStagnation(this);§}§}§
public class Skitterskin extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("you control another colorless creature");§static {§filter.add(new AnotherPredicate());§filter.add(new ColorlessPredicate());§}§public Skitterskin(UUID ownerId) {§super(ownerId, 97, "Skitterskin", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{B}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.subtype.add("Drone");§this.power = new MageInt(4);§this.toughness = new MageInt(3);§this.addAbility(new DevoidAbility(this.color));§this.addAbility(new CantBlockAbility());§Ability ability = new ActivateIfConditionActivatedAbility(Zone.BATTLEFIELD,§new RegenerateSourceEffect(),§new ManaCostsImpl("{1}{B}"),§new PermanentsOnTheBattlefieldCondition(filter));§this.addAbility(ability);§}§public Skitterskin(final Skitterskin card) {§super(card);§}§@Override§public Skitterskin copy() {§return new Skitterskin(this);§}§}§
public class SkylineCascade extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature an opponent controls");§static {§filter.add(new ControllerPredicate(TargetController.OPPONENT));§}§public SkylineCascade(UUID ownerId) {§super(ownerId, 246, "Skyline Cascade", Rarity.COMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "BFZ";§this.addAbility(new EntersBattlefieldTappedAbility());§Ability ability = new EntersBattlefieldTriggeredAbility(new DontUntapInControllersNextUntapStepTargetEffect(), false);§ability.addTarget(new TargetCreaturePermanent(filter));§this.addAbility(ability);§this.addAbility(new BlueManaAbility());§}§public SkylineCascade(final SkylineCascade card) {§super(card);§}§@Override§public SkylineCascade copy() {§return new SkylineCascade(this);§}§}§
public class SkyriderElf extends CardImpl {§public SkyriderElf(UUID ownerId) {§super(ownerId, 220, "Skyrider Elf", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{X}{G}{U}");§this.expansionSetCode = "BFZ";§this.subtype.add("Elf");§this.subtype.add("Warrior");§this.subtype.add("Ally");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new EntersBattlefieldAbility(§new AddCountersSourceEffect(CounterType.P1P1.createInstance(), ColorsOfManaSpentToCastCount.getInstance(), true),§null, "<i>Converge</i> &mdash; {this} enters the battlefield with a +1/+1 counter on it for each color of mana spent to cast it.", null));§}§public SkyriderElf(final SkyriderElf card) {§super(card);§}§@Override§public SkyriderElf copy() {§return new SkyriderElf(this);§}§}§
public class SlabHammer extends CardImpl {§public SlabHammer(UUID ownerId) {§super(ownerId, 227, "Slab Hammer", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{2}");§this.expansionSetCode = "BFZ";§this.subtype.add("Equipment");§Ability ability = new AttacksAttachedTriggeredAbility(§new DoIfCostPaid(new BoostEquippedEffect(2, 2, Duration.EndOfTurn),§new ReturnToHandChosenControlledPermanentCost(new TargetControlledPermanent(new FilterControlledLandPermanent())),§"Return a land you control to its owner's hand? (giving +2/+2 to the equipped creature)"));§this.addAbility(ability);§this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(2)));§}§public SlabHammer(final SlabHammer card) {§super(card);§}§@Override§public SlabHammer copy() {§return new SlabHammer(this);§}§}§
public class SludgeCrawler extends CardImpl {§public SludgeCrawler(UUID ownerId) {§super(ownerId, 98, "Sludge Crawler", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{B}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.subtype.add("Drone");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new DevoidAbility(this.color);§ability.setRuleAtTheTop(true);§this.addAbility(ability);§this.addAbility(new IngestAbility());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(1, 1, Duration.EndOfTurn), new GenericManaCost(2)));§}§public SludgeCrawler(final SludgeCrawler card) {§super(card);§}§@Override§public SludgeCrawler copy() {§return new SludgeCrawler(this);§}§}§
public class SmolderingMarsh extends CardImpl {§private static final FilterLandPermanent filter = new FilterLandPermanent();§static {§filter.add(new SupertypePredicate("Basic"));§}§public SmolderingMarsh(UUID ownerId) {§super(ownerId, 247, "Smoldering Marsh", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "BFZ";§this.subtype.add("Swamp");§this.subtype.add("Mountain");§Condition controls = new InvertCondition(new PermanentsOnTheBattlefieldCondition(filter, PermanentsOnTheBattlefieldCondition.CountType.MORE_THAN, 1));§String abilityText = "tapped unless you control two or more basic lands";§this.addAbility(new EntersBattlefieldAbility(new ConditionalOneShotEffect(new TapSourceEffect(), controls, abilityText), abilityText));§this.addAbility(new BlackManaAbility());§this.addAbility(new RedManaAbility());§}§public SmolderingMarsh(final SmolderingMarsh card) {§super(card);§}§@Override§public SmolderingMarsh copy() {§return new SmolderingMarsh(this);§}§}§
public class SmotheringAbomination extends CardImpl {§public SmotheringAbomination(UUID ownerId) {§super(ownerId, 99, "Smothering Abomination", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{B}{B}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.power = new MageInt(4);§this.toughness = new MageInt(3);§this.addAbility(new DevoidAbility(this.color));§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new BeginningOfUpkeepTriggeredAbility(new SacrificeControllerEffect(§new FilterCreaturePermanent(), 1, null), TargetController.YOU, false));§this.addAbility(new SmotheringAbominationTriggeredAbility());§}§public SmotheringAbomination(final SmotheringAbomination card) {§super(card);§}§@Override§public SmotheringAbomination copy() {§return new SmotheringAbomination(this);§}§}§class SmotheringAbominationTriggeredAbility extends TriggeredAbilityImpl {§public SmotheringAbominationTriggeredAbility() {§super(Zone.BATTLEFIELD, new DrawCardSourceControllerEffect(1));§setLeavesTheBattlefieldTrigger(true);§}§public SmotheringAbominationTriggeredAbility(final SmotheringAbominationTriggeredAbility ability) {§super(ability);§}§@Override§public SmotheringAbominationTriggeredAbility copy() {§return new SmotheringAbominationTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.SACRIFICED_PERMANENT;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§return event.getPlayerId().equals(this.getControllerId())§&& game.getLastKnownInformation(event.getTargetId(), Zone.BATTLEFIELD).getCardType().contains(CardType.CREATURE);§}§@Override§public String getRule() {§return "Whenever you sacrifice a creature, " + super.getRule();§}§}§
public class SnappingGnarlid extends CardImpl {§public SnappingGnarlid(UUID ownerId) {§super(ownerId, 190, "Snapping Gnarlid", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "BFZ";§this.subtype.add("Beast");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new LandfallAbility(new BoostSourceEffect(1, 1, Duration.EndOfTurn), false));§}§public SnappingGnarlid(final SnappingGnarlid card) {§super(card);§}§@Override§public SnappingGnarlid copy() {§return new SnappingGnarlid(this);§}§}§
public class SpawningBed extends CardImpl {§public SpawningBed(UUID ownerId) {§super(ownerId, 248, "Spawning Bed", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "BFZ";§this.addAbility(new ColorlessManaAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new CreateTokenEffect(new EldraziScionToken(), 3), new ManaCostsImpl("{6}"));§ability.addCost(new TapSourceCost());§ability.addCost(new SacrificeSourceCost());§this.addAbility(ability);§}§public SpawningBed(final SpawningBed card) {§super(card);§}§@Override§public SpawningBed copy() {§return new SpawningBed(this);§}§}§
public class SpellShrivel extends CardImpl {§public SpellShrivel(UUID ownerId) {§super(ownerId, 66, "Spell Shrivel", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{U}");§this.expansionSetCode = "BFZ";§Ability ability = new DevoidAbility(this.color);§ability.setRuleAtTheTop(true);§this.addAbility(ability);§this.getSpellAbility().addEffect(new SpellShrivelCounterUnlessPaysEffect());§this.getSpellAbility().addTarget(new TargetSpell());§}§public SpellShrivel(final SpellShrivel card) {§super(card);§}§@Override§public SpellShrivel copy() {§return new SpellShrivel(this);§}§}§class SpellShrivelCounterUnlessPaysEffect extends OneShotEffect {§public SpellShrivelCounterUnlessPaysEffect() {§super(Outcome.Detriment);§}§public SpellShrivelCounterUnlessPaysEffect(final SpellShrivelCounterUnlessPaysEffect effect) {§super(effect);§}§@Override§public SpellShrivelCounterUnlessPaysEffect copy() {§return new SpellShrivelCounterUnlessPaysEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§StackObject spell = game.getStack().getStackObject(targetPointer.getFirst(game, source));§MageObject sourceObject = source.getSourceObject(game);§if (spell != null && (spell instanceof Spell) && sourceObject != null) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§int amount = 4;§if (amount > 0) {§GenericManaCost cost = new GenericManaCost(amount);§if (!cost.pay(source, game, spell.getControllerId(), spell.getControllerId(), false)) {§StackObject stackObject = game.getStack().getStackObject(source.getFirstTarget());§if (stackObject != null && !game.replaceEvent(GameEvent.getEvent(GameEvent.EventType.COUNTER, source.getFirstTarget(), source.getSourceId(), stackObject.getControllerId()))) {§game.informPlayers(sourceObject.getIdName() + ": cost wasn't payed - countering " + stackObject.getName());§game.rememberLKI(source.getFirstTarget(), Zone.STACK, (Spell) stackObject);§controller.moveCards((Spell) spell, null, Zone.EXILED, source, game);§game.fireEvent(GameEvent.getEvent(GameEvent.EventType.COUNTERED, source.getFirstTarget(), source.getSourceId(), stackObject.getControllerId()));§return true;§}§return false;§}§}§}§}§return false;§}§@Override§public String getText(Mode mode) {§return "Counter target spell unless its controller pays {4}. If that spell is countered this way, exile it instead of putting it into its owner's graveyard";§}§}§
public class StasisSnare extends CardImpl {§private final static FilterCreaturePermanent filter = new FilterCreaturePermanent("creature an opponent controls");§static {§filter.add(new ControllerPredicate(TargetController.OPPONENT));§}§public StasisSnare(UUID ownerId) {§super(ownerId, 50, "Stasis Snare", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{W}{W}");§this.expansionSetCode = "BFZ";§this.addAbility(FlashAbility.getInstance());§Ability ability = new EntersBattlefieldTriggeredAbility(new StasisSnareExileEffect());§ability.addTarget(new TargetCreaturePermanent(filter));§ability.addEffect(new CreateDelayedTriggeredAbilityEffect(new OnLeaveReturnExiledToBattlefieldAbility()));§this.addAbility(ability);§}§public StasisSnare(final StasisSnare card) {§super(card);§}§@Override§public StasisSnare copy() {§return new StasisSnare(this);§}§}§class StasisSnareExileEffect extends OneShotEffect {§public StasisSnareExileEffect() {§super(Outcome.Benefit);§this.staticText = "exile target creature an opponent controls until {this} leaves the battlefield";§}§public StasisSnareExileEffect(final StasisSnareExileEffect effect) {§super(effect);§}§@Override§public StasisSnareExileEffect copy() {§return new StasisSnareExileEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getPermanent(source.getSourceId());§if (permanent != null) {§return new ExileTargetEffect(CardUtil.getCardExileZoneId(game, source), permanent.getIdName()).apply(game, source);§}§return false;§}§}§
public class Stonefury extends CardImpl {§public Stonefury(UUID ownerId) {§super(ownerId, 156, "Stonefury", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{3}{R}{R}");§this.expansionSetCode = "BFZ";§Effect effect = new DamageTargetEffect(new PermanentsOnBattlefieldCount(new FilterControlledLandPermanent("the number of lands you control")));§effect.setText("{this} deals damage to target creature equal to the number of lands you control");§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public Stonefury(final Stonefury card) {§super(card);§}§@Override§public Stonefury copy() {§return new Stonefury(this);§}§}§
public class StoneHavenMedic extends CardImpl {§public StoneHavenMedic(UUID ownerId) {§super(ownerId, 51, "Stone Haven Medic", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "BFZ";§this.subtype.add("Kor");§this.subtype.add("Cleric");§this.power = new MageInt(1);§this.toughness = new MageInt(3);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainLifeEffect(1), new ManaCostsImpl("{W}"));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§}§public StoneHavenMedic(final StoneHavenMedic card) {§super(card);§}§@Override§public StoneHavenMedic copy() {§return new StoneHavenMedic(this);§}§}§
public class SunkenHollow extends CardImpl {§private static final FilterLandPermanent filter = new FilterLandPermanent();§static {§filter.add(new SupertypePredicate("Basic"));§}§public SunkenHollow(UUID ownerId) {§super(ownerId, 249, "Sunken Hollow", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "BFZ";§this.subtype.add("Island");§this.subtype.add("Swamp");§Condition controls = new InvertCondition(new PermanentsOnTheBattlefieldCondition(filter, PermanentsOnTheBattlefieldCondition.CountType.MORE_THAN, 1));§String abilityText = "tapped unless you control two or more basic lands";§this.addAbility(new EntersBattlefieldAbility(new ConditionalOneShotEffect(new TapSourceEffect(), controls, abilityText), abilityText));§this.addAbility(new BlueManaAbility());§this.addAbility(new BlackManaAbility());§}§public SunkenHollow(final SunkenHollow card) {§super(card);§}§@Override§public SunkenHollow copy() {§return new SunkenHollow(this);§}§}§
public class SureStrike extends CardImpl {§public SureStrike(UUID ownerId) {§super(ownerId, 157, "Sure Strike", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{R}");§this.expansionSetCode = "BFZ";§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§Effect effect = new BoostTargetEffect(3, 0, Duration.EndOfTurn);§effect.setText("Target creature gets +3/+0");§this.getSpellAbility().addEffect(effect);§effect = new GainAbilityTargetEffect(FirstStrikeAbility.getInstance(), Duration.EndOfTurn);§effect.setText("and gains first strike until end of turn");§this.getSpellAbility().addEffect(effect);§}§public SureStrike(final SureStrike card) {§super(card);§}§@Override§public SureStrike copy() {§return new SureStrike(this);§}§}§
public class TajuruBeastmaster extends CardImpl {§public TajuruBeastmaster(UUID ownerId) {§super(ownerId, 193, "Tajuru Beastmaster", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{5}{G}");§this.expansionSetCode = "BFZ";§this.subtype.add("Elf");§this.subtype.add("Warrior");§this.subtype.add("Ally");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(new AllyEntersBattlefieldTriggeredAbility(new BoostControlledEffect(1, 1, Duration.EndOfTurn), false));§}§public TajuruBeastmaster(final TajuruBeastmaster card) {§super(card);§}§@Override§public TajuruBeastmaster copy() {§return new TajuruBeastmaster(this);§}§}§
public class TajuruStalwart extends CardImpl {§public TajuruStalwart(UUID ownerId) {§super(ownerId, 194, "Tajuru Stalwart", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{G}");§this.expansionSetCode = "BFZ";§this.subtype.add("Elf");§this.subtype.add("Scout");§this.subtype.add("Ally");§this.power = new MageInt(0);§this.toughness = new MageInt(1);§this.addAbility(new EntersBattlefieldAbility(§new AddCountersSourceEffect(CounterType.P1P1.createInstance(), ColorsOfManaSpentToCastCount.getInstance(), true),§null, "<i>Converge</i> - {this} enters the battlefield with a +1/+1 counter on it for each color of mana spent to cast it.", null));§}§public TajuruStalwart(final TajuruStalwart card) {§super(card);§}§@Override§public TajuruStalwart copy() {§return new TajuruStalwart(this);§}§}§
public class TajuruWarcaller extends CardImpl {§public TajuruWarcaller(UUID ownerId) {§super(ownerId, 195, "Tajuru Warcaller", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{G}{G}");§this.expansionSetCode = "BFZ";§this.subtype.add("Elf");§this.subtype.add("Warrior");§this.subtype.add("Ally");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new AllyEntersBattlefieldTriggeredAbility(new BoostControlledEffect(2, 2, Duration.EndOfTurn), false));§}§public TajuruWarcaller(final TajuruWarcaller card) {§super(card);§}§@Override§public TajuruWarcaller copy() {§return new TajuruWarcaller(this);§}§}§
public class TandemTactics extends CardImpl {§public TandemTactics(UUID ownerId) {§super(ownerId, 52, "Tandem Tactics", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{W}");§this.expansionSetCode = "BFZ";§Effect effect = new BoostTargetEffect(1, 2, Duration.EndOfTurn);§effect.setText("Up to two target creatures each get +1/+2 until end of turn");§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addTarget(new TargetCreaturePermanent(0, 2));§this.getSpellAbility().addEffect(new GainLifeEffect(2));§}§public TandemTactics(final TandemTactics card) {§super(card);§}§@Override§public TandemTactics copy() {§return new TandemTactics(this);§}§}§
public class TideDrifter extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("colorless creatures");§static {§filter.add(new ColorlessPredicate());§}§public TideDrifter(UUID ownerId) {§super(ownerId, 67, "Tide Drifter", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{U}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.subtype.add("Drone");§this.power = new MageInt(0);§this.toughness = new MageInt(5);§this.addAbility(new DevoidAbility(this.color));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostControlledEffect(0, 1, Duration.WhileOnBattlefield, filter, true)));§}§public TideDrifter(final TideDrifter card) {§super(card);§}§@Override§public TideDrifter copy() {§return new TideDrifter(this);§}§}§
public class TighteningCoils extends CardImpl {§public TighteningCoils(UUID ownerId) {§super(ownerId, 86, "Tightening Coils", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{U}");§this.expansionSetCode = "BFZ";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(-6, 0, Duration.WhileOnBattlefield));§Effect effect = new LoseAbilityAttachedEffect(FlyingAbility.getInstance(), AttachmentType.AURA);§effect.setText("and loses flying");§ability.addEffect(effect);§this.addAbility(ability);§}§public TighteningCoils(final TighteningCoils card) {§super(card);§}§@Override§public TighteningCoils copy() {§return new TighteningCoils(this);§}§}§
public class TitansPresence extends CardImpl {§private static final FilterCreatureCard filter = new FilterCreatureCard("a colorless creature card from your hand");§static {§filter.add(new ColorlessPredicate());§}§public TitansPresence(UUID ownerId) {§super(ownerId, 14, "Titan's Presence", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{3}");§this.expansionSetCode = "BFZ";§this.getSpellAbility().addCost(new RevealTargetFromHandCost(new TargetCardInHand(filter)));§this.getSpellAbility().addEffect(new TitansPresenceEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public TitansPresence(final TitansPresence card) {§super(card);§}§@Override§public TitansPresence copy() {§return new TitansPresence(this);§}§}§class TitansPresenceEffect extends OneShotEffect {§public TitansPresenceEffect() {§super(Outcome.Exile);§staticText = "Exile target creature if its power is less than or equal to the revealed card's power";§}§public TitansPresenceEffect(TitansPresenceEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§RevealTargetFromHandCost cost = (RevealTargetFromHandCost) source.getCosts().get(0);§Permanent creature = game.getPermanent(getTargetPointer().getFirst(game, source));§Player controller = game.getPlayer(source.getControllerId());§if (cost != null && creature != null && controller != null) {§List<Card> revealedCards = cost.getRevealedCards();§if (!revealedCards.isEmpty()) {§Card card = revealedCards.iterator().next();§if (card != null && card.getPower().getValue() >= creature.getPower().getValue()) {§controller.moveCards(creature, null, Zone.EXILED, source, game);§}§}§return true;§}§return false;§}§@Override§public TitansPresenceEffect copy() {§return new TitansPresenceEffect(this);§}§}§
public class TouchOfTheVoid extends CardImpl {§public TouchOfTheVoid(UUID ownerId) {§super(ownerId, 134, "Touch of the Void", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{2}{R}");§this.expansionSetCode = "BFZ";§Ability ability = new DevoidAbility(this.color);§ability.setRuleAtTheTop(true);§this.addAbility(ability);§this.getSpellAbility().addEffect(new DamageTargetEffect(3));§this.getSpellAbility().addTarget(new TargetCreatureOrPlayer());§Effect effect = new DealtDamageToCreatureBySourceDies(this, Duration.EndOfTurn);§effect.setText("If a creature dealt damage this way would die this turn, exile it instead");§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addWatcher(new DamagedByWatcher());§}§public TouchOfTheVoid(final TouchOfTheVoid card) {§super(card);§}§@Override§public TouchOfTheVoid copy() {§return new TouchOfTheVoid(this);§}§}§
public class TransgressTheMind extends CardImpl {§private static final FilterCard filter = new FilterCard("a card from it with converted mana cost 3 or greater");§static {§filter.add(new ConvertedManaCostPredicate(Filter.ComparisonType.GreaterThan, 2));§}§public TransgressTheMind(UUID ownerId) {§super(ownerId, 101, "Transgress the Mind", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{1}{B}");§this.expansionSetCode = "BFZ";§Ability ability = new DevoidAbility(this.color);§ability.setRuleAtTheTop(true);§this.addAbility(ability);§Effect effect = new ExileCardYouChooseTargetOpponentEffect(filter);§effect.setText("Target player reveals his or her hand. You may choose a card from it with converted mana cost 3 or greater and exile that card");§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addTarget(new TargetPlayer());§}§public TransgressTheMind(final TransgressTheMind card) {§super(card);§}§@Override§public TransgressTheMind copy() {§return new TransgressTheMind(this);§}§}§
public class TunnelingGeopede extends CardImpl {§public TunnelingGeopede(UUID ownerId) {§super(ownerId, 158, "Tunneling Geopede", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "BFZ";§this.subtype.add("Insect");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§this.addAbility(new LandfallAbility(new DamagePlayersEffect(1, TargetController.OPPONENT), false));§}§public TunnelingGeopede(final TunnelingGeopede card) {§super(card);§}§@Override§public TunnelingGeopede copy() {§return new TunnelingGeopede(this);§}§}§
public class TurnAgainst extends CardImpl {§public TurnAgainst(UUID ownerId) {§super(ownerId, 135, "Turn Against", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{4}{R}");§this.expansionSetCode = "BFZ";§Ability ability = new DevoidAbility(this.color);§ability.setRuleAtTheTop(true);§this.addAbility(ability);§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.getSpellAbility().addEffect(new GainControlTargetEffect(Duration.EndOfTurn));§this.getSpellAbility().addEffect(new UntapTargetEffect());§this.getSpellAbility().addEffect(new GainAbilityTargetEffect(HasteAbility.getInstance(), Duration.EndOfTurn));§}§public TurnAgainst(final TurnAgainst card) {§super(card);§}§@Override§public TurnAgainst copy() {§return new TurnAgainst(this);§}§}§
public class UginsInsight extends CardImpl {§public UginsInsight(UUID ownerId) {§super(ownerId, 87, "Ugin's Insight", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{3}{U}{U}");§this.expansionSetCode = "BFZ";§this.getSpellAbility().addEffect(new UginsInsightEffect());§}§public UginsInsight(final UginsInsight card) {§super(card);§}§@Override§public UginsInsight copy() {§return new UginsInsight(this);§}§}§class UginsInsightEffect extends OneShotEffect {§public UginsInsightEffect() {§super(Outcome.DrawCard);§this.staticText = "Scry X, where X is the highest converted mana cost among permanents you control, then draw three cards";§}§public UginsInsightEffect(final UginsInsightEffect effect) {§super(effect);§}§@Override§public UginsInsightEffect copy() {§return new UginsInsightEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§int highCMC = new HighestConvertedManaCostValue().calculate(game, source, this);§if (highCMC > 0) {§controller.scry(highCMC, source, game);§}§controller.drawCards(3, game);§return true;§}§return false;§}§}§
public class UlamogsDespoiler extends CardImpl {§public UlamogsDespoiler(UUID ownerId) {§super(ownerId, 16, "Ulamog's Despoiler", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{6}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.subtype.add("Processor");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(new EntersBattlefieldAbility(new UlamogsDespoilerEffect(), null,§"As {this} enters the battlefield, you may put two cards your opponents own from exile into their owners' graveyards. If you do, {this} enters the battlefield with four +1/+1 counters on it", null));§}§public UlamogsDespoiler(final UlamogsDespoiler card) {§super(card);§}§@Override§public UlamogsDespoiler copy() {§return new UlamogsDespoiler(this);§}§}§class UlamogsDespoilerEffect extends OneShotEffect {§private final static FilterCard filter = new FilterCard("cards your opponents own from exile");§static {§filter.add(new OwnerPredicate(TargetController.OPPONENT));§}§public UlamogsDespoilerEffect() {§super(Outcome.PutCreatureInPlay);§this.staticText = "you may put two cards your opponents own from exile into their owners' graveyards. If you do, {this} enters the battlefield with four +1/+1 counters on it";§}§public UlamogsDespoilerEffect(final UlamogsDespoilerEffect effect) {§super(effect);§}§@Override§public UlamogsDespoilerEffect copy() {§return new UlamogsDespoilerEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Target target = new TargetCardInExile(2, 2, filter, null);§if (target.canChoose(source.getSourceId(), source.getControllerId(), game)) {§if (controller.chooseTarget(outcome, target, source, game)) {§Cards cardsToGraveyard = new CardsImpl(target.getTargets());§controller.moveCards(cardsToGraveyard, null, Zone.GRAVEYARD, source, game);§return new AddCountersSourceEffect(CounterType.P1P1.createInstance(4)).apply(game, source);§}§}§return true;§}§return false;§}§}§
public class UlamogsNullifier extends CardImpl {§public UlamogsNullifier(UUID ownerId) {§super(ownerId, 207, "Ulamog's Nullifier", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{U}{B}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.subtype.add("Processor");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(new DevoidAbility(this.color));§this.addAbility(FlashAbility.getInstance());§this.addAbility(FlyingAbility.getInstance());§Ability ability = new EntersBattlefieldTriggeredAbility(new UlamogsNullifierEffect(), true);§ability.addTarget(new TargetSpell());§this.addAbility(ability);§}§public UlamogsNullifier(final UlamogsNullifier card) {§super(card);§}§@Override§public UlamogsNullifier copy() {§return new UlamogsNullifier(this);§}§}§class UlamogsNullifierEffect extends OneShotEffect {§private final static FilterCard filter = new FilterCard("cards your opponents own from exile");§static {§filter.add(new OwnerPredicate(TargetController.OPPONENT));§}§public UlamogsNullifierEffect() {§super(Outcome.Benefit);§this.staticText = "you may put two cards your opponents own from exile into their owners' graveyards. If you do, counter target spell.";§}§public UlamogsNullifierEffect(final UlamogsNullifierEffect effect) {§super(effect);§}§@Override§public UlamogsNullifierEffect copy() {§return new UlamogsNullifierEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§Spell spell = game.getStack().getSpell(source.getFirstTarget());§if (controller != null && spell != null) {§Target target = new TargetCardInExile(2, 2, filter, null);§if (target.canChoose(source.getSourceId(), source.getControllerId(), game)) {§if (controller.chooseTarget(outcome, target, source, game)) {§Cards cardsToGraveyard = new CardsImpl(target.getTargets());§controller.moveCards(cardsToGraveyard, null, Zone.GRAVEYARD, source, game);§game.getStack().counter(source.getFirstTarget(), source.getSourceId(), game);§return true;§}§}§}§return false;§}§}§
public class UlamogsReclaimer extends CardImpl {§public UlamogsReclaimer(UUID ownerId) {§super(ownerId, 68, "Ulamog's Reclaimer", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{U}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.subtype.add("Processor");§this.power = new MageInt(2);§this.toughness = new MageInt(5);§this.addAbility(new DevoidAbility(this.color));§Ability ability = new EntersBattlefieldTriggeredAbility(§new DoIfCostPaid(new ReturnFromGraveyardToHandTargetEffect(), new ExileOpponentsCardFromExileToGraveyardCost(true)), false);§ability.addTarget(new TargetCardInYourGraveyard(new FilterInstantOrSorceryCard("instant or sorcery card from your graveyard")));§this.addAbility(ability);§}§public UlamogsReclaimer(final UlamogsReclaimer card) {§super(card);§}§@Override§public UlamogsReclaimer copy() {§return new UlamogsReclaimer(this);§}§}§
public class UlamogTheCeaselessHunger extends CardImpl {§public UlamogTheCeaselessHunger(UUID ownerId) {§super(ownerId, 15, "Ulamog, the Ceaseless Hunger", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{10}");§this.expansionSetCode = "BFZ";§this.supertype.add("Legendary");§this.subtype.add("Eldrazi");§this.power = new MageInt(10);§this.toughness = new MageInt(10);§this.addAbility(new UlamogExilePermanentsOnCastAbility());§this.addAbility(IndestructibleAbility.getInstance());§Effect effect = new UlamogExileLibraryEffect();§effect.setText("defending player exiles the top twenty cards of his or her library");§this.addAbility(new UlamogAttackTriggeredAbility(effect));§}§public UlamogTheCeaselessHunger(final UlamogTheCeaselessHunger card) {§super(card);§}§@Override§public UlamogTheCeaselessHunger copy() {§return new UlamogTheCeaselessHunger(this);§}§}§class UlamogExilePermanentsOnCastAbility extends TriggeredAbilityImpl {§UlamogExilePermanentsOnCastAbility() {§super(Zone.STACK, new ExileTargetEffect("exile two target permanents"));§this.addTarget(new TargetPermanent(2, new FilterPermanent()));§}§UlamogExilePermanentsOnCastAbility(UlamogExilePermanentsOnCastAbility ability) {§super(ability);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.SPELL_CAST;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§Spell spell = (Spell) game.getObject(event.getTargetId());§return this.getSourceId().equals(spell.getSourceId());§}§@Override§public UlamogExilePermanentsOnCastAbility copy() {§return new UlamogExilePermanentsOnCastAbility(this);§}§@Override§public String getRule() {§return "When you cast {this}, " + super.getRule();§}§}§class UlamogAttackTriggeredAbility extends TriggeredAbilityImpl {§public UlamogAttackTriggeredAbility(Effect effect) {§super(Zone.BATTLEFIELD, effect);§}§public UlamogAttackTriggeredAbility(final UlamogAttackTriggeredAbility ability) {§super(ability);§}§@Override§public UlamogAttackTriggeredAbility copy() {§return new UlamogAttackTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.ATTACKER_DECLARED;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§Permanent sourcePermanent = game.getPermanent(this.getSourceId());§if (sourcePermanent != null§&& event.getSourceId() != null§&& event.getSourceId().equals(this.getSourceId())) {§UUID defender = game.getCombat().getDefendingPlayerId(this.getSourceId(), game);§this.getEffects().get(0).setTargetPointer(new FixedTarget(defender));§return true;§}§return false;§}§@Override§public String getRule() {§return new StringBuilder("Whenever {this} attacks, ").append(super.getRule()).toString();§}§}§class UlamogExileLibraryEffect extends OneShotEffect {§public UlamogExileLibraryEffect() {§super(Outcome.Exile);§this.staticText = "defending player exiles the top twenty cards of his or her library";§}§public UlamogExileLibraryEffect(final UlamogExileLibraryEffect effect) {§super(effect);§}§@Override§public UlamogExileLibraryEffect copy() {§return new UlamogExileLibraryEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player defender = game.getPlayer(targetPointer.getFirst(game, source));§if (defender != null) {§int count = Math.min(defender.getLibrary().size(), 20);§for (int i = 0; i < count; i++) {§Card card = defender.getLibrary().removeFromTop(game);§if (card != null) {§card.moveToExile(null, null, source.getSourceId(), game);§}§}§return true;§}§return false;§}§}§
public class UndergrowthChampion extends CardImpl {§public UndergrowthChampion(UUID ownerId) {§super(ownerId, 197, "Undergrowth Champion", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{1}{G}{G}");§this.expansionSetCode = "BFZ";§this.subtype.add("Elemental");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new UndergrowthChampionPreventionEffect()));§this.addAbility(new LandfallAbility(new AddCountersSourceEffect(CounterType.P1P1.createInstance()), false));§}§public UndergrowthChampion(final UndergrowthChampion card) {§super(card);§}§@Override§public UndergrowthChampion copy() {§return new UndergrowthChampion(this);§}§}§class UndergrowthChampionPreventionEffect extends PreventionEffectImpl {§private int turn = 0;§private Step combatPhaseStep = null;§public UndergrowthChampionPreventionEffect() {§super(Duration.WhileOnBattlefield);§staticText = "If damage would be dealt to {this} while it has a +1/+1 counter on it, prevent that damage and remove a +1/+1 counter from {this}";§}§public UndergrowthChampionPreventionEffect(final UndergrowthChampionPreventionEffect effect) {§super(effect);§this.turn = effect.turn;§this.combatPhaseStep = effect.combatPhaseStep;§}§@Override§public UndergrowthChampionPreventionEffect copy() {§return new UndergrowthChampionPreventionEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§Permanent permanent = game.getPermanent(source.getSourceId());§if (permanent != null) {§boolean removeCounter = true;§if (game.getTurn().getPhase().getStep().getType().equals(PhaseStep.COMBAT_DAMAGE)) {§if (game.getTurnNum() == turn§&& game.getTurn().getStep().equals(combatPhaseStep)) {§removeCounter = false;§} else {§turn = game.getTurnNum();§combatPhaseStep = game.getTurn().getStep();§}§}§if(removeCounter && permanent.getCounters().containsKey(CounterType.P1P1)) {§preventDamageAction(event, source, game);§StringBuilder sb = new StringBuilder(permanent.getName()).append(": ");§permanent.removeCounters(CounterType.P1P1.createInstance(), game);§sb.append("Removed a +1/+1 counter ");§game.informPlayers(sb.toString());§}§}§return false;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§if (super.applies(event, source, game)) {§if (event.getTargetId().equals(source.getSourceId())) {§return true;§}§}§return false;§}§}§
public class UnifiedFront extends CardImpl {§public UnifiedFront(UUID ownerId) {§super(ownerId, 53, "Unified Front", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{3}{W}");§this.expansionSetCode = "BFZ";§getSpellAbility().setAbilityWord(AbilityWord.CONVERGE);§Effect effect = new CreateTokenEffect(new KorAllyToken(), ColorsOfManaSpentToCastCount.getInstance());§effect.setText("Put a 1/1 white Kor Ally creature token onto the battlefield for each color of mana spent to cast {this}");§getSpellAbility().addEffect(effect);§}§public UnifiedFront(final UnifiedFront card) {§super(card);§}§@Override§public UnifiedFront copy() {§return new UnifiedFront(this);§}§}§
public class ValakutPredator extends CardImpl {§public ValakutPredator(UUID ownerId) {§super(ownerId, 160, "Valakut Predator", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "BFZ";§this.subtype.add("Elemental");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new LandfallAbility(new BoostSourceEffect(2, 2, Duration.EndOfTurn), false));§}§public ValakutPredator(final ValakutPredator card) {§super(card);§}§@Override§public ValakutPredator copy() {§return new ValakutPredator(this);§}§}§
public class VampiricRites extends CardImpl {§public VampiricRites(UUID ownerId) {§super(ownerId, 124, "Vampiric Rites", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{B}");§this.expansionSetCode = "BFZ";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainLifeEffect(1), new ManaCostsImpl<>("{1}{B}"));§ability.addCost(new SacrificeTargetCost(new TargetControlledCreaturePermanent(new FilterControlledCreaturePermanent("a creature"))));§Effect effect = new DrawCardSourceControllerEffect(1);§effect.setText("and draw a card");§ability.addEffect(effect);§this.addAbility(ability);§}§public VampiricRites(final VampiricRites card) {§super(card);§}§@Override§public VampiricRites copy() {§return new VampiricRites(this);§}§}§
public class VestigeOfEmrakul extends CardImpl {§public VestigeOfEmrakul(UUID ownerId) {§super(ownerId, 136, "Vestige of Emrakul", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{R}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.subtype.add("Drone");§this.power = new MageInt(3);§this.toughness = new MageInt(4);§this.addAbility(new DevoidAbility(this.color));§this.addAbility(TrampleAbility.getInstance());§}§public VestigeOfEmrakul(final VestigeOfEmrakul card) {§super(card);§}§@Override§public VestigeOfEmrakul copy() {§return new VestigeOfEmrakul(this);§}§}§
public class VileAggregate extends CardImpl {§private final static FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("colorless creatures you control");§static {§filter.add(new ColorlessPredicate());§}§public VileAggregate(UUID ownerId) {§super(ownerId, 137, "Vile Aggregate", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.subtype.add("Drone");§this.power = new MageInt(0);§this.toughness = new MageInt(5);§this.addAbility(new DevoidAbility(this.color));§Effect effect = new SetPowerSourceEffect(new PermanentsOnBattlefieldCount(filter), Duration.EndOfGame);§this.addAbility(new SimpleStaticAbility(Zone.ALL, effect));§this.addAbility(TrampleAbility.getInstance());§this.addAbility(new IngestAbility());§}§public VileAggregate(final VileAggregate card) {§super(card);§}§@Override§public VileAggregate copy() {§return new VileAggregate(this);§}§}§
public class VoidAttendant extends CardImpl {§public VoidAttendant(UUID ownerId) {§super(ownerId, 169, "Void Attendant", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{G}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.subtype.add("Processor");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(new DevoidAbility(this.color));§Effect effect = new CreateTokenEffect(new EldraziScionToken());§effect.setText("put a 1/1 colorless Eldrazi Scion creature token onto the battlefield. It has \"Sacrifice this creature: Add {C} to your mana pool.\"");§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new ManaCostsImpl("{1}{G}"));§ability.addCost(new ExileOpponentsCardFromExileToGraveyardCost(true));§this.addAbility(ability);§}§public VoidAttendant(final VoidAttendant card) {§super(card);§}§@Override§public VoidAttendant copy() {§return new VoidAttendant(this);§}§}§
public class VoidWinnower extends CardImpl {§public VoidWinnower(UUID ownerId) {§super(ownerId, 17, "Void Winnower", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{9}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.power = new MageInt(11);§this.toughness = new MageInt(9);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new VoidWinnowerCantCastEffect()));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new VoidWinnowerCantBlockEffect()));§}§public VoidWinnower(final VoidWinnower card) {§super(card);§}§@Override§public VoidWinnower copy() {§return new VoidWinnower(this);§}§}§class VoidWinnowerCantCastEffect extends ContinuousRuleModifyingEffectImpl {§public VoidWinnowerCantCastEffect() {§super(Duration.WhileOnBattlefield, Outcome.Benefit);§staticText = "Your opponent can't cast spells with even converted mana costs. <i>(Zero is even.)</i>";§}§public VoidWinnowerCantCastEffect(final VoidWinnowerCantCastEffect effect) {§super(effect);§}§@Override§public VoidWinnowerCantCastEffect copy() {§return new VoidWinnowerCantCastEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public String getInfoMessage(Ability source, GameEvent event, Game game) {§MageObject mageObject = game.getObject(source.getSourceId());§if (mageObject != null) {§return "You can't cast spells with even converted mana costs (" + mageObject.getIdName() + ").";§}§return null;§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == EventType.CAST_SPELL_LATE;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§if (game.getOpponents(source.getControllerId()).contains(event.getPlayerId())) {§Spell spell = game.getStack().getSpell(event.getTargetId());§if (spell != null) {§return (spell.getConvertedManaCost() & 1) == 0;§}§}§return false;§}§}§class VoidWinnowerCantBlockEffect extends RestrictionEffect {§public VoidWinnowerCantBlockEffect() {§super(Duration.WhileOnBattlefield);§staticText = "Your opponents can't block with creatures with even converted mana costs";§}§public VoidWinnowerCantBlockEffect(final VoidWinnowerCantBlockEffect effect) {§super(effect);§}§@Override§public VoidWinnowerCantBlockEffect copy() {§return new VoidWinnowerCantBlockEffect(this);§}§@Override§public boolean applies(Permanent permanent, Ability source, Game game) {§if (game.getOpponents(source.getControllerId()).contains(permanent.getControllerId())) {§return (permanent.getManaCost().convertedManaCost() & 1) == 0;§}§return false;§}§@Override§public boolean canBlock(Permanent attacker, Permanent blocker, Ability source, Game game) {§return false;§}§}§
public class VolcanicUpheaval extends CardImpl {§public VolcanicUpheaval(UUID ownerId) {§super(ownerId, 161, "Volcanic Upheaval", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{3}{R}");§this.expansionSetCode = "BFZ";§this.getSpellAbility().addEffect(new DestroyTargetEffect());§this.getSpellAbility().addTarget(new TargetLandPermanent());§}§public VolcanicUpheaval(final VolcanicUpheaval card) {§super(card);§}§@Override§public VolcanicUpheaval copy() {§return new VolcanicUpheaval(this);§}§}§
public class VoraciousNull extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("another creature");§static {§filter.add(new AnotherPredicate());§}§public VoraciousNull(UUID ownerId) {§super(ownerId, 125, "Voracious Null", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{B}");§this.expansionSetCode = "BFZ";§this.subtype.add("Zombie");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new ActivateAsSorceryActivatedAbility(Zone.BATTLEFIELD, new AddCountersSourceEffect(CounterType.P1P1.createInstance(2)), new ManaCostsImpl("{1}{B}"));§ability.addCost(new SacrificeTargetCost(new TargetControlledCreaturePermanent(1, 1, filter, false)));§this.addAbility(ability);§}§public VoraciousNull(final VoraciousNull card) {§super(card);§}§@Override§public VoraciousNull copy() {§return new VoraciousNull(this);§}§}§
public class WastelandStrangler extends CardImpl {§public WastelandStrangler(UUID ownerId) {§super(ownerId, 102, "Wasteland Strangler", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{B}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.subtype.add("Processor");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§this.addAbility(new DevoidAbility(this.color));§Ability ability = new EntersBattlefieldTriggeredAbility(§new DoIfCostPaid(new BoostTargetEffect(-3, -3, Duration.EndOfTurn), new ExileOpponentsCardFromExileToGraveyardCost(true)), false);§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public WastelandStrangler(final WastelandStrangler card) {§super(card);§}§@Override§public WastelandStrangler copy() {§return new WastelandStrangler(this);§}§}§
public class WaveWingElemental extends CardImpl {§public WaveWingElemental(UUID ownerId) {§super(ownerId, 88, "Wave-Wing Elemental", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{5}{U}");§this.expansionSetCode = "BFZ";§this.subtype.add("Elemental");§this.power = new MageInt(3);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new LandfallAbility(new BoostSourceEffect(2, 2, Duration.EndOfTurn), false));§}§public WaveWingElemental(final WaveWingElemental card) {§super(card);§}§@Override§public WaveWingElemental copy() {§return new WaveWingElemental(this);§}§}§
public class WindriderPatrol extends CardImpl {§public WindriderPatrol(UUID ownerId) {§super(ownerId, 89, "Windrider Patrol", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{U}{U}");§this.expansionSetCode = "BFZ";§this.subtype.add("Merfolk");§this.subtype.add("Wizard");§this.power = new MageInt(4);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new DealsCombatDamageToAPlayerTriggeredAbility(new ScryEffect(2), false));§}§public WindriderPatrol(final WindriderPatrol card) {§super(card);§}§@Override§public WindriderPatrol copy() {§return new WindriderPatrol(this);§}§}§
public class WoodlandWanderer extends CardImpl {§public WoodlandWanderer(UUID ownerId) {§super(ownerId, 198, "Woodland Wanderer", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{G}");§this.expansionSetCode = "BFZ";§this.subtype.add("Elemental");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(VigilanceAbility.getInstance());§this.addAbility(TrampleAbility.getInstance());§this.addAbility(new EntersBattlefieldAbility(§new AddCountersSourceEffect(CounterType.P1P1.createInstance(), ColorsOfManaSpentToCastCount.getInstance(), true),§null, "<i>Converge</i> &mdash; {this} enters the battlefield with a +1/+1 counter on it for each color of mana spent to cast it.", null));§}§public WoodlandWanderer(final WoodlandWanderer card) {§super(card);§}§@Override§public WoodlandWanderer copy() {§return new WoodlandWanderer(this);§}§}§
public class ZadaHedronGrinder extends CardImpl {§public ZadaHedronGrinder(UUID ownerId) {§super(ownerId, 162, "Zada, Hedron Grinder", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{R}");§this.expansionSetCode = "BFZ";§this.supertype.add("Legendary");§this.subtype.add("Goblin");§this.subtype.add("Ally");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new ZadaHedronGrinderTriggeredAbility());§}§public ZadaHedronGrinder(final ZadaHedronGrinder card) {§super(card);§}§@Override§public ZadaHedronGrinder copy() {§return new ZadaHedronGrinder(this);§}§}§class ZadaHedronGrinderTriggeredAbility extends TriggeredAbilityImpl {§ZadaHedronGrinderTriggeredAbility() {§super(Zone.BATTLEFIELD, new ZadaHedronGrinderEffect(), false);§}§ZadaHedronGrinderTriggeredAbility(final ZadaHedronGrinderTriggeredAbility ability) {§super(ability);§}§@Override§public ZadaHedronGrinderTriggeredAbility copy() {§return new ZadaHedronGrinderTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.SPELL_CAST;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (event.getPlayerId().equals(this.getControllerId())) {§Spell spell = game.getStack().getSpell(event.getTargetId());§if (isControlledInstantOrSorcery(spell)) {§boolean targetsSource = false;§for (Mode mode : spell.getSpellAbility().getModes().getSelectedModes()) {§for (Target target : mode.getTargets()) {§for (UUID targetId : target.getTargets()) {§if (targetId.equals(getSourceId())) {§targetsSource = true;§} else {§return false;§}§}§}§}§if (targetsSource) {§this.getEffects().get(0).setTargetPointer(new FixedTarget(spell.getId()));§return true;§}§}§}§return false;§}§private boolean isControlledInstantOrSorcery(Spell spell) {§return spell != null§&& (spell.getControllerId().equals(this.getControllerId()))§&& (spell.getCardType().contains(CardType.INSTANT) || spell.getCardType().contains(CardType.SORCERY));§}§@Override§public String getRule() {§return "Whenever you cast an instant or sorcery spell that targets only {this}, copy that spell for each other creature you control that the spell could target. Each copy targets a different one of those creatures.";§}§}§class ZadaHedronGrinderEffect extends OneShotEffect {§public ZadaHedronGrinderEffect() {§super(Outcome.Detriment);§this.staticText = "copy that spell for each other creature you control that the spell could target. Each copy targets a different one of those creatures";§}§public ZadaHedronGrinderEffect(final ZadaHedronGrinderEffect effect) {§super(effect);§}§@Override§public ZadaHedronGrinderEffect copy() {§return new ZadaHedronGrinderEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Spell spell = game.getStack().getSpell(targetPointer.getFirst(game, source));§if (spell == null) {§spell = (Spell) game.getLastKnownInformation(targetPointer.getFirst(game, source), Zone.STACK);§}§Player controller = game.getPlayer(source.getControllerId());§if (spell != null && controller != null) {§Target usedTarget = null;§setUsedTarget:§for (Mode mode : spell.getSpellAbility().getModes().getSelectedModes()) {§for (Target target : mode.getTargets()) {§if (target.getFirstTarget().equals(source.getSourceId())) {§usedTarget = target.copy();§usedTarget.clearChosen();§break setUsedTarget;§}§}§}§if (usedTarget == null) {§return false;§}§for (Permanent creature : game.getState().getBattlefield().getAllActivePermanents(new FilterCreaturePermanent(), source.getControllerId(), game)) {§if (!creature.getId().equals(source.getSourceId()) && usedTarget.canTarget(source.getControllerId(), creature.getId(), source, game)) {§Spell copy = spell.copySpell();§setTarget:§for (Mode mode : spell.getSpellAbility().getModes().getSelectedModes()) {§for (Target target : mode.getTargets()) {§if (target.getClass().equals(usedTarget.getClass())) {§target.clearChosen(); §
public class ZulaportCutthroat extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature you control");§static {§filter.add(new ControllerPredicate(TargetController.YOU));§}§public ZulaportCutthroat(UUID ownerId) {§super(ownerId, 126, "Zulaport Cutthroat", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{B}");§this.expansionSetCode = "BFZ";§this.subtype.add("Human");§this.subtype.add("Rogue");§this.subtype.add("Ally");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new DiesThisOrAnotherCreatureTriggeredAbility(new LoseLifeOpponentsEffect(1), false, filter);§Effect effect = new GainLifeEffect(1);§effect.setText("and you gain 1 life");§ability.addEffect(effect);§this.addAbility(ability);§}§public ZulaportCutthroat(final ZulaportCutthroat card) {§super(card);§}§@Override§public ZulaportCutthroat copy() {§return new ZulaportCutthroat(this);§}§}§
public class AkkiBlizzardHerder extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledLandPermanent();§public AkkiBlizzardHerder(UUID ownerId) {§super(ownerId, 91, "Akki Blizzard-Herder", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{R}");§this.expansionSetCode = "BOK";§this.subtype.add("Goblin");§this.subtype.add("Shaman");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new DiesTriggeredAbility(new SacrificeAllEffect(filter)));§}§public AkkiBlizzardHerder(final AkkiBlizzardHerder card) {§super(card);§}§@Override§public AkkiBlizzardHerder copy() {§return new AkkiBlizzardHerder(this);§}§}§
public class AkkiRaider extends CardImpl {§public AkkiRaider(UUID ownerId) {§super(ownerId, 92, "Akki Raider", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{R}");§this.expansionSetCode = "BOK";§this.subtype.add("Goblin");§this.subtype.add("Warrior");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new ZoneChangeAllTriggeredAbility(Zone.BATTLEFIELD, Zone.BATTLEFIELD, Zone.GRAVEYARD,§new BoostSourceEffect(1,0,Duration.EndOfTurn), new FilterLandPermanent(),§"Whenever a land is put into a graveyard from the battlefield, ", false));§}§public AkkiRaider(final AkkiRaider card) {§super(card);§}§@Override§public AkkiRaider copy() {§return new AkkiRaider(this);§}§}§
public class AshenMonstrosity extends CardImpl {§public AshenMonstrosity(UUID ownerId) {§super(ownerId, 93, "Ashen Monstrosity", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{5}{R}{R}");§this.expansionSetCode = "BOK";§this.subtype.add("Spirit");§this.power = new MageInt(7);§this.toughness = new MageInt(4);§this.addAbility(HasteAbility.getInstance());§this.addAbility(new AttacksEachTurnStaticAbility());§}§public AshenMonstrosity(final AshenMonstrosity card) {§super(card);§}§@Override§public AshenMonstrosity copy() {§return new AshenMonstrosity(this);§}§}§
public class AuraBarbs extends CardImpl {§public AuraBarbs(UUID ownerId) {§super(ownerId, 94, "Aura Barbs", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{2}{R}");§this.expansionSetCode = "BOK";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new AuraBarbsEffect());§}§public AuraBarbs(final AuraBarbs card) {§super(card);§}§@Override§public AuraBarbs copy() {§return new AuraBarbs(this);§}§private class AuraBarbsEffect extends OneShotEffect {§public AuraBarbsEffect() {§super(Outcome.Detriment);§staticText = "Each enchantment deals 2 damage to its controller, then each Aura attached to a creature deals 2 damage to the creature it's attached to";§}§public AuraBarbsEffect(final AuraBarbsEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§FilterPermanent filterEnchantments = new FilterPermanent();§filterEnchantments.add(new CardTypePredicate(CardType.ENCHANTMENT));§for (Permanent permanent : game.getBattlefield().getActivePermanents(filterEnchantments, source.getControllerId(), source.getSourceId(), game)) {§Player controller = game.getPlayer(permanent.getControllerId());§if (controller != null) {§controller.damage(2, permanent.getId(), game, false, true);§game.informPlayers("2 damage assigned to " + controller.getLogName() + " from " + permanent.getName());§}§}§filterEnchantments.add(new SubtypePredicate("Aura"));§for (Permanent auraEnchantment : game.getBattlefield().getActivePermanents(filterEnchantments, source.getControllerId(), source.getSourceId(), game)) {§if (auraEnchantment.getAttachedTo() != null) {§Permanent attachedToCreature = game.getPermanent(auraEnchantment.getAttachedTo());§if (attachedToCreature != null && attachedToCreature.getCardType().contains(CardType.CREATURE)) {§attachedToCreature.damage(2, auraEnchantment.getId(), game, false, true);§game.informPlayers("2 damage assigned to " + attachedToCreature.getName() + " from " + auraEnchantment.getName());§}§}§}§return true;§}§@Override§public AuraBarbsEffect copy() {§return new AuraBarbsEffect(this);§}§}§}§
public class BlademaneBaku extends CardImpl {§private static final FilterSpiritOrArcaneCard filter = new FilterSpiritOrArcaneCard();§public BlademaneBaku(UUID ownerId) {§super(ownerId, 95, "Blademane Baku", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{R}");§this.expansionSetCode = "BOK";§this.subtype.add("Spirit");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new SpellCastControllerTriggeredAbility(new AddCountersSourceEffect(CounterType.KI.createInstance()), filter, true));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BlademaneBakuBoostEffect(), new GenericManaCost(1));§ability.addCost(new RemoveVariableCountersSourceCost(CounterType.KI.createInstance(1)));§this.addAbility(ability);§}§public BlademaneBaku(final BlademaneBaku card) {§super(card);§}§@Override§public BlademaneBaku copy() {§return new BlademaneBaku(this);§}§class BlademaneBakuBoostEffect extends OneShotEffect {§public BlademaneBakuBoostEffect() {§super(Outcome.UnboostCreature);§staticText = "For each counter removed, {this} gets +2/+0 until end of turn";§}§public BlademaneBakuBoostEffect(BlademaneBakuBoostEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§int numberToBoost = 0;§for (Cost cost : source.getCosts()) {§if (cost instanceof RemoveVariableCountersSourceCost) {§numberToBoost = ((RemoveVariableCountersSourceCost)cost).getAmount() * 2;§}§}§if (numberToBoost >= 0) {§game.addEffect(new BoostSourceEffect(numberToBoost, 0, Duration.EndOfTurn), source);§return true;§}§return false;§}§@Override§public BlademaneBakuBoostEffect copy() {§return new BlademaneBakuBoostEffect(this);§}§}§}§
public class BlazingShoal extends CardImpl {§public BlazingShoal(UUID ownerId) {§super(ownerId, 96, "Blazing Shoal", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{X}{R}{R}");§this.expansionSetCode = "BOK";§this.subtype.add("Arcane");§FilterOwnedCard filter = new FilterOwnedCard("a red card with converted mana cost X from your hand");§filter.add(new ColorPredicate(ObjectColor.RED));§filter.add(Predicates.not(new CardIdPredicate(this.getId()))); §
public class BlessingOfLeeches extends CardImpl {§public BlessingOfLeeches(UUID ownerId) {§super(ownerId, 62, "Blessing of Leeches", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{B}");§this.expansionSetCode = "BOK";§this.subtype.add("Aura");§this.addAbility(FlashAbility.getInstance());§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.Regenerate));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new BeginningOfUpkeepTriggeredAbility(new LoseLifeSourceControllerEffect(1), TargetController.YOU, false));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new RegenerateAttachedEffect(AttachmentType.AURA),new GenericManaCost(0)));§}§public BlessingOfLeeches(final BlessingOfLeeches card) {§super(card);§}§@Override§public BlessingOfLeeches copy() {§return new BlessingOfLeeches(this);§}§}§
public class BlindingPowder extends CardImpl {§public BlindingPowder(UUID ownerId) {§super(ownerId, 153, "Blinding Powder", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{1}");§this.expansionSetCode = "BOK";§this.subtype.add("Equipment");§Effect effect = new PreventCombatDamageToSourceEffect(Duration.EndOfTurn);§effect.setText("Prevent all combat damage that would be dealt to this creature this turn");§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new BlindingPowderUnattachCost(getName(), getId()));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(ability, AttachmentType.EQUIPMENT, Duration.WhileOnBattlefield)));§this.addAbility(new EquipAbility(Outcome.PreventDamage, new GenericManaCost(2)));§}§public BlindingPowder(final BlindingPowder card) {§super(card);§}§@Override§public BlindingPowder copy() {§return new BlindingPowder(this);§}§}§class BlindingPowderUnattachCost extends CostImpl {§protected UUID sourceEquipmentId;§public BlindingPowderUnattachCost(String name, UUID sourceId) {§this.text = "Unattach " + name;§this.sourceEquipmentId = sourceId;§}§public BlindingPowderUnattachCost(final BlindingPowderUnattachCost cost) {§super(cost);§this.sourceEquipmentId = cost.sourceEquipmentId;§}§@Override§public boolean pay(Ability ability, Game game, UUID sourceId, UUID controllerId, boolean noMana, Cost costToPay) {§Permanent permanent = game.getPermanent(sourceId);§if (permanent != null) {§for (UUID attachmentId : permanent.getAttachments()) {§Permanent attachment = game.getPermanent(attachmentId);§if (attachment != null && attachment.getId().equals(sourceEquipmentId)) {§paid = permanent.removeAttachment(attachmentId, game);§if (paid) {§break;§}§}§}§}§return paid;§}§@Override§public boolean canPay(Ability ability, UUID sourceId, UUID controllerId, Game game) {§Permanent permanent = game.getPermanent(sourceId);§if (permanent != null) {§for (UUID attachmentId : permanent.getAttachments()) {§Permanent attachment = game.getPermanent(attachmentId);§if (attachment != null && attachment.getId().equals(sourceEquipmentId)) {§return true;§}§}§}§return false;§}§@Override§public BlindingPowderUnattachCost copy() {§return new BlindingPowderUnattachCost(this);§}§}§
public class BodyOfJukai extends CardImpl {§public BodyOfJukai(UUID ownerId) {§super(ownerId, 121, "Body of Jukai", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{7}{G}{G}");§this.expansionSetCode = "BOK";§this.subtype.add("Spirit");§this.power = new MageInt(8);§this.toughness = new MageInt(5);§this.addAbility(TrampleAbility.getInstance());§this.addAbility(new SoulshiftAbility(8));§}§public BodyOfJukai(final BodyOfJukai card) {§super(card);§}§@Override§public BodyOfJukai copy() {§return new BodyOfJukai(this);§}§}§
public class BudokaPupil extends CardImpl {§private static final FilterSpiritOrArcaneCard filter = new FilterSpiritOrArcaneCard();§public BudokaPupil(UUID ownerId) {§super(ownerId, 122, "Budoka Pupil", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{G}{G}");§this.expansionSetCode = "BOK";§this.subtype.add("Human");§this.subtype.add("Monk");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.flipCard = true;§this.flipCardName = "Ichiga, Who Topples Oaks";§this.addAbility(new SpellCastControllerTriggeredAbility(new AddCountersSourceEffect(CounterType.KI.createInstance()), filter, true));§this.addAbility(new ConditionalTriggeredAbility(§new OnEventTriggeredAbility(GameEvent.EventType.END_TURN_STEP_PRE, "beginning of the end step", true, new FlipSourceEffect(new IchigaWhoTopplesOaks()), true),§new SourceHasCounterCondition(CounterType.KI, 2, Integer.MAX_VALUE),§"At the beginning of the end step, if there are two or more ki counters on {this}, you may flip it."));§}§public BudokaPupil(final BudokaPupil card) {§super(card);§}§@Override§public BudokaPupil copy() {§return new BudokaPupil(this);§}§}§class IchigaWhoTopplesOaks extends Token {§IchigaWhoTopplesOaks() {§super("Ichiga, Who Topples Oaks", "");§supertype.add("Legendary");§cardType.add(CardType.CREATURE);§color.setGreen(true);§subtype.add("Spirit");§power = new MageInt(4);§toughness = new MageInt(3);§this.addAbility(TrampleAbility.getInstance());§Ability ability = new SimpleActivatedAbility(§Zone.BATTLEFIELD,§new BoostTargetEffect(2, 2, Duration.EndOfTurn),§new RemoveCountersSourceCost(CounterType.KI.createInstance()));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§}§
public class CallForBlood extends CardImpl {§public CallForBlood(UUID ownerId) {§super(ownerId, 63, "Call for Blood", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{4}{B}");§this.expansionSetCode = "BOK";§this.subtype.add("Arcane");§this.getSpellAbility().addCost(new SacrificeTargetCost(new TargetControlledCreaturePermanent()));§DynamicValue xValue = new CallForBloodDynamicValue();§this.getSpellAbility().addEffect(new BoostTargetEffect(xValue, xValue, Duration.EndOfTurn, true));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public CallForBlood(final CallForBlood card) {§super(card);§}§@Override§public CallForBlood copy() {§return new CallForBlood(this);§}§}§class CallForBloodDynamicValue implements DynamicValue {§@Override§public int calculate(Game game, Ability sourceAbility, Effect effect) {§Card sourceCard = game.getCard(sourceAbility.getSourceId());§if (sourceCard != null) {§for (Object cost: sourceAbility.getCosts()) {§if (cost instanceof SacrificeTargetCost) {§Permanent p = (Permanent) game.getLastKnownInformation(((SacrificeTargetCost) cost).getPermanents().get(0).getId(), Zone.BATTLEFIELD);§if (p != null) {§return -1 * p.getPower().getValue();§}§}§}§}§return 0;§}§@Override§public CallForBloodDynamicValue copy() {§return this;§}§@Override§public String getMessage() {§return ", where X is the sacrificed creature's power";§}§@Override§public String toString() {§return "-X";§}§}§
public class CallowJushi extends CardImpl {§private static final FilterSpiritOrArcaneCard filter = new FilterSpiritOrArcaneCard();§public CallowJushi(UUID ownerId) {§super(ownerId, 31, "Callow Jushi", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{U}{U}");§this.expansionSetCode = "BOK";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.flipCard = true;§this.flipCardName = "Jaraku the Interloper";§this.addAbility(new SpellCastControllerTriggeredAbility(new AddCountersSourceEffect(CounterType.KI.createInstance()), filter, true));§this.addAbility(new ConditionalTriggeredAbility(§new OnEventTriggeredAbility(GameEvent.EventType.END_TURN_STEP_PRE, "beginning of the end step", true, new FlipSourceEffect(new JarakuTheInterloper())),§new SourceHasCounterCondition(CounterType.KI, 2, Integer.MAX_VALUE),§"At the beginning of the end step, if there are two or more ki counters on {this}, you may flip it."));§}§public CallowJushi(final CallowJushi card) {§super(card);§}§@Override§public CallowJushi copy() {§return new CallowJushi(this);§}§}§class JarakuTheInterloper extends Token {§JarakuTheInterloper() {§super("Jaraku the Interloper", "");§supertype.add("Legendary");§cardType.add(CardType.CREATURE);§color.setBlue(true);§subtype.add("Spirit");§power = new MageInt(3);§toughness = new MageInt(4);§Ability ability = new SimpleActivatedAbility(§Zone.BATTLEFIELD,§new CounterUnlessPaysEffect(new GenericManaCost(2)),§new RemoveCountersSourceCost(CounterType.KI.createInstance()));§ability.addTarget(new TargetSpell());§this.addAbility(ability);§}§}§
public class ChildOfThorns extends CardImpl {§public ChildOfThorns(UUID ownerId) {§super(ownerId, 123, "Child of Thorns", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{G}");§this.expansionSetCode = "BOK";§this.subtype.add("Spirit");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostTargetEffect(1, 1, Duration.EndOfTurn), new SacrificeSourceCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public ChildOfThorns(final ChildOfThorns card) {§super(card);§}§@Override§public ChildOfThorns copy() {§return new ChildOfThorns(this);§}§}§
public class ChiseiHeartOfOceans extends CardImpl {§private static final FilterPermanent filter = new FilterControlledPermanent("remove a counter from a permanent you control");§static {§filter.add(new ControllerPredicate(TargetController.YOU));§filter.add(new CounterAnyPredicate());§}§public ChiseiHeartOfOceans(UUID ownerId) {§super(ownerId, 32, "Chisei, Heart of Oceans", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{U}{U}");§this.expansionSetCode = "BOK";§this.supertype.add("Legendary");§this.subtype.add("Spirit");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§TargetPermanent target = new TargetPermanent(1,1,filter,true);§target.setTargetName("a permanent you control");§this.addAbility(new BeginningOfUpkeepTriggeredAbility(new SacrificeSourceUnlessPaysEffect(new RemoveCounterCost(target)),TargetController.YOU, false));§}§public ChiseiHeartOfOceans(final ChiseiHeartOfOceans card) {§super(card);§}§@Override§public ChiseiHeartOfOceans copy() {§return new ChiseiHeartOfOceans(this);§}§}§
public class ClashOfRealities extends CardImpl {§private static final FilterCreaturePermanent filterSpirit = new FilterCreaturePermanent("Spirit creature");§private static final FilterCreaturePermanent filterNotSpirit = new FilterCreaturePermanent("non-Spirit creature");§static {§filterSpirit.add(new SubtypePredicate("Spirit"));§filterNotSpirit.add(Predicates.not(new SubtypePredicate("Spirit")));§}§public ClashOfRealities(UUID ownerId) {§super(ownerId, 97, "Clash of Realities", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{3}{R}");§this.expansionSetCode = "BOK";§Ability ability1 = new ClashOfRealitiesTriggeredAbility(new DamageTargetEffect(3), "When this permanent enters the battlefield, ");§ability1.addTarget(new TargetCreaturePermanent(filterNotSpirit));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAllEffect(ability1, Duration.WhileOnBattlefield, filterSpirit, "All Spirits have \"When this permanent enters the battlefield, you may have it deal 3 damage to target non-Spirit creature.\"")));§Ability ability2 = new ClashOfRealitiesTriggeredAbility(new DamageTargetEffect(3), "When this creature enters the battlefield, ");§ability2.addTarget(new TargetCreaturePermanent(filterSpirit));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAllEffect(ability2, Duration.WhileOnBattlefield, filterNotSpirit, "Non-Spirit creatures have \"When this creature enters the battlefield, you may have it deal 3 damage to target Spirit creature.\"")));§}§public ClashOfRealities(final ClashOfRealities card) {§super(card);§}§@Override§public ClashOfRealities copy() {§return new ClashOfRealities(this);§}§private class ClashOfRealitiesTriggeredAbility extends ZoneChangeTriggeredAbility {§public ClashOfRealitiesTriggeredAbility(Effect effect, String rule) {§super(Zone.BATTLEFIELD, effect, rule, true);§}§public ClashOfRealitiesTriggeredAbility(ClashOfRealitiesTriggeredAbility ability) {§super(ability);§}§@Override§public ClashOfRealitiesTriggeredAbility copy() {§return new ClashOfRealitiesTriggeredAbility(this);§}§}§}§
public class CrackTheEarth extends CardImpl {§public CrackTheEarth(UUID ownerId) {§super(ownerId, 98, "Crack the Earth", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{R}");§this.expansionSetCode = "BOK";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new SacrificeAllEffect(1, new FilterControlledPermanent("permanent")));§}§public CrackTheEarth(final CrackTheEarth card) {§super(card);§}§@Override§public CrackTheEarth copy() {§return new CrackTheEarth(this);§}§}§
public class CrawlingFilth extends CardImpl {§public CrawlingFilth(UUID ownerId) {§super(ownerId, 64, "Crawling Filth", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{5}{B}");§this.expansionSetCode = "BOK";§this.subtype.add("Spirit");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FearAbility.getInstance());§this.addAbility(new SoulshiftAbility(5));§}§public CrawlingFilth(final CrawlingFilth card) {§super(card);§}§@Override§public CrawlingFilth copy() {§return new CrawlingFilth(this);§}§}§
public class CunningBandit extends CardImpl {§private static final FilterSpiritOrArcaneCard filter = new FilterSpiritOrArcaneCard();§public CunningBandit(UUID ownerId) {§super(ownerId, 99, "Cunning Bandit", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{R}{R}");§this.expansionSetCode = "BOK";§this.subtype.add("Human");§this.subtype.add("Warrior");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.flipCard = true;§this.flipCardName = "Azamuki, Treachery Incarnate";§this.addAbility(new SpellCastControllerTriggeredAbility(new AddCountersSourceEffect(CounterType.KI.createInstance()), filter, true));§this.addAbility(new ConditionalTriggeredAbility(§new OnEventTriggeredAbility(GameEvent.EventType.END_TURN_STEP_PRE, "beginning of the end step", true, new FlipSourceEffect(new AzamukiTreacheryIncarnate())),§new SourceHasCounterCondition(CounterType.KI, 2, Integer.MAX_VALUE),§"At the beginning of the end step, if there are two or more ki counters on {this}, you may flip it."));§}§public CunningBandit(final CunningBandit card) {§super(card);§}§@Override§public CunningBandit copy() {§return new CunningBandit(this);§}§}§class AzamukiTreacheryIncarnate extends Token {§AzamukiTreacheryIncarnate() {§super("Azamuki, Treachery Incarnate", "");§supertype.add("Legendary");§cardType.add(CardType.CREATURE);§color.setRed(true);§subtype.add("Spirit");§power = new MageInt(5);§toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(§Zone.BATTLEFIELD,§new GainControlTargetEffect(Duration.EndOfTurn),§new RemoveCountersSourceCost(CounterType.KI.createInstance()));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§}§
public class DayOfDestiny extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Legendary creatures");§static {§filter.add(new SupertypePredicate("Legendary"));§}§public DayOfDestiny(UUID ownerId) {§super(ownerId, 1, "Day of Destiny", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{3}{W}");§this.expansionSetCode = "BOK";§this.supertype.add("Legendary");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostControlledEffect(2, 2, Duration.WhileOnBattlefield, filter, false)));§}§public DayOfDestiny(final DayOfDestiny card) {§super(card);§}§@Override§public DayOfDestiny copy() {§return new DayOfDestiny(this);§}§}§
public class DisruptingShoal extends CardImpl {§public DisruptingShoal(UUID ownerId) {§super(ownerId, 33, "Disrupting Shoal", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{X}{U}{U}");§this.expansionSetCode = "BOK";§this.subtype.add("Arcane");§FilterOwnedCard filter = new FilterOwnedCard("a blue card with converted mana cost X from your hand");§filter.add(new ColorPredicate(ObjectColor.BLUE));§filter.add(Predicates.not(new CardIdPredicate(this.getId()))); §
public class EmptyShrineKannushi extends CardImpl {§public EmptyShrineKannushi(UUID ownerId) {§super(ownerId, 2, "Empty-Shrine Kannushi", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{W}");§this.expansionSetCode = "BOK";§this.subtype.add("Human");§this.subtype.add("Cleric");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new EmptyShrineKannushiProtectionAbility());§}§public EmptyShrineKannushi(final EmptyShrineKannushi card) {§super(card);§}§@Override§public EmptyShrineKannushi copy() {§return new EmptyShrineKannushi(this);§}§}§class EmptyShrineKannushiProtectionAbility extends ProtectionAbility {§public EmptyShrineKannushiProtectionAbility() {§super(new FilterCard());§}§public EmptyShrineKannushiProtectionAbility(final EmptyShrineKannushiProtectionAbility ability) {§super(ability);§}§@Override§public EmptyShrineKannushiProtectionAbility copy() {§return new EmptyShrineKannushiProtectionAbility(this);§}§@Override§public boolean canTarget(MageObject source, Game game) {§ObjectColor color = new ObjectColor();§for (Permanent permanent: game.getBattlefield().getAllActivePermanents(controllerId)) {§ObjectColor permanentColor = permanent.getColor(game);§if (permanentColor.isColorless()) {§continue;§}§if (permanentColor.isBlack()) {§color.setBlack(true);§}§if (permanentColor.isBlue()) {§color.setBlue(true);§}§if (permanentColor.isGreen()) {§color.setGreen(true);§}§if (permanentColor.isRed()) {§color.setRed(true);§}§if (permanentColor.isWhite()) {§color.setWhite(true);§}§}§ArrayList<Predicate<MageObject>> colorPredicates = new ArrayList<Predicate<MageObject>>();§if (color.isBlack()) {§colorPredicates.add(new ColorPredicate(ObjectColor.BLACK));§}§if (color.isBlue()) {§colorPredicates.add(new ColorPredicate(ObjectColor.BLUE));§}§if (color.isGreen()) {§colorPredicates.add(new ColorPredicate(ObjectColor.GREEN));§}§if (color.isRed()) {§colorPredicates.add(new ColorPredicate(ObjectColor.RED));§}§if (color.isWhite()) {§colorPredicates.add(new ColorPredicate(ObjectColor.WHITE));§}§Filter protectionFilter = new FilterObject("the colors of permanents you control");§protectionFilter.add(Predicates.or(colorPredicates));§this.filter = protectionFilter;§return super.canTarget(source, game);§}§@Override§public String getRule() {§return "Empty-Shrine Kannushi has protection from the colors of permanents you control.";§}§}§
public class EnshrinedMemories extends CardImpl {§public EnshrinedMemories(UUID ownerId) {§super(ownerId, 124, "Enshrined Memories", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{X}{G}");§this.expansionSetCode = "BOK";§this.getSpellAbility().addEffect(new RevealLibraryPutIntoHandEffect(new ManacostVariableValue(), new FilterCreatureCard("all creature cards"),true));§}§public EnshrinedMemories(final EnshrinedMemories card) {§super(card);§}§@Override§public EnshrinedMemories copy() {§return new EnshrinedMemories(this);§}§}§
public class FinalJudgment extends CardImpl {§public FinalJudgment(UUID ownerId) {§super(ownerId, 4, "Final Judgment", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{4}{W}{W}");§this.expansionSetCode = "BOK";§this.getSpellAbility().addEffect(new FinalJudgmentEffect());§}§public FinalJudgment(final FinalJudgment card) {§super(card);§}§@Override§public FinalJudgment copy() {§return new FinalJudgment(this);§}§}§class FinalJudgmentEffect extends OneShotEffect {§private static final FilterPermanent filter = new FilterPermanent("");§static {§filter.add(new CardTypePredicate(CardType.CREATURE));§}§public FinalJudgmentEffect() {§super(Outcome.Exile);§staticText = "Exile all creatures";§}§public FinalJudgmentEffect(final FinalJudgmentEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§for (Permanent permanent : game.getBattlefield().getActivePermanents(filter, source.getControllerId(), source.getSourceId(), game)) {§permanent.moveToExile(null, null,source.getSourceId(), game);§}§return true;§}§@Override§public FinalJudgmentEffect copy() {§return new FinalJudgmentEffect(this);§}§}§
public class FirstVolley extends CardImpl {§public FirstVolley(UUID ownerId) {§super(ownerId, 100, "First Volley", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{R}");§this.expansionSetCode = "BOK";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new DamageTargetEffect(1));§Effect effect = new DamageTargetControllerEffect(1);§effect.setText("and 1 damage to that creature's controller");§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public FirstVolley(final FirstVolley card) {§super(card);§}§@Override§public FirstVolley copy() {§return new FirstVolley(this);§}§}§
public class FlamesOfTheBloodHand extends CardImpl {§public FlamesOfTheBloodHand(UUID ownerId) {§super(ownerId, 101, "Flames of the Blood Hand", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{2}{R}");§this.expansionSetCode = "BOK";§this.getSpellAbility().addEffect(new DamageTargetEffect(4, false));§this.getSpellAbility().addEffect(new FlamesOfTheBloodHandReplacementEffect());§this.getSpellAbility().addTarget(new TargetPlayer());§}§public FlamesOfTheBloodHand(final FlamesOfTheBloodHand card) {§super(card);§}§@Override§public FlamesOfTheBloodHand copy() {§return new FlamesOfTheBloodHand(this);§}§}§class FlamesOfTheBloodHandReplacementEffect extends ReplacementEffectImpl {§public FlamesOfTheBloodHandReplacementEffect() {§super(Duration.EndOfTurn, Outcome.Benefit);§staticText = "If that player would gain life this turn, that player gains no life instead";§}§public FlamesOfTheBloodHandReplacementEffect(final FlamesOfTheBloodHandReplacementEffect effect) {§super(effect);§}§@Override§public FlamesOfTheBloodHandReplacementEffect copy() {§return new FlamesOfTheBloodHandReplacementEffect(this);§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.GAIN_LIFE;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§return event.getPlayerId().equals(getTargetPointer().getFirst(game, source));§}§@Override§public boolean apply(Game game, Ability source) {§return false;§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§return true;§}§}§
public class Floodbringer extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledLandPermanent("a land you control (return to hand)");§public Floodbringer(UUID ownerId) {§super(ownerId, 34, "Floodbringer", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{U}");§this.expansionSetCode = "BOK";§this.subtype.add("Moonfolk");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new TapTargetEffect(), new GenericManaCost(2));§ReturnToHandChosenControlledPermanentCost cost = new ReturnToHandChosenControlledPermanentCost(new TargetControlledPermanent(filter));§cost.setText("Return a land you control to its owner's hand");§ability.addCost(cost);§ability.addTarget(new TargetLandPermanent());§this.addAbility(ability);§}§public Floodbringer(final Floodbringer card) {§super(card);§}§@Override§public Floodbringer copy() {§return new Floodbringer(this);§}§}§
public class ForkedBranchGarami extends CardImpl {§public ForkedBranchGarami(UUID ownerId) {§super(ownerId, 125, "Forked-Branch Garami", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{G}{G}");§this.expansionSetCode = "BOK";§this.subtype.add("Spirit");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(new SoulshiftAbility(4));§this.addAbility(new SoulshiftAbility(4));§}§public ForkedBranchGarami(final ForkedBranchGarami card) {§super(card);§}§@Override§public ForkedBranchGarami copy() {§return new ForkedBranchGarami(this);§}§}§
public class Frostling extends CardImpl {§public Frostling(UUID ownerId) {§super(ownerId, 103, "Frostling", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{R}");§this.expansionSetCode = "BOK";§this.subtype.add("Spirit");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(1), new SacrificeSourceCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public Frostling(final Frostling card) {§super(card);§}§@Override§public Frostling copy() {§return new Frostling(this);§}§}§
public class FrostOgre extends CardImpl {§public FrostOgre(UUID ownerId) {§super(ownerId, 102, "Frost Ogre", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{R}{R}");§this.expansionSetCode = "BOK";§this.subtype.add("Ogre");§this.subtype.add("Warrior");§this.power = new MageInt(5);§this.toughness = new MageInt(3);§}§public FrostOgre(final FrostOgre card) {§super(card);§}§@Override§public FrostOgre copy() {§return new FrostOgre(this);§}§}§
public class FumikoTheLowblood extends CardImpl {§public FumikoTheLowblood(UUID ownerId) {§super(ownerId, 104, "Fumiko the Lowblood", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{R}{R}");§this.expansionSetCode = "BOK";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Samurai");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§this.addAbility(new BushidoAbility(new AttackingCreatureCount("the number of attacking creatures")));§FilterCreaturePermanent filter = new FilterCreaturePermanent("Creatures your opponents control");§filter.add(new ControllerPredicate(TargetController.OPPONENT));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new AttacksIfAbleAllEffect(filter)), new AttackedThisTurnWatcher());§}§public FumikoTheLowblood(final FumikoTheLowblood card) {§super(card);§}§@Override§public FumikoTheLowblood copy() {§return new FumikoTheLowblood(this);§}§}§
public class GenjuOfTheCedars extends CardImpl {§private static final FilterLandPermanent filter = new FilterLandPermanent("Forest");§static {§filter.add(new SubtypePredicate("Forest"));§}§public GenjuOfTheCedars(UUID ownerId) {§super(ownerId, 126, "Genju of the Cedars", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{G}");§this.expansionSetCode = "BOK";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetLandPermanent(filter);§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.PutCreatureInPlay));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§Ability ability2 = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BecomesCreatureAttachedEffect(new SpiritToken(), "Enchanted Forest becomes a 4/4 green Spirit creature until end of turn. It's still a land", Duration.EndOfTurn), new GenericManaCost(2));§this.addAbility(ability2);§Effect effect = new ReturnToHandSourceEffect(false, true);§effect.setText("you may return {this} from your graveyard to your hand");§Ability ability3 = new DiesAttachedTriggeredAbility(effect, "enchanted Forest", true, false);§this.addAbility(ability3);§}§public GenjuOfTheCedars(final GenjuOfTheCedars card) {§super(card);§}§@Override§public GenjuOfTheCedars copy() {§return new GenjuOfTheCedars(this);§}§private class SpiritToken extends Token {§SpiritToken() {§super("", "4/4 green Spirit creature");§cardType.add(CardType.CREATURE);§color.setGreen(true);§subtype.add("Spirit");§power = new MageInt(4);§toughness = new MageInt(4);§}§}§}§
public class GenjuOfTheFalls extends CardImpl {§private static final FilterLandPermanent FILTER = new FilterLandPermanent("Island");§static {§FILTER.add(new SubtypePredicate("Island"));§}§public GenjuOfTheFalls(UUID ownerId) {§super(ownerId, 35, "Genju of the Falls", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{U}");§this.expansionSetCode = "BOK";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetLandPermanent(FILTER);§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.PutCreatureInPlay));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§Ability ability2 = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BecomesCreatureAttachedEffect(new SpiritToken(), "Enchanted Island becomes a 3/2 blue Spirit creature with flying until end of turn. It's still a land", Duration.EndOfTurn), new GenericManaCost(2));§this.addAbility(ability2);§Ability ability3 = new DiesAttachedTriggeredAbility(new ReturnToHandSourceEffect(false, true), "enchanted Island", true, false);§this.addAbility(ability3);§}§public GenjuOfTheFalls(final GenjuOfTheFalls card) {§super(card);§}§@Override§public GenjuOfTheFalls copy() {§return new GenjuOfTheFalls(this);§}§private class SpiritToken extends Token {§SpiritToken() {§super("Spirit", "3/2 blue Spirit creature with flying");§cardType.add(CardType.CREATURE);§color.setBlue(true);§subtype.add("Spirit");§power = new MageInt(3);§toughness = new MageInt(2);§addAbility(FlyingAbility.getInstance());§}§}§}§
public class GenjuOfTheFens extends CardImpl {§private static final FilterLandPermanent FILTER = new FilterLandPermanent("Swamp");§static {§FILTER.add(new SubtypePredicate("Swamp"));§}§public GenjuOfTheFens(UUID ownerId) {§super(ownerId, 66, "Genju of the Fens", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{B}");§this.expansionSetCode = "BOK";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetLandPermanent(FILTER);§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.PutCreatureInPlay));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§Ability ability2 = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BecomesCreatureAttachedEffect(new SpiritToken(), "Until end of turn, enchanted Swamp becomes a 2/2 black Spirit creature with \"{B}: This creature gets +1/+1 until end of turn.\" It's still a land", Duration.EndOfTurn), new GenericManaCost(2));§this.addAbility(ability2);§Ability ability3 = new DiesAttachedTriggeredAbility(new ReturnToHandSourceEffect(false, true), "enchanted Swamp", true, false);§this.addAbility(ability3);§}§public GenjuOfTheFens(final GenjuOfTheFens card) {§super(card);§}§@Override§public GenjuOfTheFens copy() {§return new GenjuOfTheFens(this);§}§private class SpiritToken extends Token {§SpiritToken() {§super("Spirit", "2/2 black Spirit creature with \"{B}: This creature gets +1/+1 until end of turn.\"");§cardType.add(CardType.CREATURE);§color.setBlack(true);§subtype.add("Spirit");§power = new MageInt(2);§toughness = new MageInt(2);§addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(1, 1, Duration.EndOfTurn), new ManaCostsImpl("{B}")));§}§}§}§
public class GenjuOfTheFields extends CardImpl {§private static final FilterLandPermanent FILTER = new FilterLandPermanent("Plains");§static {§FILTER.add(new SubtypePredicate("Plains"));§}§public GenjuOfTheFields(UUID ownerId) {§super(ownerId, 5, "Genju of the Fields", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{W}");§this.expansionSetCode = "BOK";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetLandPermanent(FILTER);§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.PutCreatureInPlay));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§Effect effect = new BecomesCreatureAttachedEffect(new SpiritToken(),§"Until end of turn, enchanted Plains becomes a 2/5 white Spirit creature", Duration.EndOfTurn);§Ability ability2 = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new GenericManaCost(2));§effect = new GainAbilityAttachedEffect(new DealsDamageGainLifeSourceTriggeredAbility(), AttachmentType.AURA, Duration.EndOfTurn);§effect.setText("with \"Whenever this creature deals damage, its controller gains that much life.\". It's still a land");§ability2.addEffect(effect);§this.addAbility(ability2);§Ability ability3 = new DiesAttachedTriggeredAbility(new ReturnToHandSourceEffect(false, true), "enchanted Plains", true, false);§this.addAbility(ability3);§}§public GenjuOfTheFields(final GenjuOfTheFields card) {§super(card);§}§@Override§public GenjuOfTheFields copy() {§return new GenjuOfTheFields(this);§}§private class SpiritToken extends Token {§SpiritToken() {§super("Spirit", "2/5 white Spirit creature");§cardType.add(CardType.CREATURE);§color.setWhite(true);§subtype.add("Spirit");§power = new MageInt(2);§toughness = new MageInt(5);§}§}§}§
public class GenjuOfTheRealm extends CardImpl {§private static final FilterLandPermanent FILTER = new FilterLandPermanent();§public GenjuOfTheRealm(UUID ownerId) {§super(ownerId, 151, "Genju of the Realm", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{W}{U}{B}{R}{G}");§this.expansionSetCode = "BOK";§this.subtype.add("Aura");§this.supertype.add("Legendary");§TargetPermanent auraTarget = new TargetLandPermanent(FILTER);§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.PutCreatureInPlay));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§Ability ability2 = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BecomesCreatureAttachedEffect(new SpiritToken(), "Enchanted land becomes a legendary 8/12 Spirit creature with trample until end of turn. It's still a land", Duration.EndOfTurn), new GenericManaCost(2));§this.addAbility(ability2);§Ability ability3 = new DiesAttachedTriggeredAbility(new ReturnToHandSourceEffect(false, true), "enchanted land", true, false);§this.addAbility(ability3);§}§public GenjuOfTheRealm(final GenjuOfTheRealm card) {§super(card);§}§@Override§public GenjuOfTheRealm copy() {§return new GenjuOfTheRealm(this);§}§private class SpiritToken extends Token {§SpiritToken() {§super("Spirit", "legendary 8/12 Spirit creature with trample");§supertype.add("Legendary");§cardType.add(CardType.CREATURE);§this.color.setWhite(true);§this.color.setBlue(true);§this.color.setBlack(true);§this.color.setRed(true);§this.color.setGreen(true);§subtype.add("Spirit");§power = new MageInt(8);§toughness = new MageInt(12);§this.addAbility(TrampleAbility.getInstance());§}§}§}§
public class GenjuOfTheSpires extends CardImpl {§private static final FilterLandPermanent FILTER = new FilterLandPermanent("Mountain");§static {§FILTER.add(new SubtypePredicate("Mountain"));§}§public GenjuOfTheSpires(UUID ownerId) {§super(ownerId, 105, "Genju of the Spires", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{R}");§this.expansionSetCode = "BOK";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetLandPermanent(FILTER);§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.PutCreatureInPlay));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§Ability ability2 = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BecomesCreatureAttachedEffect(new SpiritToken(), "Enchanted Mountain becomes a 6/1 red Spirit creature until end of turn. It's still a land", Duration.EndOfTurn), new GenericManaCost(2));§this.addAbility(ability2);§Ability ability3 = new DiesAttachedTriggeredAbility(new ReturnToHandSourceEffect(false, true), "enchanted Mountain", true, false);§this.addAbility(ability3);§}§public GenjuOfTheSpires(final GenjuOfTheSpires card) {§super(card);§}§@Override§public GenjuOfTheSpires copy() {§return new GenjuOfTheSpires(this);§}§private class SpiritToken extends Token {§SpiritToken() {§super("Spirit", "6/1 red Spirit creature");§cardType.add(CardType.CREATURE);§color.setRed(true);§subtype.add("Spirit");§power = new MageInt(6);§toughness = new MageInt(1);§}§}§}§
public class GnarledMass extends CardImpl {§public GnarledMass(UUID ownerId) {§super(ownerId, 127, "Gnarled Mass", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{G}{G}");§this.expansionSetCode = "BOK";§this.subtype.add("Spirit");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§}§public GnarledMass(final GnarledMass card) {§super(card);§}§@Override§public GnarledMass copy() {§return new GnarledMass(this);§}§}§
public class GoblinCohort extends CardImpl {§public GoblinCohort(UUID ownerId) {§super(ownerId, 106, "Goblin Cohort", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{R}");§this.expansionSetCode = "BOK";§this.subtype.add("Goblin");§this.subtype.add("Warrior");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GoblinCohortEffect()), new PlayerCastCreatureWatcher());§}§public GoblinCohort(final GoblinCohort card) {§super(card);§}§@Override§public GoblinCohort copy() {§return new GoblinCohort(this);§}§}§class GoblinCohortEffect extends RestrictionEffect {§public GoblinCohortEffect() {§super(Duration.WhileOnBattlefield);§staticText = "{this} can't attack unless you've cast a creature spell this turn";§}§public GoblinCohortEffect(final GoblinCohortEffect effect) {§super(effect);§}§@Override§public GoblinCohortEffect copy() {§return new GoblinCohortEffect(this);§}§@Override§public boolean canAttack(Game game) {§return false;§}§@Override§public boolean applies(Permanent permanent, Ability source, Game game) {§if (permanent.getId().equals(source.getSourceId())) {§PlayerCastCreatureWatcher watcher = (PlayerCastCreatureWatcher) game.getState().getWatchers().get("PlayerCastCreature");§if (watcher != null && !watcher.playerDidCastCreatureThisTurn(source.getControllerId())) {§return true;§}§}§return false;§}§}§
public class GodsEyeGateToTheReikai extends CardImpl {§public GodsEyeGateToTheReikai(UUID ownerId) {§super(ownerId, 164, "Gods' Eye, Gate to the Reikai", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "BOK";§this.supertype.add("Legendary");§this.addAbility(new ColorlessManaAbility());§this.addAbility(new PutIntoGraveFromBattlefieldSourceTriggeredAbility(new CreateTokenEffect(new SpiritToken(), 1), false));§}§public GodsEyeGateToTheReikai(final GodsEyeGateToTheReikai card) {§super(card);§}§@Override§public GodsEyeGateToTheReikai copy() {§return new GodsEyeGateToTheReikai(this);§}§}§
public class GoryosVengeance extends CardImpl {§private static final FilterCard filter = new FilterCard("legendary creature card");§static {§filter.add(new SupertypePredicate("Legendary"));§}§public GoryosVengeance(UUID ownerId) {§super(ownerId, 67, "Goryo's Vengeance", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{1}{B}");§this.expansionSetCode = "BOK";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new GoryosVengeanceEffect());§this.getSpellAbility().addTarget(new TargetCardInYourGraveyard(filter));§this.addAbility(new SpliceOntoArcaneAbility("{2}{B}"));§}§public GoryosVengeance(final GoryosVengeance card) {§super(card);§}§@Override§public GoryosVengeance copy() {§return new GoryosVengeance(this);§}§}§class GoryosVengeanceEffect extends OneShotEffect {§public GoryosVengeanceEffect() {§super(Outcome.PutCardInPlay);§this.staticText = "Return target legendary creature card from your graveyard to the battlefield. That creature gains haste. Exile it at the beginning of the next end step";§}§public GoryosVengeanceEffect(final GoryosVengeanceEffect effect) {§super(effect);§}§@Override§public GoryosVengeanceEffect copy() {§return new GoryosVengeanceEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Card card = game.getCard(targetPointer.getFirst(game, source));§if (card != null) {§if (controller.moveCards(card, Zone.BATTLEFIELD, source, game)) {§Permanent permanent = game.getPermanent(card.getId());§if (permanent != null) {§ContinuousEffect effect = new GainAbilityTargetEffect(HasteAbility.getInstance(), Duration.Custom);§effect.setTargetPointer(new FixedTarget(permanent, game));§game.addEffect(effect, source);§Effect exileEffect = new ExileTargetEffect("Exile " + permanent.getName() + " at the beginning of the next end step");§exileEffect.setTargetPointer(new FixedTarget(permanent, game));§DelayedTriggeredAbility delayedAbility = new AtTheBeginOfNextEndStepDelayedTriggeredAbility(exileEffect);§delayedAbility.setSourceId(source.getSourceId());§delayedAbility.setControllerId(source.getControllerId());§delayedAbility.setSourceObject(source.getSourceObject(game), game);§game.addDelayedTriggeredAbility(delayedAbility);§return true;§}§}§}§}§return false;§}§}§
public class HeartOfLight extends CardImpl {§public HeartOfLight(UUID ownerId) {§super(ownerId, 6, "Heart of Light", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{W}");§this.expansionSetCode = "BOK";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new HeartOfLightEffect()));§}§public HeartOfLight(final HeartOfLight card) {§super(card);§}§@Override§public HeartOfLight copy() {§return new HeartOfLight(this);§}§}§class HeartOfLightEffect extends PreventionEffectImpl {§public HeartOfLightEffect() {§super(Duration.WhileOnBattlefield);§staticText = "Prevent all damage that would be dealt to and dealt by enchanted creature";§}§public HeartOfLightEffect(final HeartOfLightEffect effect) {§super(effect);§}§@Override§public HeartOfLightEffect copy() {§return new HeartOfLightEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§GameEvent preventEvent = new GameEvent(GameEvent.EventType.PREVENT_DAMAGE, source.getFirstTarget(), source.getSourceId(), source.getControllerId(), event.getAmount(), false);§if (!game.replaceEvent(preventEvent)) {§int damage = event.getAmount();§event.setAmount(0);§game.fireEvent(GameEvent.getEvent(GameEvent.EventType.PREVENTED_DAMAGE, source.getFirstTarget(), source.getSourceId(), source.getControllerId(), damage));§}§return false;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§if (super.applies(event, source, game) && event instanceof DamageEvent) {§Permanent aura = game.getPermanent(source.getSourceId());§if (aura != null && aura.getAttachedTo() != null) {§if (event.getSourceId().equals(aura.getAttachedTo()) || event.getTargetId().equals(aura.getAttachedTo())) {§return true;§}§}§}§return false;§}§}§
public class HeedTheMists extends CardImpl {§public HeedTheMists(UUID ownerId) {§super(ownerId, 36, "Heed the Mists", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{3}{U}{U}");§this.expansionSetCode = "BOK";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new HeedTheMistsEffect());§}§public HeedTheMists(final HeedTheMists card) {§super(card);§}§@Override§public HeedTheMists copy() {§return new HeedTheMists(this);§}§private class HeedTheMistsEffect extends OneShotEffect {§public HeedTheMistsEffect() {§super(Outcome.DrawCard);§staticText = "Put the top card of your library into your graveyard, then draw cards equal to that card's converted mana cost";§}§public HeedTheMistsEffect(HeedTheMistsEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§boolean result = false;§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Card card = controller.getLibrary().removeFromTop(game);§if (card != null) {§int cmc = card.getManaCost().convertedManaCost();§controller.moveCards(card, Zone.LIBRARY, Zone.GRAVEYARD, source, game);§controller.drawCards(cmc, game);§}§}§return result;§}§@Override§public HeedTheMistsEffect copy() {§return new HeedTheMistsEffect(this);§}§}§}§
public class HerosDemise extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("legendary creature");§static {§filter.add(new SupertypePredicate("Legendary"));§}§public HerosDemise(UUID ownerId) {§super(ownerId, 68, "Hero's Demise", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{1}{B}");§this.expansionSetCode = "BOK";§this.getSpellAbility().addEffect(new DestroyTargetEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent(filter));§}§public HerosDemise(final HerosDemise card) {§super(card);§}§@Override§public HerosDemise copy() {§return new HerosDemise(this);§}§}§
public class HigureTheStillWind extends CardImpl {§private static final FilterCard filter = new FilterCard("Ninja card");§private static final FilterCreaturePermanent filterCreature = new FilterCreaturePermanent("Ninja creature");§static {§filter.add((new SubtypePredicate("Ninja")));§filterCreature.add((new SubtypePredicate("Ninja")));§}§public HigureTheStillWind(UUID ownerId) {§super(ownerId, 37, "Higure, the Still Wind", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{U}{U}");§this.expansionSetCode = "BOK";§this.subtype.add("Human");§this.subtype.add("Ninja");§this.supertype.add("Legendary");§this.power = new MageInt(3);§this.toughness = new MageInt(4);§this.addAbility(new NinjutsuAbility(new ManaCostsImpl("{2}{U}{U}")));§this.addAbility(new DealsCombatDamageToAPlayerTriggeredAbility(new SearchLibraryPutInHandEffect(new TargetCardInLibrary(filter)), true));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new CantBeBlockedTargetEffect(), new GenericManaCost(2));§ability.addTarget(new TargetCreaturePermanent(filterCreature));§this.addAbility(ability);§}§public HigureTheStillWind(final HigureTheStillWind card) {§super(card);§}§@Override§public HigureTheStillWind copy() {§return new HigureTheStillWind(this);§}§}§
public class HiredMuscle extends CardImpl {§private static final FilterSpiritOrArcaneCard filter = new FilterSpiritOrArcaneCard();§public HiredMuscle(UUID ownerId) {§super(ownerId, 69, "Hired Muscle", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{B}{B}");§this.expansionSetCode = "BOK";§this.subtype.add("Human");§this.subtype.add("Warrior");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.flipCard = true;§this.flipCardName = "Scarmaker";§this.addAbility(new SpellCastControllerTriggeredAbility(new AddCountersSourceEffect(CounterType.KI.createInstance()), filter, true));§this.addAbility(new ConditionalTriggeredAbility(§new OnEventTriggeredAbility(GameEvent.EventType.END_TURN_STEP_PRE, "beginning of the end step", true, new FlipSourceEffect(new Scarmaker())),§new SourceHasCounterCondition(CounterType.KI, 2, Integer.MAX_VALUE),§"At the beginning of the end step, if there are two or more ki counters on {this}, you may flip it."));§}§public HiredMuscle(final HiredMuscle card) {§super(card);§}§@Override§public HiredMuscle copy() {§return new HiredMuscle(this);§}§}§class Scarmaker extends Token {§Scarmaker() {§super("Scarmaker", "");§supertype.add("Legendary");§cardType.add(CardType.CREATURE);§color.setBlack(true);§subtype.add("Spirit");§power = new MageInt(4);§toughness = new MageInt(4);§Ability ability = new SimpleActivatedAbility(§Zone.BATTLEFIELD,§new GainAbilityTargetEffect(FearAbility.getInstance(), Duration.EndOfTurn),§new RemoveCountersSourceCost(CounterType.KI.createInstance()));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§}§
public class HokoriDustDrinker extends CardImpl {§public HokoriDustDrinker(UUID ownerId) {§super(ownerId, 7, "Hokori, Dust Drinker", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{W}{W}");§this.expansionSetCode = "BOK";§this.supertype.add("Legendary");§this.subtype.add("Spirit");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new DontUntapInControllersUntapStepAllEffect(Duration.WhileOnBattlefield, TargetController.ANY, new FilterLandPermanent("Lands"))));§this.addAbility(new BeginningOfUpkeepTriggeredAbility(Zone.BATTLEFIELD, new HokoriDustDrinkerUntapEffect(), TargetController.ANY, false));§}§public HokoriDustDrinker(final HokoriDustDrinker card) {§super(card);§}§@Override§public HokoriDustDrinker copy() {§return new HokoriDustDrinker(this);§}§}§class HokoriDustDrinkerUntapEffect extends OneShotEffect {§public HokoriDustDrinkerUntapEffect() {§super(Outcome.Untap);§this.staticText = "that player untaps a land he or she controls";§}§public HokoriDustDrinkerUntapEffect(final HokoriDustDrinkerUntapEffect effect) {§super(effect);§}§@Override§public HokoriDustDrinkerUntapEffect copy() {§return new HokoriDustDrinkerUntapEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(game.getActivePlayerId());§FilterLandPermanent filter = new FilterLandPermanent("land you control");§filter.add(new ControllerIdPredicate(game.getActivePlayerId()));§Target target = new TargetLandPermanent(filter);§if (player != null && player.chooseTarget(Outcome.Untap, target, source, game)) {§for (UUID landId : target.getTargets()) {§Permanent land = game.getPermanent(landId);§if (land != null) {§land.untap(game);§}§}§return true;§}§return false;§}§}§
public class HorobisWhisper extends CardImpl {§private static final FilterCreaturePermanent filterTarget = new FilterCreaturePermanent("nonblack creature");§private static final FilterLandPermanent filterCondition = new FilterLandPermanent("Swamp");§static {§filterTarget.add(Predicates.not(new ColorPredicate(ObjectColor.BLACK)));§filterCondition.add(new SubtypePredicate("Swamp"));§}§public HorobisWhisper(UUID ownerId) {§super(ownerId, 70, "Horobi's Whisper", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{B}{B}");§this.expansionSetCode = "BOK";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new ConditionalOneShotEffect(new DestroyTargetEffect(),§new PermanentsOnTheBattlefieldCondition(filterCondition),"If you control a Swamp, destroy target nonblack creature"));§this.getSpellAbility().addTarget(new TargetCreaturePermanent(filterTarget) );§this.addAbility(new SpliceOntoArcaneAbility(new ExileFromGraveCost(new TargetCardInYourGraveyard(4,4, new FilterCard("cards")))));§}§public HorobisWhisper(final HorobisWhisper card) {§super(card);§}§@Override§public HorobisWhisper copy() {§return new HorobisWhisper(this);§}§}§
public class HundredTalonStrike extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("untapped white creature you control");§static {§filter.add(Predicates.not(new TappedPredicate()));§filter.add(new ColorPredicate(ObjectColor.WHITE));§}§public HundredTalonStrike(UUID ownerId) {§super(ownerId, 8, "Hundred-Talon Strike", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{W}");§this.expansionSetCode = "BOK";§this.subtype.add("Arcane");§Effect effect = new BoostTargetEffect(1,0, Duration.EndOfTurn);§effect.setText("Target creature gets +1/+0");§this.getSpellAbility().addEffect(effect);§effect = new GainAbilityTargetEffect(FirstStrikeAbility.getInstance(), Duration.EndOfTurn);§effect.setText("and gains first strike until end of turn");§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.addAbility(new SpliceOntoArcaneAbility(new TapTargetCost(new TargetControlledCreaturePermanent(1,1,filter,false))));§}§public HundredTalonStrike(final HundredTalonStrike card) {§super(card);§}§@Override§public HundredTalonStrike copy() {§return new HundredTalonStrike(this);§}§}§
public class IndebtedSamurai extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("a Samurai you control");§static {§filter.add(new ControllerPredicate(TargetController.YOU));§filter.add(new SubtypePredicate("Samurai"));§}§public IndebtedSamurai(UUID ownerId) {§super(ownerId, 9, "Indebted Samurai", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{W}");§this.expansionSetCode = "BOK";§this.subtype.add("Human");§this.subtype.add("Samurai");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(new BushidoAbility(1));§this.addAbility(new DiesCreatureTriggeredAbility(new AddCountersSourceEffect(CounterType.P1P1.createInstance()), true, filter));§}§public IndebtedSamurai(final IndebtedSamurai card) {§super(card);§}§@Override§public IndebtedSamurai copy() {§return new IndebtedSamurai(this);§}§}§
public class InkEyesServantOfOni extends CardImpl {§public InkEyesServantOfOni(UUID ownerId) {§super(ownerId, 71, "Ink-Eyes, Servant of Oni", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{B}{B}");§this.expansionSetCode = "BOK";§this.subtype.add("Rat");§this.subtype.add("Ninja");§this.supertype.add("Legendary");§this.power = new MageInt(5);§this.toughness = new MageInt(4);§this.addAbility(new NinjutsuAbility(new ManaCostsImpl("{3}{B}{B}")));§this.addAbility(new DealsCombatDamageToAPlayerTriggeredAbility(new InkEyesServantOfOniEffect(), true, true));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new RegenerateSourceEffect(), new ManaCostsImpl("{1}{B}")));§}§public InkEyesServantOfOni(final InkEyesServantOfOni card) {§super(card);§}§@Override§public InkEyesServantOfOni copy() {§return new InkEyesServantOfOni(this);§}§}§class InkEyesServantOfOniEffect extends OneShotEffect {§public InkEyesServantOfOniEffect() {§super(Outcome.PutCreatureInPlay);§this.staticText = "you may put target creature card from that player's graveyard onto the battlefield under your control";§}§public InkEyesServantOfOniEffect(final InkEyesServantOfOniEffect effect) {§super(effect);§}§@Override§public InkEyesServantOfOniEffect copy() {§return new InkEyesServantOfOniEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player damagedPlayer = game.getPlayer(targetPointer.getFirst(game, source));§Player you = game.getPlayer(source.getControllerId());§FilterCard filter = new FilterCard("creature in that player's graveyard");§filter.add(new CardTypePredicate(CardType.CREATURE));§filter.add(new OwnerIdPredicate(damagedPlayer.getId()));§TargetCardInGraveyard target = new TargetCardInGraveyard(filter);§if (target.canChoose(source.getSourceId(), you.getId(), game)) {§if (you.chooseTarget(Outcome.PutCreatureInPlay, target, source, game)) {§Card card = game.getCard(target.getFirstTarget());§if (card != null) {§card.putOntoBattlefield(game, Zone.GRAVEYARD, id, you.getId());§return true;§}§}§}§return false;§}§}§
public class InTheWebOfWar extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("a creature");§public InTheWebOfWar(UUID ownerId) {§super(ownerId, 108, "In the Web of War", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{3}{R}{R}");§this.expansionSetCode = "BOK";§Effect effect = new BoostTargetEffect(2,0, Duration.EndOfTurn);§effect.setText("it gets +2/+0");§Ability ability = new EntersBattlefieldControlledTriggeredAbility(Zone.BATTLEFIELD, effect, filter, false, SetTargetPointer.PERMANENT, null);§effect = new GainAbilityTargetEffect(HasteAbility.getInstance(), Duration.EndOfTurn);§effect.setText("and gains haste until end of turn");§ability.addEffect(effect);§this.addAbility(ability);§}§public InTheWebOfWar(final InTheWebOfWar card) {§super(card);§}§@Override§public InTheWebOfWar copy() {§return new InTheWebOfWar(this);§}§}§
public class IreOfKaminari extends CardImpl {§private static final FilterCard filter = new FilterCard("Arcane");§static {§filter.add(new SubtypePredicate("Arcane"));§}§public IreOfKaminari(UUID ownerId) {§super(ownerId, 109, "Ire of Kaminari", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{3}{R}");§this.expansionSetCode = "BOK";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new DamageTargetEffect(new CardsInControllerGraveyardCount(filter)));§this.getSpellAbility().addTarget(new TargetCreatureOrPlayer());§}§public IreOfKaminari(final IreOfKaminari card) {§super(card);§}§@Override§public IreOfKaminari copy() {§return new IreOfKaminari(this);§}§}§
public class IsaoEnlightenedBushi extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("Samurai");§static {§filter.add(new SubtypePredicate("Samurai"));§}§public IsaoEnlightenedBushi(UUID ownerId) {§super(ownerId, 129, "Isao, Enlightened Bushi", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{G}");§this.expansionSetCode = "BOK";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Samurai");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new CantBeCounteredAbility());§this.addAbility(new BushidoAbility(2));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new RegenerateTargetEffect(), new GenericManaCost(2));§ability.addTarget(new TargetPermanent(filter));§this.addAbility(ability);§}§public IsaoEnlightenedBushi(final IsaoEnlightenedBushi card) {§super(card);§}§@Override§public IsaoEnlightenedBushi copy() {§return new IsaoEnlightenedBushi(this);§}§}§
public class IshiIshiAkkiCrackshot extends CardImpl {§private static final FilterSpiritOrArcaneCard filter = new FilterSpiritOrArcaneCard();§static {§filter.add(new ControllerPredicate(TargetController.OPPONENT));§}§public IshiIshiAkkiCrackshot(UUID ownerId) {§super(ownerId, 110, "Ishi-Ishi, Akki Crackshot", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{R}");§this.expansionSetCode = "BOK";§this.supertype.add("Legendary");§this.subtype.add("Goblin");§this.subtype.add("Warrior");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new SpellCastOpponentTriggeredAbility(Zone.BATTLEFIELD, new DamageTargetEffect(2, true, "that player"), filter, false, SetTargetPointer.PLAYER));§}§public IshiIshiAkkiCrackshot(final IshiIshiAkkiCrackshot card) {§super(card);§}§@Override§public IshiIshiAkkiCrackshot copy() {§return new IshiIshiAkkiCrackshot(this);§}§}§
public class IwamoriOfTheOpenFist extends CardImpl {§public IwamoriOfTheOpenFist(UUID ownerId) {§super(ownerId, 130, "Iwamori of the Open Fist", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{G}{G}");§this.expansionSetCode = "BOK";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Monk");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(TrampleAbility.getInstance());§this.addAbility(new EntersBattlefieldTriggeredAbility(new IwamoriOfTheOpenFistEffect(), false));§}§public IwamoriOfTheOpenFist(final IwamoriOfTheOpenFist card) {§super(card);§}§@Override§public IwamoriOfTheOpenFist copy() {§return new IwamoriOfTheOpenFist(this);§}§}§class IwamoriOfTheOpenFistEffect extends OneShotEffect {§private static final FilterCard filter = new FilterCard("legendary creature card");§static {§filter.add(new SupertypePredicate("Legendary"));§filter.add(new CardTypePredicate(CardType.CREATURE));§}§public IwamoriOfTheOpenFistEffect() {§super(Outcome.Detriment);§this.staticText = "each opponent may put a legendary creature card from his or her hand onto the battlefield";§}§public IwamoriOfTheOpenFistEffect(final IwamoriOfTheOpenFistEffect effect) {§super(effect);§}§@Override§public IwamoriOfTheOpenFistEffect copy() {§return new IwamoriOfTheOpenFistEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Cards cards = new CardsImpl();§for (UUID playerId : game.getOpponents(controller.getId())) {§Player opponent = game.getPlayer(playerId);§Target target = new TargetCardInHand(filter);§if (opponent != null && target.canChoose(source.getSourceId(), opponent.getId(), game)) {§if (opponent.chooseUse(Outcome.PutCreatureInPlay, "Put a legendary creature card from your hand onto the battlefield?", source, game)) {§if (target.chooseTarget(Outcome.PutCreatureInPlay, opponent.getId(), source, game)) {§Card card = game.getCard(target.getFirstTarget());§if (card != null) {§cards.add(card);§}§}§}§}§}§controller.moveCards(cards.getCards(game), Zone.BATTLEFIELD, source, game, false, false, true, null);§return true;§}§return false;§}§}§
public class JettingGlasskite extends CardImpl {§public JettingGlasskite(UUID ownerId) {§super(ownerId, 38, "Jetting Glasskite", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{U}{U}");§this.expansionSetCode = "BOK";§this.subtype.add("Spirit");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new JettingGlasskiteAbility());§}§public JettingGlasskite(final JettingGlasskite card) {§super(card);§}§@Override§public JettingGlasskite copy() {§return new JettingGlasskite(this);§}§}§class JettingGlasskiteAbility extends TriggeredAbilityImpl {§protected int turnUsed;§public JettingGlasskiteAbility() {§super(Zone.BATTLEFIELD, new CounterTargetEffect(), false);§}§public JettingGlasskiteAbility(final JettingGlasskiteAbility ability) {§super(ability);§turnUsed = ability.turnUsed;§}§@Override§public JettingGlasskiteAbility copy() {§return new JettingGlasskiteAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.TARGETED;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (event.getTargetId().equals(this.getSourceId()) && game.getTurnNum() > turnUsed) {§this.getTargets().clear();§TargetStackObject target = new TargetStackObject();§target.add(event.getSourceId(), game);§this.addTarget(target);§turnUsed = game.getTurnNum();§return true;§}§return false;§}§@Override§public String getRule() {§return "Whenever {this} becomes the target of a spell or ability for the first time in a turn, counter that spell or ability.";§}§}§
public class KaijinOfTheVanishingTouch extends CardImpl {§public KaijinOfTheVanishingTouch(UUID ownerId) {§super(ownerId, 39, "Kaijin of the Vanishing Touch", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{U}");§this.expansionSetCode = "BOK";§this.subtype.add("Spirit");§this.power = new MageInt(0);§this.toughness = new MageInt(3);§this.addAbility(DefenderAbility.getInstance());§Effect effect = new ReturnToHandTargetEffect();§effect.setText("return that creature to its owner's hand at end of combat");§this.addAbility(new BlocksCreatureTriggeredAbility(new CreateDelayedTriggeredAbilityEffect(§new AtTheEndOfCombatDelayedTriggeredAbility(effect)), false, true));§}§public KaijinOfTheVanishingTouch(final KaijinOfTheVanishingTouch card) {§super(card);§}§@Override§public KaijinOfTheVanishingTouch copy() {§return new KaijinOfTheVanishingTouch(this);§}§}§
public class KamiOfFalseHope extends CardImpl {§public KamiOfFalseHope(UUID ownerId) {§super(ownerId, 10, "Kami of False Hope", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{W}");§this.expansionSetCode = "BOK";§this.subtype.add("Spirit");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new PreventAllDamageByAllEffect(Duration.EndOfTurn, true), new SacrificeSourceCost());§this.addAbility(ability);§}§public KamiOfFalseHope(final KamiOfFalseHope card) {§super(card);§}§@Override§public KamiOfFalseHope copy() {§return new KamiOfFalseHope(this);§}§}§
public class KentaroTheSmilingCat extends CardImpl {§public KentaroTheSmilingCat(UUID ownerId) {§super(ownerId, 13, "Kentaro, the Smiling Cat", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "BOK";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Samurai");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new BushidoAbility(1));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new KentaroTheSmilingCatCastingEffect()));§}§public KentaroTheSmilingCat(final KentaroTheSmilingCat card) {§super(card);§}§@Override§public KentaroTheSmilingCat copy() {§return new KentaroTheSmilingCat(this);§}§}§class KentaroTheSmilingCatCastingEffect extends ContinuousEffectImpl {§private static final FilterCard filterSamurai = new FilterCard();§static {§filterSamurai.add(new SubtypePredicate("Samurai"));§}§static final AlternativeCostSourceAbility alternativeCastingCostAbility = new AlternativeCostSourceAbility(§SourceIsSpellCondition.getInstance(), null, filterSamurai, true, new ColorlessConvertedManaCost());§public KentaroTheSmilingCatCastingEffect() {§super(Duration.WhileOnBattlefield, Outcome.Benefit);§staticText = "You may pay {X} rather than pay the mana cost for Samurai spells you cast, where X is that spell's converted mana cost";§}§public KentaroTheSmilingCatCastingEffect(final KentaroTheSmilingCatCastingEffect effect) {§super(effect);§}§@Override§public KentaroTheSmilingCatCastingEffect copy() {§return new KentaroTheSmilingCatCastingEffect(this);§}§@Override§public boolean apply(Layer layer, SubLayer sublayer, Ability source, Game game) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§controller.getAlternativeSourceCosts().add(alternativeCastingCostAbility);§return true;§}§return false;§}§@Override§public boolean apply(Game game, Ability source) {§return false;§}§@Override§public boolean hasLayer(Layer layer) {§return layer == Layer.RulesEffects;§}§}§class ColorlessConvertedManaCost implements DynamicCost {§@Override§public Cost getCost(Ability ability, Game game) {§return new GenericManaCost(ability.getManaCosts().convertedManaCost());§}§@Override§public String getText(Ability ability, Game game) {§return "Pay " + getCost(ability, game).getText() + " rather than " + ability.getManaCosts().getText() + " for Samurai card?";§}§}§
public class KiraGreatGlassSpinner extends CardImpl {§public KiraGreatGlassSpinner(UUID ownerId) {§super(ownerId, 40, "Kira, Great Glass-Spinner", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{U}{U}");§this.expansionSetCode = "BOK";§this.subtype.add("Spirit");§this.supertype.add("Legendary");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§Effect effect = new CounterTargetEffect();§effect.setText("counter that spell or ability");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityControlledEffect(new KiraGreatGlassSpinnerAbility(effect), Duration.WhileOnBattlefield, new FilterCreaturePermanent("Creatures you control"))),§new CreatureWasTargetedThisTurnWatcher());§}§public KiraGreatGlassSpinner(final KiraGreatGlassSpinner card) {§super(card);§}§@Override§public KiraGreatGlassSpinner copy() {§return new KiraGreatGlassSpinner(this);§}§}§class KiraGreatGlassSpinnerAbility extends TriggeredAbilityImpl {§public KiraGreatGlassSpinnerAbility(Effect effect) {§super(Zone.BATTLEFIELD, effect, false);§}§public KiraGreatGlassSpinnerAbility(final KiraGreatGlassSpinnerAbility ability) {§super(ability);§}§@Override§public KiraGreatGlassSpinnerAbility copy() {§return new KiraGreatGlassSpinnerAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.TARGETED;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (event.getTargetId().equals(this.getSourceId())) {§Permanent permanent = game.getPermanent(event.getTargetId());§if (permanent != null && permanent.getCardType().contains(CardType.CREATURE)) {§CreatureWasTargetedThisTurnWatcher watcher = (CreatureWasTargetedThisTurnWatcher) game.getState().getWatchers().get("CreatureWasTargetedThisTurn");§if (watcher != null && watcher.notMoreThanOnceTargetedThisTurn(permanent, game)) {§for (Effect effect : getEffects()) {§effect.setTargetPointer(new FixedTarget(event.getSourceId()));§}§return true;§}§}§}§return false;§}§@Override§public String getRule() {§return "Whenever this creature becomes the target of a spell or ability for the first time in a turn, counter that spell or ability.";§}§}§class CreatureWasTargetedThisTurnWatcher extends Watcher {§private final Map<MageObjectReference, Integer> creaturesTargeted = new HashMap<>();§public CreatureWasTargetedThisTurnWatcher() {§super("CreatureWasTargetedThisTurn", WatcherScope.GAME);§}§public CreatureWasTargetedThisTurnWatcher(final CreatureWasTargetedThisTurnWatcher watcher) {§super(watcher);§this.creaturesTargeted.putAll(creaturesTargeted);§}§@Override§public void watch(GameEvent event, Game game) {§if (event.getType() == GameEvent.EventType.TARGETED) {§Permanent permanent = game.getPermanent(event.getTargetId());§if (permanent != null && permanent.getCardType().contains(CardType.CREATURE)) {§MageObjectReference mor = new MageObjectReference(permanent, game);§int amount = 0;§if (creaturesTargeted.containsKey(mor)) {§amount = creaturesTargeted.get(mor);§}§creaturesTargeted.put(mor, ++amount);§}§}§}§public boolean notMoreThanOnceTargetedThisTurn(Permanent creature, Game game) {§if (creaturesTargeted.containsKey(new MageObjectReference(creature, game))) {§return creaturesTargeted.get(new MageObjectReference(creature, game)) < 2;§}§return true;§}§@Override§public void reset() {§super.reset();§creaturesTargeted.clear();§}§@Override§public CreatureWasTargetedThisTurnWatcher copy() {§return new CreatureWasTargetedThisTurnWatcher(this);§}§}§
public class KitsunePalliator extends CardImpl {§public KitsunePalliator(UUID ownerId) {§super(ownerId, 14, "Kitsune Palliator", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "BOK";§this.subtype.add("Fox");§this.subtype.add("Cleric");§this.power = new MageInt(0);§this.toughness = new MageInt(2);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new KitsunePalliatorEffect(), new TapSourceCost()));§}§public KitsunePalliator(final KitsunePalliator card) {§super(card);§}§@Override§public KitsunePalliator copy() {§return new KitsunePalliator(this);§}§}§class KitsunePalliatorEffect extends OneShotEffect {§public KitsunePalliatorEffect() {§super(Outcome.PreventDamage);§this.staticText = "Prevent the next 1 damage that would be dealt to each creature and each player this turn";§}§public KitsunePalliatorEffect(final KitsunePalliatorEffect effect) {§super(effect);§}§@Override§public KitsunePalliatorEffect copy() {§return new KitsunePalliatorEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§PreventDamageToTargetEffect effect = new PreventDamageToTargetEffect(Duration.EndOfTurn, 1);§List<Permanent> permanents = game.getBattlefield().getActivePermanents(new FilterCreaturePermanent(), source.getControllerId(), game);§for (Permanent permanent: permanents) {§effect.setTargetPointer(new FixedTarget(permanent.getId()));§game.addEffect(effect, source);§}§for (UUID playerId: game.getState().getPlayersInRange(source.getControllerId(), game)) {§Player player = game.getPlayer(playerId);§if (player != null) {§effect.setTargetPointer(new FixedTarget(player.getId()));§game.addEffect(effect, source);§}§}§return false;§}§}§
public class KodamaOfTheCenterTree extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("Spirits you control");§static {§filter.add(new SubtypePredicate("Spirit"));§}§public KodamaOfTheCenterTree(UUID ownerId) {§super(ownerId, 131, "Kodama of the Center Tree", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{G}");§this.expansionSetCode = "BOK";§this.supertype.add("Legendary");§this.subtype.add("Spirit");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§this.addAbility(new SimpleStaticAbility(Zone.ALL, new SetPowerToughnessSourceEffect(new PermanentsOnBattlefieldCount(filter), Duration.EndOfGame)));§this.addAbility(new SoulshiftAbility(new PermanentsOnBattlefieldCount(filter)));§}§public KodamaOfTheCenterTree(final KodamaOfTheCenterTree card) {§super(card);§}§@Override§public KodamaOfTheCenterTree copy() {§return new KodamaOfTheCenterTree(this);§}§}§
public class KumanosBlessing extends CardImpl {§public KumanosBlessing(UUID ownerId) {§super(ownerId, 111, "Kumano's Blessing", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{R}");§this.expansionSetCode = "BOK";§this.subtype.add("Aura");§this.addAbility(FlashAbility.getInstance());§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.Benefit));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new KumanosBlessingEffect()), new DamagedByEnchantedWatcher());§}§public KumanosBlessing(final KumanosBlessing card) {§super(card);§}§@Override§public KumanosBlessing copy() {§return new KumanosBlessing(this);§}§}§class KumanosBlessingEffect extends ReplacementEffectImpl {§public KumanosBlessingEffect() {§super(Duration.WhileOnBattlefield, Outcome.Exile);§staticText = "If a creature dealt damage by enchanted creature this turn would die, exile it instead";§}§public KumanosBlessingEffect(final KumanosBlessingEffect effect) {§super(effect);§}§@Override§public KumanosBlessingEffect copy() {§return new KumanosBlessingEffect(this);§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§Permanent permanent = ((ZoneChangeEvent)event).getTarget();§Player controller = game.getPlayer(source.getControllerId());§if (controller != null && permanent != null) {§return controller.moveCardToExileWithInfo(permanent, null, null, source.getSourceId(), game, Zone.BATTLEFIELD, true);§}§return false;§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == EventType.ZONE_CHANGE;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§ZoneChangeEvent zce = (ZoneChangeEvent) event;§if (zce.isDiesEvent()) {§DamagedByEnchantedWatcher watcher = (DamagedByEnchantedWatcher) game.getState().getWatchers().get("DamagedByEnchantedWatcher", source.getSourceId());§if (watcher != null) {§return watcher.wasDamaged(zce.getTarget(), game);§}§}§return false;§}§}§class DamagedByEnchantedWatcher extends Watcher {§private final Set<MageObjectReference> damagedCreatures = new HashSet<>();§public DamagedByEnchantedWatcher() {§super("DamagedByEnchantedWatcher", WatcherScope.CARD);§}§public DamagedByEnchantedWatcher(final DamagedByEnchantedWatcher watcher) {§super(watcher);§this.damagedCreatures.addAll(watcher.damagedCreatures);§}§@Override§public DamagedByEnchantedWatcher copy() {§return new DamagedByEnchantedWatcher(this);§}§@Override§public void watch(GameEvent event, Game game) {§if (event.getType() == EventType.DAMAGED_CREATURE) {§Permanent enchantment = game.getPermanent(this.getSourceId());§if (enchantment != null && enchantment.getAttachedTo() != null) {§if (enchantment.getAttachedTo().equals(event.getSourceId())) {§MageObjectReference mor = new MageObjectReference(event.getTargetId(), game);§if (!damagedCreatures.contains(mor)) {§damagedCreatures.add(mor);§}§}§}§}§}§@Override§public void reset() {§super.reset();§damagedCreatures.clear();§}§public boolean wasDamaged(Permanent permanent, Game game) {§return damagedCreatures.contains(new MageObjectReference(permanent, game));§}§}§
public class KyokiSanitysEclipse extends CardImpl {§public KyokiSanitysEclipse(UUID ownerId) {§super(ownerId, 72, "Kyoki, Sanity's Eclipse", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{B}{B}");§this.expansionSetCode = "BOK";§this.supertype.add("Legendary");§this.subtype.add("Demon");§this.subtype.add("Spirit");§this.power = new MageInt(6);§this.toughness = new MageInt(4);§Ability ability = new SpellCastControllerTriggeredAbility(new ExileFromZoneTargetEffect(Zone.HAND, null, "", new FilterCard()), new FilterSpiritOrArcaneCard(), false);§ability.addTarget(new TargetOpponent());§this.addAbility(ability);§}§public KyokiSanitysEclipse(final KyokiSanitysEclipse card) {§super(card);§}§@Override§public KyokiSanitysEclipse copy() {§return new KyokiSanitysEclipse(this);§}§}§
public class Lifegift extends CardImpl {§public Lifegift(UUID ownerId) {§super(ownerId, 132, "Lifegift", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{2}{G}");§this.expansionSetCode = "BOK";§this.addAbility(new EntersBattlefieldAllTriggeredAbility(Zone.BATTLEFIELD, new GainLifeEffect(1), new FilterLandPermanent("a land"), true));§}§public Lifegift(final Lifegift card) {§super(card);§}§@Override§public Lifegift copy() {§return new Lifegift(this);§}§}§
public class Lifespinner extends CardImpl {§private static final FilterPermanentCard filter = new FilterPermanentCard("legendary Spirit permanent card");§static {§filter.add(new SupertypePredicate("Legendary"));§filter.add(new SubtypePredicate("Spirit"));§}§public Lifespinner(UUID ownerId) {§super(ownerId, 133, "Lifespinner", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{G}");§this.expansionSetCode = "BOK";§this.subtype.add("Spirit");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§SimpleActivatedAbility ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,§new SearchLibraryPutInPlayEffect(new TargetCardInLibrary(filter)),§new TapSourceCost());§ability.addCost(new SacrificeTargetCost(new TargetControlledPermanent(3, 3, new FilterControlledCreaturePermanent("Spirit", "three Spirits"), false)));§this.addAbility(ability);§}§public Lifespinner(final Lifespinner card) {§super(card);§}§@Override§public Lifespinner copy() {§return new Lifespinner(this);§}§}§
public class LoamDweller extends CardImpl {§public LoamDweller(UUID ownerId) {§super(ownerId, 134, "Loam Dweller", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "BOK";§this.subtype.add("Spirit");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new SpellCastControllerTriggeredAbility(new PutLandFromHandOntoBattlefieldEffect(true), new FilterSpiritOrArcaneCard(), true));§}§public LoamDweller(final LoamDweller card) {§super(card);§}§@Override§public LoamDweller copy() {§return new LoamDweller(this);§}§}§
public class MannichiTheFeveredDream extends CardImpl {§public MannichiTheFeveredDream(UUID ownerId) {§super(ownerId, 112, "Mannichi, the Fevered Dream", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "BOK";§this.supertype.add("Legendary");§this.subtype.add("Spirit");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new SwitchPowerToughnessAllEffect(Duration.EndOfTurn), new ManaCostsImpl("{1}{R}")));§}§public MannichiTheFeveredDream(final MannichiTheFeveredDream card) {§super(card);§}§@Override§public MannichiTheFeveredDream copy() {§return new MannichiTheFeveredDream(this);§}§}§
public class MarkOfSakiko extends CardImpl {§public MarkOfSakiko(UUID ownerId) {§super(ownerId, 135, "Mark of Sakiko", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{G}");§this.expansionSetCode = "BOK";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§Effect effect = new GainAbilityAttachedEffect(new MarkOfSakikoTriggeredAbility(), AttachmentType.AURA);§effect.setText("Enchanted creature has \"Whenever this creature deals combat damage to a player, add that much {G} to your mana pool. Until end of turn, this mana doesn't empty from your mana pool as steps and phases end.\"");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, effect));§}§public MarkOfSakiko(final MarkOfSakiko card) {§super(card);§}§@Override§public MarkOfSakiko copy() {§return new MarkOfSakiko(this);§}§}§class MarkOfSakikoTriggeredAbility extends TriggeredAbilityImpl {§public MarkOfSakikoTriggeredAbility() {§super(Zone.BATTLEFIELD, null, false);§}§public MarkOfSakikoTriggeredAbility(final MarkOfSakikoTriggeredAbility ability) {§super(ability);§}§@Override§public MarkOfSakikoTriggeredAbility copy() {§return new MarkOfSakikoTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.DAMAGED_PLAYER;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (((DamagedEvent) event).isCombatDamage()) {§if (event.getSourceId().equals(getSourceId())) {§this.getEffects().clear();§Effect effect = new AddManaToManaPoolTargetControllerEffect(new Mana(0,event.getAmount(),0,0,0,0,0, 0), "that player", true);§effect.setTargetPointer(new FixedTarget(getControllerId()));§effect.setText("add that much {G} to your mana pool. Until end of turn, this mana doesn't empty from your mana pool as steps and phases end");§this.addEffect(effect);§return true;§}§}§return false;§}§@Override§public String getRule() {§return "Whenever this creature deals combat damage to a player, add that much {G} to your mana pool. Until end of turn, this mana doesn't empty from your mana pool as steps and phases end.";§}§}§
public class MarkOfTheOni extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("if you control no Demons");§static {§filter.add(new SubtypePredicate("Demon"));§}§public MarkOfTheOni(UUID ownerId) {§super(ownerId, 73, "Mark of the Oni", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{B}");§this.expansionSetCode = "BOK";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.GainControl));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new ControlEnchantedEffect()));§this.addAbility(new BeginningOfEndStepTriggeredAbility(Zone.BATTLEFIELD,§new SacrificeSourceEffect(),§TargetController.ANY,§new PermanentsOnTheBattlefieldCondition(filter, PermanentsOnTheBattlefieldCondition.CountType.FEWER_THAN, 1),§false));§}§public MarkOfTheOni(final MarkOfTheOni card) {§super(card);§}§@Override§public MarkOfTheOni copy() {§return new MarkOfTheOni(this);§}§}§
public class MatsuTribeSniper extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature with flying");§static {§filter.add(new AbilityPredicate(FlyingAbility.class));§}§public MatsuTribeSniper(UUID ownerId) {§super(ownerId, 136, "Matsu-Tribe Sniper", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "BOK";§this.subtype.add("Snake");§this.subtype.add("Warrior");§this.subtype.add("Archer");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(1), new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent(filter));§this.addAbility(ability);§ability = new DealsDamageToACreatureTriggeredAbility(new TapTargetEffect("that creature"), false, false, true);§ability.addEffect(new DontUntapInControllersNextUntapStepTargetEffect("and it"));§this.addAbility(ability);§}§public MatsuTribeSniper(final MatsuTribeSniper card) {§super(card);§}§@Override§public MatsuTribeSniper copy() {§return new MatsuTribeSniper(this);§}§}§
public class MendingHands extends CardImpl {§public MendingHands(UUID ownerId) {§super(ownerId, 15, "Mending Hands", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{W}");§this.expansionSetCode = "BOK";§this.getSpellAbility().addEffect(new PreventDamageToTargetEffect(Duration.EndOfTurn, 4));§this.getSpellAbility().addTarget(new TargetCreatureOrPlayer());§}§public MendingHands(final MendingHands card) {§super(card);§}§@Override§public MendingHands copy() {§return new MendingHands(this);§}§}§
public class MinamoSightbender extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature with power X or less");§private final UUID originalId;§public MinamoSightbender(UUID ownerId) {§super(ownerId, 41, "Minamo Sightbender", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{U}");§this.expansionSetCode = "BOK";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new CantBeBlockedTargetEffect(), new ManaCostsImpl("{X}"));§Target target = new TargetCreaturePermanent(filter);§ability.addTarget(target);§ability.addCost(new TapSourceCost());§originalId = ability.getOriginalId();§this.addAbility(ability);§}§@Override§public void adjustTargets(Ability ability, Game game) {§if (ability.getOriginalId().equals(originalId)) {§for (Effect effect : ability.getEffects()) {§if (effect instanceof CantBeBlockedTargetEffect) {§int manaX = ability.getManaCostsToPay().getX();§ability.getTargets().clear();§FilterCreaturePermanent newFilter = new FilterCreaturePermanent(new StringBuilder("creature with power ").append(manaX).append(" or less").toString());§filter.add(new PowerPredicate(Filter.ComparisonType.LessThan, manaX + 1));§Target target = new TargetCreaturePermanent(newFilter);§ability.addTarget(target);§break;§}§}§}§}§public MinamoSightbender(final MinamoSightbender card) {§super(card);§this.originalId = card.originalId;§}§@Override§public MinamoSightbender copy() {§return new MinamoSightbender(this);§}§}§
public class MinamosMeddling extends CardImpl {§public MinamosMeddling(UUID ownerId) {§super(ownerId, 42, "Minamo's Meddling", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{U}{U}");§this.expansionSetCode = "BOK";§this.getSpellAbility().addTarget(new TargetSpell(new FilterSpell()));§this.getSpellAbility().addEffect(new MinamosMeddlingCounterTargetEffect());§}§public MinamosMeddling(final MinamosMeddling card) {§super(card);§}§@Override§public MinamosMeddling copy() {§return new MinamosMeddling(this);§}§}§class MinamosMeddlingCounterTargetEffect extends OneShotEffect {§public MinamosMeddlingCounterTargetEffect() {§super(Outcome.Benefit);§staticText = "Counter target spell. That spell's controller reveals his or her hand, then discards each card with the same name as a card spliced onto that spell";§}§public MinamosMeddlingCounterTargetEffect(final MinamosMeddlingCounterTargetEffect effect) {§super(effect);§}§@Override§public MinamosMeddlingCounterTargetEffect copy() {§return new MinamosMeddlingCounterTargetEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§MageObject sourceObject = game.getObject(source.getSourceId());§if (sourceObject != null) {§for (UUID targetId : getTargetPointer().getTargets(game, source) ) {§Spell spell = game.getStack().getSpell(targetId);§if (spell != null) {§game.getStack().counter(targetId, source.getSourceId(), game);§Player spellController = game.getPlayer(spell.getControllerId());§if (spellController != null) {§spellController.revealCards(sourceObject.getName(), spellController.getHand(), game);§Cards cardsToDiscard = new CardsImpl();§for (SpellAbility spellAbility : spell.getSpellAbilities()) {§if (spellAbility.getSpellAbilityType().equals(SpellAbilityType.SPLICE)) {§for (Card card: spellController.getHand().getCards(game)) {§if (card.getName().equals(spellAbility.getCardName()) && !cardsToDiscard.contains(card.getId())) {§cardsToDiscard.add(card);§}§}§}§}§if (!cardsToDiscard.isEmpty()) {§for (Card card :cardsToDiscard.getCards(game)) {§spellController.discard(card, source, game);§}§}§}§}§}§return true;§}§return false;§}§}§
public class MirrorGallery extends CardImpl {§public MirrorGallery(UUID ownerId) {§super(ownerId, 154, "Mirror Gallery", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{5}");§this.expansionSetCode = "BOK";§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new MirrorGalleryRuleEffect()));§}§public MirrorGallery(final MirrorGallery card) {§super(card);§}§@Override§public MirrorGallery copy() {§return new MirrorGallery(this);§}§}§class MirrorGalleryRuleEffect extends ContinuousEffectImpl {§public MirrorGalleryRuleEffect() {§super(Duration.WhileOnBattlefield, Outcome.Detriment);§staticText = "The \"legend rule\" doesn't apply";§}§public MirrorGalleryRuleEffect(final MirrorGalleryRuleEffect effect) {§super(effect);§}§@Override§public MirrorGalleryRuleEffect copy() {§return new MirrorGalleryRuleEffect(this);§}§@Override§public boolean apply(Layer layer, SubLayer sublayer, Ability source, Game game) {§game.getState().setLegendaryRuleActive(false);§return true;§}§@Override§public boolean apply(Game game, Ability source) {§return false;§}§@Override§public boolean hasLayer(Layer layer) {§return layer == Layer.RulesEffects;§}§}§
public class MistbladeShinobi extends CardImpl {§public MistbladeShinobi(UUID ownerId) {§super(ownerId, 43, "Mistblade Shinobi", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{U}");§this.expansionSetCode = "BOK";§this.subtype.add("Human");§this.subtype.add("Ninja");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new NinjutsuAbility(new ManaCostsImpl("{U}")));§this.addAbility(new MistbladeShinobiTriggeredAbility());§}§public MistbladeShinobi(final MistbladeShinobi card) {§super(card);§}§@Override§public MistbladeShinobi copy() {§return new MistbladeShinobi(this);§}§}§class MistbladeShinobiTriggeredAbility extends TriggeredAbilityImpl {§MistbladeShinobiTriggeredAbility() {§super(Zone.BATTLEFIELD, new ReturnToHandTargetEffect(), true);§}§MistbladeShinobiTriggeredAbility(final MistbladeShinobiTriggeredAbility ability) {§super(ability);§}§@Override§public MistbladeShinobiTriggeredAbility copy() {§return new MistbladeShinobiTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.DAMAGED_PLAYER;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (((DamagedPlayerEvent) event).isCombatDamage()§&& event.getSourceId().equals(sourceId)) {§Player opponent = game.getPlayer(event.getPlayerId());§if (opponent != null) {§FilterCreaturePermanent filter = new FilterCreaturePermanent("creature " + opponent.getLogName() + " controls");§filter.add(new ControllerIdPredicate(opponent.getId()));§this.getTargets().clear();§this.addTarget(new TargetCreaturePermanent(filter));§return true;§}§}§return false;§}§@Override§public String getRule() {§return "Whenever {this} deals combat damage to a player, you may return target creature that player controls to its owner's hand.";§}§}§
public class NezumiShadowWatcher extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("Ninja");§static {§filter.add(new SubtypePredicate("Ninja"));§}§public NezumiShadowWatcher(UUID ownerId) {§super(ownerId, 74, "Nezumi Shadow-Watcher", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{B}");§this.expansionSetCode = "BOK";§this.subtype.add("Rat");§this.subtype.add("Warrior");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DestroyTargetEffect(), new SacrificeSourceCost());§ability.addTarget(new TargetPermanent(filter));§this.addAbility(ability);§}§public NezumiShadowWatcher(final NezumiShadowWatcher card) {§super(card);§}§@Override§public NezumiShadowWatcher copy() {§return new NezumiShadowWatcher(this);§}§}§
public class NinjaOfTheDeepHours extends CardImpl {§public NinjaOfTheDeepHours(UUID ownerId) {§super(ownerId, 44, "Ninja of the Deep Hours", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{U}");§this.expansionSetCode = "BOK";§this.subtype.add("Human");§this.subtype.add("Ninja");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new NinjutsuAbility(new ManaCostsImpl("{1}{U}")));§this.addAbility(new DealsCombatDamageToAPlayerTriggeredAbility(new DrawCardSourceControllerEffect(1), true, false));§}§public NinjaOfTheDeepHours(final NinjaOfTheDeepHours card) {§super(card);§}§@Override§public NinjaOfTheDeepHours copy() {§return new NinjaOfTheDeepHours(this);§}§}§
public class NourishingShoal extends CardImpl {§public NourishingShoal(UUID ownerId) {§super(ownerId, 137, "Nourishing Shoal", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{X}{G}{G}");§this.expansionSetCode = "BOK";§this.subtype.add("Arcane");§FilterOwnedCard filter = new FilterOwnedCard("a green card with converted mana cost X from your hand");§filter.add(new ColorPredicate(ObjectColor.GREEN));§filter.add(Predicates.not(new CardIdPredicate(this.getId()))); §
public class OgreMarauder extends CardImpl {§public OgreMarauder(UUID ownerId) {§super(ownerId, 75, "Ogre Marauder", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{B}{B}");§this.expansionSetCode = "BOK";§this.subtype.add("Ogre");§this.subtype.add("Warrior");§this.power = new MageInt(3);§this.toughness = new MageInt(1);§this.addAbility(new AttacksTriggeredAbility(new OgreMarauderEffect(), false));§}§public OgreMarauder(final OgreMarauder card) {§super(card);§}§@Override§public OgreMarauder copy() {§return new OgreMarauder(this);§}§}§class OgreMarauderEffect extends OneShotEffect {§public OgreMarauderEffect() {§super(Outcome.Benefit);§this.staticText = "it gains \"{this} can't be blocked\" until end of turn unless defending player sacrifices a creature";§}§public OgreMarauderEffect(final OgreMarauderEffect effect) {§super(effect);§}§@Override§public OgreMarauderEffect copy() {§return new OgreMarauderEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§UUID defendingPlayerId = game.getCombat().getDefendingPlayerId(source.getSourceId(), game);§MageObject sourceObject = game.getObject(source.getSourceId());§Player defender = game.getPlayer(defendingPlayerId);§if (defender != null && sourceObject != null) {§Cost cost = new SacrificeTargetCost(new TargetControlledCreaturePermanent());§if (cost.canPay(source, source.getSourceId(), defendingPlayerId, game) &&§defender.chooseUse(Outcome.LoseAbility, "Sacrifice a creature to prevent that " + sourceObject.getLogName() + " can't be blocked?", source, game)) {§if (!cost.pay(source, game, source.getSourceId(), defendingPlayerId, false, null)) {§ContinuousEffect effect = new CantBeBlockedSourceEffect(Duration.EndOfTurn);§game.addEffect(effect, source);§}§}§return true;§}§return false;§}§}§
public class OgreRecluse extends CardImpl {§public OgreRecluse(UUID ownerId) {§super(ownerId, 113, "Ogre Recluse", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{R}");§this.expansionSetCode = "BOK";§this.subtype.add("Ogre");§this.subtype.add("Warrior");§this.power = new MageInt(5);§this.toughness = new MageInt(4);§this.addAbility(new SpellCastAllTriggeredAbility(new TapSourceEffect(), false));§}§public OgreRecluse(final OgreRecluse card) {§super(card);§}§@Override§public OgreRecluse copy() {§return new OgreRecluse(this);§}§}§
public class OkibaGangShinobi extends CardImpl {§public OkibaGangShinobi(UUID ownerId) {§super(ownerId, 76, "Okiba-Gang Shinobi", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{B}{B}");§this.expansionSetCode = "BOK";§this.subtype.add("Rat");§this.subtype.add("Ninja");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§this.addAbility(new NinjutsuAbility(new ManaCostsImpl("{3}{B}")));§this.addAbility(new DealsCombatDamageToAPlayerTriggeredAbility(new DiscardTargetEffect(2), false, true));§}§public OkibaGangShinobi(final OkibaGangShinobi card) {§super(card);§}§@Override§public OkibaGangShinobi copy() {§return new OkibaGangShinobi(this);§}§}§
public class OpalEyeKondasYojimbo extends CardImpl {§public OpalEyeKondasYojimbo(UUID ownerId) {§super(ownerId, 17, "Opal-Eye, Konda's Yojimbo", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{W}{W}");§this.expansionSetCode = "BOK";§this.supertype.add("Legendary");§this.subtype.add("Fox");§this.subtype.add("Samurai");§this.power = new MageInt(1);§this.toughness = new MageInt(4);§this.addAbility(DefenderAbility.getInstance());§this.addAbility(new BushidoAbility(1));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new OpalEyeKondasYojimboRedirectionEffect(), new TapSourceCost());§ability.addTarget(new TargetSource());§this.addAbility(ability);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new PreventDamageToSourceEffect(Duration.EndOfTurn, 1), new ManaCostsImpl("{1}{W}")));§}§public OpalEyeKondasYojimbo(final OpalEyeKondasYojimbo card) {§super(card);§}§@Override§public OpalEyeKondasYojimbo copy() {§return new OpalEyeKondasYojimbo(this);§}§}§class OpalEyeKondasYojimboRedirectionEffect extends ReplacementEffectImpl {§private final TargetSource target;§OpalEyeKondasYojimboRedirectionEffect() {§super(Duration.EndOfTurn, Outcome.RedirectDamage);§staticText = "The next time a source of your choice would deal damage this turn, that damage is dealt to {this} instead";§this.target = new TargetSource();§}§OpalEyeKondasYojimboRedirectionEffect(final OpalEyeKondasYojimboRedirectionEffect effect) {§super(effect);§this.target = effect.target.copy();§}§@Override§public void init(Ability source, Game game) {§this.target.choose(Outcome.PreventDamage, source.getControllerId(), source.getSourceId(), game);§super.init(source, game);§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType().equals(GameEvent.EventType.DAMAGE_CREATURE ) ||§event.getType().equals(GameEvent.EventType.DAMAGE_PLANESWALKER ) ||§event.getType().equals(GameEvent.EventType.DAMAGE_PLAYER );§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§if (event.getSourceId().equals(target.getFirstTarget())) {§MageObject object = game.getObject(event.getSourceId());§if (object == null) {§game.informPlayers("Couldn't find source of damage");§return false;§}§return true;§}§return false;§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§DamageEvent damageEvent = (DamageEvent)event;§Permanent sourcePermanent = game.getPermanent(source.getSourceId());§if (sourcePermanent != null) {§Permanent targetPermanent = game.getPermanent(event.getTargetId());§StringBuilder message = new StringBuilder();§message.append(sourcePermanent.getName()).append(": gets ");§message.append(damageEvent.getAmount()).append(" damage redirected from ");§if (targetPermanent != null) {§message.append(targetPermanent.getName());§}§else {§Player targetPlayer = game.getPlayer(event.getTargetId());§if (targetPlayer != null) {§message.append(targetPlayer.getLogName());§}§else {§message.append("unknown");§}§}§game.informPlayers(message.toString());§discard();§sourcePermanent.damage(damageEvent.getAmount(), damageEvent.getSourceId(), game, damageEvent.isCombatDamage(), damageEvent.isPreventable(), event.getAppliedEffects());§return true;§}§return false;§}§@Override§public OpalEyeKondasYojimboRedirectionEffect copy() {§return new OpalEyeKondasYojimboRedirectionEffect(this);§}§}§
public class OrbOfDreams extends CardImpl {§public OrbOfDreams(UUID ownerId) {§super(ownerId, 156, "Orb of Dreams", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "BOK";§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new OrbOfDreamsEffect()));§}§public OrbOfDreams(final OrbOfDreams card) {§super(card);§}§@Override§public OrbOfDreams copy() {§return new OrbOfDreams(this);§}§private class OrbOfDreamsEffect extends ReplacementEffectImpl {§OrbOfDreamsEffect() {§super(Duration.WhileOnBattlefield, Outcome.Tap, false);§staticText = "Permanents enter the battlefield tapped";§}§OrbOfDreamsEffect(final OrbOfDreamsEffect effect) {§super(effect);§}§@Override§public OrbOfDreamsEffect copy() {§return new OrbOfDreamsEffect(this);§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§Permanent permanent = ((EntersTheBattlefieldEvent) event).getTarget();§if (permanent != null) {§permanent.setTapped(true);§}§return false;§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.ENTERS_THE_BATTLEFIELD;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§return true;§}§}§}§
public class OrnateKanzashi extends CardImpl {§public OrnateKanzashi(UUID ownerId) {§super(ownerId, 157, "Ornate Kanzashi", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{5}");§this.expansionSetCode = "BOK";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new OrnateKanzashiEffect(), new GenericManaCost(2));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetOpponent());§this.addAbility(ability);§}§public OrnateKanzashi(final OrnateKanzashi card) {§super(card);§}§@Override§public OrnateKanzashi copy() {§return new OrnateKanzashi(this);§}§}§class OrnateKanzashiEffect extends OneShotEffect {§public OrnateKanzashiEffect() {§super(Outcome.Detriment);§this.staticText = "Target opponent exiles the top card of his or her library. You may play that card this turn";§}§public OrnateKanzashiEffect(final OrnateKanzashiEffect effect) {§super(effect);§}§@Override§public OrnateKanzashiEffect copy() {§return new OrnateKanzashiEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player opponent = game.getPlayer(targetPointer.getFirst(game, source));§MageObject sourceObject = game.getObject(source.getSourceId());§if (sourceObject != null && opponent != null) {§if (opponent.getLibrary().size() > 0) {§Library library = opponent.getLibrary();§Card card = library.getFromTop(game);§if (card != null) {§opponent.moveCardToExileWithInfo(card, source.getSourceId(), sourceObject.getName(), source.getSourceId(), game, Zone.LIBRARY, true);§ContinuousEffect effect = new OrnateKanzashiCastFromExileEffect();§effect.setTargetPointer(new FixedTarget(card.getId()));§game.addEffect(effect, source);§}§}§return true;§}§return false;§}§}§class OrnateKanzashiCastFromExileEffect extends AsThoughEffectImpl {§public OrnateKanzashiCastFromExileEffect() {§super(AsThoughEffectType.PLAY_FROM_NOT_OWN_HAND_ZONE, Duration.EndOfTurn, Outcome.Benefit);§staticText = "You may play that card from exile this turn";§}§public OrnateKanzashiCastFromExileEffect(final OrnateKanzashiCastFromExileEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public OrnateKanzashiCastFromExileEffect copy() {§return new OrnateKanzashiCastFromExileEffect(this);§}§@Override§public boolean applies(UUID objectId, Ability source, UUID affectedControllerId, Game game) {§return source.getControllerId().equals(affectedControllerId)§&& objectId.equals(getTargetPointer().getFirst(game, source));§}§}§
public class Overblaze extends CardImpl {§public Overblaze(UUID ownerId) {§super(ownerId, 114, "Overblaze", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{3}{R}");§this.expansionSetCode = "BOK";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new FireServantEffect());§this.getSpellAbility().addTarget(new TargetPermanent());§this.addAbility(new SpliceOntoArcaneAbility("{2}{R}{R}"));§}§public Overblaze(final Overblaze card) {§super(card);§}§@Override§public Overblaze copy() {§return new Overblaze(this);§}§}§class FireServantEffect extends ReplacementEffectImpl {§public FireServantEffect() {§super(Duration.EndOfTurn, Outcome.Damage);§staticText = "Each time target permanent would deal damage to a creature or player this turn, it deals double that damage to that creature or player instead.";§}§public FireServantEffect(final FireServantEffect effect) {§super(effect);§}§@Override§public FireServantEffect copy() {§return new FireServantEffect(this);§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType().equals(GameEvent.EventType.DAMAGE_CREATURE) ||§event.getType().equals(GameEvent.EventType.DAMAGE_PLAYER);§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§return event.getSourceId().equals(this.getTargetPointer().getFirst(game, source));§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§event.setAmount(event.getAmount() * 2);§return false;§}§}§
public class OyobiWhoSplitTheHeavens extends CardImpl {§private static final FilterSpiritOrArcaneCard filter = new FilterSpiritOrArcaneCard();§public OyobiWhoSplitTheHeavens(UUID ownerId) {§super(ownerId, 18, "Oyobi, Who Split the Heavens", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{6}{W}");§this.expansionSetCode = "BOK";§this.supertype.add("Legendary");§this.subtype.add("Spirit");§this.power = new MageInt(3);§this.toughness = new MageInt(6);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new SpellCastControllerTriggeredAbility(new CreateTokenEffect(new AnotherSpiritToken()), filter, false));§}§public OyobiWhoSplitTheHeavens(final OyobiWhoSplitTheHeavens card) {§super(card);§}§@Override§public OyobiWhoSplitTheHeavens copy() {§return new OyobiWhoSplitTheHeavens(this);§}§}§class AnotherSpiritToken extends Token {§AnotherSpiritToken() {§super("Spirit", "3/3 white Spirit creature token with flying");§cardType.add(CardType.CREATURE);§color.setWhite(true);§subtype.add("Spirit");§power = new MageInt(3);§toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§}§}§
public class PatronOfTheAkki extends CardImpl {§public PatronOfTheAkki(UUID ownerId) {§super(ownerId, 115, "Patron of the Akki", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{R}{R}");§this.expansionSetCode = "BOK";§this.supertype.add("Legendary");§this.subtype.add("Spirit");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(new OfferingAbility("Goblin"));§this.addAbility(new AttacksTriggeredAbility(new BoostControlledEffect(2, 0, Duration.EndOfTurn, new FilterCreaturePermanent(), false), false));§}§public PatronOfTheAkki(final PatronOfTheAkki card) {§super(card);§}§@Override§public PatronOfTheAkki copy() {§return new PatronOfTheAkki(this);§}§}§
public class PatronOfTheKitsune extends CardImpl {§public PatronOfTheKitsune(UUID ownerId) {§super(ownerId, 19, "Patron of the Kitsune", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{W}{W}");§this.expansionSetCode = "BOK";§this.supertype.add("Legendary");§this.subtype.add("Spirit");§this.power = new MageInt(5);§this.toughness = new MageInt(6);§this.addAbility(new OfferingAbility("Fox"));§this.addAbility(new AttacksAllTriggeredAbility(new GainLifeEffect(1), true));§}§public PatronOfTheKitsune(final PatronOfTheKitsune card) {§super(card);§}§@Override§public PatronOfTheKitsune copy() {§return new PatronOfTheKitsune(this);§}§}§
public class PatronOfTheMoon extends CardImpl {§public PatronOfTheMoon(UUID ownerId) {§super(ownerId, 45, "Patron of the Moon", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}{U}{U}");§this.expansionSetCode = "BOK";§this.supertype.add("Legendary");§this.subtype.add("Spirit");§this.power = new MageInt(5);§this.toughness = new MageInt(4);§this.addAbility(new OfferingAbility("Moonfolk"));§this.addAbility(FlyingAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new PatronOfTheMoonEffect(), new ManaCostsImpl("{1}"));§this.addAbility(ability);§}§public PatronOfTheMoon(final PatronOfTheMoon card) {§super(card);§}§@Override§public PatronOfTheMoon copy() {§return new PatronOfTheMoon(this);§}§}§class PatronOfTheMoonEffect extends OneShotEffect {§PatronOfTheMoonEffect() {§super(Outcome.PutLandInPlay);§staticText = "Put up to two land cards from your hand onto the battlefield tapped";§}§PatronOfTheMoonEffect(final PatronOfTheMoonEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§TargetCard target = new TargetCardInHand(0, 2, new FilterLandCard("up to two land cards to put onto the battlefield tapped"));§controller.chooseTarget(outcome, controller.getHand(), target, source, game);§return controller.moveCards(new CardsImpl(target.getTargets()).getCards(game),§Zone.BATTLEFIELD, source, game, true, false, false, null);§}§return false;§}§@Override§public PatronOfTheMoonEffect copy() {§return new PatronOfTheMoonEffect(this);§}§}§
public class PatronOfTheNezumi extends CardImpl {§public PatronOfTheNezumi(UUID ownerId) {§super(ownerId, 77, "Patron of the Nezumi", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}{B}{B}");§this.expansionSetCode = "BOK";§this.supertype.add("Legendary");§this.subtype.add("Spirit");§this.power = new MageInt(6);§this.toughness = new MageInt(6);§this.addAbility(new OfferingAbility("Rat"));§this.addAbility(new PatronOfTheNezumiTriggeredAbility(new LoseLifeTargetEffect(1)));§}§public PatronOfTheNezumi(final PatronOfTheNezumi card) {§super(card);§}§@Override§public PatronOfTheNezumi copy() {§return new PatronOfTheNezumi(this);§}§}§class PatronOfTheNezumiTriggeredAbility extends TriggeredAbilityImpl {§public PatronOfTheNezumiTriggeredAbility(Effect effect) {§super(Zone.BATTLEFIELD, effect, false);§}§public PatronOfTheNezumiTriggeredAbility(final PatronOfTheNezumiTriggeredAbility ability) {§super(ability);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.ZONE_CHANGE;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§ZoneChangeEvent zEvent = (ZoneChangeEvent) event;§if (zEvent.getFromZone() == Zone.BATTLEFIELD§&& zEvent.getToZone() == Zone.GRAVEYARD) {§Card card = game.getCard(zEvent.getTargetId());§if (card != null && game.getOpponents(controllerId).contains(card.getOwnerId())) {§this.getEffects().get(0).setTargetPointer(new FixedTarget(zEvent.getPlayerId()));§return true;§}§}§return false;§}§@Override§public String getRule() {§return "Whenever a permanent is put into an opponent's graveyard, that player loses 1 life.";§}§@Override§public PatronOfTheNezumiTriggeredAbility copy() {§return new PatronOfTheNezumiTriggeredAbility(this);§}§}§
public class PatronOfTheOrochi extends CardImpl {§public PatronOfTheOrochi(UUID ownerId) {§super(ownerId, 138, "Patron of the Orochi", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{6}{G}{G}");§this.expansionSetCode = "BOK";§this.supertype.add("Legendary");§this.subtype.add("Spirit");§this.power = new MageInt(7);§this.toughness = new MageInt(7);§this.addAbility(new OfferingAbility("Snake"));§this.addAbility(new LimitedTimesPerTurnActivatedAbility(Zone.BATTLEFIELD, new PatronOfTheOrochiEffect(), new TapSourceCost()));§}§public PatronOfTheOrochi(final PatronOfTheOrochi card) {§super(card);§}§@Override§public PatronOfTheOrochi copy() {§return new PatronOfTheOrochi(this);§}§}§class PatronOfTheOrochiEffect extends OneShotEffect {§private static final FilterPermanent filter = new FilterPermanent();§static {§filter.add(Predicates.or( new SubtypePredicate("Forest"),§Predicates.and(new CardTypePredicate(CardType.CREATURE),§new ColorPredicate(ObjectColor.GREEN))§));§}§public PatronOfTheOrochiEffect() {§super(Outcome.Untap);§staticText = "Untap all Forests and all green creatures";§}§public PatronOfTheOrochiEffect(final PatronOfTheOrochiEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§for (Permanent permanent: game.getBattlefield().getActivePermanents(filter, source.getControllerId(), source.getSourceId(), game)) {§permanent.untap(game);§}§return true;§}§return false;§}§@Override§public PatronOfTheOrochiEffect copy() {§return new PatronOfTheOrochiEffect(this);§}§}§
public class PetalmaneBaku extends CardImpl {§private static final FilterSpiritOrArcaneCard filter = new FilterSpiritOrArcaneCard();§public PetalmaneBaku(UUID ownerId) {§super(ownerId, 139, "Petalmane Baku", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "BOK";§this.subtype.add("Spirit");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§this.addAbility(new SpellCastControllerTriggeredAbility(new AddCountersSourceEffect(CounterType.KI.createInstance()), filter, true));§Ability ability = new DynamicManaAbility(§new Mana(0, 0, 0, 0, 0, 0, 1, 0),§new RemovedCountersForCostValue(),§new ManaCostsImpl<>("{1}"),§"Add X mana of any one color to your mana pool",§true, new CountersCount(CounterType.KI));§ability.addCost(new RemoveVariableCountersSourceCost(CounterType.KI.createInstance(),§"Remove X ki counters from {this}"));§this.addAbility(ability);§}§public PetalmaneBaku(final PetalmaneBaku card) {§super(card);§}§@Override§public PetalmaneBaku copy() {§return new PetalmaneBaku(this);§}§private class PetalmaneBakuManaAbility extends BasicManaAbility {§PetalmaneBakuManaAbility() {§super(new PetalmaneBakuManaEffect());§this.addChoice(new ChoiceColor());§}§PetalmaneBakuManaAbility(final PetalmaneBakuManaAbility ability) {§super(ability);§}§@Override§public PetalmaneBakuManaAbility copy() {§return new PetalmaneBakuManaAbility(this);§}§}§private class PetalmaneBakuManaEffect extends ManaEffect {§PetalmaneBakuManaEffect() {§super();§staticText = "Add X mana of any one color to your mana pool";§}§PetalmaneBakuManaEffect(final PetalmaneBakuManaEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§ChoiceColor choice = (ChoiceColor) source.getChoices().get(0);§Player player = game.getPlayer(source.getControllerId());§if (player != null && choice != null) {§int numberOfMana = 0;§for (Cost cost : source.getCosts()) {§if (cost instanceof RemoveVariableCountersSourceCost) {§numberOfMana = ((RemoveVariableCountersSourceCost) cost).getAmount();§}§}§if (choice.getColor().isBlack()) {§player.getManaPool().addMana(new Mana(0, 0, 0, 0, numberOfMana, 0, 0, 0), game, source);§return true;§} else if (choice.getColor().isBlue()) {§player.getManaPool().addMana(new Mana(0, 0, numberOfMana, 0, 0, 0, 0, 0), game, source);§return true;§} else if (choice.getColor().isRed()) {§player.getManaPool().addMana(new Mana(numberOfMana, 0, 0, 0, 0, 0, 0, 0), game, source);§return true;§} else if (choice.getColor().isGreen()) {§player.getManaPool().addMana(new Mana(0, numberOfMana, 0, 0, 0, 0, 0, 0), game, source);§return true;§} else if (choice.getColor().isWhite()) {§player.getManaPool().addMana(new Mana(0, 0, 0, numberOfMana, 0, 0, 0, 0), game, source);§return true;§}§}§return false;§}§@Override§public Mana getMana(Game game, Ability source) {§return null;§}§@Override§public PetalmaneBakuManaEffect copy() {§return new PetalmaneBakuManaEffect(this);§}§}§}§
public class PhantomWings extends CardImpl {§public PhantomWings(UUID ownerId) {§super(ownerId, 46, "Phantom Wings", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{U}");§this.expansionSetCode = "BOK";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(FlyingAbility.getInstance(), AttachmentType.AURA)));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new PhantomWingsReturnEffect(), new SacrificeSourceCost()));§}§public PhantomWings(final PhantomWings card) {§super(card);§}§@Override§public PhantomWings copy() {§return new PhantomWings(this);§}§private class PhantomWingsReturnEffect extends OneShotEffect {§public PhantomWingsReturnEffect() {§super(Outcome.ReturnToHand);§staticText = "Return enchanted creature to its owner's hand";§}§public PhantomWingsReturnEffect(final PhantomWingsReturnEffect effect) {§super(effect);§}§@Override§public PhantomWingsReturnEffect copy() {§return new PhantomWingsReturnEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = (Permanent) game.getLastKnownInformation(source.getSourceId(), Zone.BATTLEFIELD);§if (permanent != null && permanent.getAttachedTo() != null)§{§Permanent enchantedCreature = game.getPermanent(permanent.getAttachedTo());§if (enchantedCreature != null) {§return enchantedCreature.moveToZone(Zone.HAND, source.getSourceId(), game, false);§}§}§return false;§}§}§}§
public class Quash extends CardImpl {§private static final FilterSpell filter = new FilterSpell("instant or sorcery spell");§static {§Predicates.or(§new CardTypePredicate(CardType.INSTANT),§new CardTypePredicate(CardType.SORCERY));§}§public Quash(UUID ownerId) {§super(ownerId, 47, "Quash", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{2}{U}{U}");§this.expansionSetCode = "BOK";§this.getSpellAbility().addTarget(new TargetSpell(filter));§this.getSpellAbility().addEffect(new CounterTargetAndSearchGraveyardHandLibraryEffect());§}§public Quash(final Quash card) {§super(card);§}§@Override§public Quash copy() {§return new Quash(this);§}§}§
public class QuillmaneBaku extends CardImpl {§private static final FilterSpiritOrArcaneCard filter = new FilterSpiritOrArcaneCard();§private final UUID originalId;§public QuillmaneBaku(UUID ownerId) {§super(ownerId, 48, "Quillmane Baku", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{U}");§this.expansionSetCode = "BOK";§this.subtype.add("Spirit");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new SpellCastControllerTriggeredAbility(new AddCountersSourceEffect(CounterType.KI.createInstance()), filter, true));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new QuillmaneBakuReturnEffect(), new GenericManaCost(1));§ability.addCost(new TapSourceCost());§ability.addCost(new RemoveVariableCountersSourceCost(CounterType.KI.createInstance(1)));§ability.addTarget(new TargetCreaturePermanent());§originalId = ability.getOriginalId();§this.addAbility(ability);§}§@Override§public void adjustTargets(Ability ability, Game game) {§if (ability.getOriginalId().equals(originalId)) {§int maxConvManaCost = 0;§for (Cost cost : ability.getCosts()) {§if (cost instanceof RemoveVariableCountersSourceCost) {§maxConvManaCost = ((RemoveVariableCountersSourceCost) cost).getAmount();§}§}§ability.getTargets().clear();§FilterCreaturePermanent newFilter = new FilterCreaturePermanent("creature with converted mana cost " + maxConvManaCost + " or less");§newFilter.add(new ConvertedManaCostPredicate(Filter.ComparisonType.LessThan, maxConvManaCost + 1));§TargetCreaturePermanent target = new TargetCreaturePermanent(newFilter);§ability.getTargets().add(target);§}§}§public QuillmaneBaku(final QuillmaneBaku card) {§super(card);§this.originalId = card.originalId;§}§@Override§public QuillmaneBaku copy() {§return new QuillmaneBaku(this);§}§class QuillmaneBakuReturnEffect extends OneShotEffect {§public QuillmaneBakuReturnEffect() {§super(Outcome.ReturnToHand);§this.staticText = "Return target creature with converted mana cost X or less to its owner's hand";§}§public QuillmaneBakuReturnEffect(final QuillmaneBakuReturnEffect effect) {§super(effect);§}§@Override§public QuillmaneBakuReturnEffect copy() {§return new QuillmaneBakuReturnEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller == null) {§return false;§}§Permanent permanent = game.getPermanent(this.getTargetPointer().getFirst(game, source));§if (permanent != null) {§controller.moveCards(permanent, null, Zone.HAND, source, game);§}§return true;§}§}§}§
public class ReduceToDreams extends CardImpl {§public ReduceToDreams(UUID ownerId) {§super(ownerId, 49, "Reduce to Dreams", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{3}{U}{U}");§this.expansionSetCode = "BOK";§this.getSpellAbility().addEffect(new ReduceToDreamsEffect());§}§public ReduceToDreams(final ReduceToDreams card) {§super(card);§}§@Override§public ReduceToDreams copy() {§return new ReduceToDreams(this);§}§}§class ReduceToDreamsEffect extends OneShotEffect {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("artifacts and enchantments");§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.ARTIFACT),§new CardTypePredicate(CardType.ENCHANTMENT)§));§}§public ReduceToDreamsEffect() {§super(Outcome.ReturnToHand);§staticText = "Return all artifacts and enchantments to their owners' hands";§}§public ReduceToDreamsEffect(final ReduceToDreamsEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§for (Permanent creature : game.getBattlefield().getActivePermanents(filter, source.getControllerId(), source.getSourceId(), game)) {§creature.moveToZone(Zone.HAND, source.getSourceId(), game, true);§}§return true;§}§@Override§public ReduceToDreamsEffect copy() {§return new ReduceToDreamsEffect(this);§}§}§
public class RibbonsOfTheReikai extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("Spirit you control");§static {§filter.add(new SubtypePredicate("Spirit"));§}§public RibbonsOfTheReikai(UUID ownerId) {§super(ownerId, 50, "Ribbons of the Reikai", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{4}{U}");§this.expansionSetCode = "BOK";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(new PermanentsOnBattlefieldCount(filter)));§}§public RibbonsOfTheReikai(final RibbonsOfTheReikai card) {§super(card);§}§@Override§public RibbonsOfTheReikai copy() {§return new RibbonsOfTheReikai(this);§}§}§
public class RoarOfJukai extends CardImpl {§public RoarOfJukai(UUID ownerId) {§super(ownerId, 140, "Roar of Jukai", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{G}");§this.expansionSetCode = "BOK";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new RoarOfJukaiEffect());§this.addAbility(new SpliceOntoArcaneAbility(new GainLifeOpponentCost(5)));§}§public RoarOfJukai(final RoarOfJukai card) {§super(card);§}§@Override§public RoarOfJukai copy() {§return new RoarOfJukai(this);§}§}§class RoarOfJukaiEffect extends OneShotEffect {§private static final FilterPermanent filter = new FilterPermanent("Forest");§private static final FilterCreaturePermanent filterBlocked = new FilterCreaturePermanent("blocked creature");§static {§filter.add(new SubtypePredicate("Forest"));§filterBlocked.add(new BlockedPredicate());§}§static {§}§public RoarOfJukaiEffect() {§super(Outcome.BoostCreature);§this.staticText = "If you control a Forest, each blocked creature gets +2/+2 until end of turn";§}§public RoarOfJukaiEffect(final RoarOfJukaiEffect effect) {§super(effect);§}§@Override§public RoarOfJukaiEffect copy() {§return new RoarOfJukaiEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§if (new PermanentsOnTheBattlefieldCondition(filter, CountType.MORE_THAN, 0).apply(game, source)) {§for(Permanent permanent : game.getBattlefield().getActivePermanents(filterBlocked, source.getControllerId(), source.getSourceId(), game)) {§ContinuousEffect effect = new BoostTargetEffect(2,2, Duration.EndOfTurn);§effect.setTargetPointer(new FixedTarget(permanent.getId()));§game.addEffect(effect, source);§}§}§return true;§}§return false;§}§}§
public class RoninCliffrider extends CardImpl {§public RoninCliffrider(UUID ownerId) {§super(ownerId, 116, "Ronin Cliffrider", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{R}{R}");§this.expansionSetCode = "BOK";§this.subtype.add("Human");§this.subtype.add("Samurai");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new BushidoAbility(1));§this.addAbility(new AttacksTriggeredAbility(new RoninCliffriderEffect(), true));§}§public RoninCliffrider(final RoninCliffrider card) {§super(card);§}§@Override§public RoninCliffrider copy() {§return new RoninCliffrider(this);§}§}§class RoninCliffriderEffect extends OneShotEffect {§public RoninCliffriderEffect() {§super(Outcome.Damage);§this.staticText = "you may have it deal 1 damage to each creature defending player controls";§}§public RoninCliffriderEffect(final RoninCliffriderEffect effect) {§super(effect);§}§@Override§public RoninCliffriderEffect copy() {§return new RoninCliffriderEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§UUID defenderId = game.getCombat().getDefenderId(source.getSourceId());§if (defenderId != null) {§FilterCreaturePermanent filter = new FilterCreaturePermanent();§filter.add(new ControllerIdPredicate(defenderId));§List<Permanent> permanents = game.getBattlefield().getActivePermanents(filter, source.getControllerId(), source.getSourceId(), game);§for (Permanent permanent : permanents) {§permanent.damage(1, source.getSourceId(), game, false, true);§}§return true;§}§return false;§}§}§
public class RoninWarclub extends CardImpl {§public RoninWarclub(UUID ownerId) {§super(ownerId, 158, "Ronin Warclub", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "BOK";§this.subtype.add("Equipment");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEquippedEffect(2, 1)));§Ability ability = new RoninWarclubTriggeredAbility();§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§this.addAbility(new EquipAbility(Outcome.BoostCreature, new GenericManaCost(5)));§}§public RoninWarclub(final RoninWarclub card) {§super(card);§}§@Override§public RoninWarclub copy() {§return new RoninWarclub(this);§}§private class RoninWarclubTriggeredAbility extends TriggeredAbilityImpl {§public RoninWarclubTriggeredAbility() {§super(Zone.BATTLEFIELD, new RoninWarclubAttachEffect(), false);§}§public RoninWarclubTriggeredAbility(RoninWarclubTriggeredAbility ability) {§super(ability);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.ENTERS_THE_BATTLEFIELD;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§Permanent permanent = game.getPermanent(event.getTargetId());§if (permanent.getCardType().contains(CardType.CREATURE)§&& (permanent.getControllerId().equals(this.controllerId))) {§if (!this.getTargets().isEmpty()) {§if (this.getTargets().get(0).getTargets().size() > 0) {§this.getTargets().clear();§this.addTarget(new TargetCreaturePermanent());§}§Target target = this.getTargets().get(0);§if (target instanceof TargetCreaturePermanent) {§target.add(event.getTargetId(), game);§}§}§return true;§}§return false;§}§@Override§public RoninWarclubTriggeredAbility copy() {§return new RoninWarclubTriggeredAbility(this);§}§}§private class RoninWarclubAttachEffect extends OneShotEffect {§public RoninWarclubAttachEffect() {§super(Outcome.BoostCreature);§this.staticText = "Whenever a creature enters the battlefield under your control, attach {this} to that creature";§}§public RoninWarclubAttachEffect(final RoninWarclubAttachEffect effect) {§super(effect);§}§@Override§public RoninWarclubAttachEffect copy() {§return new RoninWarclubAttachEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getPermanent(source.getFirstTarget());§Permanent attachment = game.getPermanent(source.getSourceId());§if (permanent != null && attachment != null) {§if (attachment.getAttachedTo() != null) {§Permanent oldTarget = game.getPermanent(attachment.getAttachedTo());§if (oldTarget != null) {§oldTarget.removeAttachment(source.getSourceId(), game);§}§}§boolean result;§result = permanent.addAttachment(source.getSourceId(), game);§return result;§}§return false;§}§}§}§
public class SakikoMotherOfSummer extends CardImpl {§public SakikoMotherOfSummer(UUID ownerId) {§super(ownerId, 141, "Sakiko, Mother of Summer", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{G}{G}");§this.expansionSetCode = "BOK";§this.supertype.add("Legendary");§this.subtype.add("Snake");§this.subtype.add("Shaman");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new SakikoMotherOfSummerTriggeredAbility());§}§public SakikoMotherOfSummer(final SakikoMotherOfSummer card) {§super(card);§}§@Override§public SakikoMotherOfSummer copy() {§return new SakikoMotherOfSummer(this);§}§}§class SakikoMotherOfSummerTriggeredAbility extends TriggeredAbilityImpl {§public SakikoMotherOfSummerTriggeredAbility() {§super(Zone.BATTLEFIELD, null, false);§}§public SakikoMotherOfSummerTriggeredAbility(final SakikoMotherOfSummerTriggeredAbility ability) {§super(ability);§}§@Override§public SakikoMotherOfSummerTriggeredAbility copy() {§return new SakikoMotherOfSummerTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.DAMAGED_PLAYER;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (((DamagedPlayerEvent) event).isCombatDamage()) {§Permanent creature = game.getPermanent(event.getSourceId());§if (creature != null && creature.getControllerId().equals(controllerId)) {§this.getEffects().clear();§Effect effect = new AddManaToManaPoolTargetControllerEffect(new Mana(0,event.getAmount(),0,0,0,0,0, 0), "that player", true);§effect.setTargetPointer(new FixedTarget(creature.getControllerId()));§effect.setText("add that much {G} to your mana pool. Until end of turn, this mana doesn't empty from your mana pool as steps and phases end");§this.addEffect(effect);§return true;§}§}§return false;§}§@Override§public String getRule() {§return "Whenever a creature you control deals combat damage to a player, add that much {G} to your mana pool. Until end of turn, this mana doesn't empty from your mana pool as steps and phases end.";§}§}§
public class SakuraTribeSpringcaller extends CardImpl {§public SakuraTribeSpringcaller(UUID ownerId) {§super(ownerId, 142, "Sakura-Tribe Springcaller", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{G}");§this.expansionSetCode = "BOK";§this.subtype.add("Snake");§this.subtype.add("Shaman");§this.power = new MageInt(2);§this.toughness = new MageInt(4);§Effect effect = new AddManaToManaPoolTargetControllerEffect(new Mana(Mana.GreenMana(1)), "your", true);§effect.setText("add {G} to your mana pool. Until end of turn, this mana doesn't empty from your mana pool as steps and phases end");§this.addAbility(new BeginningOfUpkeepTriggeredAbility(Zone.BATTLEFIELD, effect, TargetController.YOU, false));§}§public SakuraTribeSpringcaller(final SakuraTribeSpringcaller card) {§super(card);§}§@Override§public SakuraTribeSpringcaller copy() {§return new SakuraTribeSpringcaller(this);§}§}§
public class ScaledHulk extends CardImpl {§private static final FilterSpiritOrArcaneCard filter = new FilterSpiritOrArcaneCard();§public ScaledHulk(UUID ownerId) {§super(ownerId, 143, "Scaled Hulk", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{5}{G}");§this.expansionSetCode = "BOK";§this.subtype.add("Spirit");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(new SpellCastControllerTriggeredAbility(new BoostSourceEffect(2, 2, Duration.EndOfTurn), filter, false));§}§public ScaledHulk(final ScaledHulk card) {§super(card);§}§@Override§public ScaledHulk copy() {§return new ScaledHulk(this);§}§}§
public class Scour extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("enchantment");§static {§filter.add(new CardTypePredicate(CardType.ENCHANTMENT));§}§public Scour(UUID ownerId) {§super(ownerId, 20, "Scour", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{2}{W}{W}");§this.expansionSetCode = "BOK";§this.getSpellAbility().addTarget(new TargetPermanent(filter));§this.getSpellAbility().addEffect(new ExileTargetAndSearchGraveyardHandLibraryEffect(false, "its controller's","all cards with the same name as that enchantment"));§}§public Scour(final Scour card) {§super(card);§}§@Override§public Scour copy() {§return new Scour(this);§}§}§
public class ScourgeOfNumai extends CardImpl {§public ScourgeOfNumai(UUID ownerId) {§super(ownerId, 80, "Scourge of Numai", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{B}");§this.expansionSetCode = "BOK";§this.subtype.add("Demon");§this.subtype.add("Spirit");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(new BeginningOfUpkeepTriggeredAbility(new ScourgeOfNumaiEffect(), TargetController.YOU, false));§}§public ScourgeOfNumai(final ScourgeOfNumai card) {§super(card);§}§@Override§public ScourgeOfNumai copy() {§return new ScourgeOfNumai(this);§}§}§class ScourgeOfNumaiEffect extends OneShotEffect {§public ScourgeOfNumaiEffect() {§super(Outcome.LoseLife);§this.staticText = "you lose 2 life if you don't control an Ogre.";§}§public ScourgeOfNumaiEffect(final ScourgeOfNumaiEffect effect) {§super(effect);§}§@Override§public ScourgeOfNumaiEffect copy() {§return new ScourgeOfNumaiEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§if (game.getBattlefield().countAll(new FilterCreaturePermanent("Ogre", "Ogre"), source.getControllerId(), game) < 1) {§controller.loseLife(2, game);§}§return true;§}§return false;§}§}§
public class ShimmeringGlasskite extends CardImpl {§public ShimmeringGlasskite(UUID ownerId) {§super(ownerId, 51, "Shimmering Glasskite", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{U}");§this.expansionSetCode = "BOK";§this.subtype.add("Spirit");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new ShimmeringGlasskiteAbility());§}§public ShimmeringGlasskite(final ShimmeringGlasskite card) {§super(card);§}§@Override§public ShimmeringGlasskite copy() {§return new ShimmeringGlasskite(this);§}§}§class ShimmeringGlasskiteAbility extends TriggeredAbilityImpl {§protected int turnUsed;§public ShimmeringGlasskiteAbility() {§super(Zone.BATTLEFIELD, new CounterTargetEffect(), false);§}§public ShimmeringGlasskiteAbility(final ShimmeringGlasskiteAbility ability) {§super(ability);§turnUsed = ability.turnUsed;§}§@Override§public ShimmeringGlasskiteAbility copy() {§return new ShimmeringGlasskiteAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.TARGETED;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (event.getTargetId().equals(this.getSourceId()) && game.getTurnNum() > turnUsed) {§this.getTargets().clear();§TargetStackObject target = new TargetStackObject();§target.add(event.getSourceId(), game);§this.addTarget(target);§turnUsed = game.getTurnNum();§return true;§}§return false;§}§@Override§public String getRule() {§return "Whenever {this} becomes the target of a spell or ability for the first time in a turn, counter that spell or ability.";§}§}§
public class ShiningShoal extends CardImpl {§public ShiningShoal(UUID ownerId) {§super(ownerId, 21, "Shining Shoal", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{X}{W}{W}");§this.expansionSetCode = "BOK";§this.subtype.add("Arcane");§FilterOwnedCard filter = new FilterOwnedCard("a white card with converted mana cost X from your hand");§filter.add(new ColorPredicate(ObjectColor.WHITE));§filter.add(Predicates.not(new CardIdPredicate(this.getId()))); §
public class ShinkaGatekeeper extends CardImpl {§public ShinkaGatekeeper(UUID ownerId) {§super(ownerId, 117, "Shinka Gatekeeper", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "BOK";§this.subtype.add("Ogre");§this.subtype.add("Warrior");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§this.addAbility(new DealtDamageToSourceTriggeredAbility(Zone.BATTLEFIELD, new ShinkaGatekeeperDealDamageEffect(), false));§}§public ShinkaGatekeeper(final ShinkaGatekeeper card) {§super(card);§}§@Override§public ShinkaGatekeeper copy() {§return new ShinkaGatekeeper(this);§}§}§class ShinkaGatekeeperDealDamageEffect extends OneShotEffect {§public ShinkaGatekeeperDealDamageEffect() {§super(Outcome.Damage);§this.staticText = "it deals that much damage to you";§}§public ShinkaGatekeeperDealDamageEffect(final ShinkaGatekeeperDealDamageEffect effect) {§super(effect);§}§@Override§public ShinkaGatekeeperDealDamageEffect copy() {§return new ShinkaGatekeeperDealDamageEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§int amount = (Integer) getValue("damage");§if (amount > 0) {§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§player.damage(amount, source.getSourceId(), game, false, true);§return true;§}§}§return false;§}§}§
public class ShireiShizosCaretaker extends CardImpl {§public ShireiShizosCaretaker(UUID ownerId) {§super(ownerId, 81, "Shirei, Shizo's Caretaker", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{B}");§this.expansionSetCode = "BOK";§this.supertype.add("Legendary");§this.subtype.add("Spirit");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new ShireiShizosCaretakerTriggeredAbility(this.getId()));§}§public ShireiShizosCaretaker(final ShireiShizosCaretaker card) {§super(card);§}§@Override§public ShireiShizosCaretaker copy() {§return new ShireiShizosCaretaker(this);§}§}§class ShireiShizosCaretakerTriggeredAbility extends TriggeredAbilityImpl {§ShireiShizosCaretakerTriggeredAbility(UUID shireiId) {§super(Zone.BATTLEFIELD, new ShireiShizosCaretakerEffect(shireiId), false);§}§ShireiShizosCaretakerTriggeredAbility(final ShireiShizosCaretakerTriggeredAbility ability) {§super(ability);§}§@Override§public ShireiShizosCaretakerTriggeredAbility copy() {§return new ShireiShizosCaretakerTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.ZONE_CHANGE;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§ZoneChangeEvent zEvent = (ZoneChangeEvent) event;§Permanent LKIpermanent = game.getPermanentOrLKIBattlefield(zEvent.getTargetId());§Card card = game.getCard(zEvent.getTargetId());§if (card != null && LKIpermanent != null§&& card.getOwnerId().equals(this.controllerId)§&& zEvent.getToZone() == Zone.GRAVEYARD§&& zEvent.getFromZone() == Zone.BATTLEFIELD§&& card.getCardType().contains(CardType.CREATURE)§&& LKIpermanent.getPower().getValue() <= 1) {§for (Effect effect : this.getEffects()) {§effect.setTargetPointer(new FixedTarget(zEvent.getTargetId()));§}§return true;§}§return false;§}§@Override§public String getRule() {§return "Whenever a creature with power 1 or less is put into your graveyard from the battlefield, you may return that card to the battlefield at the beginning of the next end step if Shirei, Shizo's Caretaker is still on the battlefield.";§}§}§class ShireiShizosCaretakerEffect extends OneShotEffect {§protected final UUID shireiId;§ShireiShizosCaretakerEffect(UUID shireiId) {§super(Outcome.PutCreatureInPlay);§this.staticText = "you may return that card to the battlefield at the beginning of the next end step if {this} is still on the battlefield.";§this.shireiId = shireiId;§}§ShireiShizosCaretakerEffect(final ShireiShizosCaretakerEffect effect) {§super(effect);§this.shireiId = effect.shireiId;§}§@Override§public ShireiShizosCaretakerEffect copy() {§return new ShireiShizosCaretakerEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Card card = game.getCard(this.getTargetPointer().getFirst(game, source));§if (card != null) {§Effect effect = new ShireiShizosCaretakerReturnEffect(shireiId);§effect.setText("return that card to the battlefield if {this} is still on the battlefield");§DelayedTriggeredAbility delayedAbility = new AtTheBeginOfNextEndStepDelayedTriggeredAbility(effect);§delayedAbility.getEffects().get(0).setTargetPointer(new FixedTarget(card.getId()));§game.addDelayedTriggeredAbility(delayedAbility, source);§return true;§}§return false;§}§}§class ShireiShizosCaretakerReturnEffect extends ReturnToBattlefieldUnderYourControlTargetEffect {§protected final UUID shireiId;§ShireiShizosCaretakerReturnEffect(UUID shireiId) {§this.shireiId = shireiId;§}§ShireiShizosCaretakerReturnEffect(final ShireiShizosCaretakerReturnEffect effect) {§super(effect);§this.shireiId = effect.shireiId;§}§@Override§public ShireiShizosCaretakerReturnEffect copy() {§return new ShireiShizosCaretakerReturnEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§if (game.getBattlefield().containsPermanent(shireiId)) {§return super.apply(game, source);§}§return false;§}§}§
public class ShizukoCallerOfAutumn extends CardImpl {§public ShizukoCallerOfAutumn(UUID ownerId) {§super(ownerId, 144, "Shizuko, Caller of Autumn", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{G}{G}");§this.expansionSetCode = "BOK";§this.supertype.add("Legendary");§this.subtype.add("Snake");§this.subtype.add("Shaman");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§Effect effect = new AddManaToManaPoolTargetControllerEffect(new Mana(0,3,0,0,0,0,0, 0), "that player", true);§effect.setText("that player adds {G}{G}{G} to his or her mana pool. Until end of turn, this mana doesn't empty from that player's mana pool as steps and phases end");§this.addAbility(new BeginningOfUpkeepTriggeredAbility(Zone.BATTLEFIELD, effect, TargetController.ANY, false));§}§public ShizukoCallerOfAutumn(final ShizukoCallerOfAutumn card) {§super(card);§}§@Override§public ShizukoCallerOfAutumn copy() {§return new ShizukoCallerOfAutumn(this);§}§}§
public class Shuko extends CardImpl {§public Shuko(UUID ownerId) {§super(ownerId, 159, "Shuko", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{1}");§this.expansionSetCode = "BOK";§this.subtype.add("Equipment");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEquippedEffect(1, 0)));§this.addAbility(new EquipAbility(Outcome.BoostCreature, new GenericManaCost(0)));§}§public Shuko(final Shuko card) {§super(card);§}§@Override§public Shuko copy() {§return new Shuko(this);§}§}§
public class SilverstormSamurai extends CardImpl {§public SilverstormSamurai(UUID ownerId) {§super(ownerId, 22, "Silverstorm Samurai", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{W}{W}");§this.expansionSetCode = "BOK";§this.subtype.add("Fox");§this.subtype.add("Samurai");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(FlashAbility.getInstance());§this.addAbility(new BushidoAbility(1));§}§public SilverstormSamurai(final SilverstormSamurai card) {§super(card);§}§@Override§public SilverstormSamurai copy() {§return new SilverstormSamurai(this);§}§}§
public class SkullmaneBaku extends CardImpl {§private static final FilterSpiritOrArcaneCard filter = new FilterSpiritOrArcaneCard();§public SkullmaneBaku(UUID ownerId) {§super(ownerId, 83, "Skullmane Baku", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{B}{B}");§this.expansionSetCode = "BOK";§this.subtype.add("Spirit");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new SpellCastControllerTriggeredAbility(new AddCountersSourceEffect(CounterType.KI.createInstance()), filter, true));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new SkullmaneBakuUnboostEffect(), new GenericManaCost(1));§ability.addCost(new TapSourceCost());§ability.addCost(new RemoveVariableCountersSourceCost(CounterType.KI.createInstance(1)));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public SkullmaneBaku(final SkullmaneBaku card) {§super(card);§}§@Override§public SkullmaneBaku copy() {§return new SkullmaneBaku(this);§}§class SkullmaneBakuUnboostEffect extends OneShotEffect {§public SkullmaneBakuUnboostEffect() {§super(Outcome.UnboostCreature);§staticText = "Target creature gets -X/-X until end of turn";§}§public SkullmaneBakuUnboostEffect(SkullmaneBakuUnboostEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§int numberToUnboost = 0;§for (Cost cost : source.getCosts()) {§if (cost instanceof RemoveVariableCountersSourceCost) {§numberToUnboost = ((RemoveVariableCountersSourceCost)cost).getAmount() * -1;§}§}§Permanent creature = game.getPermanent(targetPointer.getFirst(game, source));§if (creature != null && numberToUnboost != 0) {§creature.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostSourceEffect(numberToUnboost, numberToUnboost, Duration.EndOfTurn)), source.getSourceId(), game, false);§}§return true;§}§@Override§public SkullmaneBakuUnboostEffect copy() {§return new SkullmaneBakuUnboostEffect(this);§}§}§}§
public class Skullsnatcher extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("unblocked attacker you control");§static {§filter.add(new UnblockedPredicate());§}§public Skullsnatcher(UUID ownerId) {§super(ownerId, 84, "Skullsnatcher", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{B}");§this.expansionSetCode = "BOK";§this.subtype.add("Rat");§this.subtype.add("Ninja");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new NinjutsuAbility(new ManaCostsImpl("{B")));§Effect effect = new ExileTargetEffect(null, "", Zone.GRAVEYARD);§effect.setText("exile up to two target cards from that player's graveyard");§this.addAbility(new SkullsnatcherTriggeredAbility(effect));§}§public Skullsnatcher(final Skullsnatcher card) {§super(card);§}§@Override§public Skullsnatcher copy() {§return new Skullsnatcher(this);§}§}§class SkullsnatcherTriggeredAbility extends TriggeredAbilityImpl {§SkullsnatcherTriggeredAbility(Effect effect) {§super(Zone.BATTLEFIELD, effect, false);§}§SkullsnatcherTriggeredAbility(final SkullsnatcherTriggeredAbility ability) {§super(ability);§}§@Override§public SkullsnatcherTriggeredAbility copy() {§return new SkullsnatcherTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.DAMAGED_PLAYER;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (((DamagedPlayerEvent) event).isCombatDamage()§&& event.getSourceId().equals(sourceId)) {§FilterCard filter = new FilterCard("up to two target cards from that player's graveyard");§filter.add(new OwnerIdPredicate(event.getPlayerId()));§filter.setMessage("up to two cards in " + game.getPlayer(event.getTargetId()).getLogName() + "'s graveyard");§this.getTargets().clear();§this.addTarget(new TargetCardInOpponentsGraveyard(0,2,filter));§return true;§}§return false;§}§@Override§public String getRule() {§return "Whenever {this} deals combat damage to a player, " + super.getRule();§}§}§
public class SlumberingTora extends CardImpl {§private static final FilterCard filter = new FilterCard("Spirit or Arcane card");§static {§filter.add(Predicates.or(new SubtypePredicate("Spirit"),new SubtypePredicate("Arcane")));§}§public SlumberingTora(UUID ownerId) {§super(ownerId, 161, "Slumbering Tora", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "BOK";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new SlumberingToraEffect(), new ManaCostsImpl("{2}"));§ability.addCost(new DiscardTargetCost(new TargetCardInHand(filter)));§this.addAbility(ability);§}§public SlumberingTora(final SlumberingTora card) {§super(card);§}§@Override§public SlumberingTora copy() {§return new SlumberingTora(this);§}§private class SlumberingToraEffect extends ContinuousEffectImpl {§public SlumberingToraEffect() {§super(Duration.EndOfTurn, Outcome.BecomeCreature);§setText();§}§public SlumberingToraEffect(final SlumberingToraEffect effect) {§super(effect);§}§@Override§public SlumberingToraEffect copy() {§return new SlumberingToraEffect(this);§}§@Override§public boolean apply(Layer layer, SubLayer sublayer, Ability source, Game game) {§Permanent permanent = game.getPermanent(source.getSourceId());§if (permanent != null) {§switch (layer) {§case TypeChangingEffects_4:§if (sublayer == SubLayer.NA) {§permanent.getCardType().add(CardType.CREATURE);§permanent.getSubtype().add("Cat");§}§break;§case PTChangingEffects_7:§if (sublayer == SubLayer.SetPT_7b) {§int convManaCosts = 0;§for (Cost cost: source.getCosts()) {§if (cost instanceof DiscardTargetCost && ((DiscardTargetCost)cost).getCards().size() > 0) {§convManaCosts = ((DiscardTargetCost)cost).getCards().get(0).getManaCost().convertedManaCost();§break;§}§}§permanent.getPower().setValue(convManaCosts);§permanent.getToughness().setValue(convManaCosts);§}§}§return true;§}§return false;§}§@Override§public boolean apply(Game game, Ability source) {§return false;§}§private void setText() {§staticText = "{this} becomes an X/X Cat artifact creature until end of turn, where X is the discarded card's converted mana cost";§}§@Override§public boolean hasLayer(Layer layer) {§return layer == Layer.PTChangingEffects_7 || layer == Layer.TypeChangingEffects_4;§}§}§}§
public class SoratamiMindsweeper extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledLandPermanent("a land");§public SoratamiMindsweeper(UUID ownerId) {§super(ownerId, 52, "Soratami Mindsweeper", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{U}");§this.expansionSetCode = "BOK";§this.subtype.add("Moonfolk");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,new PutLibraryIntoGraveTargetEffect(2), new ManaCostsImpl("{2}"));§ability.addTarget(new TargetPlayer());§ability.addCost(new ReturnToHandChosenControlledPermanentCost(new TargetControlledPermanent(filter)));§this.addAbility(ability);§}§public SoratamiMindsweeper(final SoratamiMindsweeper card) {§super(card);§}§@Override§public SoratamiMindsweeper copy() {§return new SoratamiMindsweeper(this);§}§}§
public class SosukesSummons extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("nontoken Snake");§static {§filter.add(new SubtypePredicate("Snake"));§filter.add(Predicates.not(new TokenPredicate()));§}§public SosukesSummons(UUID ownerId) {§super(ownerId, 145, "Sosuke's Summons", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{2}{G}");§this.expansionSetCode = "BOK";§this.getSpellAbility().addEffect(new CreateTokenEffect(new SnakeToken(), 2));§this.addAbility(new CreatureEntersBattlefieldTriggeredAbility(Zone.GRAVEYARD, new ReturnSourceFromGraveyardToHandEffect(), filter, true, false));§}§public SosukesSummons(final SosukesSummons card) {§super(card);§}§@Override§public SosukesSummons copy() {§return new SosukesSummons(this);§}§}§
public class SowingSalt extends CardImpl {§public SowingSalt(UUID ownerId) {§super(ownerId, 118, "Sowing Salt", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{2}{R}{R}");§this.expansionSetCode = "BOK";§this.getSpellAbility().addTarget(new TargetNonBasicLandPermanent());§this.getSpellAbility().addEffect(new ExileTargetAndSearchGraveyardHandLibraryEffect(false, "its controller's","all cards with the same name as that land"));§}§public SowingSalt(final SowingSalt card) {§super(card);§}§@Override§public SowingSalt copy() {§return new SowingSalt(this);§}§}§
public class Splinter extends CardImpl {§private static final FilterPermanent filter = new FilterArtifactPermanent();§public Splinter(UUID ownerId) {§super(ownerId, 146, "Splinter", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{2}{G}{G}");§this.expansionSetCode = "BOK";§this.getSpellAbility().addTarget(new TargetPermanent(filter));§this.getSpellAbility().addEffect(new ExileTargetAndSearchGraveyardHandLibraryEffect(false, "its controller's","all cards with the same name as that artifact"));§}§public Splinter(final Splinter card) {§super(card);§}§@Override§public Splinter copy() {§return new Splinter(this);§}§}§
public class SplitTailMiko extends CardImpl {§public SplitTailMiko(UUID ownerId) {§super(ownerId, 23, "Split-Tail Miko", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "BOK";§this.subtype.add("Fox");§this.subtype.add("Cleric");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new PreventDamageToTargetEffect(Duration.EndOfTurn, 2), new ColoredManaCost(ColoredManaSymbol.W));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetCreatureOrPlayer());§this.addAbility(ability);§}§public SplitTailMiko(final SplitTailMiko card) {§super(card);§}§@Override§public SplitTailMiko copy() {§return new SplitTailMiko(this);§}§}§
public class StirTheGrave extends CardImpl {§public StirTheGrave(UUID ownerId) {§super(ownerId, 85, "Stir the Grave", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{X}{B}");§this.expansionSetCode = "BOK";§this.getSpellAbility().addEffect(new ReturnFromGraveyardToBattlefieldTargetEffect());§this.getSpellAbility().addTarget(new TargetCardInYourGraveyard(new FilterCreatureCard("creature card from your graveyard")));§}§@Override§public void adjustTargets(Ability ability, Game game) {§ability.getTargets().clear();§int xValue = ability.getManaCostsToPay().getX();§FilterCard filter = new FilterCreatureCard("creature card with converted mana cost " + xValue + " or less from your graveyard");§filter.add(new ConvertedManaCostPredicate(Filter.ComparisonType.LessThan, xValue + 1));§ability.getTargets().add(new TargetCardInYourGraveyard(filter));§}§public StirTheGrave(final StirTheGrave card) {§super(card);§}§@Override§public StirTheGrave copy() {§return new StirTheGrave(this);§}§}§
public class StreamOfConsciousness extends CardImpl {§public StreamOfConsciousness(UUID ownerId) {§super(ownerId, 53, "Stream of Consciousness", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{1}{U}");§this.expansionSetCode = "BOK";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new StreamOfConsciousnessEffect());§this.getSpellAbility().addTarget(new TargetPlayer());§this.getSpellAbility().addTarget(new StreamOfConsciousnessTarget());§}§public StreamOfConsciousness(final StreamOfConsciousness card) {§super(card);§}§@Override§public StreamOfConsciousness copy() {§return new StreamOfConsciousness(this);§}§}§class StreamOfConsciousnessEffect extends OneShotEffect {§public StreamOfConsciousnessEffect() {§super(Outcome.Neutral);§this.staticText = "Target player shuffles up to four target cards from his or her graveyard into his or her library";§}§public StreamOfConsciousnessEffect(final StreamOfConsciousnessEffect effect) {§super(effect);§}§@Override§public StreamOfConsciousnessEffect copy() {§return new StreamOfConsciousnessEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getFirstTarget());§if (player != null) {§List<UUID> targets = source.getTargets().get(1).getTargets();§boolean shuffle = false;§for (UUID targetId : targets) {§Card card = game.getCard(targetId);§if (card != null) {§if (player.getGraveyard().contains(card.getId())) {§player.getGraveyard().remove(card);§card.moveToZone(Zone.LIBRARY, source.getSourceId(), game, true);§shuffle = true;§}§}§}§if (shuffle) {§player.shuffleLibrary(game);§}§return true;§}§return false;§}§}§class StreamOfConsciousnessTarget extends TargetCard {§public StreamOfConsciousnessTarget() {§super(0, 4, Zone.GRAVEYARD, new FilterCard("cards from target player's graveyard"));§}§public StreamOfConsciousnessTarget(final StreamOfConsciousnessTarget target) {§super(target);§}§@Override§public boolean canTarget(UUID id, Ability source, Game game) {§Card card = game.getCard(id);§if (card != null && game.getState().getZone(card.getId()) == Zone.GRAVEYARD) {§UUID firstTarget = source.getFirstTarget();§if (firstTarget != null && game.getPlayer(firstTarget).getGraveyard().contains(id)) {§return filter.match(card, game);§}§}§return false;§}§@Override§public StreamOfConsciousnessTarget copy() {§return new StreamOfConsciousnessTarget(this);§}§}§
public class SwayOfTheStars extends CardImpl {§public SwayOfTheStars(UUID ownerId) {§super(ownerId, 54, "Sway of the Stars", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{8}{U}{U}");§this.expansionSetCode = "BOK";§this.getSpellAbility().addEffect(new SwayOfTheStarsEffect());§Effect effect = new DrawCardAllEffect(7);§effect.setText(", then draws seven cards");§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addEffect(new SetPlayerLifeAllEffect(7));§}§public SwayOfTheStars(final SwayOfTheStars card) {§super(card);§}§@Override§public SwayOfTheStars copy() {§return new SwayOfTheStars(this);§}§}§class SwayOfTheStarsEffect extends OneShotEffect {§public SwayOfTheStarsEffect() {§super(Outcome.Neutral);§staticText = "Each player shuffles his or her hand, graveyard, and permanents he or she owns into his or her library, then draws seven cards. Each player's life total becomes 7";§}§public SwayOfTheStarsEffect(final SwayOfTheStarsEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§for (UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {§Player player = game.getPlayer(playerId);§if (player != null) {§player.moveCards(player.getHand(), Zone.HAND, Zone.LIBRARY, source, game);§player.moveCards(player.getGraveyard(), Zone.GRAVEYARD, Zone.LIBRARY, source, game);§FilterPermanent filter = new FilterPermanent();§filter.add(new OwnerIdPredicate(playerId));§for (Permanent permanent : game.getBattlefield().getActivePermanents(filter, controller.getId(), source.getSourceId(), game)) {§permanent.moveToZone(Zone.LIBRARY, source.getSourceId(), game, true);§}§player.shuffleLibrary(game);§}§}§return true;§}§@Override§public SwayOfTheStarsEffect copy() {§return new SwayOfTheStarsEffect(this);§}§}§
public class TakenosCavalry extends CardImpl {§private static final FilterAttackingOrBlockingCreature filter = new FilterAttackingOrBlockingCreature("attacking or blocking Spirit");§static {§filter.add(new SubtypePredicate("Spirit"));§}§public TakenosCavalry(UUID ownerId) {§super(ownerId, 24, "Takeno's Cavalry", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{W}");§this.expansionSetCode = "BOK";§this.subtype.add("Human");§this.subtype.add("Samurai");§this.subtype.add("Archer");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new BushidoAbility(1));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(1), new TapSourceCost());§ability.addTarget(new TargetAttackingOrBlockingCreature(1, 1, filter, false));§this.addAbility(ability);§}§public TakenosCavalry(final TakenosCavalry card) {§super(card);§}§@Override§public TakenosCavalry copy() {§return new TakenosCavalry(this);§}§}§
public class TakenumaBleeder extends CardImpl {§public TakenumaBleeder(UUID ownerId) {§super(ownerId, 86, "Takenuma Bleeder", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{B}");§this.expansionSetCode = "BOK";§this.subtype.add("Ogre");§this.subtype.add("Shaman");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new AttacksOrBlocksTriggeredAbility(new TakenumaBleederEffect(), false));§}§public TakenumaBleeder(final TakenumaBleeder card) {§super(card);§}§@Override§public TakenumaBleeder copy() {§return new TakenumaBleeder(this);§}§}§class TakenumaBleederEffect extends OneShotEffect {§public TakenumaBleederEffect() {§super(Outcome.LoseLife);§this.staticText = "you lose 1 life if you don't control a Demon";§}§public TakenumaBleederEffect(final TakenumaBleederEffect effect) {§super(effect);§}§@Override§public TakenumaBleederEffect copy() {§return new TakenumaBleederEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§if (game.getBattlefield().countAll(new FilterCreaturePermanent("Demon", "Demon"), source.getControllerId(), game) < 1) {§controller.loseLife(1, game);§}§return true;§}§return false;§}§}§
public class Tallowisp extends CardImpl {§private static final FilterCard filterAura = new FilterCard("Aura card");§private static final FilterSpell filterTrigger = new FilterSpiritOrArcaneCard();§static {§filterAura.add(new CardTypePredicate(CardType.ENCHANTMENT));§filterAura.add(new SubtypePredicate("Aura"));§filterAura.add(new TallowispAbilityPredicate());§}§public Tallowisp(UUID ownerId) {§super(ownerId, 25, "Tallowisp", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "BOK";§this.subtype.add("Spirit");§this.power = new MageInt(1);§this.toughness = new MageInt(3);§this.addAbility(new SpellCastControllerTriggeredAbility(new SearchLibraryPutInHandEffect(new TargetCardInLibrary(filterAura), true, true), filterTrigger, true));§}§public Tallowisp(final Tallowisp card) {§super(card);§}§@Override§public Tallowisp copy() {§return new Tallowisp(this);§}§}§class TallowispAbilityPredicate implements Predicate<MageObject> {§public TallowispAbilityPredicate() {§}§@Override§public boolean apply(MageObject input, Game game) {§Abilities<Ability> abilities = input.getAbilities();§for (int i = 0; i < abilities.size(); i++) {§if (abilities.get(i) instanceof EnchantAbility) {§String enchantText = abilities.get(i).getRule();§if (enchantText.startsWith("Enchant") && enchantText.contains("creature")) {§return true;§}§}§}§return false;§}§@Override§public String toString() {§return "Aura card with enchant creature";§}§}§
public class TeardropKami extends CardImpl {§public TeardropKami(UUID ownerId) {§super(ownerId, 55, "Teardrop Kami", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{U}");§this.expansionSetCode = "BOK";§this.subtype.add("Spirit");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,new MayTapOrUntapTargetEffect(), new SacrificeSourceCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public TeardropKami(final TeardropKami card) {§super(card);§}§@Override§public TeardropKami copy() {§return new TeardropKami(this);§}§}§
public class TendoIceBridge extends CardImpl {§public TendoIceBridge(UUID ownerId) {§super(ownerId, 165, "Tendo Ice Bridge", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "BOK";§this.addAbility(new EntersBattlefieldAbility(§new AddCountersSourceEffect(CounterType.CHARGE.createInstance(1)), "with a charge counter on it"));§this.addAbility(new ColorlessManaAbility());§Ability ability = new AnyColorManaAbility();§ability.addCost(new RemoveCountersSourceCost(CounterType.CHARGE.createInstance(1)));§this.addAbility(ability);§}§public TendoIceBridge(final TendoIceBridge card) {§super(card);§}§@Override§public TendoIceBridge copy() {§return new TendoIceBridge(this);§}§}§
public class TerashisGrasp extends CardImpl {§public TerashisGrasp(UUID ownerId) {§super(ownerId, 26, "Terashi's Grasp", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{2}{W}");§this.expansionSetCode = "BOK";§this.subtype.add("Arcane");§this.getSpellAbility().addTarget(new TargetPermanent(new FilterArtifactOrEnchantmentPermanent()));§this.getSpellAbility().addEffect(new DestroyTargetEffect());§this.getSpellAbility().addEffect(new TerashisGraspEffect());§}§public TerashisGrasp(final TerashisGrasp card) {§super(card);§}§@Override§public TerashisGrasp copy() {§return new TerashisGrasp(this);§}§private class TerashisGraspEffect extends OneShotEffect {§public TerashisGraspEffect() {§super(Outcome.DestroyPermanent);§staticText = "You gain life equal to its converted mana cost";§}§public TerashisGraspEffect(TerashisGraspEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent targetPermanent = game.getPermanentOrLKIBattlefield(getTargetPointer().getFirst(game, source));§if (targetPermanent != null) {§int cost = targetPermanent.getManaCost().convertedManaCost();§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§player.gainLife(cost, game);§}§}§return true;§}§@Override§public TerashisGraspEffect copy() {§return new TerashisGraspEffect(this);§}§}§}§
public class ThreadsOfDisloyalty extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature with converted mana cost 2 or less");§static {§filter.add(new ConvertedManaCostPredicate(Filter.ComparisonType.LessThan, 3));§}§public ThreadsOfDisloyalty(UUID ownerId) {§super(ownerId, 56, "Threads of Disloyalty", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{1}{U}{U}");§this.expansionSetCode = "BOK";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent(filter);§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.GainControl));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new ControlEnchantedEffect()));§}§public ThreadsOfDisloyalty(final ThreadsOfDisloyalty card) {§super(card);§}§@Override§public ThreadsOfDisloyalty copy() {§return new ThreadsOfDisloyalty(this);§}§}§
public class ThreeTragedies extends CardImpl {§public ThreeTragedies(UUID ownerId) {§super(ownerId, 87, "Three Tragedies", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{3}{B}{B}");§this.expansionSetCode = "BOK";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new DiscardTargetEffect(3));§this.getSpellAbility().addTarget(new TargetPlayer());§}§public ThreeTragedies(final ThreeTragedies card) {§super(card);§}§@Override§public ThreeTragedies copy() {§return new ThreeTragedies(this);§}§}§
public class ThroatSlitter extends CardImpl {§public ThroatSlitter(UUID ownerId) {§super(ownerId, 88, "Throat Slitter", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{B}");§this.expansionSetCode = "BOK";§this.subtype.add("Rat");§this.subtype.add("Ninja");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new NinjutsuAbility(new ManaCostsImpl("{2}{B}")));§this.addAbility(new ThroatSlitterTriggeredAbility());§}§public ThroatSlitter(final ThroatSlitter card) {§super(card);§}§@Override§public ThroatSlitter copy() {§return new ThroatSlitter(this);§}§}§class ThroatSlitterTriggeredAbility extends TriggeredAbilityImpl {§ThroatSlitterTriggeredAbility() {§super(Zone.BATTLEFIELD, new DestroyTargetEffect(), false);§}§ThroatSlitterTriggeredAbility(final ThroatSlitterTriggeredAbility ability) {§super(ability);§}§@Override§public ThroatSlitterTriggeredAbility copy() {§return new ThroatSlitterTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.DAMAGED_PLAYER;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (((DamagedPlayerEvent) event).isCombatDamage()§&& event.getSourceId().equals(sourceId)) {§FilterCreaturePermanent filter = new FilterCreaturePermanent("nonblack creature that player controls");§filter.add(new ControllerIdPredicate(event.getPlayerId()));§filter.add(Predicates.not(new ColorPredicate(ObjectColor.BLACK)));§filter.setMessage("nonblack creature controlled by " + game.getPlayer(event.getTargetId()).getLogName());§this.getTargets().clear();§this.addTarget(new TargetPermanent(filter));§return true;§}§return false;§}§@Override§public String getRule() {§return "Whenever {this} deals combat damage to a player, destroy target nonblack creature that player controls.";§}§}§
public class ToilsOfNightAndDay extends CardImpl {§public ToilsOfNightAndDay(UUID ownerId) {§super(ownerId, 57, "Toils of Night and Day", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{U}");§this.expansionSetCode = "BOK";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new ToilsOfNightAndDayEffect());§this.getSpellAbility().addTarget(new TargetPermanent(0, 2, new FilterPermanent(), false));§}§public ToilsOfNightAndDay(final ToilsOfNightAndDay card) {§super(card);§}§@Override§public ToilsOfNightAndDay copy() {§return new ToilsOfNightAndDay(this);§}§private class ToilsOfNightAndDayEffect extends OneShotEffect {§public ToilsOfNightAndDayEffect() {§super(Outcome.Tap);§this.staticText = "You may tap or untap target permanent, then you may tap or untap another target permanent";§}§public ToilsOfNightAndDayEffect(final ToilsOfNightAndDayEffect effect) {§super(effect);§}§@Override§public ToilsOfNightAndDayEffect copy() {§return new ToilsOfNightAndDayEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§for (UUID targetId : source.getTargets().get(0).getTargets()) {§Permanent permanent = game.getPermanent(targetId);§if (permanent != null) {§if (player.chooseUse(Outcome.Tap, new StringBuilder("Tap ").append(permanent.getName()).append("?").toString(), source, game)) {§permanent.tap(game);§} else if (player.chooseUse(Outcome.Untap, new StringBuilder("Untap ").append(permanent.getName()).append("?").toString(), source, game)) {§permanent.untap(game);§}§}§}§return true;§}§return false;§}§}§}§
public class TomorrowAzamisFamiliar extends CardImpl {§public TomorrowAzamisFamiliar(UUID ownerId) {§super(ownerId, 58, "Tomorrow, Azami's Familiar", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}{U}");§this.expansionSetCode = "BOK";§this.supertype.add("Legendary");§this.subtype.add("Spirit");§this.power = new MageInt(1);§this.toughness = new MageInt(5);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new TomorrowAzamisFamiliarReplacementEffect()));§}§public TomorrowAzamisFamiliar(final TomorrowAzamisFamiliar card) {§super(card);§}§@Override§public TomorrowAzamisFamiliar copy() {§return new TomorrowAzamisFamiliar(this);§}§}§class TomorrowAzamisFamiliarReplacementEffect extends ReplacementEffectImpl {§TomorrowAzamisFamiliarReplacementEffect() {§super(Duration.WhileOnBattlefield, Outcome.Benefit);§staticText = "If you would draw a card, look at the top three cards of your library instead. Put one of those cards into your hand and the rest on the bottom of your library in any order";§}§TomorrowAzamisFamiliarReplacementEffect(final TomorrowAzamisFamiliarReplacementEffect effect) {§super(effect);§}§@Override§public TomorrowAzamisFamiliarReplacementEffect copy() {§return new TomorrowAzamisFamiliarReplacementEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§new LookLibraryAndPickControllerEffect(new StaticValue(3), false, new StaticValue(1), new FilterCard(), Zone.LIBRARY, false, false)§.apply(game, source);§return true;§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.DRAW_CARD;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§return event.getPlayerId().equals(source.getControllerId());§}§}§
public class TorrentOfStone extends CardImpl {§private static final FilterControlledLandPermanent filterSacrifice = new FilterControlledLandPermanent("two Mountains");§static {§filterSacrifice.add(new SubtypePredicate("Mountain"));§}§public TorrentOfStone(UUID ownerId) {§super(ownerId, 119, "Torrent of Stone", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{3}{R}");§this.expansionSetCode = "BOK";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new DamageTargetEffect(4));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.addAbility(new SpliceOntoArcaneAbility(new SacrificeTargetCost(new TargetControlledPermanent(2,2, filterSacrifice, false))));§}§public TorrentOfStone(final TorrentOfStone card) {§super(card);§}§@Override§public TorrentOfStone copy() {§return new TorrentOfStone(this);§}§}§
public class ToshiroUmezawa extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("a creature an opponent controls");§private static final FilterCard filterInstant = new FilterCard("instant card from your graveyard");§static {§filter.add(new ControllerPredicate(TargetController.OPPONENT));§filterInstant.add(new CardTypePredicate(CardType.INSTANT));§}§public ToshiroUmezawa(UUID ownerId) {§super(ownerId, 89, "Toshiro Umezawa", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{B}{B}");§this.expansionSetCode = "BOK";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Samurai");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new BushidoAbility(1));§Ability ability = new DiesCreatureTriggeredAbility(new ToshiroUmezawaEffect(), true, filter);§ability.addTarget(new TargetCardInYourGraveyard(1,1, filterInstant));§this.addAbility(ability);§}§public ToshiroUmezawa(final ToshiroUmezawa card) {§super(card);§}§@Override§public ToshiroUmezawa copy() {§return new ToshiroUmezawa(this);§}§}§class ToshiroUmezawaEffect extends OneShotEffect {§public ToshiroUmezawaEffect() {§super(Outcome.Benefit);§this.staticText = "cast target instant card from your graveyard. If that card would be put into a graveyard this turn, exile it instead";§}§public ToshiroUmezawaEffect(final ToshiroUmezawaEffect effect) {§super(effect);§}§@Override§public ToshiroUmezawaEffect copy() {§return new ToshiroUmezawaEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Card card = game.getCard(getTargetPointer().getFirst(game, source));§if (card != null) {§controller.cast(card.getSpellAbility(), game, false);§game.addEffect(new ToshiroUmezawaReplacementEffect(card.getId()), source);§}§}§return false;§}§}§class ToshiroUmezawaReplacementEffect extends ReplacementEffectImpl {§private final UUID cardId;§public ToshiroUmezawaReplacementEffect(UUID cardId) {§super(Duration.EndOfTurn, Outcome.Exile);§this.cardId = cardId;§}§public ToshiroUmezawaReplacementEffect(final ToshiroUmezawaReplacementEffect effect) {§super(effect);§this.cardId = effect.cardId;§}§@Override§public ToshiroUmezawaReplacementEffect copy() {§return new ToshiroUmezawaReplacementEffect(this);§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§UUID eventObject = ((ZoneChangeEvent) event).getTargetId();§StackObject card = game.getStack().getStackObject(eventObject);§if (card != null) {§if (card instanceof Spell) {§game.rememberLKI(card.getId(), Zone.STACK, (Spell) card);§}§if (card instanceof Card && eventObject.equals(cardId)) {§((Card) card).moveToExile(null, null, source.getSourceId(), game);§return true;§}§}§return false;§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == EventType.ZONE_CHANGE;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§ZoneChangeEvent zEvent = (ZoneChangeEvent) event;§return zEvent.getToZone() == Zone.GRAVEYARD§&& ((ZoneChangeEvent) event).getTargetId().equals(cardId);§}§}§
public class TraprootKami extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("the number of Forests on the battlefield");§static {§filter.add(new SubtypePredicate("Forest"));§}§public TraprootKami(UUID ownerId) {§super(ownerId, 147, "Traproot Kami", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{G}");§this.expansionSetCode = "BOK";§this.subtype.add("Spirit");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§this.addAbility(DefenderAbility.getInstance());§this.addAbility(ReachAbility.getInstance());§this.addAbility(new SimpleStaticAbility(Zone.ALL, new SetToughnessSourceEffect(new PermanentsOnBattlefieldCount(filter), Duration.EndOfGame)));§}§public TraprootKami(final TraprootKami card) {§super(card);§}§@Override§public TraprootKami copy() {§return new TraprootKami(this);§}§}§
public class TwistAllegiance extends CardImpl {§public TwistAllegiance(UUID ownerId) {§super(ownerId, 120, "Twist Allegiance", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{6}{R}");§this.expansionSetCode = "BOK";§this.getSpellAbility().addEffect(new TwistAllegianceEffect());§this.getSpellAbility().addTarget(new TargetOpponent());§}§public TwistAllegiance(final TwistAllegiance card) {§super(card);§}§@Override§public TwistAllegiance copy() {§return new TwistAllegiance(this);§}§}§class TwistAllegianceEffect extends OneShotEffect {§public TwistAllegianceEffect() {§super(Outcome.Detriment);§this.staticText = "You and target opponent each gain control of all creatures the other controls until end of turn. Untap those creatures. Those creatures gain haste until end of turn";§}§public TwistAllegianceEffect(final TwistAllegianceEffect effect) {§super(effect);§}§@Override§public TwistAllegianceEffect copy() {§return new TwistAllegianceEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§Player targetOpponent = game.getPlayer(getTargetPointer().getFirst(game, source));§if (controller != null) {§for (Permanent permanent: game.getBattlefield().getActivePermanents(new FilterCreaturePermanent(), source.getControllerId(), source.getSourceId(), game)) {§if (permanent.getControllerId().equals(source.getControllerId()) || permanent.getControllerId().equals(targetOpponent.getId())) {§UUID newController = permanent.getControllerId().equals(source.getControllerId()) ? targetOpponent.getId() : source.getControllerId();§ContinuousEffect effect = new GainControlTargetEffect(Duration.EndOfTurn, true, newController);§effect.setTargetPointer(new FixedTarget(permanent.getId()));§game.addEffect(effect, source);§permanent.untap(game);§effect = new GainAbilityTargetEffect(HasteAbility.getInstance(), Duration.EndOfTurn);§effect.setTargetPointer(new FixedTarget(permanent.getId()));§game.addEffect(effect, source);§}§}§return true;§}§return false;§}§}§
public class UmezawasJitte extends CardImpl {§public UmezawasJitte(UUID ownerId) {§super(ownerId, 163, "Umezawa's Jitte", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{2}");§this.expansionSetCode = "BOK";§this.supertype.add("Legendary");§this.subtype.add("Equipment");§this.addAbility(new UmezawasJitteAbility());§Ability ability = new SimpleActivatedAbility(§Zone.BATTLEFIELD,§new BoostEquippedEffect(2, 2, Duration.EndOfTurn),§new RemoveCountersSourceCost(CounterType.CHARGE.createInstance()));§Mode mode = new Mode();§mode.getEffects().add(new BoostTargetEffect(-1, -1, Duration.EndOfTurn));§mode.getTargets().add(new TargetCreaturePermanent());§ability.addMode(mode);§mode = new Mode();§mode.getEffects().add(new GainLifeEffect(2));§ability.addMode(mode);§this.addAbility(ability);§this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(2)));§}§public UmezawasJitte(final UmezawasJitte card) {§super(card);§}§@Override§public UmezawasJitte copy() {§return new UmezawasJitte(this);§}§}§class UmezawasJitteAbility extends TriggeredAbilityImpl {§private boolean usedInPhase;§public UmezawasJitteAbility() {§super(Zone.BATTLEFIELD, new AddCountersSourceEffect(CounterType.CHARGE.createInstance(2)));§this.usedInPhase = false;§}§public UmezawasJitteAbility(final UmezawasJitteAbility ability) {§super(ability);§this.usedInPhase = ability.usedInPhase;§}§@Override§public UmezawasJitteAbility copy() {§return new UmezawasJitteAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§switch(event.getType()) {§case DAMAGED_CREATURE:§case DAMAGED_PLANESWALKER:§case DAMAGED_PLAYER:§case COMBAT_DAMAGE_STEP_PRE:§return true;§}§return false;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (event instanceof DamagedEvent && !usedInPhase && ((DamagedEvent) event).isCombatDamage()) {§Permanent permanent = game.getPermanent(event.getSourceId());§if (permanent != null && permanent.getAttachments().contains(this.getSourceId())) {§usedInPhase = true;§return true;§}§}§if (event.getType().equals(EventType.COMBAT_DAMAGE_STEP_PRE)) {§usedInPhase = false;§}§return false;§}§@Override§public String getRule() {§return "Whenever equipped creature deals combat damage, " + super.getRule();§}§}§
public class UncheckedGrowth extends CardImpl {§public UncheckedGrowth(UUID ownerId) {§super(ownerId, 148, "Unchecked Growth", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{2}{G}");§this.expansionSetCode = "BOK";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new BoostTargetEffect(4, 4, Duration.EndOfTurn));§this.getSpellAbility().addEffect(new UncheckedGrowthTrampleEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public UncheckedGrowth(final UncheckedGrowth card) {§super(card);§}§@Override§public UncheckedGrowth copy() {§return new UncheckedGrowth(this);§}§private class UncheckedGrowthTrampleEffect extends ContinuousEffectImpl {§public UncheckedGrowthTrampleEffect() {§super(Duration.EndOfTurn, Layer.AbilityAddingRemovingEffects_6, SubLayer.NA, Outcome.AddAbility);§staticText = "If it's a Spirit, it gains trample until end of turn";§}§public UncheckedGrowthTrampleEffect(final UncheckedGrowthTrampleEffect effect) {§super(effect);§}§@Override§public UncheckedGrowthTrampleEffect copy() {§return new UncheckedGrowthTrampleEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§int affectedTargets = 0;§for (UUID permanentId : targetPointer.getTargets(game, source)) {§Permanent permanent = game.getPermanent(permanentId);§if (permanent != null && permanent.hasSubtype("Spirit")) {§permanent.addAbility(TrampleAbility.getInstance(), game);§affectedTargets++;§}§}§return affectedTargets > 0;§}§}§}§
public class Uproot extends CardImpl {§public Uproot(UUID ownerId) {§super(ownerId, 149, "Uproot", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{3}{G}");§this.expansionSetCode = "BOK";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new PutOnLibraryTargetEffect(true));§this.getSpellAbility().addTarget(new TargetLandPermanent());§}§public Uproot(final Uproot card) {§super(card);§}§@Override§public Uproot copy() {§return new Uproot(this);§}§}§
public class VeilOfSecrecy extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("a blue creature");§static {§filter.add(new ColorPredicate(ObjectColor.BLUE));§}§public VeilOfSecrecy(UUID ownerId) {§super(ownerId, 59, "Veil of Secrecy", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{U}");§this.expansionSetCode = "BOK";§this.subtype.add("Arcane");§Effect effect = new GainAbilityTargetEffect(ShroudAbility.getInstance(), Duration.EndOfTurn);§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§effect.setText("Target creature gains shroud until end of turn");§this.getSpellAbility().addEffect(effect);§effect = new CantBeBlockedTargetEffect();§effect.setText("and can't be blocked this turn");§this.getSpellAbility().addEffect(effect);§this.addAbility(new SpliceOntoArcaneAbility(new ReturnToHandChosenControlledPermanentCost(new TargetControlledCreaturePermanent(filter))));§}§public VeilOfSecrecy(final VeilOfSecrecy card) {§super(card);§}§@Override§public VeilOfSecrecy copy() {§return new VeilOfSecrecy(this);§}§}§
public class VitalSurge extends CardImpl {§public VitalSurge(UUID ownerId) {§super(ownerId, 150, "Vital Surge", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{G}");§this.expansionSetCode = "BOK";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new GainLifeEffect(3));§this.addAbility(new SpliceOntoArcaneAbility("{1}{G}"));§}§public VitalSurge(final VitalSurge card) {§super(card);§}§@Override§public VitalSurge copy() {§return new VitalSurge(this);§}§}§
public class WalkerOfSecretWays extends CardImpl {§private static final FilterControlledCreaturePermanent filterCreature = new FilterControlledCreaturePermanent("Ninja you control");§static {§filterCreature.add((new SubtypePredicate("Ninja")));§}§public WalkerOfSecretWays(UUID ownerId) {§super(ownerId, 60, "Walker of Secret Ways", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{U}");§this.expansionSetCode = "BOK";§this.subtype.add("Human");§this.subtype.add("Ninja");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§this.addAbility(new NinjutsuAbility(new ManaCostsImpl("{1}{U}")));§this.addAbility(new DealsCombatDamageToAPlayerTriggeredAbility(new WalkerOfSecretWaysEffect(), true, true));§Ability ability = new ActivateIfConditionActivatedAbility(Zone.BATTLEFIELD, new ReturnToHandTargetEffect(), new ManaCostsImpl("{1}{U}"), MyTurnCondition.getInstance());§ability.addTarget(new TargetControlledCreaturePermanent(1,1, filterCreature, false));§this.addAbility(ability);§}§public WalkerOfSecretWays(final WalkerOfSecretWays card) {§super(card);§}§@Override§public WalkerOfSecretWays copy() {§return new WalkerOfSecretWays(this);§}§}§class WalkerOfSecretWaysEffect extends OneShotEffect {§WalkerOfSecretWaysEffect() {§super(Outcome.Detriment);§staticText = "look at that player's hand";§}§WalkerOfSecretWaysEffect(final WalkerOfSecretWaysEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§Player player = game.getPlayer(targetPointer.getFirst(game, source));§if (player != null && controller != null) {§controller.lookAtCards("Walker of Secret Ways", player.getHand(), game);§}§return true;§}§@Override§public WalkerOfSecretWaysEffect copy() {§return new WalkerOfSecretWaysEffect(this);§}§}§
public class WardOfPiety extends CardImpl {§public WardOfPiety(UUID ownerId) {§super(ownerId, 28, "Ward of Piety", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{W}");§this.expansionSetCode = "BOK";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.PreventDamage));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new WardOfPietyPreventDamageTargetEffect(), new ManaCostsImpl("{1}{W}"));§ability.addTarget(new TargetCreatureOrPlayer());§this.addAbility(ability);§}§public WardOfPiety(final WardOfPiety card) {§super(card);§}§@Override§public WardOfPiety copy() {§return new WardOfPiety(this);§}§}§class WardOfPietyPreventDamageTargetEffect extends RedirectionEffect {§protected MageObjectReference redirectToObject;§public WardOfPietyPreventDamageTargetEffect() {§super(Duration.EndOfTurn, 1, true);§staticText = "The next 1 damage that would be dealt to enchanted creature this turn is dealt to target creature or player instead";§}§public WardOfPietyPreventDamageTargetEffect(final WardOfPietyPreventDamageTargetEffect effect) {§super(effect);§}§@Override§public WardOfPietyPreventDamageTargetEffect copy() {§return new WardOfPietyPreventDamageTargetEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public void init(Ability source, Game game) {§super.init(source, game);§redirectToObject = new MageObjectReference(source.getTargets().get(0).getFirstTarget(), game);§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§Permanent enchantment = game.getPermanent(source.getSourceId());§if (enchantment != null && event.getTargetId().equals(enchantment.getAttachedTo())) {§if (redirectToObject.equals(new MageObjectReference(source.getTargets().get(0).getFirstTarget(), game))) {§redirectTarget = source.getTargets().get(0);§return true;§}§}§return false;§}§}§
public class WaxmaneBaku extends CardImpl {§private static final FilterSpiritOrArcaneCard filter = new FilterSpiritOrArcaneCard();§public WaxmaneBaku(UUID ownerId) {§super(ownerId, 29, "Waxmane Baku", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "BOK";§this.subtype.add("Spirit");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new SpellCastControllerTriggeredAbility(new AddCountersSourceEffect(CounterType.KI.createInstance()), filter, true));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new WaxmaneBakuTapEffect(), new GenericManaCost(1));§ability.addCost(new RemoveVariableCountersSourceCost(CounterType.KI.createInstance(1)));§this.addAbility(ability);§}§public WaxmaneBaku(final WaxmaneBaku card) {§super(card);§}§@Override§public WaxmaneBaku copy() {§return new WaxmaneBaku(this);§}§}§class WaxmaneBakuTapEffect extends OneShotEffect {§private static final FilterPermanent filter = new FilterCreaturePermanent();§public WaxmaneBakuTapEffect() {§super(Outcome.Tap);§staticText = "Tap X target creatures";§}§public WaxmaneBakuTapEffect(final WaxmaneBakuTapEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§int numberToTap = 0;§for (Cost cost : source.getCosts()) {§if (cost instanceof RemoveVariableCountersSourceCost) {§numberToTap = ((RemoveVariableCountersSourceCost) cost).getAmount();§}§}§TargetPermanent target = new TargetPermanent(numberToTap, filter);§if (target.canChoose(source.getControllerId(), game) && target.choose(Outcome.Tap, source.getControllerId(), source.getSourceId(), game)) {§if (!target.getTargets().isEmpty()) {§List<UUID> targets = target.getTargets();§for (UUID targetId : targets) {§Permanent permanent = game.getPermanent(targetId);§if (permanent != null) {§permanent.tap(game);§}§}§}§return true;§}§return false;§}§@Override§public WaxmaneBakuTapEffect copy() {§return new WaxmaneBakuTapEffect(this);§}§}§
public class YomijiWhoBarsTheWay extends CardImpl {§public YomijiWhoBarsTheWay(UUID ownerId) {§super(ownerId, 30, "Yomiji, Who Bars the Way", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}{W}{W}");§this.expansionSetCode = "BOK";§this.supertype.add("Legendary");§this.subtype.add("Spirit");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§FilterPermanent filter = new FilterPermanent("a legendary permanent other than " + getName());§filter.add(new AnotherPredicate());§filter.add(new SupertypePredicate("Legendary"));§Effect effect = new ReturnToHandTargetEffect();§effect.setText("return that card to its owner's hand");§this.addAbility(new PutIntoGraveFromBattlefieldAllTriggeredAbility(effect, false, filter, true));§}§public YomijiWhoBarsTheWay(final YomijiWhoBarsTheWay card) {§super(card);§}§@Override§public YomijiWhoBarsTheWay copy() {§return new YomijiWhoBarsTheWay(this);§}§}§
public class AcolytesReward extends CardImpl {§public AcolytesReward(UUID ownerId) {§super(ownerId, 1, "Acolyte's Reward", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{1}{W}");§this.expansionSetCode = "BNG";§this.getSpellAbility().addEffect(new AcolytesRewardEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.getSpellAbility().addTarget(new TargetCreatureOrPlayer());§}§public AcolytesReward(final AcolytesReward card) {§super(card);§}§@Override§public AcolytesReward copy() {§return new AcolytesReward(this);§}§}§class AcolytesRewardEffect extends PreventionEffectImpl {§protected int amount = 0;§public AcolytesRewardEffect() {§super(Duration.EndOfTurn);§staticText = "Prevent the next X damage that would be dealt to target creature this turn, where X is your devotion to white. If damage is prevented this way, {this} deals that much damage to target creature or player";§}§public AcolytesRewardEffect(final AcolytesRewardEffect effect) {§super(effect);§this.amount = effect.amount;§}§@Override§public AcolytesRewardEffect copy() {§return new AcolytesRewardEffect(this);§}§@Override§public void init(Ability source, Game game) {§super.init(source, game);§amount = new DevotionCount(ColoredManaSymbol.W).calculate(game, source, this);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§boolean result = false;§int toPrevent = amount;§if (event.getAmount() < this.amount) {§toPrevent = event.getAmount();§amount -= event.getAmount();§} else {§amount = 0;§}§GameEvent preventEvent = new GameEvent(GameEvent.EventType.PREVENT_DAMAGE, source.getControllerId(), source.getSourceId(), source.getControllerId(), toPrevent, false);§if (!game.replaceEvent(preventEvent)) {§Permanent targetCreature = game.getPermanent(source.getFirstTarget());§if (targetCreature != null) {§if (amount == 0) {§this.used = true;§this.discard();§}§if (event.getAmount() >= toPrevent) {§event.setAmount(event.getAmount() - toPrevent);§} else {§event.setAmount(0);§result = true;§}§if (toPrevent > 0) {§game.informPlayers(new StringBuilder("Acolyte's Reward ").append("prevented ").append(toPrevent).append(" to ").append(targetCreature.getName()).toString());§game.fireEvent(GameEvent.getEvent(GameEvent.EventType.PREVENTED_DAMAGE,§source.getControllerId(), source.getSourceId(), source.getControllerId(), toPrevent));§Player targetPlayer = game.getPlayer(source.getTargets().get(1).getFirstTarget());§if (targetPlayer != null) {§targetPlayer.damage(toPrevent, source.getSourceId(), game, false, true);§game.informPlayers(new StringBuilder("Acolyte's Reward ").append("deals ").append(toPrevent).append(" damage to ").append(targetPlayer.getLogName()).toString());§} else {§Permanent targetDamageCreature = game.getPermanent(source.getTargets().get(1).getFirstTarget());§if (targetDamageCreature != null) {§targetDamageCreature.damage(toPrevent, source.getSourceId(), game, false, true);§game.informPlayers(new StringBuilder("Acolyte's Reward ").append("deals ").append(toPrevent).append(" damage to ").append(targetDamageCreature.getName()).toString());§}§}§}§}§}§return result;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§return !this.used && super.applies(event, source, game) && event.getTargetId().equals(source.getFirstTarget());§}§}§
public class AerieWorshippers extends CardImpl {§public AerieWorshippers(UUID ownerId) {§super(ownerId, 30, "Aerie Worshippers", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{U}");§this.expansionSetCode = "BNG";§this.subtype.add("Human");§this.subtype.add("Cleric");§this.power = new MageInt(2);§this.toughness = new MageInt(4);§this.addAbility(new InspiredAbility(new DoIfCostPaid(new CreateTokenEffect(new AerieWorshippersBirdToken()), new ManaCostsImpl("{2}{U}"))));§}§public AerieWorshippers(final AerieWorshippers card) {§super(card);§}§@Override§public AerieWorshippers copy() {§return new AerieWorshippers(this);§}§}§class AerieWorshippersBirdToken extends Token {§public AerieWorshippersBirdToken() {§super("Bird", "2/2 blue Bird enchantment creature token with flying");§cardType.add(CardType.ENCHANTMENT);§cardType.add(CardType.CREATURE);§color.setBlue(true);§subtype.add("Bird");§power = new MageInt(2);§toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§this.setOriginalExpansionSetCode("BNG");§this.setTokenType(2);§}§}§
public class AkroanConscriptor extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("another target creature");§static {§filter.add(new AnotherPredicate());§}§public AkroanConscriptor(UUID ownerId) {§super(ownerId, 87, "Akroan Conscriptor", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{R}");§this.expansionSetCode = "BNG";§this.subtype.add("Human");§this.subtype.add("Shaman");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§Ability ability = new HeroicAbility(new GainControlTargetEffect(Duration.EndOfTurn, true), false);§Effect effect = new UntapTargetEffect();§effect.setText("Untap that creature");§ability.addEffect(effect);§effect = new GainAbilityTargetEffect(HasteAbility.getInstance(), Duration.EndOfTurn);§effect.setText("It gains haste until end of turn");§ability.addEffect(effect);§ability.addTarget(new TargetCreaturePermanent(filter));§this.addAbility(ability);§}§public AkroanConscriptor(final AkroanConscriptor card) {§super(card);§}§@Override§public AkroanConscriptor copy() {§return new AkroanConscriptor(this);§}§}§
public class AkroanPhalanx extends CardImpl {§public AkroanPhalanx(UUID ownerId) {§super(ownerId, 2, "Akroan Phalanx", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{W}");§this.expansionSetCode = "BNG";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(VigilanceAbility.getInstance());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostControlledEffect(1,0, Duration.EndOfTurn), new ManaCostsImpl("{2}{R}")));§}§public AkroanPhalanx(final AkroanPhalanx card) {§super(card);§}§@Override§public AkroanPhalanx copy() {§return new AkroanPhalanx(this);§}§}§
public class AkroanSkyguard extends CardImpl {§public AkroanSkyguard(UUID ownerId) {§super(ownerId, 3, "Akroan Skyguard", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "BNG";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new HeroicAbility(new AddCountersSourceEffect(CounterType.P1P1.createInstance(), true)));§}§public AkroanSkyguard(final AkroanSkyguard card) {§super(card);§}§@Override§public AkroanSkyguard copy() {§return new AkroanSkyguard(this);§}§}§
public class ArbiterOfTheIdeal extends CardImpl {§public ArbiterOfTheIdeal(UUID ownerId) {§super(ownerId, 31, "Arbiter of the Ideal", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{U}{U}");§this.expansionSetCode = "BNG";§this.subtype.add("Sphinx");§this.power = new MageInt(4);§this.toughness = new MageInt(5);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new InspiredAbility(new ArbiterOfTheIdealEffect()));§}§public ArbiterOfTheIdeal(final ArbiterOfTheIdeal card) {§super(card);§}§@Override§public ArbiterOfTheIdeal copy() {§return new ArbiterOfTheIdeal(this);§}§}§class ArbiterOfTheIdealEffect extends OneShotEffect {§private static final FilterCard filter = new FilterCard();§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.ARTIFACT),§new CardTypePredicate(CardType.CREATURE),§new CardTypePredicate(CardType.LAND)));§}§public ArbiterOfTheIdealEffect() {§super(Outcome.PutCardInPlay);§this.staticText = "reveal the top card of your library. If it's an artifact, creature, or land card, you may put it onto the battlefield with a manifestation counter on it. It's an enchantment in addition to its other types";§}§public ArbiterOfTheIdealEffect(final ArbiterOfTheIdealEffect effect) {§super(effect);§}§@Override§public ArbiterOfTheIdealEffect copy() {§return new ArbiterOfTheIdealEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player == null) {§return false;§}§if (player.getLibrary().size() > 0) {§Card card = player.getLibrary().getFromTop(game);§Cards cards = new CardsImpl();§cards.add(card);§player.revealCards("Arbiter of the Ideal", cards, game);§if (card != null) {§if (filter.match(card, game) && player.chooseUse(outcome, new StringBuilder("Put ").append(card.getName()).append("onto battlefield?").toString(), source, game)) {§card.putOntoBattlefield(game, Zone.LIBRARY, source.getSourceId(), source.getControllerId());§Permanent permanent = game.getPermanent(card.getId());§if (permanent != null) {§permanent.addCounters(new Counter("Manifestation"), game);§ContinuousEffect effect = new AddCardTypeTargetEffect(CardType.ENCHANTMENT, Duration.Custom);§effect.setTargetPointer(new FixedTarget(permanent.getId()));§game.addEffect(effect, source);§}§}§}§return true;§}§return false;§}§}§
public class ArchetypeOfAggression extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Creatures your opponents control");§static {§filter.add(new ControllerPredicate(TargetController.OPPONENT));§}§public ArchetypeOfAggression(UUID ownerId) {§super(ownerId, 88, "Archetype of Aggression", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT, CardType.CREATURE}, "{1}{R}{R}");§this.expansionSetCode = "BNG";§this.subtype.add("Human");§this.subtype.add("Warrior");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityControlledEffect(TrampleAbility.getInstance(), Duration.WhileOnBattlefield, new FilterCreaturePermanent("Creatures"))));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new CreaturesCantGetOrHaveAbilityEffect(TrampleAbility.getInstance(), Duration.WhileOnBattlefield, filter)));§}§public ArchetypeOfAggression(final ArchetypeOfAggression card) {§super(card);§}§@Override§public ArchetypeOfAggression copy() {§return new ArchetypeOfAggression(this);§}§}§
public class ArchetypeOfCourage extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Creatures your opponents control");§static {§filter.add(new ControllerPredicate(TargetController.OPPONENT));§}§public ArchetypeOfCourage(UUID ownerId) {§super(ownerId, 4, "Archetype of Courage", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT, CardType.CREATURE}, "{1}{W}{W}");§this.expansionSetCode = "BNG";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityControlledEffect(FirstStrikeAbility.getInstance(), Duration.WhileOnBattlefield, new FilterCreaturePermanent("Creatures"))));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new CreaturesCantGetOrHaveAbilityEffect(FirstStrikeAbility.getInstance(), Duration.WhileOnBattlefield, filter)));§}§public ArchetypeOfCourage(final ArchetypeOfCourage card) {§super(card);§}§@Override§public ArchetypeOfCourage copy() {§return new ArchetypeOfCourage(this);§}§}§
public class ArchetypeOfEndurance extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Creatures your opponents control");§static {§filter.add(new ControllerPredicate(TargetController.OPPONENT));§}§public ArchetypeOfEndurance(UUID ownerId) {§super(ownerId, 116, "Archetype of Endurance", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT, CardType.CREATURE}, "{6}{G}{G}");§this.expansionSetCode = "BNG";§this.subtype.add("Boar");§this.power = new MageInt(6);§this.toughness = new MageInt(5);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityControlledEffect(HexproofAbility.getInstance(), Duration.WhileOnBattlefield, new FilterCreaturePermanent("Creatures"))));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new CreaturesCantGetOrHaveAbilityEffect(HexproofAbility.getInstance(), Duration.WhileOnBattlefield, filter)));§}§public ArchetypeOfEndurance(final ArchetypeOfEndurance card) {§super(card);§}§@Override§public ArchetypeOfEndurance copy() {§return new ArchetypeOfEndurance(this);§}§}§
public class ArchetypeOfFinality extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Creatures your opponents control");§static {§filter.add(new ControllerPredicate(TargetController.OPPONENT));§}§public ArchetypeOfFinality(UUID ownerId) {§super(ownerId, 58, "Archetype of Finality", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT, CardType.CREATURE}, "{4}{B}{B}");§this.expansionSetCode = "BNG";§this.subtype.add("Gorgon");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityControlledEffect(DeathtouchAbility.getInstance(), Duration.WhileOnBattlefield, new FilterCreaturePermanent("Creatures"))));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new CreaturesCantGetOrHaveAbilityEffect(DeathtouchAbility.getInstance(), Duration.WhileOnBattlefield, filter)));§}§public ArchetypeOfFinality(final ArchetypeOfFinality card) {§super(card);§}§@Override§public ArchetypeOfFinality copy() {§return new ArchetypeOfFinality(this);§}§}§
public class ArchetypeOfImagination extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Creatures your opponents control");§static {§filter.add(new ControllerPredicate(TargetController.OPPONENT));§}§public ArchetypeOfImagination(UUID ownerId) {§super(ownerId, 32, "Archetype of Imagination", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT, CardType.CREATURE}, "{4}{U}{U}");§this.expansionSetCode = "BNG";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityControlledEffect(FlyingAbility.getInstance(), Duration.WhileOnBattlefield, new FilterCreaturePermanent("Creatures"))));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new CreaturesCantGetOrHaveAbilityEffect(FlyingAbility.getInstance(), Duration.WhileOnBattlefield, filter)));§}§public ArchetypeOfImagination(final ArchetypeOfImagination card) {§super(card);§}§@Override§public ArchetypeOfImagination copy() {§return new ArchetypeOfImagination(this);§}§}§
public class AshioksAdept extends CardImpl {§public AshioksAdept(UUID ownerId) {§super(ownerId, 59, "Ashiok's Adept", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{B}");§this.expansionSetCode = "BNG";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(3);§this.addAbility(new HeroicAbility(new DiscardEachPlayerEffect(TargetController.OPPONENT)));§}§public AshioksAdept(final AshioksAdept card) {§super(card);§}§@Override§public AshioksAdept copy() {§return new AshioksAdept(this);§}§}§
public class AspectOfHydra extends CardImpl {§public AspectOfHydra(UUID ownerId) {§super(ownerId, 117, "Aspect of Hydra", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{G}");§this.expansionSetCode = "BNG";§DynamicValue greenDevotion = new DevotionCount(ColoredManaSymbol.G);§Effect effect = new BoostTargetEffect(greenDevotion, greenDevotion, Duration.EndOfTurn, true);§effect.setText("Target creature gets +X/+X until end of turn, where X is your devotion to green");§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public AspectOfHydra(final AspectOfHydra card) {§super(card);§}§@Override§public AspectOfHydra copy() {§return new AspectOfHydra(this);§}§}§
public class Asphyxiate extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("untapped creature");§static {§filter.add(Predicates.not(new TappedPredicate()));§}§public Asphyxiate(UUID ownerId) {§super(ownerId, 60, "Asphyxiate", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{1}{B}{B}");§this.expansionSetCode = "BNG";§this.getSpellAbility().addEffect(new DestroyTargetEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent(filter));§}§public Asphyxiate(final Asphyxiate card) {§super(card);§}§@Override§public Asphyxiate copy() {§return new Asphyxiate(this);§}§}§
public class AstralCornucopia extends CardImpl {§public AstralCornucopia(UUID ownerId) {§super(ownerId, 157, "Astral Cornucopia", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{X}{X}{X}");§this.expansionSetCode = "BNG";§this.addAbility(new EntersBattlefieldAbility(new EntersBattlefieldWithXCountersEffect(CounterType.CHARGE.createInstance())));§this.addAbility(new AstralCornucopiaManaAbility());§}§public AstralCornucopia(final AstralCornucopia card) {§super(card);§}§@Override§public AstralCornucopia copy() {§return new AstralCornucopia(this);§}§}§class AstralCornucopiaManaAbility extends ManaAbility {§public AstralCornucopiaManaAbility() {§super(Zone.BATTLEFIELD, new AstralCornucopiaManaEffect(), new TapSourceCost());§}§public AstralCornucopiaManaAbility(final AstralCornucopiaManaAbility ability) {§super(ability);§}§@Override§public AstralCornucopiaManaAbility copy() {§return new AstralCornucopiaManaAbility(this);§}§@Override§public List<Mana> getNetMana(Game game) {§netMana.clear();§Permanent sourcePermanent = game.getPermanent(getSourceId());§if (sourcePermanent != null) {§int counters = sourcePermanent.getCounters().getCount(CounterType.CHARGE.getName());§if (counters > 0) {§netMana.add(new Mana(0, 0, 0, 0, 0, 0, counters, 0));§}§}§return netMana;§}§}§class AstralCornucopiaManaEffect extends ManaEffect {§private final Mana computedMana;§public AstralCornucopiaManaEffect() {§super();§computedMana = new Mana();§this.staticText = "Choose a color. Add one mana of that color to your mana pool for each charge counter on {this}";§}§public AstralCornucopiaManaEffect(final AstralCornucopiaManaEffect effect) {§super(effect);§this.computedMana = effect.computedMana.copy();§}§@Override§public AstralCornucopiaManaEffect copy() {§return new AstralCornucopiaManaEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§ChoiceColor choice = new ChoiceColor();§choice.setMessage("Choose a color to add mana of that color");§if (controller.choose(outcome, choice, game)) {§Permanent sourcePermanent = game.getPermanent(source.getSourceId());§if (choice.getChoice() != null) {§String color = choice.getChoice();§int counters = sourcePermanent.getCounters().getCount(CounterType.CHARGE.getName());§switch (color) {§case "Red":§computedMana.setRed(counters);§break;§case "Blue":§computedMana.setBlue(counters);§break;§case "White":§computedMana.setWhite(counters);§break;§case "Black":§computedMana.setBlack(counters);§break;§case "Green":§computedMana.setGreen(counters);§break;§}§}§checkToFirePossibleEvents(computedMana, game, source);§controller.getManaPool().addMana(computedMana, game, source);§return true;§}§}§return false;§}§@Override§public Mana getMana(Game game, Ability source) {§return null;§}§}§
public class BileBlight extends CardImpl {§public BileBlight(UUID ownerId) {§super(ownerId, 61, "Bile Blight", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{B}{B}");§this.expansionSetCode = "BNG";§this.getSpellAbility().addEffect(new BileBlightEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public BileBlight(final BileBlight card) {§super(card);§}§@Override§public BileBlight copy() {§return new BileBlight(this);§}§}§class BileBlightEffect extends BoostAllEffect {§public BileBlightEffect() {§super(-3, -3, Duration.EndOfTurn);§staticText = "Target creature and all creatures with the same name as that creature get -3/-3 until end of turn";§}§public BileBlightEffect(final BileBlightEffect effect) {§super(effect);§}§@Override§public void init(Ability source, Game game) {§super.init(source, game);§affectedObjectList.clear();§if (this.affectedObjectsSet) {§Permanent target = game.getPermanent(getTargetPointer().getFirst(game, source));§if (target != null) {§if (target.getName().isEmpty()) { §
public class BlackOakOfOdunos extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("another untapped creature you control");§static {§filter.add(new AnotherPredicate());§filter.add(Predicates.not(new TappedPredicate()));§}§public BlackOakOfOdunos(UUID ownerId) {§super(ownerId, 62, "Black Oak of Odunos", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{B}");§this.expansionSetCode = "BNG";§this.subtype.add("Zombie");§this.subtype.add("Treefolk");§this.power = new MageInt(0);§this.toughness = new MageInt(5);§this.addAbility(DefenderAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(1, 1, Duration.EndOfTurn), new ManaCostsImpl("{B}"));§ability.addCost(new TapTargetCost(new TargetControlledCreaturePermanent(1, 1, filter, true)));§this.addAbility(ability);§}§public BlackOakOfOdunos(final BlackOakOfOdunos card) {§super(card);§}§@Override§public BlackOakOfOdunos copy() {§return new BlackOakOfOdunos(this);§}§}§
public class BoltOfKeranos extends CardImpl {§public BoltOfKeranos(UUID ownerId) {§super(ownerId, 89, "Bolt of Keranos", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{1}{R}{R}");§this.expansionSetCode = "BNG";§this.getSpellAbility().addEffect(new DamageTargetEffect(3));§this.getSpellAbility().addTarget(new TargetCreatureOrPlayer());§this.getSpellAbility().addEffect(new ScryEffect(1));§}§public BoltOfKeranos(final BoltOfKeranos card) {§super(card);§}§@Override§public BoltOfKeranos copy() {§return new BoltOfKeranos(this);§}§}§
public class ChargingBadger extends CardImpl {§public ChargingBadger(UUID ownerId) {§super(ownerId, 118, "Charging Badger", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{G}");§this.expansionSetCode = "BNG";§this.subtype.add("Badger");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(TrampleAbility.getInstance());§}§public ChargingBadger(final ChargingBadger card) {§super(card);§}§@Override§public ChargingBadger copy() {§return new ChargingBadger(this);§}§}§
public class ChorusOfTheTides extends CardImpl {§public ChorusOfTheTides(UUID ownerId) {§super(ownerId, 33, "Chorus of the Tides", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{U}");§this.expansionSetCode = "BNG";§this.subtype.add("Siren");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new HeroicAbility(new ScryEffect(1)));§}§public ChorusOfTheTides(final ChorusOfTheTides card) {§super(card);§}§@Override§public ChorusOfTheTides copy() {§return new ChorusOfTheTides(this);§}§}§
public class Chromanticore extends CardImpl {§public Chromanticore(UUID ownerId) {§super(ownerId, 144, "Chromanticore", Rarity.MYTHIC, new CardType[]{CardType.ENCHANTMENT, CardType.CREATURE}, "{W}{U}{B}{R}{G}");§this.expansionSetCode = "BNG";§this.subtype.add("Manticore");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(new BestowAbility(this, "{2}{W}{U}{B}{R}{G}"));§this.addAbility(FlyingAbility.getInstance());§this.addAbility(FirstStrikeAbility.getInstance());§this.addAbility(VigilanceAbility.getInstance());§this.addAbility(TrampleAbility.getInstance());§this.addAbility(LifelinkAbility.getInstance());§Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(4,4));§Effect effect = new GainAbilityAttachedEffect(FlyingAbility.getInstance(), AttachmentType.AURA);§effect.setText("and has flying");§ability.addEffect(effect);§effect = new GainAbilityAttachedEffect(FirstStrikeAbility.getInstance(), AttachmentType.AURA);§effect.setText(", first strike");§ability.addEffect(effect);§effect = new GainAbilityAttachedEffect(VigilanceAbility.getInstance(), AttachmentType.AURA);§effect.setText(", vigilance");§ability.addEffect(effect);§effect = new GainAbilityAttachedEffect(TrampleAbility.getInstance(), AttachmentType.AURA);§effect.setText(", trample");§ability.addEffect(effect);§effect = new GainAbilityAttachedEffect(LifelinkAbility.getInstance(), AttachmentType.AURA);§effect.setText("and lifelink");§ability.addEffect(effect);§this.addAbility(ability);§}§public Chromanticore(final Chromanticore card) {§super(card);§}§@Override§public Chromanticore copy() {§return new Chromanticore(this);§}§}§
public class ClaimOfErebos extends CardImpl {§public ClaimOfErebos(UUID ownerId) {§super(ownerId, 64, "Claim of Erebos", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{B}");§this.expansionSetCode = "BNG";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§Ability grantedAbility = new SimpleActivatedAbility(Zone.BATTLEFIELD, new LoseLifeTargetEffect(2), new ManaCostsImpl("{1}{B}"));§grantedAbility.addCost(new TapSourceCost());§grantedAbility.addTarget(new TargetPlayer());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(grantedAbility, AttachmentType.AURA, Duration.WhileOnBattlefield)));§}§public ClaimOfErebos(final ClaimOfErebos card) {§super(card);§}§@Override§public ClaimOfErebos copy() {§return new ClaimOfErebos(this);§}§}§
public class CourserOfKruphix extends CardImpl {§public CourserOfKruphix(UUID ownerId) {§super(ownerId, 119, "Courser of Kruphix", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT, CardType.CREATURE}, "{1}{G}{G}");§this.expansionSetCode = "BNG";§this.subtype.add("Centaur");§this.power = new MageInt(2);§this.toughness = new MageInt(4);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new PlayWithTheTopCardRevealedEffect()));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new PlayTheTopCardEffect(new FilterLandCard())));§this.addAbility(new EntersBattlefieldControlledTriggeredAbility(new GainLifeEffect(1), new FilterLandPermanent("a land")));§}§public CourserOfKruphix(final CourserOfKruphix card) {§super(card);§}§@Override§public CourserOfKruphix copy() {§return new CourserOfKruphix(this);§}§}§
public class Crypsis extends CardImpl {§public static final FilterCard filter = new FilterCard("creatures your opponents control");§static {§filter.add(new CardTypePredicate(CardType.CREATURE));§filter.add(new ControllerPredicate(TargetController.OPPONENT));§}§public Crypsis(UUID ownerId) {§super(ownerId, 34, "Crypsis", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{U}");§this.expansionSetCode = "BNG";§this.getSpellAbility().addEffect(new GainAbilityTargetEffect(new ProtectionAbility(filter), Duration.EndOfTurn));§Effect effect = new UntapTargetEffect();§effect.setText("Untap it.");§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addTarget(new TargetControlledCreaturePermanent());§}§public Crypsis(final Crypsis card) {§super(card);§}§@Override§public Crypsis copy() {§return new Crypsis(this);§}§}§
public class CullingMark extends CardImpl {§public CullingMark(UUID ownerId) {§super(ownerId, 120, "Culling Mark", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{2}{G}");§this.expansionSetCode = "BNG";§this.getSpellAbility().addEffect(new BlocksIfAbleTargetEffect(Duration.EndOfTurn));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public CullingMark(final CullingMark card) {§super(card);§}§@Override§public CullingMark copy() {§return new CullingMark(this);§}§}§
public class CyclopsOfOneEyedPass extends CardImpl {§public CyclopsOfOneEyedPass(UUID ownerId) {§super(ownerId, 90, "Cyclops of One-Eyed Pass", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{R}{R}");§this.expansionSetCode = "BNG";§this.subtype.add("Cyclops");§this.power = new MageInt(5);§this.toughness = new MageInt(2);§}§public CyclopsOfOneEyedPass(final CyclopsOfOneEyedPass card) {§super(card);§}§@Override§public CyclopsOfOneEyedPass copy() {§return new CyclopsOfOneEyedPass(this);§}§}§
public class DawnToDusk extends CardImpl {§private static final FilterCard filterCard = new FilterCard("enchantment card from your graveyard");§private static final FilterPermanent filter = new FilterPermanent("enchantment");§static {§filterCard.add(new CardTypePredicate(CardType.ENCHANTMENT));§filter.add(new CardTypePredicate(CardType.ENCHANTMENT));§}§public DawnToDusk(UUID ownerId) {§super(ownerId, 6, "Dawn to Dusk", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{2}{W}{W}");§this.expansionSetCode = "BNG";§this.getSpellAbility().getModes().setMinModes(1);§this.getSpellAbility().getModes().setMaxModes(2);§this.getSpellAbility().addEffect(new ReturnFromGraveyardToHandTargetEffect());§this.getSpellAbility().addTarget(new TargetCardInYourGraveyard(filterCard));§Mode mode = new Mode();§mode.getEffects().add(new DestroyTargetEffect());§mode.getTargets().add(new TargetPermanent(filter));§this.getSpellAbility().addMode(mode);§}§public DawnToDusk(final DawnToDusk card) {§super(card);§}§@Override§public DawnToDusk copy() {§return new DawnToDusk(this);§}§}§
public class DeepwaterHypnotist extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature an opponent controls");§static {§filter.add(new ControllerPredicate(TargetController.OPPONENT));§}§public DeepwaterHypnotist(UUID ownerId) {§super(ownerId, 35, "Deepwater Hypnotist", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{U}");§this.expansionSetCode = "BNG";§this.subtype.add("Merfolk");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§Ability ability = new InspiredAbility(new BoostTargetEffect(-3,0,Duration.EndOfTurn));§ability.addTarget(new TargetCreaturePermanent(filter));§this.addAbility(ability);§}§public DeepwaterHypnotist(final DeepwaterHypnotist card) {§super(card);§}§@Override§public DeepwaterHypnotist copy() {§return new DeepwaterHypnotist(this);§}§}§
public class DrownInSorrow extends CardImpl {§public DrownInSorrow(UUID ownerId) {§super(ownerId, 65, "Drown in Sorrow", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{1}{B}{B}");§this.expansionSetCode = "BNG";§this.getSpellAbility().addEffect(new BoostAllEffect(-2, -2, Duration.EndOfTurn));§this.getSpellAbility().addEffect(new ScryEffect(1));§}§public DrownInSorrow(final DrownInSorrow card) {§super(card);§}§@Override§public DrownInSorrow copy() {§return new DrownInSorrow(this);§}§}§
public class EaterOfHope extends CardImpl {§private static final FilterControlledCreaturePermanent regenFilter = new FilterControlledCreaturePermanent("another creature");§private static final FilterControlledCreaturePermanent destroyFilter = new FilterControlledCreaturePermanent("two other creatures");§static {§regenFilter.add(new AnotherPredicate());§destroyFilter.add(new AnotherPredicate());§}§public EaterOfHope(UUID ownerId) {§super(ownerId, 66, "Eater of Hope", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}{B}{B}");§this.expansionSetCode = "BNG";§this.subtype.add("Demon");§this.power = new MageInt(6);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§Ability regenAbility = new SimpleActivatedAbility(Zone.BATTLEFIELD, new RegenerateSourceEffect(), new ManaCostsImpl("{B}"));§regenAbility.addCost(new SacrificeTargetCost(new TargetControlledCreaturePermanent(1, 1, regenFilter, true)));§this.addAbility(regenAbility);§Ability destroyAbility = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DestroyTargetEffect(), new ManaCostsImpl("{2}{B}"));§destroyAbility.addCost(new SacrificeTargetCost(new TargetControlledCreaturePermanent(2, 2, destroyFilter, true)));§destroyAbility.addTarget(new TargetCreaturePermanent());§this.addAbility(destroyAbility);§}§public EaterOfHope(final EaterOfHope card) {§super(card);§}§@Override§public EaterOfHope copy() {§return new EaterOfHope(this);§}§}§
public class EidolonOfCountlessBattles extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent();§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.CREATURE),§new SubtypePredicate("Aura")));§}§public EidolonOfCountlessBattles(UUID ownerId) {§super(ownerId, 7, "Eidolon of Countless Battles", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT, CardType.CREATURE}, "{1}{W}{W}");§this.expansionSetCode = "BNG";§this.subtype.add("Spirit");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§this.addAbility(new BestowAbility(this, "{2}{W}{W}"));§PermanentsOnBattlefieldCount amount = new PermanentsOnBattlefieldCount(filter, 1);§Effect effect = new BoostSourceEffect(amount, amount, Duration.WhileOnBattlefield);§effect.setText("{this} and enchanted creature get +1/+1 for each creature you control");§Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, effect);§effect = new BoostEnchantedEffect(amount, amount, Duration.WhileOnBattlefield);§effect.setText("and +1/+1 for each Aura you control");§ability.addEffect(effect);§this.addAbility(ability);§}§public EidolonOfCountlessBattles(final EidolonOfCountlessBattles card) {§super(card);§}§@Override§public EidolonOfCountlessBattles copy() {§return new EidolonOfCountlessBattles(this);§}§}§
public class EliteSkirmisher extends CardImpl {§public EliteSkirmisher(UUID ownerId) {§super(ownerId, 8, "Elite Skirmisher", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "BNG";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(3);§this.toughness = new MageInt(1);§Ability ability = new HeroicAbility(new TapTargetEffect(), true);§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public EliteSkirmisher(final EliteSkirmisher card) {§super(card);§}§@Override§public EliteSkirmisher copy() {§return new EliteSkirmisher(this);§}§}§
public class EpharaGodOfThePolis extends CardImpl {§public EpharaGodOfThePolis(UUID ownerId) {§super(ownerId, 145, "Ephara, God of the Polis", Rarity.MYTHIC, new CardType[]{CardType.ENCHANTMENT, CardType.CREATURE}, "{2}{W}{U}");§this.expansionSetCode = "BNG";§this.supertype.add("Legendary");§this.subtype.add("God");§this.power = new MageInt(6);§this.toughness = new MageInt(5);§this.addAbility(IndestructibleAbility.getInstance());§Effect effect = new LoseCreatureTypeSourceEffect(new DevotionCount(ColoredManaSymbol.W, ColoredManaSymbol.U), 7);§effect.setText("As long as your devotion to white and blue is less than seven, Ephara isn't a creature");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, effect));§this.addAbility(new ConditionalTriggeredAbility(§new BeginningOfUpkeepTriggeredAbility(Zone.BATTLEFIELD, new DrawCardSourceControllerEffect(1), TargetController.ANY, false),§HadAnotherCreatureEnterTheBattlefieldCondition.getInstance(),§"At the beginning of each upkeep, if you had another creature enter the battlefield under your control last turn, draw a card."),§new CreatureEnteredBattlefieldLastTurnWatcher());§}§public EpharaGodOfThePolis(final EpharaGodOfThePolis card) {§super(card);§}§@Override§public EpharaGodOfThePolis copy() {§return new EpharaGodOfThePolis(this);§}§}§class HadAnotherCreatureEnterTheBattlefieldCondition implements Condition {§private static HadAnotherCreatureEnterTheBattlefieldCondition fInstance = new HadAnotherCreatureEnterTheBattlefieldCondition();§public static HadAnotherCreatureEnterTheBattlefieldCondition getInstance() {§return fInstance;§}§@Override§public boolean apply(Game game, Ability source) {§Watcher watcher = game.getState().getWatchers().get("CreatureEnteredBattlefieldLastTurnWatcher", source.getSourceId());§return watcher != null && watcher.conditionMet();§}§}§class CreatureEnteredBattlefieldLastTurnWatcher extends Watcher {§private boolean anotherCreatureEntered = false;§public CreatureEnteredBattlefieldLastTurnWatcher() {§super("CreatureEnteredBattlefieldLastTurnWatcher", WatcherScope.CARD);§}§public CreatureEnteredBattlefieldLastTurnWatcher(final CreatureEnteredBattlefieldLastTurnWatcher watcher) {§super(watcher);§this.anotherCreatureEntered = watcher.anotherCreatureEntered;§}§@Override§public void watch(GameEvent event, Game game) {§if (!anotherCreatureEntered && event.getType() == GameEvent.EventType.ENTERS_THE_BATTLEFIELD) {§if (!event.getTargetId().equals(this.getSourceId()) && event.getPlayerId().equals(this.getControllerId())) {§Permanent permanent = game.getPermanent(event.getTargetId());§if (permanent != null && permanent.getCardType().contains(CardType.CREATURE)) {§anotherCreatureEntered = true;§}§}§}§}§@Override§public void reset() {§condition = anotherCreatureEntered;§anotherCreatureEntered = false;§}§@Override§public CreatureEnteredBattlefieldLastTurnWatcher copy() {§return new CreatureEnteredBattlefieldLastTurnWatcher(this);§}§}§
public class EpharasEnlightenment extends CardImpl {§public EpharasEnlightenment(UUID ownerId) {§super(ownerId, 146, "Ephara's Enlightenment", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{W}{U}");§this.expansionSetCode = "BNG";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new EntersBattlefieldTriggeredAbility(new AddCountersAttachedEffect(CounterType.P1P1.createInstance(), "enchanted creature"), false));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(FlyingAbility.getInstance(), AttachmentType.AURA)));§this.addAbility(new EntersBattlefieldControlledTriggeredAbility(Zone.BATTLEFIELD,§new ReturnToHandSourceEffect(true),§new FilterCreaturePermanent("a creature"),§true));§}§public EpharasEnlightenment(final EpharasEnlightenment card) {§super(card);§}§@Override§public EpharasEnlightenment copy() {§return new EpharasEnlightenment(this);§}§}§
public class EpharasRadiance extends CardImpl {§public EpharasRadiance(UUID ownerId) {§super(ownerId, 9, "Ephara's Radiance", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{W}");§this.expansionSetCode = "BNG";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainLifeEffect(3), new ManaCostsImpl("{1}{W}"));§ability.addCost(new TapSourceCost());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(ability, AttachmentType.AURA, Duration.WhileOnBattlefield)));§}§public EpharasRadiance(final EpharasRadiance card) {§super(card);§}§@Override§public EpharasRadiance copy() {§return new EpharasRadiance(this);§}§}§
public class EpiphanyStorm extends CardImpl {§public EpiphanyStorm(UUID ownerId) {§super(ownerId, 91, "Epiphany Storm", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{R}");§this.expansionSetCode = "BNG";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§Ability drawAbility = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DrawCardSourceControllerEffect(1), new ManaCostsImpl("{R}"));§drawAbility.addCost(new TapSourceCost());§drawAbility.addCost(new DiscardCardCost());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(drawAbility, AttachmentType.AURA)));§}§public EpiphanyStorm(final EpiphanyStorm card) {§super(card);§}§@Override§public EpiphanyStorm copy() {§return new EpiphanyStorm(this);§}§}§
public class Excoriate extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("tapped creature");§static {§filter.add(new TappedPredicate());§}§public Excoriate(UUID ownerId) {§super(ownerId, 10, "Excoriate", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{3}{W}");§this.expansionSetCode = "BNG";§this.getSpellAbility().addEffect(new ExileTargetEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent(filter));§}§public Excoriate(final Excoriate card) {§super(card);§}§@Override§public Excoriate copy() {§return new Excoriate(this);§}§}§
public class EyeGouge extends CardImpl {§public EyeGouge(UUID ownerId) {§super(ownerId, 67, "Eye Gouge", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{B}");§this.expansionSetCode = "BNG";§this.getSpellAbility().addEffect(new BoostTargetEffect(-1,-1, Duration.EndOfTurn));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§Effect effect = new ConditionalOneShotEffect(new DestroyTargetEffect(), new TargetHasSubtypeCondition("Cyclops"),§"If it's a Cyclops, destroy it");§this.getSpellAbility().addEffect(effect);§}§public EyeGouge(final EyeGouge card) {§super(card);§}§@Override§public EyeGouge copy() {§return new EyeGouge(this);§}§}§
public class FallOfTheHammer extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("another target creature");§public FallOfTheHammer(UUID ownerId) {§super(ownerId, 93, "Fall of the Hammer", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{R}");§this.expansionSetCode = "BNG";§this.getSpellAbility().addEffect(new FallOfTheHammerDamageEffect());§this.getSpellAbility().addTarget(new TargetControlledCreaturePermanent());§this.getSpellAbility().addTarget(new FallOfTheHammerTargetCreaturePermanent(filter));§}§public FallOfTheHammer(final FallOfTheHammer card) {§super(card);§}§@Override§public FallOfTheHammer copy() {§return new FallOfTheHammer(this);§}§}§class FallOfTheHammerDamageEffect extends OneShotEffect {§public FallOfTheHammerDamageEffect() {§super(Outcome.Damage);§this.staticText = "Target creature you control deals damage equal to its power to another target creature";§}§public FallOfTheHammerDamageEffect(final FallOfTheHammerDamageEffect effect) {§super(effect);§}§@Override§public FallOfTheHammerDamageEffect copy() {§return new FallOfTheHammerDamageEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent ownCreature = game.getPermanent(source.getFirstTarget());§if (ownCreature != null) {§int damage = ownCreature.getPower().getValue();§Permanent targetCreature = game.getPermanent(source.getTargets().get(1).getFirstTarget());§if (targetCreature != null) {§targetCreature.damage(damage, ownCreature.getId(), game, false, true);§return true;§}§}§return false;§}§}§class FallOfTheHammerTargetCreaturePermanent extends TargetCreaturePermanent {§public FallOfTheHammerTargetCreaturePermanent(FilterCreaturePermanent filter) {§super(filter);§}§@Override§public boolean canTarget(UUID id, Ability source, Game game) {§if (source.getTargets().getFirstTarget().equals(id)) {§return false;§}§return super.canTarget(id, source, game);§}§@Override§public boolean canTarget(UUID controllerId, UUID id, Ability source, Game game) {§if (source.getTargets().getFirstTarget().equals(id)) {§return false;§}§return super.canTarget(controllerId, id, source, game);§}§}§
public class FanaticOfXenagos extends CardImpl {§public FanaticOfXenagos(UUID ownerId) {§super(ownerId, 147, "Fanatic of Xenagos", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{R}{G}");§this.expansionSetCode = "BNG";§this.subtype.add("Centaur");§this.subtype.add("Warrior");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(TrampleAbility.getInstance());§this.addAbility(new TributeAbility(1));§TriggeredAbility ability = new EntersBattlefieldTriggeredAbility(new BoostSourceEffect(1,1, Duration.EndOfTurn));§ability.addEffect( new GainAbilitySourceEffect(new GainAbilitySourceEffect(HasteAbility.getInstance(), Duration.EndOfTurn)));§this.addAbility(new ConditionalTriggeredAbility(ability, TributeNotPaidCondition.getInstance(),§"When {this} enters the battlefield, if its tribute wasn't paid, it gets +1/+1 and gains haste until end of turn."));§}§public FanaticOfXenagos(final FanaticOfXenagos card) {§super(card);§}§@Override§public FanaticOfXenagos copy() {§return new FanaticOfXenagos(this);§}§}§
public class FatedConflagration extends CardImpl {§public FatedConflagration(UUID ownerId) {§super(ownerId, 94, "Fated Conflagration", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{1}{R}{R}{R}");§this.expansionSetCode = "BNG";§this.getSpellAbility().addEffect(new DamageTargetEffect(5));§this.getSpellAbility().addTarget(new TargetCreatureOrPlaneswalker());§this.getSpellAbility().addEffect(new ConditionalOneShotEffect(new ScryEffect(2), MyTurnCondition.getInstance(), "If it's your turn, scry 2"));§}§public FatedConflagration(final FatedConflagration card) {§super(card);§}§@Override§public FatedConflagration copy() {§return new FatedConflagration(this);§}§}§
public class FatedInfatuation extends CardImpl {§public FatedInfatuation(UUID ownerId) {§super(ownerId, 39, "Fated Infatuation", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{U}{U}{U}");§this.expansionSetCode = "BNG";§this.getSpellAbility().addEffect(new PutTokenOntoBattlefieldCopyTargetEffect());§this.getSpellAbility().addTarget(new TargetControlledCreaturePermanent());§this.getSpellAbility().addEffect(new ConditionalOneShotEffect(new ScryEffect(2), MyTurnCondition.getInstance(), "If it's your turn, scry 2"));§}§public FatedInfatuation(final FatedInfatuation card) {§super(card);§}§@Override§public FatedInfatuation copy() {§return new FatedInfatuation(this);§}§}§
public class FatedIntervention extends CardImpl {§public FatedIntervention(UUID ownerId) {§super(ownerId, 121, "Fated Intervention", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{2}{G}{G}{G}");§this.expansionSetCode = "BNG";§this.getSpellAbility().addEffect(new CreateTokenEffect(new CentaurEnchantmentCreatureToken(), 2));§this.getSpellAbility().addEffect(new ConditionalOneShotEffect(new ScryEffect(2), MyTurnCondition.getInstance(), "If it's your turn, scry 2"));§}§public FatedIntervention(final FatedIntervention card) {§super(card);§}§@Override§public FatedIntervention copy() {§return new FatedIntervention(this);§}§}§
public class FatedRetribution extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("creatures and planeswalkers");§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.CREATURE),§new CardTypePredicate(CardType.PLANESWALKER)));§}§public FatedRetribution(UUID ownerId) {§super(ownerId, 11, "Fated Retribution", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{4}{W}{W}{W}");§this.expansionSetCode = "BNG";§this.getSpellAbility().addEffect(new DestroyAllEffect(filter, false));§this.getSpellAbility().addEffect(new ConditionalOneShotEffect(new ScryEffect(2), MyTurnCondition.getInstance(), "If it's your turn, scry 2"));§}§public FatedRetribution(final FatedRetribution card) {§super(card);§}§@Override§public FatedRetribution copy() {§return new FatedRetribution(this);§}§}§
public class FatedReturn extends CardImpl {§public FatedReturn(UUID ownerId) {§super(ownerId, 69, "Fated Return", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{4}{B}{B}{B}");§this.expansionSetCode = "BNG";§this.getSpellAbility().addEffect(new ReturnFromGraveyardToBattlefieldTargetEffect());§this.getSpellAbility().addTarget(new TargetCardInGraveyard(new FilterCreatureCard("creature card from a graveyard")));§this.getSpellAbility().addEffect(new GainAbilityTargetEffect(IndestructibleAbility.getInstance(), Duration.Custom,§"It gains indestructible"));§this.getSpellAbility().addEffect(new ConditionalOneShotEffect(new ScryEffect(2), MyTurnCondition.getInstance(),§"If it's your turn, scry 2 <i>(Look at the top two cards of your library, then put any number of them on the bottom of your library and the rest on top in any order.)</i>"));§}§public FatedReturn(final FatedReturn card) {§super(card);§}§@Override§public FatedReturn copy() {§return new FatedReturn(this);§}§}§
public class FateUnraveler extends CardImpl {§public FateUnraveler(UUID ownerId) {§super(ownerId, 68, "Fate Unraveler", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT, CardType.CREATURE}, "{3}{B}");§this.expansionSetCode = "BNG";§this.subtype.add("Hag");§this.power = new MageInt(3);§this.toughness = new MageInt(4);§this.addAbility(new DrawCardOpponentTriggeredAbility(new DamageTargetEffect(1, true, "that player"), false, true));§}§public FateUnraveler(final FateUnraveler card) {§super(card);§}§@Override§public FateUnraveler copy() {§return new FateUnraveler(this);§}§}§
public class FearsomeTemper extends CardImpl {§public FearsomeTemper(UUID ownerId) {§super(ownerId, 95, "Fearsome Temper", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{R}");§this.expansionSetCode = "BNG";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§Effect effect = new BoostEnchantedEffect(2,2, Duration.WhileOnBattlefield);§effect.setText("Enchanted creature gets +2/+2");§ability = new SimpleStaticAbility(Zone.BATTLEFIELD, effect);§Ability grantedAbility = new SimpleActivatedAbility(Zone.BATTLEFIELD, new CantBeBlockedByTargetSourceEffect(Duration.EndOfTurn), new ManaCostsImpl("{2}{R}"));§grantedAbility.addTarget(new TargetCreaturePermanent());§effect = new GainAbilityAttachedEffect(grantedAbility, AttachmentType.AURA, Duration.WhileOnBattlefield);§effect.setText("and has \"{2}{R}: Target creature can't block this creature this turn");§ability.addEffect(effect);§this.addAbility(ability);§}§public FearsomeTemper(final FearsomeTemper card) {§super(card);§}§@Override§public FearsomeTemper copy() {§return new FearsomeTemper(this);§}§}§
public class FelhideBrawler extends CardImpl {§public FelhideBrawler(UUID ownerId) {§super(ownerId, 70, "Felhide Brawler", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{B}");§this.expansionSetCode = "BNG";§this.subtype.add("Minotaur");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new FelhideBrawlerRestrictionEffect()));§}§public FelhideBrawler(final FelhideBrawler card) {§super(card);§}§@Override§public FelhideBrawler copy() {§return new FelhideBrawler(this);§}§}§class FelhideBrawlerRestrictionEffect extends RestrictionEffect {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("another Minotaur");§static {§filter.add(new SubtypePredicate("Minotaur"));§filter.add(new AnotherPredicate());§}§public FelhideBrawlerRestrictionEffect() {§super(Duration.WhileOnBattlefield);§staticText = "{this} can't block unless you control another Minotaur";§}§public FelhideBrawlerRestrictionEffect(final FelhideBrawlerRestrictionEffect effect) {§super(effect);§}§@Override§public FelhideBrawlerRestrictionEffect copy() {§return new FelhideBrawlerRestrictionEffect(this);§}§@Override§public boolean canBlock(Permanent attacker, Permanent blocker, Ability source, Game game) {§return false;§}§@Override§public boolean applies(Permanent permanent, Ability source, Game game) {§if (permanent.getId().equals(source.getSourceId())§&& game.getBattlefield().count(filter, source.getSourceId(), source.getControllerId(), game) == 0) {§return true;§}§return false;§}§}§
public class FelhideSpiritbinder extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("another creature");§static {§filter.add(new AnotherPredicate());§}§public FelhideSpiritbinder(UUID ownerId) {§super(ownerId, 96, "Felhide Spiritbinder", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{R}");§this.expansionSetCode = "BNG";§this.subtype.add("Minotaur");§this.subtype.add("Shaman");§this.power = new MageInt(3);§this.toughness = new MageInt(4);§Ability ability = new InspiredAbility(new DoIfCostPaid(new FelhideSpiritbinderEffect(), new ManaCostsImpl("{1}{R}"), "Use effect of {source}?"));§ability.addTarget(new TargetCreaturePermanent(filter));§this.addAbility(ability);§}§public FelhideSpiritbinder(final FelhideSpiritbinder card) {§super(card);§}§@Override§public FelhideSpiritbinder copy() {§return new FelhideSpiritbinder(this);§}§}§class FelhideSpiritbinderEffect extends OneShotEffect {§public FelhideSpiritbinderEffect() {§super(Outcome.PutCreatureInPlay);§this.staticText = "put a token onto the battlefield that's a copy of another target creature except it's an enchantment in addition to its other types. It gains haste. Exile it at the beginning of the next end step";§}§public FelhideSpiritbinderEffect(final FelhideSpiritbinderEffect effect) {§super(effect);§}§@Override§public FelhideSpiritbinderEffect copy() {§return new FelhideSpiritbinderEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getPermanentOrLKIBattlefield(source.getFirstTarget());§if (permanent != null) {§PutTokenOntoBattlefieldCopyTargetEffect effect = new PutTokenOntoBattlefieldCopyTargetEffect(null, CardType.ENCHANTMENT, true);§effect.setTargetPointer(getTargetPointer());§if (effect.apply(game, source)) {§for (Permanent tokenPermanent : effect.getAddedPermanent()) {§ExileTargetEffect exileEffect = new ExileTargetEffect();§exileEffect.setTargetPointer(new FixedTarget(tokenPermanent, game));§DelayedTriggeredAbility delayedAbility = new AtTheBeginOfNextEndStepDelayedTriggeredAbility(exileEffect);§game.addDelayedTriggeredAbility(delayedAbility, source);§}§return true;§}§}§return false;§}§}§
public class FlameWreathedPhoenix extends CardImpl {§public FlameWreathedPhoenix(UUID ownerId) {§super(ownerId, 97, "Flame-Wreathed Phoenix", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{2}{R}{R}");§this.expansionSetCode = "BNG";§this.subtype.add("Phoenix");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new TributeAbility(2));§TriggeredAbility ability = new EntersBattlefieldTriggeredAbility(new GainAbilitySourceEffect(HasteAbility.getInstance(), Duration.WhileOnBattlefield));§Effect effect = new GainAbilitySourceEffect(new DiesTriggeredAbility(new ReturnToHandSourceEffect()));§ability.addEffect(effect);§this.addAbility(new ConditionalTriggeredAbility(ability, TributeNotPaidCondition.getInstance(),§"When {this} enters the battlefield, if its tribute wasn't paid, it gains haste and \"When this creature dies, return it to its owner's hand.\""));§}§public FlameWreathedPhoenix(final FlameWreathedPhoenix card) {§super(card);§}§@Override§public FlameWreathedPhoenix copy() {§return new FlameWreathedPhoenix(this);§}§}§
public class FlitterstepEidolon extends CardImpl {§public FlitterstepEidolon(UUID ownerId) {§super(ownerId, 40, "Flitterstep Eidolon", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT, CardType.CREATURE}, "{1}{U}");§this.expansionSetCode = "BNG";§this.subtype.add("Spirit");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new BestowAbility(this, "{5}{U}"));§this.addAbility(new CantBeBlockedSourceAbility());§Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(1,1, Duration.WhileOnBattlefield));§ability.addEffect(new CantBeBlockedAttachedEffect(AttachmentType.AURA));§this.addAbility(ability);§}§public FlitterstepEidolon(final FlitterstepEidolon card) {§super(card);§}§@Override§public FlitterstepEidolon copy() {§return new FlitterstepEidolon(this);§}§}§
public class FloodtideSerpent extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("an enchantment you control");§static {§filter.add(new CardTypePredicate(CardType.ENCHANTMENT));§}§public FloodtideSerpent(UUID ownerId) {§super(ownerId, 41, "Floodtide Serpent", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{U}");§this.expansionSetCode = "BNG";§this.subtype.add("Serpent");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new CantAttackBlockUnlessPaysSourceEffect(§new ReturnToHandChosenControlledPermanentCost(new TargetControlledPermanent(filter)), PayCostToAttackBlockEffectImpl.RestrictType.ATTACK)));§}§public FloodtideSerpent(final FloodtideSerpent card) {§super(card);§}§@Override§public FloodtideSerpent copy() {§return new FloodtideSerpent(this);§}§}§class FloodtideSerpentReplacementEffect extends ReplacementEffectImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("an enchantment you control");§static {§filter.add(new CardTypePredicate(CardType.ENCHANTMENT));§}§FloodtideSerpentReplacementEffect() {§super(Duration.WhileOnBattlefield, Outcome.Neutral);§staticText = "{this} can't attack unless you return an enchantment you control to its owner's hand <i>(This cost is paid as attackers are declared.)</i>";§}§FloodtideSerpentReplacementEffect(FloodtideSerpentReplacementEffect effect) {§super(effect);§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§Player player = game.getPlayer(event.getPlayerId());§if (player != null) {§ReturnToHandChosenControlledPermanentCost attackCost = new ReturnToHandChosenControlledPermanentCost(new TargetControlledPermanent(filter));§if (attackCost.canPay(source, source.getSourceId(), event.getPlayerId(), game)§&& player.chooseUse(Outcome.Neutral, "Return an enchantment you control to hand to attack?", source, game)) {§if (attackCost.pay(source, game, source.getSourceId(), event.getPlayerId(), true, null)) {§return false;§}§}§return true;§}§return false;§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == EventType.DECLARE_ATTACKER;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§return event.getSourceId().equals(source.getSourceId());§}§@Override§public FloodtideSerpentReplacementEffect copy() {§return new FloodtideSerpentReplacementEffect(this);§}§}§
public class ForgestokerDragon extends CardImpl {§public ForgestokerDragon(UUID ownerId) {§super(ownerId, 98, "Forgestoker Dragon", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{R}{R}");§this.expansionSetCode = "BNG";§this.subtype.add("Dragon");§this.power = new MageInt(5);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new ActivateIfConditionActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(1), new ManaCostsImpl("{1}{R}"), new SourceAttackingCondition());§ability.addTarget(new TargetCreaturePermanent());§Effect effect = new CantBlockTargetEffect(Duration.EndOfCombat);§effect.setText("That creature can't block this combat");§ability.addEffect(effect);§this.addAbility(ability);§}§public ForgestokerDragon(final ForgestokerDragon card) {§super(card);§}§@Override§public ForgestokerDragon copy() {§return new ForgestokerDragon(this);§}§}§
public class ForlornPseudamma extends CardImpl {§public ForlornPseudamma(UUID ownerId) {§super(ownerId, 71, "Forlorn Pseudamma", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{B}");§this.expansionSetCode = "BNG";§this.subtype.add("Zombie");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(IntimidateAbility.getInstance());§this.addAbility(new InspiredAbility(new DoIfCostPaid(new CreateTokenEffect(new ForlornPseudammaZombieToken()), new ManaCostsImpl("{2}{B}"))));§}§public ForlornPseudamma(final ForlornPseudamma card) {§super(card);§}§@Override§public ForlornPseudamma copy() {§return new ForlornPseudamma(this);§}§}§class ForlornPseudammaZombieToken extends Token {§public ForlornPseudammaZombieToken() {§super("Zombie", "2/2 black Zombie enchantment creature token");§cardType.add(CardType.ENCHANTMENT);§cardType.add(CardType.CREATURE);§color.setBlack(true);§subtype.add("Zombie");§power = new MageInt(2);§toughness = new MageInt(2);§this.setOriginalExpansionSetCode("BNG");§}§}§
public class Gild extends CardImpl {§public Gild(UUID ownerId) {§super(ownerId, 73, "Gild", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{3}{B}");§this.expansionSetCode = "BNG";§this.getSpellAbility().addEffect(new ExileTargetEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§Effect effect = new CreateTokenEffect(new GoldToken());§effect.setText("Put a colorless artifact token named Gold onto the battlefield. It has \"Sacrifice this artifact: Add one mana of any color to your mana pool.\"");§this.getSpellAbility().addEffect(effect);§}§public Gild(final Gild card) {§super(card);§}§@Override§public Gild copy() {§return new Gild(this);§}§}§
public class GlimpseTheSunGod extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creatures");§public GlimpseTheSunGod(UUID ownerId) {§super(ownerId, 13, "Glimpse the Sun God", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{X}{W}");§this.expansionSetCode = "BNG";§this.getSpellAbility().addEffect(new TapTargetEffect("X target creatures"));§this.getSpellAbility().addTarget(new TargetCreaturePermanent(0, 1,filter, false));§this.getSpellAbility().addEffect(new ScryEffect(1));§}§public GlimpseTheSunGod(final GlimpseTheSunGod card) {§super(card);§}§@Override§public void adjustTargets(Ability ability, Game game) {§if (ability instanceof SpellAbility) {§ability.getTargets().clear();§int numberToTap = ability.getManaCostsToPay().getX();§numberToTap = Math.min(game.getBattlefield().count(filter, ability.getSourceId(), ability.getControllerId(), game), numberToTap);§ability.addTarget(new TargetCreaturePermanent(numberToTap, numberToTap, filter, false));§}§}§@Override§public GlimpseTheSunGod copy() {§return new GlimpseTheSunGod(this);§}§}§
public class GodFavoredGeneral extends CardImpl {§public GodFavoredGeneral(UUID ownerId) {§super(ownerId, 14, "God-Favored General", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "BNG";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new InspiredAbility(new DoIfCostPaid(new CreateTokenEffect(new SoldierToken(), 2), new ManaCostsImpl("{2}{W}"))));§}§public GodFavoredGeneral(final GodFavoredGeneral card) {§super(card);§}§@Override§public GodFavoredGeneral copy() {§return new GodFavoredGeneral(this);§}§}§class SoldierToken extends Token {§public SoldierToken() {§super("Soldier", "1/1 white Soldier enchantment creature token");§cardType.add(CardType.ENCHANTMENT);§cardType.add(CardType.CREATURE);§color.setWhite(true);§subtype.add("Soldier");§power = new MageInt(1);§toughness = new MageInt(1);§this.setOriginalExpansionSetCode("BNG");§}§}§
public class GorgonsHead extends CardImpl {§public GorgonsHead(UUID ownerId) {§super(ownerId, 158, "Gorgon's Head", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{1}");§this.expansionSetCode = "BNG";§this.subtype.add("Equipment");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(DeathtouchAbility.getInstance(), AttachmentType.EQUIPMENT)));§this.addAbility(new EquipAbility(Outcome.AddAbility, new ManaCostsImpl("{2}")));§}§public GorgonsHead(final GorgonsHead card) {§super(card);§}§@Override§public GorgonsHead copy() {§return new GorgonsHead(this);§}§}§
public class GraverobberSpider extends CardImpl {§public GraverobberSpider(UUID ownerId) {§super(ownerId, 122, "Graverobber Spider", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{G}");§this.expansionSetCode = "BNG";§this.subtype.add("Spider");§this.power = new MageInt(2);§this.toughness = new MageInt(4);§this.addAbility(ReachAbility.getInstance());§DynamicValue xValue = new CardsInControllerGraveyardCount(new FilterCreatureCard("creature cards"));§Ability ability = new LimitedTimesPerTurnActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(xValue, xValue, Duration.EndOfTurn, true), new ManaCostsImpl("{3}{B}"));§this.addAbility(ability);§}§public GraverobberSpider(final GraverobberSpider card) {§super(card);§}§@Override§public GraverobberSpider copy() {§return new GraverobberSpider(this);§}§}§
public class GreatHart extends CardImpl {§public GreatHart(UUID ownerId) {§super(ownerId, 15, "Great Hart", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{W}");§this.expansionSetCode = "BNG";§this.subtype.add("Elk");§this.power = new MageInt(2);§this.toughness = new MageInt(4);§}§public GreatHart(final GreatHart card) {§super(card);§}§@Override§public GreatHart copy() {§return new GreatHart(this);§}§}§
public class GriffinDreamfinder extends CardImpl {§private static final FilterCard filter = new FilterCard("enchantment card from your graveyard");§static {§filter.add(new CardTypePredicate(CardType.ENCHANTMENT));§}§public GriffinDreamfinder(UUID ownerId) {§super(ownerId, 16, "Griffin Dreamfinder", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{W}{W}");§this.expansionSetCode = "BNG";§this.subtype.add("Griffin");§this.power = new MageInt(1);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new EntersBattlefieldTriggeredAbility(new ReturnFromGraveyardToHandTargetEffect(), false);§ability.addTarget(new TargetCardInYourGraveyard(filter));§this.addAbility(ability);§}§public GriffinDreamfinder(final GriffinDreamfinder card) {§super(card);§}§@Override§public GriffinDreamfinder copy() {§return new GriffinDreamfinder(this);§}§}§
public class GrislyTransformation extends CardImpl {§public GrislyTransformation(UUID ownerId) {§super(ownerId, 74, "Grisly Transformation", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{B}");§this.expansionSetCode = "BNG";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new EntersBattlefieldTriggeredAbility(new DrawCardSourceControllerEffect(1), false));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(IntimidateAbility.getInstance(), AttachmentType.AURA, Duration.WhileOnBattlefield)));§}§public GrislyTransformation(final GrislyTransformation card) {§super(card);§}§@Override§public GrislyTransformation copy() {§return new GrislyTransformation(this);§}§}§
public class HeraldOfTorment extends CardImpl {§public HeraldOfTorment(UUID ownerId) {§super(ownerId, 75, "Herald of Torment", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT, CardType.CREATURE}, "{1}{B}{B}");§this.expansionSetCode = "BNG";§this.subtype.add("Demon");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new BestowAbility(this, "{3}{B}{B}"));§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new BeginningOfUpkeepTriggeredAbility(new LoseLifeSourceControllerEffect(1), TargetController.YOU, false));§Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(3, 3));§Effect effect = new GainAbilityAttachedEffect(FlyingAbility.getInstance(), AttachmentType.AURA);§effect.setText("and has flying");§ability.addEffect(effect);§this.addAbility(ability);§}§public HeraldOfTorment(final HeraldOfTorment card) {§super(card);§}§@Override§public HeraldOfTorment copy() {§return new HeraldOfTorment(this);§}§}§
public class HeroesPodium extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Each legendary creature you control");§static {§filter.add(new SupertypePredicate("Legendary"));§}§public HeroesPodium(UUID ownerId) {§super(ownerId, 159, "Heroes' Podium", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{5}");§this.expansionSetCode = "BNG";§this.supertype.add("Legendary");§DynamicValue xValue = new HeroesPodiumLegendaryCount();§Effect effect = new BoostControlledEffect(xValue, xValue, Duration.WhileOnBattlefield, filter, false);§effect.setText("Each legendary creature you control gets +1/+1 for each other legendary creature you control");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, effect));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new HeroesPodiumEffect(), new ManaCostsImpl("{X}"));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§}§public HeroesPodium(final HeroesPodium card) {§super(card);§}§@Override§public HeroesPodium copy() {§return new HeroesPodium(this);§}§}§class HeroesPodiumLegendaryCount implements DynamicValue {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("other legendary creature you control");§static {§filter.add(new SupertypePredicate("Legendary"));§}§@Override§public int calculate(Game game, Ability sourceAbility, Effect effect) {§int value = game.getBattlefield().count(filter, sourceAbility.getSourceId(), sourceAbility.getControllerId(), game);§if (value > 0) {§value--;§}§return value;§}§@Override§public String toString() {§return "X";§}§@Override§public String getMessage() {§return filter.getMessage();§}§@Override§public HeroesPodiumLegendaryCount copy() {§return new HeroesPodiumLegendaryCount();§}§}§class HeroesPodiumEffect extends OneShotEffect {§private static final FilterCreatureCard filter = new FilterCreatureCard("a legendary creature card");§static {§filter.add(new SupertypePredicate(("Legendary")));§}§public HeroesPodiumEffect() {§super(Outcome.DrawCard);§this.staticText = "Look at the top X cards of your library. You may reveal a legendary creature card from among them and put it into your hand. Put the rest on the bottom of your library in a random order";§}§public HeroesPodiumEffect(final HeroesPodiumEffect effect) {§super(effect);§}§@Override§public HeroesPodiumEffect copy() {§return new HeroesPodiumEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player == null) {§return false;§}§Cards cards = new CardsImpl();§int count = source.getManaCostsToPay().getX();§count = Math.min(player.getLibrary().size(), count);§boolean legendaryIncluded = false;§for (int i = 0; i < count; i++) {§Card card = player.getLibrary().removeFromTop(game);§if (card != null) {§cards.add(card);§if (filter.match(card, game)) {§legendaryIncluded = true;§}§}§}§player.lookAtCards("Heroes' Podium", cards, game);§if (!cards.isEmpty() && legendaryIncluded && player.chooseUse(outcome, "Put a legendary creature card into your hand?", source, game)) {§if (cards.size() == 1) {§Card card = cards.getRandom(game);§cards.remove(card);§card.moveToZone(Zone.HAND, source.getSourceId(), game, false);§return true;§} else {§TargetCard target = new TargetCard(Zone.LIBRARY, filter);§if (player.choose(outcome, cards, target, game)) {§Card card = cards.get(target.getFirstTarget(), game);§if (card != null) {§cards.remove(card);§card.moveToZone(Zone.HAND, source.getSourceId(), game, false);§}§}§}§}§while (cards.size() > 0) {§Card card = cards.getRandom(game);§if (card != null) {§cards.remove(card);§card.moveToZone(Zone.LIBRARY, source.getSourceId(), game, false);§}§}§return true;§}§}§
public class HeroOfIroas extends CardImpl {§private static final FilterCard filter = new FilterCard("Aura spells");§static {§filter.add(new SubtypePredicate("Aura"));§}§public HeroOfIroas(UUID ownerId) {§super(ownerId, 17, "Hero of Iroas", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "BNG";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new SpellsCostReductionControllerEffect(filter, 1)));§this.addAbility(new HeroicAbility(new AddCountersSourceEffect(CounterType.P1P1.createInstance())));§}§public HeroOfIroas(final HeroOfIroas card) {§super(card);§}§@Override§public HeroOfIroas copy() {§return new HeroOfIroas(this);§}§}§
public class HeroOfLeinaTower extends CardImpl {§public HeroOfLeinaTower(UUID ownerId) {§super(ownerId, 123, "Hero of Leina Tower", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{G}");§this.expansionSetCode = "BNG";§this.subtype.add("Human");§this.subtype.add("Warrior");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new HeroicAbility(new HeroOfLeinaTowerEffect()));§}§public HeroOfLeinaTower(final HeroOfLeinaTower card) {§super(card);§}§@Override§public HeroOfLeinaTower copy() {§return new HeroOfLeinaTower(this);§}§}§class HeroOfLeinaTowerEffect extends OneShotEffect {§public HeroOfLeinaTowerEffect() {§super(Outcome.BoostCreature);§staticText = "you may pay {X}. If you do, put X +1/+1 counters on {this}";§}§public HeroOfLeinaTowerEffect(final HeroOfLeinaTowerEffect effect) {§super(effect);§}§@Override§public HeroOfLeinaTowerEffect copy() {§return new HeroOfLeinaTowerEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player you = game.getPlayer(source.getControllerId());§ManaCosts cost = new ManaCostsImpl("{X}");§if (you != null && you.chooseUse(Outcome.BoostCreature, "Do you want to to pay {X}?", source, game)) {§int costX = you.announceXMana(0, Integer.MAX_VALUE, "Announce the value for {X}", game, source);§cost.add(new GenericManaCost(costX));§if (cost.pay(source, game, source.getSourceId(), source.getControllerId(), false, null)) {§Permanent sourcePermanent = game.getPermanent(source.getSourceId());§if (sourcePermanent != null) {§return new AddCountersSourceEffect(CounterType.P1P1.createInstance(costX), true).apply(game, source);§}§}§}§return false;§}§}§
public class HoldAtBay extends CardImpl {§public HoldAtBay(UUID ownerId) {§super(ownerId, 18, "Hold at Bay", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{W}");§this.expansionSetCode = "BNG";§this.getSpellAbility().addEffect(new PreventDamageToTargetEffect(Duration.EndOfTurn, 7));§this.getSpellAbility().addTarget(new TargetCreatureOrPlayer());§}§public HoldAtBay(final HoldAtBay card) {§super(card);§}§@Override§public HoldAtBay copy() {§return new HoldAtBay(this);§}§}§
public class HuntersProwess extends CardImpl {§public HuntersProwess(UUID ownerId) {§super(ownerId, 124, "Hunter's Prowess", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{4}{G}");§this.expansionSetCode = "BNG";§Effect effect = new BoostTargetEffect(3,3, Duration.EndOfTurn);§effect.setText("Until end of turn, target creature gets +3/+3");§this.getSpellAbility().addEffect(effect);§effect = new GainAbilityTargetEffect(TrampleAbility.getInstance(), Duration.EndOfTurn);§effect.setText("and gains trample");§this.getSpellAbility().addEffect(effect);§Ability grantedAbility = new DealsCombatDamageToAPlayerTriggeredAbility(new HuntersProwessDrawEffect(), false, true);§this.getSpellAbility().addEffect(new GainAbilityTargetEffect(grantedAbility, Duration.EndOfTurn,§"and \"Whenever this creature deals combat damage to a player, draw that many cards.\""));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public HuntersProwess(final HuntersProwess card) {§super(card);§}§@Override§public HuntersProwess copy() {§return new HuntersProwess(this);§}§}§class HuntersProwessDrawEffect extends OneShotEffect {§public HuntersProwessDrawEffect() {§super(Outcome.Benefit);§this.staticText = "draw that many cards";§}§public HuntersProwessDrawEffect(final HuntersProwessDrawEffect effect) {§super(effect);§}§@Override§public HuntersProwessDrawEffect copy() {§return new HuntersProwessDrawEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§int damage = (Integer) this.getValue("damage");§if (damage > 0) {§controller.drawCards(damage, game);§}§return true;§}§return false;§}§}§
public class ImpetuousSunchaser extends CardImpl {§public ImpetuousSunchaser(UUID ownerId) {§super(ownerId, 99, "Impetuous Sunchaser", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{R}");§this.expansionSetCode = "BNG";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(HasteAbility.getInstance());§this.addAbility(new AttacksEachTurnStaticAbility());§}§public ImpetuousSunchaser(final ImpetuousSunchaser card) {§super(card);§}§@Override§public ImpetuousSunchaser copy() {§return new ImpetuousSunchaser(this);§}§}§
public class KarametraGodOfHarvests extends CardImpl {§private static final FilterCard filter = new FilterCard("a Forest or Plains card");§static {§filter.add(Predicates.or(§new SubtypePredicate("Forest"),§new SubtypePredicate("Plains")));§}§public KarametraGodOfHarvests(UUID ownerId) {§super(ownerId, 148, "Karametra, God of Harvests", Rarity.MYTHIC, new CardType[]{CardType.ENCHANTMENT, CardType.CREATURE}, "{3}{G}{W}");§this.expansionSetCode = "BNG";§this.supertype.add("Legendary");§this.subtype.add("God");§this.power = new MageInt(6);§this.toughness = new MageInt(7);§this.addAbility(IndestructibleAbility.getInstance());§Effect effect = new LoseCreatureTypeSourceEffect(new DevotionCount(ColoredManaSymbol.G, ColoredManaSymbol.W), 7);§effect.setText("As long as your devotion to green and white is less than seven, Karametra isn't a creature");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, effect));§this.addAbility(new SpellCastControllerTriggeredAbility(§new SearchLibraryPutInPlayEffect(new TargetCardInLibrary(filter), true), new FilterCreatureSpell("a creature spell"), true));§}§public KarametraGodOfHarvests(final KarametraGodOfHarvests card) {§super(card);§}§@Override§public KarametraGodOfHarvests copy() {§return new KarametraGodOfHarvests(this);§}§}§
public class KarametrasFavor extends CardImpl {§public KarametrasFavor(UUID ownerId) {§super(ownerId, 125, "Karametra's Favor", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{G}");§this.expansionSetCode = "BNG";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new EntersBattlefieldTriggeredAbility(new DrawCardSourceControllerEffect(1), false));§Effect effect = new GainAbilityAttachedEffect(new AnyColorManaAbility(), AttachmentType.AURA, Duration.WhileOnBattlefield);§effect.setText("Enchanted creature has \"{T}: Add one mana of any color to your mana pool.\"");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, effect));§}§public KarametrasFavor(final KarametrasFavor card) {§super(card);§}§@Override§public KarametrasFavor copy() {§return new KarametrasFavor(this);§}§}§
public class KiorasFollower extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("another target permanent");§static {§filter.add(new AnotherPredicate());§}§public KiorasFollower(UUID ownerId) {§super(ownerId, 150, "Kiora's Follower", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{G}{U}");§this.expansionSetCode = "BNG";§this.subtype.add("Merfolk");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new UntapTargetEffect(), new TapSourceCost());§ability.addTarget(new TargetPermanent(filter));§this.addAbility(ability);§}§public KiorasFollower(final KiorasFollower card) {§super(card);§}§@Override§public KiorasFollower copy() {§return new KiorasFollower(this);§}§}§
public class KrakenOfTheStraits extends CardImpl {§public KrakenOfTheStraits(UUID ownerId) {§super(ownerId, 42, "Kraken of the Straits", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{5}{U}{U}");§this.expansionSetCode = "BNG";§this.subtype.add("Kraken");§this.power = new MageInt(6);§this.toughness = new MageInt(6);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new CantBeBlockedByCreaturesWithLessPowerEffect()));§}§public KrakenOfTheStraits(final KrakenOfTheStraits card) {§super(card);§}§@Override§public KrakenOfTheStraits copy() {§return new KrakenOfTheStraits(this);§}§}§class CantBeBlockedByCreaturesWithLessPowerEffect extends RestrictionEffect {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("Islands");§static {§filter.add(new SubtypePredicate("Island"));§}§private final DynamicValue dynamicValue = new PermanentsOnBattlefieldCount(filter);§public CantBeBlockedByCreaturesWithLessPowerEffect() {§super(Duration.WhileOnBattlefield);§staticText = "Creatures with power less than the number of Islands you control can't block {this}";§}§public CantBeBlockedByCreaturesWithLessPowerEffect(final CantBeBlockedByCreaturesWithLessPowerEffect effect) {§super(effect);§}§@Override§public boolean applies(Permanent permanent, Ability source, Game game) {§return permanent.getId().equals(source.getSourceId());§}§@Override§public boolean canBeBlocked(Permanent attacker, Permanent blocker, Ability source, Game game) {§return blocker.getPower().getValue() >= dynamicValue.calculate(game, source, this);§}§@Override§public CantBeBlockedByCreaturesWithLessPowerEffect copy() {§return new CantBeBlockedByCreaturesWithLessPowerEffect(this);§}§}§
public class LightningVolley extends CardImpl {§public LightningVolley(UUID ownerId) {§super(ownerId, 101, "Lightning Volley", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{3}{R}");§this.expansionSetCode = "BNG";§Ability grantedAbility = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(1), new TapSourceCost());§grantedAbility.addTarget(new TargetCreatureOrPlayer());§Effect effect = new GainAbilityControlledEffect(grantedAbility, Duration.EndOfTurn, new FilterCreaturePermanent("Creatures"));§effect.setText("Until end of turn, creatures you control gain \"{T}: This creature deals 1 damage to target creature or player.\"");§this.getSpellAbility().addEffect(effect);§}§public LightningVolley(final LightningVolley card) {§super(card);§}§@Override§public LightningVolley copy() {§return new LightningVolley(this);§}§}§
public class LoyalPegasus extends CardImpl {§public LoyalPegasus(UUID ownerId) {§super(ownerId, 19, "Loyal Pegasus", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{W}");§this.expansionSetCode = "BNG";§this.subtype.add("Pegasus");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new CantAttackAloneAbility());§this.addAbility(CantBlockAloneAbility.getInstance());§}§public LoyalPegasus(final LoyalPegasus card) {§super(card);§}§@Override§public LoyalPegasus copy() {§return new LoyalPegasus(this);§}§}§
public class MarshmistTitan extends CardImpl {§public MarshmistTitan(UUID ownerId) {§super(ownerId, 76, "Marshmist Titan", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{6}{B}");§this.expansionSetCode = "BNG";§this.subtype.add("Giant");§this.power = new MageInt(4);§this.toughness = new MageInt(5);§this.addAbility(new SimpleStaticAbility(Zone.STACK, new MarshmistTitanCostReductionEffect()));§}§public MarshmistTitan(final MarshmistTitan card) {§super(card);§}§@Override§public MarshmistTitan copy() {§return new MarshmistTitan(this);§}§}§class MarshmistTitanCostReductionEffect extends CostModificationEffectImpl {§public MarshmistTitanCostReductionEffect() {§super(Duration.Custom, Outcome.Benefit, CostModificationType.REDUCE_COST);§staticText = "{this} costs {X} less to cast, where X is your devotion to black <i>(Each {B} in the mana costs of permanents you control counts toward your devotion to black.)</i> ";§}§public MarshmistTitanCostReductionEffect(final MarshmistTitanCostReductionEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source, Ability abilityToModify) {§SpellAbility spellAbility = (SpellAbility)abilityToModify;§Mana mana = spellAbility.getManaCostsToPay().getMana();§if (mana.getGeneric() > 0) {§int count = new DevotionCount(ColoredManaSymbol.B).calculate(game, source, this);§int newCount = mana.getGeneric() - count;§if (newCount < 0) {§newCount = 0;§}§mana.setGeneric(newCount);§spellAbility.getManaCostsToPay().load(mana.toString());§return true;§}§return false;§}§@Override§public boolean applies(Ability abilityToModify, Ability source, Game game) {§if (abilityToModify.getSourceId().equals(source.getSourceId()) && (abilityToModify instanceof SpellAbility)) {§return true;§}§return false;§}§@Override§public MarshmistTitanCostReductionEffect copy() {§return new MarshmistTitanCostReductionEffect(this);§}§}§
public class MeletisAstronomer extends CardImpl {§private static final FilterCard filter = new FilterCard("an enchantment card");§static {§filter.add(new CardTypePredicate(CardType.ENCHANTMENT));§}§public MeletisAstronomer(UUID ownerId) {§super(ownerId, 43, "Meletis Astronomer", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{U}");§this.expansionSetCode = "BNG";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(3);§this.addAbility(new HeroicAbility(new LookLibraryAndPickControllerEffect(3, 1, filter, true, false, Zone.HAND, true), false));§}§public MeletisAstronomer(final MeletisAstronomer card) {§super(card);§}§@Override§public MeletisAstronomer copy() {§return new MeletisAstronomer(this);§}§}§
public class Mindreaver extends CardImpl {§public Mindreaver(UUID ownerId) {§super(ownerId, 44, "Mindreaver", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{U}{U}");§this.expansionSetCode = "BNG";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§Ability ability = new HeroicAbility(new MindreaverExileEffect(), false);§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new CounterTargetEffect(), new ManaCostsImpl("{U}{U}"));§FilterSpell filter = new FilterSpell("spell with the same name as a card exiled with {this}");§filter.add(new MindreaverNamePredicate(this.getId()));§ability.addTarget(new TargetSpell(filter));§ability.addCost(new SacrificeSourceCost());§this.addAbility(ability);§}§public Mindreaver(final Mindreaver card) {§super(card);§}§@Override§public Mindreaver copy() {§return new Mindreaver(this);§}§}§class MindreaverExileEffect extends OneShotEffect {§public MindreaverExileEffect() {§super(Outcome.Exile);§this.staticText = "exile the top three cards of target opponent's library";§}§public MindreaverExileEffect(final MindreaverExileEffect effect) {§super(effect);§}§@Override§public MindreaverExileEffect copy() {§return new MindreaverExileEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§UUID exileId = CardUtil.getCardExileZoneId(game, source);§MageObject sourceObject = source.getSourceObject(game);§Player opponent = game.getPlayer(this.getTargetPointer().getFirst(game, source));§if (opponent != null && sourceObject != null) {§for (int i = 0; i < 3; i++) {§Card card = opponent.getLibrary().getFromTop(game);§if (card != null) {§card.moveToExile(exileId, sourceObject.getIdName(), source.getSourceId(), game);§}§}§}§return false;§}§}§class MindreaverNamePredicate implements Predicate<MageObject> {§private final UUID sourceId;§public MindreaverNamePredicate(UUID sourceId) {§this.sourceId = sourceId;§}§@Override§public boolean apply(MageObject input, Game game) {§Set<String> cardNames = new HashSet<String>();§UUID exileId = CardUtil.getCardExileZoneId(game, sourceId);§ExileZone exileZone = game.getExile().getExileZone(exileId);§if (exileZone != null) {§for (Card card : exileZone.getCards(game)) {§cardNames.add(card.getName());§}§}§if (input instanceof SplitCard) {§return cardNames.contains(((SplitCard) input).getLeftHalfCard().getName()) || cardNames.contains(((SplitCard) input).getRightHalfCard().getName());§} else if (input instanceof Spell && ((Spell) input).getSpellAbility().getSpellAbilityType().equals(SpellAbilityType.SPLIT_FUSED)) {§SplitCard card = (SplitCard) ((Spell) input).getCard();§return cardNames.contains(card.getLeftHalfCard().getName()) || cardNames.contains(card.getRightHalfCard().getName());§} else {§return cardNames.contains(input.getName());§}§}§@Override§public String toString() {§return "spell with the same name as a card exiled with {source}";§}§}§
public class MischiefAndMayhem extends CardImpl {§public MischiefAndMayhem(UUID ownerId) {§super(ownerId, 126, "Mischief and Mayhem", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{4}{G}");§this.expansionSetCode = "BNG";§this.getSpellAbility().addEffect(new BoostTargetEffect(4,4, Duration.EndOfTurn));§this.getSpellAbility().addTarget(new TargetCreaturePermanent(0,2, new FilterCreaturePermanent("creatures each"), false));§}§public MischiefAndMayhem(final MischiefAndMayhem card) {§super(card);§}§@Override§public MischiefAndMayhem copy() {§return new MischiefAndMayhem(this);§}§}§
public class MogisGodOfSlaughter extends CardImpl {§public MogisGodOfSlaughter(UUID ownerId) {§super(ownerId, 151, "Mogis, God of Slaughter", Rarity.MYTHIC, new CardType[]{CardType.ENCHANTMENT, CardType.CREATURE}, "{2}{B}{R}");§this.expansionSetCode = "BNG";§this.supertype.add("Legendary");§this.subtype.add("God");§this.power = new MageInt(7);§this.toughness = new MageInt(5);§this.addAbility(IndestructibleAbility.getInstance());§Effect effect = new LoseCreatureTypeSourceEffect(new DevotionCount(ColoredManaSymbol.B, ColoredManaSymbol.R), 7);§effect.setText("As long as your devotion to black and red is less than seven, Mogis isn't a creature");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, effect));§effect = new DoUnlessTargetPaysCost(new DamageTargetEffect(2, false, "that player"), new SacrificeTargetCost(new TargetControlledCreaturePermanent()),§"Sacrifice a creature? (otherwise you get 2 damage)");§effect.setText("Mogis deals 2 damage to that player unless he or she sacrifices a creature");§Ability ability = new BeginningOfUpkeepTriggeredAbility(Zone.BATTLEFIELD, effect, TargetController.OPPONENT, false, true);§this.addAbility(ability);§}§public MogisGodOfSlaughter(final MogisGodOfSlaughter card) {§super(card);§}§@Override§public MogisGodOfSlaughter copy() {§return new MogisGodOfSlaughter(this);§}§}§class DoUnlessTargetPaysCost extends OneShotEffect {§private final OneShotEffect executingEffect;§private final Cost cost;§private final String userMessage;§public DoUnlessTargetPaysCost(OneShotEffect effect, Cost cost) {§this(effect, cost, null);§}§public DoUnlessTargetPaysCost(OneShotEffect effect, Cost cost, String userMessage) {§super(Outcome.Benefit);§this.executingEffect = effect;§this.cost = cost;§this.userMessage = userMessage;§}§public DoUnlessTargetPaysCost(final DoUnlessTargetPaysCost effect) {§super(effect);§this.executingEffect = (OneShotEffect) effect.executingEffect.copy();§this.cost = effect.cost.copy();§this.userMessage = effect.userMessage;§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(targetPointer.getFirst(game, source));§MageObject mageObject = game.getObject(source.getSourceId());§if (player != null && mageObject != null) {§String message = userMessage;§if (message == null) {§message = getCostText() + " to prevent " + executingEffect.getText(source.getModes().getMode()) + "?";§}§message = CardUtil.replaceSourceName(message, mageObject.getLogName());§cost.clearPaid();§if (cost.canPay(source, source.getSourceId(), player.getId(), game) && player.chooseUse(executingEffect.getOutcome(), message, source, game)) {§cost.pay(source, game, source.getSourceId(), player.getId(), false, null);§}§if (!cost.isPaid()) {§executingEffect.setTargetPointer(this.targetPointer);§return executingEffect.apply(game, source);§}§return true;§}§return false;§}§@Override§public String getText(Mode mode) {§if (!staticText.isEmpty()) {§return staticText;§}§StringBuilder sb = new StringBuilder(executingEffect.getText(mode));§sb.append("unless he or she");§sb.append(getCostText());§return sb.toString();§}§private String getCostText() {§StringBuilder sb = new StringBuilder();§String costText = cost.getText();§if (costText != null§&& !costText.toLowerCase().startsWith("discard")§&& !costText.toLowerCase().startsWith("sacrifice")§&& !costText.toLowerCase().startsWith("remove")) {§sb.append("pay ");§}§return sb.append(costText).toString();§}§@Override§public DoUnlessTargetPaysCost copy() {§return new DoUnlessTargetPaysCost(this);§}§}§
public class MortalsArdor extends CardImpl {§public MortalsArdor(UUID ownerId) {§super(ownerId, 20, "Mortal's Ardor", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{W}");§this.expansionSetCode = "BNG";§Effect effect = new BoostTargetEffect(1,1, Duration.EndOfTurn);§effect.setText("Target creature gets +1/+1");§this.getSpellAbility().addEffect(effect);§effect = new GainAbilityTargetEffect(LifelinkAbility.getInstance(), Duration.EndOfTurn);§effect.setText("and gains lifelink until end of turn");§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public MortalsArdor(final MortalsArdor card) {§super(card);§}§@Override§public MortalsArdor copy() {§return new MortalsArdor(this);§}§}§
public class MortalsResolve extends CardImpl {§public MortalsResolve(UUID ownerId) {§super(ownerId, 127, "Mortal's Resolve", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{G}");§this.expansionSetCode = "BNG";§Effect effect = new BoostTargetEffect(1,1, Duration.EndOfTurn);§effect.setText("Target creature gets +1/+1");§this.getSpellAbility().addEffect(effect);§effect = new GainAbilityTargetEffect(IndestructibleAbility.getInstance(), Duration.EndOfTurn);§effect.setText("and gains indestructible until end of turn");§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public MortalsResolve(final MortalsResolve card) {§super(card);§}§@Override§public MortalsResolve copy() {§return new MortalsResolve(this);§}§}§
public class NessianDemolok extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("noncreature permanent");§static {§filter.add(Predicates.not(new CardTypePredicate(CardType.CREATURE)));§}§public NessianDemolok(UUID ownerId) {§super(ownerId, 128, "Nessian Demolok", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{G}{G}");§this.expansionSetCode = "BNG";§this.subtype.add("Beast");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new TributeAbility(3));§TriggeredAbility ability = new EntersBattlefieldTriggeredAbility(new DestroyTargetEffect(), false);§ability.addTarget(new TargetPermanent(filter));§this.addAbility(new ConditionalTriggeredAbility(ability, TributeNotPaidCondition.getInstance(),§"When {this} enters the battlefield, if its tribute wasn't paid, destroy target noncreature permanent."));§}§public NessianDemolok(final NessianDemolok card) {§super(card);§}§@Override§public NessianDemolok copy() {§return new NessianDemolok(this);§}§}§
public class NessianWildsRavager extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("another target creature");§static {§filter.add(new AnotherPredicate());§}§public NessianWildsRavager(UUID ownerId) {§super(ownerId, 129, "Nessian Wilds Ravager", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{G}{G}");§this.expansionSetCode = "BNG";§this.subtype.add("Hydra");§this.power = new MageInt(6);§this.toughness = new MageInt(6);§this.addAbility(new TributeAbility(6));§TriggeredAbility ability = new EntersBattlefieldTriggeredAbility(new FightTargetSourceEffect(), true);§ability.addTarget(new TargetCreaturePermanent(filter));§this.addAbility(new ConditionalTriggeredAbility(ability, TributeNotPaidCondition.getInstance(),§"When {this} enters the battlefield, if its tribute wasn't paid, you may have {this} fight another target creature."));§}§public NessianWildsRavager(final NessianWildsRavager card) {§super(card);§}§@Override§public NessianWildsRavager copy() {§return new NessianWildsRavager(this);§}§}§
public class NobleQuarry extends CardImpl {§public NobleQuarry(UUID ownerId) {§super(ownerId, 130, "Noble Quarry", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT, CardType.CREATURE}, "{2}{G}");§this.expansionSetCode = "BNG";§this.subtype.add("Unicorn");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new BestowAbility(this, "{5}{G}"));§Effect effect = new MustBeBlockedByAllSourceEffect(Duration.WhileOnBattlefield);§effect.setText("All creatures able to block Noble Quarry");§Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, effect);§effect = new MustBeBlockedByAllAttachedEffect(Duration.WhileOnBattlefield, AttachmentType.AURA);§effect.setText("or enchanted creature do so");§ability.addEffect(effect);§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(1,1, Duration.WhileOnBattlefield)));§}§public NobleQuarry(final NobleQuarry card) {§super(card);§}§@Override§public NobleQuarry copy() {§return new NobleQuarry(this);§}§}§
public class Nullify extends CardImpl {§private static final FilterSpell filter = new FilterSpell("creature or Aura spell");§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.CREATURE),§new SubtypePredicate("Aura")));§}§public Nullify(UUID ownerId) {§super(ownerId, 45, "Nullify", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{U}{U}");§this.expansionSetCode = "BNG";§this.getSpellAbility().addEffect(new CounterTargetEffect());§this.getSpellAbility().addTarget(new TargetSpell(filter));§}§public Nullify(final Nullify card) {§super(card);§}§@Override§public Nullify copy() {§return new Nullify(this);§}§}§
public class NyxbornEidolon extends CardImpl {§public NyxbornEidolon(UUID ownerId) {§super(ownerId, 78, "Nyxborn Eidolon", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT, CardType.CREATURE}, "{1}{B}");§this.expansionSetCode = "BNG";§this.subtype.add("Spirit");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new BestowAbility(this, "{4}{B}"));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(2, 1, Duration.WhileOnBattlefield)));§}§public NyxbornEidolon(final NyxbornEidolon card) {§super(card);§}§@Override§public NyxbornEidolon copy() {§return new NyxbornEidolon(this);§}§}§
public class NyxbornRollicker extends CardImpl {§public NyxbornRollicker(UUID ownerId) {§super(ownerId, 102, "Nyxborn Rollicker", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT, CardType.CREATURE}, "{R}");§this.expansionSetCode = "BNG";§this.subtype.add("Satyr");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new BestowAbility(this, "{1}{R}"));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(1,1, Duration.WhileOnBattlefield )));§}§public NyxbornRollicker(final NyxbornRollicker card) {§super(card);§}§@Override§public NyxbornRollicker copy() {§return new NyxbornRollicker(this);§}§}§
public class NyxbornShieldmate extends CardImpl {§public NyxbornShieldmate(UUID ownerId) {§super(ownerId, 21, "Nyxborn Shieldmate", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT, CardType.CREATURE}, "{W}");§this.expansionSetCode = "BNG";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§this.addAbility(new BestowAbility(this, "{2}{W}"));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(1,2, Duration.WhileOnBattlefield)));§}§public NyxbornShieldmate(final NyxbornShieldmate card) {§super(card);§}§@Override§public NyxbornShieldmate copy() {§return new NyxbornShieldmate(this);§}§}§
public class NyxbornTriton extends CardImpl {§public NyxbornTriton(UUID ownerId) {§super(ownerId, 46, "Nyxborn Triton", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT, CardType.CREATURE}, "{2}{U}");§this.expansionSetCode = "BNG";§this.subtype.add("Merfolk");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(new BestowAbility(this, "{4}{U}"));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(2,3, Duration.WhileOnBattlefield)));§}§public NyxbornTriton(final NyxbornTriton card) {§super(card);§}§@Override§public NyxbornTriton copy() {§return new NyxbornTriton(this);§}§}§
public class OracleOfBones extends CardImpl {§public OracleOfBones(UUID ownerId) {§super(ownerId, 103, "Oracle of Bones", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{R}{R}");§this.expansionSetCode = "BNG";§this.subtype.add("Minotaur");§this.subtype.add("Shaman");§this.power = new MageInt(3);§this.toughness = new MageInt(1);§this.addAbility(HasteAbility.getInstance());§this.addAbility(new TributeAbility(2));§TriggeredAbility ability = new EntersBattlefieldTriggeredAbility(new OracleOfBonesCastEffect(), false);§this.addAbility(new ConditionalTriggeredAbility(ability, TributeNotPaidCondition.getInstance(),§"When {this} enters the battlefield, if its tribute wasn't paid, you may cast an instant or sorcery card from your hand without paying its mana cost."));§}§public OracleOfBones(final OracleOfBones card) {§super(card);§}§@Override§public OracleOfBones copy() {§return new OracleOfBones(this);§}§}§class OracleOfBonesCastEffect extends OneShotEffect {§private static final FilterCard filter = new FilterInstantOrSorceryCard("instant or sorcery card from your hand");§public OracleOfBonesCastEffect() {§super(Outcome.PlayForFree);§this.staticText = "you may cast an instant or sorcery card from your hand without paying its mana cost";§}§public OracleOfBonesCastEffect(final OracleOfBonesCastEffect effect) {§super(effect);§}§@Override§public OracleOfBonesCastEffect copy() {§return new OracleOfBonesCastEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Target target = new TargetCardInHand(filter);§if (target.canChoose(source.getSourceId(), controller.getId(), game) &&§controller.chooseUse(outcome, "Cast an instant or sorcery card from your hand without paying its mana cost?", source, game)) {§Card cardToCast = null;§boolean cancel = false;§while (controller.canRespond() && !cancel) {§if (controller.chooseTarget(outcome, target, source, game)) {§cardToCast = game.getCard(target.getFirstTarget());§if (cardToCast != null && cardToCast.getSpellAbility().canChooseTarget(game)) {§cancel = true;§}§} else {§cancel = true;§}§}§if (cardToCast != null) {§controller.cast(cardToCast.getSpellAbility(), game, true);§}§}§return true;§}§return false;§}§}§
public class OraclesInsight extends CardImpl {§public OraclesInsight(UUID ownerId) {§super(ownerId, 47, "Oracle's Insight", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{3}{U}");§this.expansionSetCode = "BNG";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ScryEffect(1), new TapSourceCost());§Effect effect = new DrawCardSourceControllerEffect(1);§effect.setText("then draw a card");§ability.addEffect(effect);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(ability, AttachmentType.AURA, Duration.WhileOnBattlefield)));§}§public OraclesInsight(final OraclesInsight card) {§super(card);§}§@Override§public OraclesInsight copy() {§return new OraclesInsight(this);§}§}§
public class OreskosSunGuide extends CardImpl {§public OreskosSunGuide(UUID ownerId) {§super(ownerId, 22, "Oreskos Sun Guide", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "BNG";§this.subtype.add("Cat");§this.subtype.add("Monk");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new InspiredAbility(new GainLifeEffect(2)));§}§public OreskosSunGuide(final OreskosSunGuide card) {§super(card);§}§@Override§public OreskosSunGuide copy() {§return new OreskosSunGuide(this);§}§}§
public class Ornitharch extends CardImpl {§public Ornitharch(UUID ownerId) {§super(ownerId, 23, "Ornitharch", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{W}{W}");§this.expansionSetCode = "BNG";§this.subtype.add("Archon");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new TributeAbility(2));§TriggeredAbility ability = new EntersBattlefieldTriggeredAbility(new CreateTokenEffect(new BirdToken(), 2), false);§this.addAbility(new ConditionalTriggeredAbility(ability, TributeNotPaidCondition.getInstance(),§"When {this} enters the battlefield, if its tribute wasn't paid, put two 1/1 white Bird creature tokens with flying onto the battlefield."));§}§public Ornitharch(final Ornitharch card) {§super(card);§}§@Override§public Ornitharch copy() {§return new Ornitharch(this);§}§}§
public class PainSeer extends CardImpl {§public PainSeer(UUID ownerId) {§super(ownerId, 80, "Pain Seer", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{B}");§this.expansionSetCode = "BNG";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new InspiredAbility(new PainSeerEffect()));§}§public PainSeer(final PainSeer card) {§super(card);§}§@Override§public PainSeer copy() {§return new PainSeer(this);§}§}§class PainSeerEffect extends OneShotEffect {§public PainSeerEffect() {§super(Outcome.DrawCard);§this.staticText = "reveal the top card of your library and put that card into your hand. You lose life equal to that card's converted mana cost";§}§public PainSeerEffect(final PainSeerEffect effect) {§super(effect);§}§@Override§public PainSeerEffect copy() {§return new PainSeerEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player == null) {§return false;§}§if (player.getLibrary().size() > 0) {§Card card = player.getLibrary().getFromTop(game);§Cards cards = new CardsImpl();§cards.add(card);§player.revealCards("Pain Seer", cards, game);§if (card != null &&§card.moveToZone(Zone.HAND, source.getSourceId(), game, false)) {§player.loseLife(card.getManaCost().convertedManaCost(), game);§return true;§}§}§return false;§}§}§
public class Peregrination extends CardImpl {§public Peregrination(UUID ownerId) {§super(ownerId, 132, "Peregrination", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{3}{G}");§this.expansionSetCode = "BNG";§this.getSpellAbility().addEffect(new PeregrinationEffect());§Effect effect = new ScryEffect(1);§effect.setText("then scry 1 <i>(Look at the top card of your library. You may put that card on the bottom of your library.)</i>");§this.getSpellAbility().addEffect(effect);§}§public Peregrination(final Peregrination card) {§super(card);§}§@Override§public Peregrination copy() {§return new Peregrination(this);§}§}§class PeregrinationEffect extends OneShotEffect {§protected static final FilterCard filter = new FilterCard("card to put on the battlefield tapped");§public PeregrinationEffect() {§super(Outcome.PutLandInPlay);§staticText = "Search your library for up to two basic land cards, reveal those cards, and put one onto the battlefield tapped and the other into your hand. Shuffle your library";§}§public PeregrinationEffect(final PeregrinationEffect effect) {§super(effect);§}§@Override§public PeregrinationEffect copy() {§return new PeregrinationEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§MageObject sourceObject = game.getObject(source.getSourceId());§if (controller == null || sourceObject == null) {§return false;§}§TargetCardInLibrary target = new TargetCardInLibrary(0, 2, new FilterBasicLandCard());§if (controller.searchLibrary(target, game)) {§if (target.getTargets().size() > 0) {§Cards revealed = new CardsImpl();§for (UUID cardId : target.getTargets()) {§Card card = controller.getLibrary().getCard(cardId, game);§revealed.add(card);§}§controller.revealCards(sourceObject.getIdName(), revealed, game);§if (target.getTargets().size() == 2) {§TargetCard target2 = new TargetCard(Zone.LIBRARY, filter);§controller.choose(Outcome.Benefit, revealed, target2, game);§Card card = revealed.get(target2.getFirstTarget(), game);§controller.moveCards(card, Zone.BATTLEFIELD, source, game, true, false, false, null);§revealed.remove(card);§card = revealed.getCards(game).iterator().next();§controller.moveCards(card, Zone.HAND, source, game);§} else if (target.getTargets().size() == 1) {§Card card = revealed.getCards(game).iterator().next();§controller.moveCards(card, Zone.BATTLEFIELD, source, game, true, false, false, null);§}§}§controller.shuffleLibrary(game);§return true;§}§controller.shuffleLibrary(game);§return false;§}§}§
public class PerplexingChimera extends CardImpl {§public PerplexingChimera(UUID ownerId) {§super(ownerId, 48, "Perplexing Chimera", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT, CardType.CREATURE}, "{4}{U}");§this.expansionSetCode = "BNG";§this.subtype.add("Chimera");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new PerplexingChimeraTriggeredAbility());§}§public PerplexingChimera(final PerplexingChimera card) {§super(card);§}§@Override§public PerplexingChimera copy() {§return new PerplexingChimera(this);§}§}§class PerplexingChimeraTriggeredAbility extends TriggeredAbilityImpl {§public PerplexingChimeraTriggeredAbility() {§super(Zone.BATTLEFIELD, new PerplexingChimeraControlExchangeEffect(), true);§}§public PerplexingChimeraTriggeredAbility(final PerplexingChimeraTriggeredAbility ability) {§super(ability);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.SPELL_CAST;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (game.getOpponents(controllerId).contains(event.getPlayerId())) {§for (Effect effect : this.getEffects()) {§effect.setTargetPointer(new FixedTarget(event.getTargetId()));§}§return true;§}§return false;§}§@Override§public String getRule() {§return "Whenever an opponent casts a spell, " + super.getRule();§}§@Override§public PerplexingChimeraTriggeredAbility copy() {§return new PerplexingChimeraTriggeredAbility(this);§}§}§class PerplexingChimeraControlExchangeEffect extends OneShotEffect {§public PerplexingChimeraControlExchangeEffect() {§super(Outcome.Benefit);§this.staticText = "exchange control of {this} and that spell. If you do, you may choose new targets for the spell";§}§public PerplexingChimeraControlExchangeEffect(final PerplexingChimeraControlExchangeEffect effect) {§super(effect);§}§@Override§public PerplexingChimeraControlExchangeEffect copy() {§return new PerplexingChimeraControlExchangeEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Spell spell = game.getStack().getSpell(targetPointer.getFirst(game, source));§Player controller = game.getPlayer(source.getControllerId());§if (spell != null && controller != null) {§Player spellCaster = game.getPlayer(spell.getControllerId());§spell.setControllerId(controller.getId());§spell.chooseNewTargets(game, controller.getId());§game.informPlayers(controller.getLogName() + " got control of " + spell.getName() + " spell.");§if (spellCaster != null) {§ContinuousEffect effect = new PerplexingChimeraControlEffect();§effect.setTargetPointer(new FixedTarget(spellCaster.getId()));§game.addEffect(effect, source);§}§}§return false;§}§}§class PerplexingChimeraControlEffect extends ContinuousEffectImpl {§public PerplexingChimeraControlEffect() {§super(Duration.Custom, Layer.ControlChangingEffects_2, SubLayer.NA, Outcome.GainControl);§staticText = "PerplexingChimeraControlEffect";§}§public PerplexingChimeraControlEffect(final PerplexingChimeraControlEffect effect) {§super(effect);§}§@Override§public PerplexingChimeraControlEffect copy() {§return new PerplexingChimeraControlEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getPermanent(source.getSourceId());§if (permanent != null) {§return permanent.changeControllerId(this.getTargetPointer().getFirst(game, source), game);§} else {§discard(); §
public class PharagaxGiant extends CardImpl {§public PharagaxGiant(UUID ownerId) {§super(ownerId, 104, "Pharagax Giant", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{R}");§this.expansionSetCode = "BNG";§this.subtype.add("Giant");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new TributeAbility(2));§TriggeredAbility ability = new EntersBattlefieldTriggeredAbility(new DamagePlayersEffect(5, TargetController.OPPONENT), false);§this.addAbility(new ConditionalTriggeredAbility(ability, TributeNotPaidCondition.getInstance(),§"When {this} enters the battlefield, if its tribute wasn't paid, {this} deals 5 damage to each opponent."));§}§public PharagaxGiant(final PharagaxGiant card) {§super(card);§}§@Override§public PharagaxGiant copy() {§return new PharagaxGiant(this);§}§}§
public class PhenaxGodOfDeception extends CardImpl {§public PhenaxGodOfDeception(UUID ownerId) {§super(ownerId, 152, "Phenax, God of Deception", Rarity.MYTHIC, new CardType[]{CardType.ENCHANTMENT, CardType.CREATURE}, "{3}{U}{B}");§this.expansionSetCode = "BNG";§this.supertype.add("Legendary");§this.subtype.add("God");§this.power = new MageInt(4);§this.toughness = new MageInt(7);§this.addAbility(IndestructibleAbility.getInstance());§Effect effect = new LoseCreatureTypeSourceEffect(new DevotionCount(ColoredManaSymbol.U, ColoredManaSymbol.B), 7);§effect.setText("As long as your devotion to blue and black is less than seven, Phenax isn't a creature");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, effect));§effect = new PutTopCardOfLibraryIntoGraveTargetEffect(SourcePermanentToughnessValue.getInstance());§effect.setText("Target player puts the top X cards of his or her library into his or her graveyard, where X is this creature's toughness");§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new TapSourceCost());§ability.addTarget(new TargetPlayer());§effect = new GainAbilityControlledEffect(ability, Duration.WhileOnBattlefield, new FilterCreaturePermanent("Creatures"),false);§effect.setText("Creatures you control have \"{T}: Target player puts the top X cards of his or her library into his or her graveyard, where X is this creature's toughness.\"");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, effect));§}§public PhenaxGodOfDeception(final PhenaxGodOfDeception card) {§super(card);§}§@Override§public PhenaxGodOfDeception copy() {§return new PhenaxGodOfDeception(this);§}§}§
public class PheresBandRaiders extends CardImpl {§public PheresBandRaiders(UUID ownerId) {§super(ownerId, 133, "Pheres-Band Raiders", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{5}{G}");§this.expansionSetCode = "BNG";§this.subtype.add("Centaur");§this.subtype.add("Warrior");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(new InspiredAbility(new DoIfCostPaid(new CreateTokenEffect(new CentaurEnchantmentCreatureToken()), new ManaCostsImpl("{2}{G}"))));§}§public PheresBandRaiders(final PheresBandRaiders card) {§super(card);§}§@Override§public PheresBandRaiders copy() {§return new PheresBandRaiders(this);§}§}§
public class PheresBandTromper extends CardImpl {§public PheresBandTromper(UUID ownerId) {§super(ownerId, 134, "Pheres-Band Tromper", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{G}");§this.expansionSetCode = "BNG";§this.subtype.add("Centaur");§this.subtype.add("Warrior");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new InspiredAbility(new AddCountersSourceEffect(CounterType.P1P1.createInstance())));§}§public PheresBandTromper(final PheresBandTromper card) {§super(card);§}§@Override§public PheresBandTromper copy() {§return new PheresBandTromper(this);§}§}§
public class PillarOfWar extends CardImpl {§public PillarOfWar(UUID ownerId) {§super(ownerId, 160, "Pillar of War", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{3}");§this.expansionSetCode = "BNG";§this.subtype.add("Golem");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(DefenderAbility.getInstance());§Effect effect = new ConditionalAsThoughEffect(§new CanAttackAsThoughItDidntHaveDefenderSourceEffect(Duration.WhileOnBattlefield),§new EnchantedCondition());§effect.setText("As long as {this} is enchanted, it can attack as though it didn't have defender");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, effect));§}§public PillarOfWar(final PillarOfWar card) {§super(card);§}§@Override§public PillarOfWar copy() {§return new PillarOfWar(this);§}§}§
public class PinnacleOfRage extends CardImpl {§public PinnacleOfRage(UUID ownerId) {§super(ownerId, 105, "Pinnacle of Rage", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{4}{R}{R}");§this.expansionSetCode = "BNG";§Effect effect = new DamageTargetEffect(3);§effect.setText("{this} deals 3 damage to each of two target creatures and/or players");§this.getSpellAbility().addTarget(new TargetCreatureOrPlayer(2,2));§this.getSpellAbility().addEffect(effect);§}§public PinnacleOfRage(final PinnacleOfRage card) {§super(card);§}§@Override§public PinnacleOfRage copy() {§return new PinnacleOfRage(this);§}§}§
public class PleaForGuidance extends CardImpl {§private static final FilterCard filter = new FilterCard("enchantment cards");§static {§filter.add(new CardTypePredicate(CardType.ENCHANTMENT));§}§public PleaForGuidance(UUID ownerId) {§super(ownerId, 24, "Plea for Guidance", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{5}{W}");§this.expansionSetCode = "BNG";§this.getSpellAbility().addEffect(new SearchLibraryPutInHandEffect(new TargetCardInLibrary(0,2, filter), true, true));§}§public PleaForGuidance(final PleaForGuidance card) {§super(card);§}§@Override§public PleaForGuidance copy() {§return new PleaForGuidance(this);§}§}§
public class Ragemonger extends CardImpl {§private static final FilterCard filter = new FilterCard("Minotaur spells");§static {§filter.add(new SubtypePredicate("Minotaur"));§}§public Ragemonger(UUID ownerId) {§super(ownerId, 153, "Ragemonger", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{B}{R}");§this.expansionSetCode = "BNG";§this.subtype.add("Minotaur");§this.subtype.add("Shaman");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new SpellsCostReductionControllerEffect(filter, new ManaCostsImpl<>("{B}{R}"))));§}§public Ragemonger(final Ragemonger card) {§super(card);§}§@Override§public Ragemonger copy() {§return new Ragemonger(this);§}§}§
public class RaisedByWolves extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("Wolf you control");§static {§filter.add(new SubtypePredicate("Wolf"));§}§public RaisedByWolves(UUID ownerId) {§super(ownerId, 135, "Raised by Wolves", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{3}{G}{G}");§this.expansionSetCode = "BNG";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new EntersBattlefieldTriggeredAbility(new CreateTokenEffect(new WolfToken(), 2)));§DynamicValue amountOfWolves = new PermanentsOnBattlefieldCount(filter);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(amountOfWolves, amountOfWolves, Duration.WhileOnBattlefield)));§}§public RaisedByWolves(final RaisedByWolves card) {§super(card);§}§@Override§public RaisedByWolves copy() {§return new RaisedByWolves(this);§}§}§
public class ReapWhatIsSown extends CardImpl {§public ReapWhatIsSown(UUID ownerId) {§super(ownerId, 154, "Reap What Is Sown", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{1}{G}{W}");§this.expansionSetCode = "BNG";§Effect effect = new AddCountersTargetEffect(CounterType.P1P1.createInstance());§effect.setText("Put a +1/+1 counter on each of up to three target creatures");§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addTarget(new TargetCreaturePermanent(0, 3, new FilterCreaturePermanent("creatures"), false));§}§public ReapWhatIsSown(final ReapWhatIsSown card) {§super(card);§}§@Override§public ReapWhatIsSown copy() {§return new ReapWhatIsSown(this);§}§}§
public class RecklessReveler extends CardImpl {§public RecklessReveler(UUID ownerId) {§super(ownerId, 106, "Reckless Reveler", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{R}");§this.expansionSetCode = "BNG";§this.subtype.add("Satyr");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DestroyTargetEffect(), new ManaCostsImpl("{R}"));§ability.addCost(new SacrificeSourceCost());§ability.addTarget(new TargetArtifactPermanent());§this.addAbility(ability);§}§public RecklessReveler(final RecklessReveler card) {§super(card);§}§@Override§public RecklessReveler copy() {§return new RecklessReveler(this);§}§}§
public class Sanguimancy extends CardImpl {§public Sanguimancy(UUID ownerId) {§super(ownerId, 81, "Sanguimancy", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{4}{B}");§this.expansionSetCode = "BNG";§DynamicValue blackDevotion = new DevotionCount(ColoredManaSymbol.B);§Effect effect = new DrawCardSourceControllerEffect(blackDevotion);§effect.setText("You draw X cards");§this.getSpellAbility().addEffect(effect);§effect = new LoseLifeSourceControllerEffect(blackDevotion);§effect.setText("and you lose X life, where X is your devotion to black");§this.getSpellAbility().addEffect(effect);§}§public Sanguimancy(final Sanguimancy card) {§super(card);§}§@Override§public Sanguimancy copy() {§return new Sanguimancy(this);§}§}§
public class SatyrFiredancer extends CardImpl {§public SatyrFiredancer(UUID ownerId) {§super(ownerId, 108, "Satyr Firedancer", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT, CardType.CREATURE}, "{1}{R}");§this.expansionSetCode = "BNG";§this.subtype.add("Satyr");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new SatyrFiredancerTriggeredAbility());§}§public SatyrFiredancer(final SatyrFiredancer card) {§super(card);§}§@Override§public void adjustTargets(Ability ability, Game game) {§if (ability instanceof SatyrFiredancerTriggeredAbility) {§Player opponent = game.getPlayer(ability.getEffects().get(0).getTargetPointer().getFirst(game, ability));§if (opponent != null) {§FilterCreaturePermanent filter = new FilterCreaturePermanent("creature controlled by " + opponent.getLogName());§filter.add(new ControllerIdPredicate(opponent.getId()));§ability.getTargets().add(new TargetCreaturePermanent(filter));§}§}§}§@Override§public SatyrFiredancer copy() {§return new SatyrFiredancer(this);§}§}§class SatyrFiredancerTriggeredAbility extends TriggeredAbilityImpl {§private List<UUID> handledStackObjects = new ArrayList<>();§public SatyrFiredancerTriggeredAbility() {§super(Zone.BATTLEFIELD, new SatyrFiredancerDamageEffect(), false);§}§public SatyrFiredancerTriggeredAbility(final SatyrFiredancerTriggeredAbility ability) {§super(ability);§}§@Override§public SatyrFiredancerTriggeredAbility copy() {§return new SatyrFiredancerTriggeredAbility(this);§}§@Override§public void reset(Game game) {§handledStackObjects.clear();§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.DAMAGED_PLAYER;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (getControllerId().equals(game.getControllerId(event.getSourceId()))) {§MageObject damageSource = game.getObject(event.getSourceId());§if (damageSource != null) {§if (game.getOpponents(getControllerId()).contains(event.getTargetId())) {§MageObject object = game.getObject(event.getSourceId());§if (object.getCardType().contains(CardType.INSTANT) || object.getCardType().contains(CardType.SORCERY)) {§if (!(damageSource instanceof StackObject) || !handledStackObjects.contains(damageSource.getId())) {§if (damageSource instanceof StackObject) {§handledStackObjects.add(damageSource.getId());§}§for (Effect effect: this.getEffects()) {§effect.setTargetPointer(new FixedTarget(event.getTargetId())); §
public class SatyrNyxSmith extends CardImpl {§public SatyrNyxSmith(UUID ownerId) {§super(ownerId, 109, "Satyr Nyx-Smith", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "BNG";§this.subtype.add("Satyr");§this.subtype.add("Shaman");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(HasteAbility.getInstance());§this.addAbility(new InspiredAbility(new DoIfCostPaid(new CreateTokenEffect(new SatyrNyxSmithElementalToken()), new ManaCostsImpl("{2}{R}"))));§}§public SatyrNyxSmith(final SatyrNyxSmith card) {§super(card);§}§@Override§public SatyrNyxSmith copy() {§return new SatyrNyxSmith(this);§}§}§class SatyrNyxSmithElementalToken extends Token {§public SatyrNyxSmithElementalToken() {§super("Elemental", "3/1 red Elemental enchantment creature token with haste");§cardType.add(CardType.ENCHANTMENT);§cardType.add(CardType.CREATURE);§color.setRed(true);§subtype.add("Elemental");§power = new MageInt(3);§toughness = new MageInt(1);§this.addAbility(HasteAbility.getInstance());§this.setOriginalExpansionSetCode("BNG");§}§}§
public class SatyrWayfinder extends CardImpl {§public SatyrWayfinder(UUID ownerId) {§super(ownerId, 136, "Satyr Wayfinder", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "BNG";§this.subtype.add("Satyr");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new EntersBattlefieldTriggeredAbility(new SatyrWayfinderEffect()));§}§public SatyrWayfinder(final SatyrWayfinder card) {§super(card);§}§@Override§public SatyrWayfinder copy() {§return new SatyrWayfinder(this);§}§}§class SatyrWayfinderEffect extends OneShotEffect {§private static final FilterLandCard filterPutInHand = new FilterLandCard("land card to put in hand");§public SatyrWayfinderEffect() {§super(Outcome.DrawCard);§this.staticText = "reveal the top four cards of your library. You may put a land card from among them into your hand. Put the rest into your graveyard";§}§public SatyrWayfinderEffect(final SatyrWayfinderEffect effect) {§super(effect);§}§@Override§public SatyrWayfinderEffect copy() {§return new SatyrWayfinderEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§MageObject sourceObject = game.getObject(source.getSourceId());§if (controller != null && sourceObject != null) {§Cards cards = new CardsImpl();§cards.addAll(controller.getLibrary().getTopCards(game, 4));§boolean properCardFound = cards.count(filterPutInHand, source.getControllerId(), source.getSourceId(), game) > 0;§if (!cards.isEmpty()) {§controller.revealCards(sourceObject.getName(), cards, game);§TargetCard target = new TargetCard(Zone.LIBRARY, filterPutInHand);§if (properCardFound§&& controller.chooseUse(outcome, "Put a land card into your hand?", source, game)§&& controller.choose(Outcome.DrawCard, cards, target, game)) {§Card card = game.getCard(target.getFirstTarget());§if (card != null) {§cards.remove(card);§controller.moveCards(card, null, Zone.HAND, source, game);§}§}§controller.moveCards(cards, Zone.LIBRARY, Zone.GRAVEYARD, source, game);§}§return true;§}§return false;§}§}§
public class ScourgeOfSkolaVale extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("another creature");§static {§filter.add(new AnotherPredicate());§}§public ScourgeOfSkolaVale(UUID ownerId) {§super(ownerId, 137, "Scourge of Skola Vale", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{G}");§this.expansionSetCode = "BNG";§this.subtype.add("Hydra");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§this.addAbility(TrampleAbility.getInstance());§Effect effect = new AddCountersSourceEffect(CounterType.P1P1.createInstance(2), true);§effect.setText("with two +1/+1 counters on it");§this.addAbility(new EntersBattlefieldAbility(effect));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ScourgeOfSkolaValeEffect(), new TapSourceCost());§ability.addCost(new SacrificeTargetCost(new TargetControlledPermanent(filter)));§this.addAbility(ability);§}§public ScourgeOfSkolaVale(final ScourgeOfSkolaVale card) {§super(card);§}§@Override§public ScourgeOfSkolaVale copy() {§return new ScourgeOfSkolaVale(this);§}§}§class ScourgeOfSkolaValeEffect extends OneShotEffect {§public ScourgeOfSkolaValeEffect() {§super(Outcome.GainLife);§this.staticText = "Put a number of +1/+1 counters on {this} equal to the sacrificed creature's toughness";§}§public ScourgeOfSkolaValeEffect(final ScourgeOfSkolaValeEffect effect) {§super(effect);§}§@Override§public ScourgeOfSkolaValeEffect copy() {§return new ScourgeOfSkolaValeEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§for (Cost cost : source.getCosts()) {§if (cost instanceof SacrificeTargetCost) {§int amount = ((SacrificeTargetCost) cost).getPermanents().get(0).getToughness().getValue();§Player player = game.getPlayer(source.getControllerId());§if (amount > 0 && player != null) {§return new AddCountersSourceEffect(CounterType.P1P1.createInstance(amount), true).apply(game, source);§}§}§}§return false;§}§}§
public class ScouringSands extends CardImpl {§public ScouringSands(UUID ownerId) {§super(ownerId, 110, "Scouring Sands", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{1}{R}");§this.expansionSetCode = "BNG";§this.getSpellAbility().addEffect(new ScouringSandsDamageEffect());§this.getSpellAbility().addEffect(new ScryEffect(1));§}§public ScouringSands(final ScouringSands card) {§super(card);§}§@Override§public ScouringSands copy() {§return new ScouringSands(this);§}§}§class ScouringSandsDamageEffect extends OneShotEffect {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature your opponents control");§static {§filter.add(new ControllerPredicate(TargetController.OPPONENT));§}§public ScouringSandsDamageEffect() {§super(Outcome.GainLife);§staticText = "{this} deals 1 damage to each creature your opponents control";§}§public ScouringSandsDamageEffect(ScouringSandsDamageEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§for (Permanent creature : game.getBattlefield().getActivePermanents(filter, source.getControllerId(), game)) {§if (creature != null) {§creature.damage(1, source.getSourceId(), game, false, false);§}§}§return true;§}§@Override§public ScouringSandsDamageEffect copy() {§return new ScouringSandsDamageEffect(this);§}§}§
public class SearingBlood extends CardImpl {§public SearingBlood(UUID ownerId) {§super(ownerId, 111, "Searing Blood", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{R}{R}");§this.expansionSetCode = "BNG";§this.getSpellAbility().addEffect(new SearingBloodEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public SearingBlood(final SearingBlood card) {§super(card);§}§@Override§public SearingBlood copy() {§return new SearingBlood(this);§}§}§class SearingBloodEffect extends OneShotEffect {§public SearingBloodEffect() {§super(Outcome.Damage);§this.staticText = "{this} deals 2 damage to target creature. When that creature dies this turn, {this} deals 3 damage to that creature's controller";§}§public SearingBloodEffect(final SearingBloodEffect effect) {§super(effect);§}§@Override§public SearingBloodEffect copy() {§return new SearingBloodEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§DelayedTriggeredAbility delayedAbility = new SearingBloodDelayedTriggeredAbility(source.getFirstTarget());§game.addDelayedTriggeredAbility(delayedAbility, source);§return new DamageTargetEffect(2).apply(game, source);§}§}§class SearingBloodDelayedTriggeredAbility extends DelayedTriggeredAbility {§private UUID target;§public SearingBloodDelayedTriggeredAbility(UUID target) {§super(new SearingBloodDelayedEffect(target), Duration.EndOfTurn);§this.target = target;§}§public SearingBloodDelayedTriggeredAbility(SearingBloodDelayedTriggeredAbility ability) {§super(ability);§this.target = ability.target;§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.ZONE_CHANGE;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (event.getTargetId().equals(target)) {§ZoneChangeEvent zEvent = (ZoneChangeEvent) event;§if (zEvent.getFromZone() == Zone.BATTLEFIELD && zEvent.getToZone() == Zone.GRAVEYARD) {§return true;§}§}§return false;§}§@Override§public SearingBloodDelayedTriggeredAbility copy() {§return new SearingBloodDelayedTriggeredAbility(this);§}§@Override§public String getRule() {§return "When that creature dies this turn, {this} deals 3 damage to that creature's controller.";§}§}§class SearingBloodDelayedEffect extends OneShotEffect {§protected UUID target;§public SearingBloodDelayedEffect(UUID target) {§super(Outcome.Damage);§this.target = target;§}§public SearingBloodDelayedEffect(final SearingBloodDelayedEffect effect) {§super(effect);§this.target = effect.target;§}§@Override§public SearingBloodDelayedEffect copy() {§return new SearingBloodDelayedEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = (Permanent) game.getLastKnownInformation(target, Zone.BATTLEFIELD);§if (permanent != null) {§Player player = game.getPlayer(permanent.getControllerId());§if (player != null) {§MageObject sourceObject = source.getSourceObject(game);§player.damage(3, source.getSourceId(), game, false, true);§return true;§}§}§return false;§}§}§
public class ServantOfTymaret extends CardImpl {§public ServantOfTymaret(UUID ownerId) {§super(ownerId, 82, "Servant of Tymaret", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{B}");§this.expansionSetCode = "BNG";§this.subtype.add("Zombie");§this.power = new MageInt(1);§this.toughness = new MageInt(3);§this.addAbility(new InspiredAbility(new ServantOfTymaretEffect()));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new RegenerateSourceEffect(), new ManaCostsImpl("{2}{B}")));§}§public ServantOfTymaret(final ServantOfTymaret card) {§super(card);§}§@Override§public ServantOfTymaret copy() {§return new ServantOfTymaret(this);§}§}§class ServantOfTymaretEffect extends OneShotEffect {§public ServantOfTymaretEffect() {§super(Outcome.Damage);§staticText = "each opponent loses 1 life. You gain life equal to the life lost this way";§}§public ServantOfTymaretEffect(final ServantOfTymaretEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§int lostAmount = 0;§for (UUID opponentId: game.getOpponents(source.getControllerId())) {§lostAmount += game.getPlayer(opponentId).loseLife(1, game);§}§game.getPlayer(source.getControllerId()).gainLife(lostAmount, game);§return true;§}§@Override§public ServantOfTymaretEffect copy() {§return new ServantOfTymaretEffect(this);§}§}§
public class SetessanOathsworn extends CardImpl {§public SetessanOathsworn(UUID ownerId) {§super(ownerId, 138, "Setessan Oathsworn", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{G}{G}");§this.expansionSetCode = "BNG";§this.subtype.add("Satyr");§this.subtype.add("Warrior");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new HeroicAbility(new AddCountersSourceEffect(CounterType.P1P1.createInstance(2), true)));§}§public SetessanOathsworn(final SetessanOathsworn card) {§super(card);§}§@Override§public SetessanOathsworn copy() {§return new SetessanOathsworn(this);§}§}§
public class SetessanStarbreaker extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("Aura");§static {§filter.add(new SubtypePredicate("Aura"));§}§public SetessanStarbreaker(UUID ownerId) {§super(ownerId, 139, "Setessan Starbreaker", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{G}");§this.expansionSetCode = "BNG";§this.subtype.add("Human");§this.subtype.add("Warrior");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§Ability ability = new EntersBattlefieldTriggeredAbility(new DestroyTargetEffect(), true);§ability.addTarget(new TargetPermanent(filter));§this.addAbility(ability);§}§public SetessanStarbreaker(final SetessanStarbreaker card) {§super(card);§}§@Override§public SetessanStarbreaker copy() {§return new SetessanStarbreaker(this);§}§}§
public class ShrikeHarpy extends CardImpl {§public ShrikeHarpy(UUID ownerId) {§super(ownerId, 83, "Shrike Harpy", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{B}{B}");§this.expansionSetCode = "BNG";§this.subtype.add("Harpy");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new TributeAbility(2));§TriggeredAbility ability = new EntersBattlefieldTriggeredAbility(new SacrificeEffect(new FilterCreaturePermanent("a creature"), 1, "target opponent"), false);§ability.addTarget(new TargetOpponent());§this.addAbility(new ConditionalTriggeredAbility(ability, TributeNotPaidCondition.getInstance(),§"When {this} enters the battlefield, if its tribute wasn't paid, target opponent sacrifices a creature."));§}§public ShrikeHarpy(final ShrikeHarpy card) {§super(card);§}§@Override§public ShrikeHarpy copy() {§return new ShrikeHarpy(this);§}§}§
public class SilentSentinel extends CardImpl {§private static final FilterCard filter = new FilterCard("enchantment card from your graveyard");§static {§filter.add(new CardTypePredicate(CardType.ENCHANTMENT));§filter.add(new OwnerPredicate(TargetController.YOU));§}§public SilentSentinel(UUID ownerId) {§super(ownerId, 26, "Silent Sentinel", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}{W}{W}");§this.expansionSetCode = "BNG";§this.subtype.add("Archon");§this.power = new MageInt(4);§this.toughness = new MageInt(6);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new AttacksTriggeredAbility(new ReturnFromGraveyardToBattlefieldTargetEffect(), true);§ability.addTarget(new TargetCardInGraveyard(filter));§this.addAbility(ability);§}§public SilentSentinel(final SilentSentinel card) {§super(card);§}§@Override§public SilentSentinel copy() {§return new SilentSentinel(this);§}§}§
public class SirenOfTheFangedCoast extends CardImpl {§public SirenOfTheFangedCoast(UUID ownerId) {§super(ownerId, 50, "Siren of the Fanged Coast", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{U}{U}");§this.expansionSetCode = "BNG";§this.subtype.add("Siren");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new TributeAbility(3));§TriggeredAbility ability = new EntersBattlefieldTriggeredAbility(new GainControlTargetEffect(Duration.EndOfGame, true), false);§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(new ConditionalTriggeredAbility(ability, TributeNotPaidCondition.getInstance(),§"When {this} enters the battlefield, if its tribute wasn't paid, gain control of target creature."));§}§public SirenOfTheFangedCoast(final SirenOfTheFangedCoast card) {§super(card);§}§@Override§public SirenOfTheFangedCoast copy() {§return new SirenOfTheFangedCoast(this);§}§}§
public class SirenOfTheSilentSong extends CardImpl {§public SirenOfTheSilentSong(UUID ownerId) {§super(ownerId, 155, "Siren of the Silent Song", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{U}{B}");§this.expansionSetCode = "BNG";§this.subtype.add("Zombie");§this.subtype.add("Siren");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new InspiredAbility(new DiscardEachPlayerEffect(TargetController.OPPONENT));§Effect effect = new PutTopCardOfLibraryIntoGraveEachPlayerEffect(1, TargetController.OPPONENT);§effect.setText(", then puts the top card of his or her library into his or her graveyard");§ability.addEffect(effect);§this.addAbility(ability);§}§public SirenOfTheSilentSong(final SirenOfTheSilentSong card) {§super(card);§}§@Override§public SirenOfTheSilentSong copy() {§return new SirenOfTheSilentSong(this);§}§}§
public class SirenSongLyre extends CardImpl {§public SirenSongLyre(UUID ownerId) {§super(ownerId, 161, "Siren Song Lyre", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{2}");§this.expansionSetCode = "BNG";§this.subtype.add("Equipment");§Ability grantedAbility = new SimpleActivatedAbility(Zone.BATTLEFIELD, new TapTargetEffect(), new GenericManaCost(2));§grantedAbility.addCost(new TapSourceCost());§grantedAbility.addTarget(new TargetCreaturePermanent());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(grantedAbility, AttachmentType.EQUIPMENT)));§this.addAbility(new EquipAbility(Outcome.AddAbility, new ManaCostsImpl("{2}")));§}§public SirenSongLyre(final SirenSongLyre card) {§super(card);§}§@Override§public SirenSongLyre copy() {§return new SirenSongLyre(this);§}§}§
public class Skyreaping extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature with flying");§static {§filter.add(new AbilityPredicate(FlyingAbility.class));§}§public Skyreaping(UUID ownerId) {§super(ownerId, 140, "Skyreaping", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{1}{G}");§this.expansionSetCode = "BNG";§Effect effect = new DamageAllEffect(new DevotionCount(ColoredManaSymbol.G), filter);§effect.setText("{this} deals damage to each creature with flying equal to your devotion to green <i>(Each {G} in the mana costs of permanents you control counts toward your devotion to green.)</i>");§this.getSpellAbility().addEffect(effect);§}§public Skyreaping(final Skyreaping card) {§super(card);§}§@Override§public Skyreaping copy() {§return new Skyreaping(this);§}§}§
public class SnakeOfTheGoldenGrove extends CardImpl {§public SnakeOfTheGoldenGrove(UUID ownerId) {§super(ownerId, 141, "Snake of the Golden Grove", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{G}");§this.expansionSetCode = "BNG";§this.subtype.add("Snake");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(new TributeAbility(3));§TriggeredAbility ability = new EntersBattlefieldTriggeredAbility(new GainLifeEffect(4), false);§this.addAbility(new ConditionalTriggeredAbility(ability, TributeNotPaidCondition.getInstance(),§"When {this} enters the battlefield, if its tribute wasn't paid, you gain 4 life."));§}§public SnakeOfTheGoldenGrove(final SnakeOfTheGoldenGrove card) {§super(card);§}§@Override§public SnakeOfTheGoldenGrove copy() {§return new SnakeOfTheGoldenGrove(this);§}§}§
public class SphinxsDisciple extends CardImpl {§public SphinxsDisciple(UUID ownerId) {§super(ownerId, 51, "Sphinx's Disciple", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{U}{U}");§this.expansionSetCode = "BNG";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new InspiredAbility(new DrawCardSourceControllerEffect(1)));§}§public SphinxsDisciple(final SphinxsDisciple card) {§super(card);§}§@Override§public SphinxsDisciple copy() {§return new SphinxsDisciple(this);§}§}§
public class StormcallerOfKeranos extends CardImpl {§public StormcallerOfKeranos(UUID ownerId) {§super(ownerId, 112, "Stormcaller of Keranos", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "BNG";§this.subtype.add("Human");§this.subtype.add("Shaman");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(HasteAbility.getInstance());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new ScryEffect(1), new ManaCostsImpl("{1}{U}")));§}§public StormcallerOfKeranos(final StormcallerOfKeranos card) {§super(card);§}§@Override§public StormcallerOfKeranos copy() {§return new StormcallerOfKeranos(this);§}§}§
public class StratusWalk extends CardImpl {§public StratusWalk(UUID ownerId) {§super(ownerId, 52, "Stratus Walk", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{U}");§this.expansionSetCode = "BNG";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new EntersBattlefieldTriggeredAbility(new DrawCardSourceControllerEffect(1)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(FlyingAbility.getInstance(), AttachmentType.AURA, Duration.WhileOnBattlefield)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new CanBlockOnlyFlyingAttachedEffect(AttachmentType.AURA)));§}§public StratusWalk(final StratusWalk card) {§super(card);§}§@Override§public StratusWalk copy() {§return new StratusWalk(this);§}§}§
public class SuddenStorm extends CardImpl {§public SuddenStorm(UUID ownerId) {§super(ownerId, 53, "Sudden Storm", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{3}{U}");§this.expansionSetCode = "BNG";§this.getSpellAbility().addEffect(new TapTargetEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent(0, 2));§this.getSpellAbility().addEffect(new DontUntapInControllersNextUntapStepTargetEffect());§this.getSpellAbility().addEffect(new ScryEffect(1));§}§public SuddenStorm(final SuddenStorm card) {§super(card);§}§@Override§public SuddenStorm copy() {§return new SuddenStorm(this);§}§}§
public class Sunbond extends CardImpl {§public Sunbond(UUID ownerId) {§super(ownerId, 28, "Sunbond", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{3}{W}");§this.expansionSetCode = "BNG";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§Effect effect = new GainAbilityAttachedEffect(new GainLifeControllerTriggeredAbility(new SunbondEffect(), false, true), AttachmentType.AURA, Duration.WhileOnBattlefield);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, effect));§}§public Sunbond(final Sunbond card) {§super(card);§}§@Override§public Sunbond copy() {§return new Sunbond(this);§}§}§class SunbondEffect extends OneShotEffect {§public SunbondEffect() {§super(Outcome.Benefit);§this.staticText = "put that many +1/+1 counters on this creature";§}§public SunbondEffect(final SunbondEffect effect) {§super(effect);§}§@Override§public SunbondEffect copy() {§return new SunbondEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§int lifeGained = (Integer) this.getValue("gainedLife");§if (lifeGained > 0) {§return new AddCountersSourceEffect(CounterType.P1P1.createInstance(lifeGained)).apply(game, source);§}§return false;§}§}§
public class SwordwiseCentaur extends CardImpl {§public SwordwiseCentaur(UUID ownerId) {§super(ownerId, 142, "Swordwise Centaur", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{G}{G}");§this.expansionSetCode = "BNG";§this.subtype.add("Centaur");§this.subtype.add("Warrior");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§}§public SwordwiseCentaur(final SwordwiseCentaur card) {§super(card);§}§@Override§public SwordwiseCentaur copy() {§return new SwordwiseCentaur(this);§}§}§
public class TempleOfEnlightenment extends CardImpl {§public TempleOfEnlightenment(UUID ownerId) {§super(ownerId, 163, "Temple of Enlightenment", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "BNG";§this.addAbility(new EntersBattlefieldTappedAbility());§this.addAbility(new EntersBattlefieldTriggeredAbility(new ScryEffect(1)));§this.addAbility(new WhiteManaAbility());§this.addAbility(new BlueManaAbility());§}§public TempleOfEnlightenment(final TempleOfEnlightenment card) {§super(card);§}§@Override§public TempleOfEnlightenment copy() {§return new TempleOfEnlightenment(this);§}§}§
public class TempleOfMalice extends CardImpl {§public TempleOfMalice(UUID ownerId) {§super(ownerId, 164, "Temple of Malice", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "BNG";§this.addAbility(new EntersBattlefieldTappedAbility());§this.addAbility(new EntersBattlefieldTriggeredAbility(new ScryEffect(1)));§this.addAbility(new BlackManaAbility());§this.addAbility(new RedManaAbility());§}§public TempleOfMalice(final TempleOfMalice card) {§super(card);§}§@Override§public TempleOfMalice copy() {§return new TempleOfMalice(this);§}§}§
public class TempleOfPlenty extends CardImpl {§public TempleOfPlenty(UUID ownerId) {§super(ownerId, 165, "Temple of Plenty", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "BNG";§this.addAbility(new EntersBattlefieldTappedAbility());§this.addAbility(new EntersBattlefieldTriggeredAbility(new ScryEffect(1)));§this.addAbility(new GreenManaAbility());§this.addAbility(new WhiteManaAbility());§}§public TempleOfPlenty(final TempleOfPlenty card) {§super(card);§}§@Override§public TempleOfPlenty copy() {§return new TempleOfPlenty(this);§}§}§
public class ThassasRebuff extends CardImpl {§public ThassasRebuff(UUID ownerId) {§super(ownerId, 54, "Thassa's Rebuff", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{1}{U}");§this.expansionSetCode = "BNG";§this.getSpellAbility().addEffect(new CounterUnlessPaysEffect(new DevotionCount(ColoredManaSymbol.U)));§this.getSpellAbility().addTarget(new TargetSpell());§}§public ThassasRebuff(final ThassasRebuff card) {§super(card);§}§@Override§public ThassasRebuff copy() {§return new ThassasRebuff(this);§}§}§
public class ThunderBrute extends CardImpl {§public ThunderBrute(UUID ownerId) {§super(ownerId, 113, "Thunder Brute", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{R}{R}");§this.expansionSetCode = "BNG";§this.subtype.add("Cyclops");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(TrampleAbility.getInstance());§this.addAbility(new TributeAbility(3));§TriggeredAbility ability = new EntersBattlefieldTriggeredAbility(new GainAbilitySourceEffect(HasteAbility.getInstance(), Duration.EndOfTurn), false);§this.addAbility(new ConditionalTriggeredAbility(ability, TributeNotPaidCondition.getInstance(),§"When {this} enters the battlefield, if its tribute wasn't paid, it gains haste until end of turn."));§}§public ThunderBrute(final ThunderBrute card) {§super(card);§}§@Override§public ThunderBrute copy() {§return new ThunderBrute(this);§}§}§
public class ThunderousMight extends CardImpl {§public ThunderousMight(UUID ownerId) {§super(ownerId, 114, "Thunderous Might", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{R}");§this.expansionSetCode = "BNG";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§Effect effect = new BoostEnchantedEffect(new DevotionCount(ColoredManaSymbol.R), new StaticValue(0), Duration.EndOfTurn);§effect.setText("it gets +X/+0 until end of turn, where X is your devotion to red");§this.addAbility(new AttacksAttachedTriggeredAbility(effect, AttachmentType.AURA, false));§}§public ThunderousMight(final ThunderousMight card) {§super(card);§}§@Override§public ThunderousMight copy() {§return new ThunderousMight(this);§}§}§
public class ThunderousMight extends CardImpl {§public ThunderousMight(UUID ownerId) {§super(ownerId, 114, "Thunderous Might", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{R}");§this.expansionSetCode = "BNG";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§Effect effect = new BoostEnchantedEffect(new DevotionCount(ColoredManaSymbol.R), new StaticValue(0), Duration.EndOfTurn);§effect.setText("it gets +X/+0 until end of turn, where X is your devotion to red");§this.addAbility(new AttacksAttachedTriggeredAbility(effect, AttachmentType.AURA, false));§}§public ThunderousMight(final ThunderousMight card) {§super(card);§}§@Override§public ThunderousMight copy() {§return new ThunderousMight(this);§}§}§
public class Tromokratis extends CardImpl {§public Tromokratis(UUID ownerId) {§super(ownerId, 55, "Tromokratis", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}{U}{U}");§this.expansionSetCode = "BNG";§this.supertype.add("Legendary");§this.subtype.add("Kraken");§this.power = new MageInt(8);§this.toughness = new MageInt(8);§Effect effect = new ConditionalContinuousEffect(§new GainAbilitySourceEffect(HexproofAbility.getInstance(), Duration.WhileOnBattlefield),§new InvertCondition(new SourceMatchesFilterCondition(new FilterAttackingOrBlockingCreature())),§"{this} has hexproof unless it's attacking or blocking");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, effect));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new CantBeBlockedUnlessAllEffect()));§}§public Tromokratis(final Tromokratis card) {§super(card);§}§@Override§public Tromokratis copy() {§return new Tromokratis(this);§}§}§class CantBeBlockedUnlessAllEffect extends RestrictionEffect {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent();§public CantBeBlockedUnlessAllEffect() {§super(Duration.WhileOnBattlefield);§staticText = "{this} can't be blocked unless all creatures defending player controls block it";§}§public CantBeBlockedUnlessAllEffect(final CantBeBlockedUnlessAllEffect effect) {§super(effect);§}§@Override§public boolean applies(Permanent permanent, Ability source, Game game) {§return permanent.getId().equals(source.getSourceId());§}§@Override§public boolean canBeBlocked(Permanent attacker, Permanent blocker, Ability source, Game game) {§for (Permanent permanent: game.getBattlefield().getAllActivePermanents(filter, blocker.getControllerId(), game)) {§if (permanent.isTapped() && !game.getState().getContinuousEffects().asThough(this.getId(), AsThoughEffectType.BLOCK_TAPPED, source, blocker.getControllerId(), game)) {§return false;§}§for (Map.Entry<RestrictionEffect, HashSet<Ability>> entry: game.getContinuousEffects().getApplicableRestrictionEffects(permanent, game).entrySet()) {§for (Ability ability : entry.getValue()) {§if (!entry.getKey().canBlock(attacker, permanent, ability, game)) {§return false;§}§}§}§for (Map.Entry<RestrictionEffect, HashSet<Ability>> restrictionEntry: game.getContinuousEffects().getApplicableRestrictionEffects(attacker, game).entrySet()) {§for (Ability ability : restrictionEntry.getValue()) {§if (!(restrictionEntry.getKey() instanceof CantBeBlockedUnlessAllEffect)§&& !restrictionEntry.getKey().canBeBlocked(attacker, permanent, ability, game)) {§return false;§}§}§}§if (attacker.hasProtectionFrom(permanent, game)) {§return false;§}§}§return true;§}§@Override§public boolean canBeBlockedCheckAfter(Permanent attacker, Ability source, Game game) {§for (CombatGroup combatGroup: game.getCombat().getGroups()) {§if (combatGroup.getAttackers().contains(source.getSourceId())) {§for(UUID blockerId :combatGroup.getBlockers()) {§Permanent blockingCreature = game.getPermanent(blockerId);§if (blockingCreature != null) {§for (Permanent permanent: game.getBattlefield().getAllActivePermanents(new FilterCreaturePermanent(), blockingCreature.getControllerId(), game)) {§if (!combatGroup.getBlockers().contains(permanent.getId())) {§return false;§}§}§}§}§}§}§return true;§}§@Override§public CantBeBlockedUnlessAllEffect copy() {§return new CantBeBlockedUnlessAllEffect(this);§}§}§
public class UnravelTheAEther extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent();§static {§filter.add(Predicates.or(new CardTypePredicate(CardType.ARTIFACT),§new CardTypePredicate(CardType.ENCHANTMENT)));§}§public UnravelTheAEther(UUID ownerId) {§super(ownerId, 143, "Unravel the AEther", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{1}{G}");§this.expansionSetCode = "BNG";§this.getSpellAbility().addEffect(new UnravelTheAEtherShuffleIntoLibraryEffect());§Target target = new TargetPermanent(1, 1, filter, false);§this.getSpellAbility().addTarget(target);§}§public UnravelTheAEther(final UnravelTheAEther card) {§super(card);§}§@Override§public UnravelTheAEther copy() {§return new UnravelTheAEther(this);§}§}§class UnravelTheAEtherShuffleIntoLibraryEffect extends OneShotEffect {§public UnravelTheAEtherShuffleIntoLibraryEffect() {§super(Outcome.Detriment);§this.staticText = "Choose target artifact or enchantment. Its owner shuffles it into his or her library";§}§public UnravelTheAEtherShuffleIntoLibraryEffect(final UnravelTheAEtherShuffleIntoLibraryEffect effect) {§super(effect);§}§@Override§public UnravelTheAEtherShuffleIntoLibraryEffect copy() {§return new UnravelTheAEtherShuffleIntoLibraryEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getPermanent(targetPointer.getFirst(game, source));§if (permanent != null) {§if (permanent.moveToZone(Zone.LIBRARY, source.getSourceId(), game, true)) {§game.getPlayer(permanent.getOwnerId()).shuffleLibrary(game);§return true;§}§}§return false;§}§}§
public class VanguardOfBrimaz extends CardImpl {§public VanguardOfBrimaz(UUID ownerId) {§super(ownerId, 29, "Vanguard of Brimaz", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{W}{W}");§this.expansionSetCode = "BNG";§this.subtype.add("Cat");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(VigilanceAbility.getInstance());§this.addAbility(new HeroicAbility(new CreateTokenEffect(new CatSoldierCreatureToken()), false));§}§public VanguardOfBrimaz(final VanguardOfBrimaz card) {§super(card);§}§@Override§public VanguardOfBrimaz copy() {§return new VanguardOfBrimaz(this);§}§}§
public class VortexElemental extends CardImpl {§public VortexElemental(UUID ownerId) {§super(ownerId, 56, "Vortex Elemental", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{U}");§this.expansionSetCode = "BNG";§this.subtype.add("Elemental");§this.power = new MageInt(0);§this.toughness = new MageInt(1);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new VortexElementalEffect(), new ManaCostsImpl("{U}")));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new MustBeBlockedByTargetSourceEffect(), new ManaCostsImpl("{3}{U}{U}"));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public VortexElemental(final VortexElemental card) {§super(card);§}§@Override§public VortexElemental copy() {§return new VortexElemental(this);§}§}§class VortexElementalEffect extends OneShotEffect {§public VortexElementalEffect() {§super(Outcome.Benefit);§this.staticText = "Put {this} and each creature blocking or blocked by it on top of their owners' libraries, then those players shuffle their libraries";§}§public VortexElementalEffect(final VortexElementalEffect effect) {§super(effect);§}§@Override§public VortexElementalEffect copy() {§return new VortexElementalEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Combat combat = game.getState().getCombat();§Set<UUID> creaturesToReturn = new HashSet<>();§Set<UUID> playersToShuffle = new HashSet<>();§creaturesToReturn.add(source.getSourceId());§if (combat != null) {§for(CombatGroup combatGroup: combat.getGroups()) {§if (combatGroup.getAttackers().contains(source.getSourceId())) {§creaturesToReturn.addAll(combatGroup.getBlockers());§} else if (combatGroup.getBlockers().contains(source.getSourceId())) {§creaturesToReturn.addAll(combatGroup.getAttackers());§}§}§}§for (UUID creatureId: creaturesToReturn) {§Permanent creature = game.getPermanent(creatureId);§if (creature != null) {§playersToShuffle.add(creature.getControllerId());§creature.moveToZone(Zone.LIBRARY, source.getSourceId(), game, true);§}§}§for (UUID playerId: playersToShuffle){§Player player = game.getPlayer(playerId);§if (player != null) {§player.shuffleLibrary(game);§}§}§return true;§}§return false;§}§}§
public class WarchanterOfMogis extends CardImpl {§public WarchanterOfMogis(UUID ownerId) {§super(ownerId, 85, "Warchanter of Mogis", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{B}{B}");§this.expansionSetCode = "BNG";§this.subtype.add("Minotaur");§this.subtype.add("Shaman");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§Ability ability = new InspiredAbility(new GainAbilityTargetEffect(IntimidateAbility.getInstance(), Duration.EndOfTurn), false);§ability.addTarget(new TargetControlledCreaturePermanent());§this.addAbility(ability);§}§public WarchanterOfMogis(final WarchanterOfMogis card) {§super(card);§}§@Override§public WarchanterOfMogis copy() {§return new WarchanterOfMogis(this);§}§}§
public class WeightOfTheUnderworld extends CardImpl {§public WeightOfTheUnderworld(UUID ownerId) {§super(ownerId, 86, "Weight of the Underworld", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{3}{B}");§this.expansionSetCode = "BNG";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.UnboostCreature));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(-3,-2, Duration.WhileOnBattlefield)));§}§public WeightOfTheUnderworld(final WeightOfTheUnderworld card) {§super(card);§}§@Override§public WeightOfTheUnderworld copy() {§return new WeightOfTheUnderworld(this);§}§}§
public class XenagosGodOfRevels extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("another target creature you control");§static {§filter.add(new AnotherPredicate());§}§public XenagosGodOfRevels(UUID ownerId) {§super(ownerId, 156, "Xenagos, God of Revels", Rarity.MYTHIC, new CardType[]{CardType.ENCHANTMENT, CardType.CREATURE}, "{3}{R}{G}");§this.expansionSetCode = "BNG";§this.supertype.add("Legendary");§this.subtype.add("God");§this.power = new MageInt(6);§this.toughness = new MageInt(5);§this.addAbility(IndestructibleAbility.getInstance());§Effect effect = new LoseCreatureTypeSourceEffect(new DevotionCount(ColoredManaSymbol.R, ColoredManaSymbol.G), 7);§effect.setText("As long as your devotion to red and green is less than seven, Xenagos isn't a creature");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, effect));§effect = new GainAbilityTargetEffect(HasteAbility.getInstance(), Duration.EndOfTurn);§effect.setText("another target creature you control gains haste");§Ability ability = new BeginningOfCombatTriggeredAbility(Zone.BATTLEFIELD, effect, TargetController.YOU, false, false);§ability.addEffect(new XenagosGodOfRevelsEffect());§ability.addTarget(new TargetControlledCreaturePermanent(1,1,filter, false));§this.addAbility(ability);§}§public XenagosGodOfRevels(final XenagosGodOfRevels card) {§super(card);§}§@Override§public XenagosGodOfRevels copy() {§return new XenagosGodOfRevels(this);§}§}§class XenagosGodOfRevelsEffect extends OneShotEffect {§public XenagosGodOfRevelsEffect() {§super(Outcome.BoostCreature);§this.staticText = "and gets +X/+X until end of turn, where X is that creature's power";§}§public XenagosGodOfRevelsEffect(final XenagosGodOfRevelsEffect effect) {§super(effect);§}§@Override§public XenagosGodOfRevelsEffect copy() {§return new XenagosGodOfRevelsEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent targetCreature = game.getPermanent(getTargetPointer().getFirst(game, source));§if (targetCreature != null) {§ContinuousEffect effect = new BoostTargetEffect(targetCreature.getPower().getValue(), targetCreature.getPower().getValue(), Duration.EndOfTurn);§effect.setTargetPointer(this.getTargetPointer());§game.addEffect(effect, source);§}§return false;§}§}§
public class AkkiAvalanchers extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledLandPermanent("a land");§public AkkiAvalanchers(UUID ownerId) {§super(ownerId, 151, "Akki Avalanchers", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{R}");§this.expansionSetCode = "CHK";§this.subtype.add("Goblin");§this.subtype.add("Warrior");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new LimitedTimesPerTurnActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(2, 0, Duration.EndOfTurn), new SacrificeTargetCost(new TargetControlledPermanent(filter))));§}§public AkkiAvalanchers(final AkkiAvalanchers card) {§super(card);§}§@Override§public AkkiAvalanchers copy() {§return new AkkiAvalanchers(this);§}§}§
public class AkkiCoalflinger extends CardImpl {§public AkkiCoalflinger (UUID ownerId) {§super(ownerId, 152, "Akki Coalflinger", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{R}{R}");§this.expansionSetCode = "CHK";§this.subtype.add("Goblin");§this.subtype.add("Shaman");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FirstStrikeAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilityAllEffect(FirstStrikeAbility.getInstance(), Duration.EndOfTurn, new FilterAttackingCreature()), new ColoredManaCost(ColoredManaSymbol.R));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§}§public AkkiCoalflinger (final AkkiCoalflinger card) {§super(card);§}§@Override§public AkkiCoalflinger copy() {§return new AkkiCoalflinger(this);§}§}§
public class AkkiLavarunner extends CardImpl {§public AkkiLavarunner(UUID ownerId) {§super(ownerId, 153, "Akki Lavarunner", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{R}");§this.expansionSetCode = "CHK";§this.subtype.add("Goblin");§this.subtype.add("Warrior");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.flipCard = true;§this.flipCardName = "Tok-Tok, Volcano Born";§this.addAbility(HasteAbility.getInstance());§this.addAbility(new AkkiLavarunnerAbility());§}§public AkkiLavarunner(final AkkiLavarunner card) {§super(card);§}§@Override§public AkkiLavarunner copy() {§return new AkkiLavarunner(this);§}§}§class AkkiLavarunnerAbility extends TriggeredAbilityImpl {§public AkkiLavarunnerAbility() {§super(Zone.BATTLEFIELD, new FlipSourceEffect(new TokTokVolcanoBorn()));§}§public AkkiLavarunnerAbility(final AkkiLavarunnerAbility ability) {§super(ability);§}§@Override§public AkkiLavarunnerAbility copy() {§return new AkkiLavarunnerAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.DAMAGED_PLAYER;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§DamagedPlayerEvent damageEvent = (DamagedPlayerEvent) event;§return damageEvent.isCombatDamage() && this.sourceId.equals(event.getSourceId());§}§@Override§public String getRule() {§return "Whenever {this} deals damage to an opponent, flip it.";§}§}§class TokTokVolcanoBorn extends Token {§private static final FilterCard filter = new FilterCard("red");§static {§filter.add(new ColorPredicate(ObjectColor.RED));§}§TokTokVolcanoBorn() {§super("Tok-Tok, Volcano Born", "");§supertype.add("Legendary");§cardType.add(CardType.CREATURE);§color.setRed(true);§subtype.add("Goblin");§subtype.add("Shaman");§power = new MageInt(2);§toughness = new MageInt(2);§this.addAbility(new ProtectionAbility(filter));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new TokTokVolcanoBornEffect()));§}§}§class TokTokVolcanoBornEffect extends ReplacementEffectImpl {§TokTokVolcanoBornEffect() {§super(Duration.WhileOnBattlefield, Outcome.Benefit);§staticText = "If a red source would deal damage to a player, it deals that much damage plus 1 to that player instead";§}§TokTokVolcanoBornEffect(final TokTokVolcanoBornEffect effect) {§super(effect);§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.DAMAGE_PLAYER;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§MageObject sourceObject;§Permanent sourcePermanent = game.getPermanentOrLKIBattlefield(event.getSourceId());§if(sourcePermanent == null) {§sourceObject = game.getObject(event.getSourceId());§}§else {§sourceObject = sourcePermanent;§}§if (sourceObject != null && sourceObject.getColor(game).isRed()) {§return true;§}§return false;§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§event.setAmount(event.getAmount() + 1);§return false;§}§@Override§public TokTokVolcanoBornEffect copy() {§return new TokTokVolcanoBornEffect(this);§}§}§
public class AkkiRockspeaker extends CardImpl {§public AkkiRockspeaker(UUID ownerId) {§super(ownerId, 154, "Akki Rockspeaker", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{R}");§this.expansionSetCode = "CHK";§this.subtype.add("Goblin");§this.subtype.add("Shaman");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new EntersBattlefieldTriggeredAbility(new BasicManaEffect(new Mana(ColoredManaSymbol.R))));§}§public AkkiRockspeaker(final AkkiRockspeaker card) {§super(card);§}§@Override§public AkkiRockspeaker copy() {§return new AkkiRockspeaker(this);§}§}§
public class AkkiUnderminer extends CardImpl {§public AkkiUnderminer (UUID ownerId) {§super(ownerId, 155, "Akki Underminer", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{R}");§this.expansionSetCode = "CHK";§this.subtype.add("Goblin");§this.subtype.add("Rogue");§this.subtype.add("Shaman");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new AkkiUnderminerAbility());§}§public AkkiUnderminer (final AkkiUnderminer card) {§super(card);§}§@Override§public AkkiUnderminer copy() {§return new AkkiUnderminer(this);§}§}§class AkkiUnderminerAbility extends TriggeredAbilityImpl {§public AkkiUnderminerAbility() {§super(Zone.BATTLEFIELD, new SacrificeEffect(new FilterPermanent(), 1, ""));§}§public AkkiUnderminerAbility(final AkkiUnderminerAbility ability) {§super(ability);§}§@Override§public AkkiUnderminerAbility copy() {§return new AkkiUnderminerAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.DAMAGED_PLAYER;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§DamagedPlayerEvent damageEvent = (DamagedPlayerEvent)event;§if (damageEvent.isCombatDamage() && event.getSourceId().equals(this.getSourceId())) {§for (Effect effect : this.getEffects()) {§effect.setTargetPointer(new FixedTarget(event.getPlayerId()));§}§return true;§}§return false;§}§@Override§public String getRule() {§return "Whenever {this} deals combat damage to a player, that player sacrifices a permanent.";§}§}§
public class AshenSkinZubera extends CardImpl {§public AshenSkinZubera(UUID ownerId) {§super(ownerId, 101, "Ashen-Skin Zubera", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{B}");§this.expansionSetCode = "CHK";§this.subtype.add("Zubera");§this.subtype.add("Spirit");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§Ability ability = new DiesTriggeredAbility(new DiscardTargetEffect(new ZuberasDiedDynamicValue()));§ability.addTarget(new TargetOpponent());§this.addAbility(ability, new ZuberasDiedWatcher());§}§public AshenSkinZubera(final AshenSkinZubera card) {§super(card);§}§@Override§public AshenSkinZubera copy() {§return new AshenSkinZubera(this);§}§}§
public class AuraOfDominion extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("untapped creature you control");§static {§filter.add(Predicates.not(new TappedPredicate()));§}§public AuraOfDominion(UUID ownerId) {§super(ownerId, 51, "Aura of Dominion", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{U}{U}");§this.expansionSetCode = "CHK";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.Untap));§this.addAbility(new EnchantAbility(auraTarget.getTargetName()));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new UntapEnchantedEffect(), new GenericManaCost(1));§ability.addCost(new TapTargetCost(new TargetControlledCreaturePermanent(1, 1, filter, false)));§this.addAbility(ability);§}§public AuraOfDominion(final AuraOfDominion card) {§super(card);§}§@Override§public AuraOfDominion copy() {§return new AuraOfDominion(this);§}§}§
public class AzamiLadyOfScrolls extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("untapped Wizard you control");§static {§filter.add(Predicates.not(new TappedPredicate()));§filter.add(new SubtypePredicate("Wizard"));§}§public AzamiLadyOfScrolls(UUID ownerId) {§super(ownerId, 52, "Azami, Lady of Scrolls", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{U}{U}{U}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(0);§this.toughness = new MageInt(2);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new DrawCardSourceControllerEffect(1), new TapTargetCost(new TargetControlledPermanent(1, 1, filter, false))));§}§public AzamiLadyOfScrolls(final AzamiLadyOfScrolls card) {§super(card);§}§@Override§public AzamiLadyOfScrolls copy() {§return new AzamiLadyOfScrolls(this);§}§}§
public class AzusaLostButSeeking extends CardImpl {§public AzusaLostButSeeking (UUID ownerId) {§super(ownerId, 201, "Azusa, Lost but Seeking", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{G}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Monk");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new PlayAdditionalLandsControllerEffect(2, Duration.WhileOnBattlefield)));§}§public AzusaLostButSeeking (final AzusaLostButSeeking card) {§super(card);§}§@Override§public AzusaLostButSeeking copy() {§return new AzusaLostButSeeking(this);§}§}§
public class BattleMadRonin extends CardImpl {§public BattleMadRonin(UUID ownerId) {§super(ownerId, 156, "Battle-Mad Ronin", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{R}");§this.expansionSetCode = "CHK";§this.subtype.add("Human");§this.subtype.add("Samurai");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new BushidoAbility(2));§this.addAbility(new AttacksEachTurnStaticAbility());§}§public BattleMadRonin(final BattleMadRonin card) {§super(card);§}§@Override§public BattleMadRonin copy() {§return new BattleMadRonin(this);§}§}§
public class Befoul extends CardImpl {§public static final FilterPermanent filter = new FilterPermanent("land or nonblack creature");§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.LAND),§Predicates.and(§Predicates.not(new ColorPredicate(ObjectColor.BLACK)),§new CardTypePredicate(CardType.CREATURE))));§}§public Befoul (UUID ownerId) {§super(ownerId, 102, "Befoul", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{2}{B}{B}");§this.expansionSetCode = "CHK";§this.getSpellAbility().addEffect(new DestroyTargetEffect(true));§this.getSpellAbility().addTarget(new TargetPermanent(filter));§}§public Befoul (final Befoul card) {§super(card);§}§@Override§public Befoul copy() {§return new Befoul(this);§}§}§
public class BenBenAkkiHermit extends CardImpl {§private static final FilterLandPermanent filter = new FilterLandPermanent("untapped Mountain you control");§static {§filter.add(Predicates.not(new TappedPredicate()));§filter.add(new SubtypePredicate("Mountain"));§}§public BenBenAkkiHermit (UUID ownerId) {§super(ownerId, 157, "Ben-Ben, Akki Hermit", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{R}{R}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Goblin");§this.subtype.add("Shaman");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(new PermanentsOnBattlefieldCount(filter), true), new TapSourceCost());§ability.addTarget(new TargetAttackingCreature());§this.addAbility(ability);§}§public BenBenAkkiHermit (final BenBenAkkiHermit card) {§super(card);§}§@Override§public BenBenAkkiHermit copy() {§return new BenBenAkkiHermit(this);§}§}§
public class BlessedBreath extends CardImpl {§public BlessedBreath(UUID ownerId) {§super(ownerId, 1, "Blessed Breath", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{W}");§this.expansionSetCode = "CHK";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new GainProtectionFromColorTargetEffect(Duration.EndOfTurn));§this.getSpellAbility().addTarget(new TargetControlledCreaturePermanent());§this.addAbility(new SpliceOntoArcaneAbility("{W}"));§}§public BlessedBreath(final BlessedBreath card) {§super(card);§}§@Override§public BlessedBreath copy() {§return new BlessedBreath(this);§}§}§
public class BlindWithAnger extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("nonlegendary creature");§static {§filter.add(Predicates.not(new SupertypePredicate("Legendary")));§}§public BlindWithAnger(UUID ownerId) {§super(ownerId, 158, "Blind with Anger", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{3}{R}");§this.expansionSetCode = "CHK";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new UntapTargetEffect());§this.getSpellAbility().addEffect(new GainControlTargetEffect(Duration.EndOfTurn));§this.getSpellAbility().addEffect(new GainAbilityTargetEffect(HasteAbility.getInstance(), Duration.EndOfTurn));§Target target = new TargetCreaturePermanent(filter);§this.getSpellAbility().addTarget(target);§}§public BlindWithAnger(final BlindWithAnger card) {§super(card);§}§@Override§public BlindWithAnger copy() {§return new BlindWithAnger(this);§}§}§
public class BloodRites extends CardImpl {§public BloodRites(UUID ownerId) {§super(ownerId, 159, "Blood Rites", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{3}{R}{R}");§this.expansionSetCode = "CHK";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(2), new ManaCostsImpl("{1}{R}"));§ability.addCost(new SacrificeTargetCost(new TargetControlledCreaturePermanent()));§ability.addTarget(new TargetCreatureOrPlayer());§this.addAbility(ability);§}§public BloodRites(final BloodRites card) {§super(card);§}§@Override§public BloodRites copy() {§return new BloodRites(this);§}§}§
public class BloodSpeaker extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("a Demon under your control");§private static final FilterCard filterCard = new FilterCard("Demon card");§static {§filter.add(new SubtypePredicate("Demon"));§filterCard.add(new SubtypePredicate("Demon"));§}§public BloodSpeaker (UUID ownerId) {§super(ownerId, 103, "Blood Speaker", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{B}");§this.expansionSetCode = "CHK";§this.subtype.add("Ogre");§this.subtype.add("Shaman");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§Ability ability = new BeginningOfUpkeepTriggeredAbility(Zone.BATTLEFIELD, new SacrificeSourceEffect(), TargetController.YOU, true);§ability.addEffect(new SearchLibraryPutInHandEffect(new TargetCardInLibrary(filterCard), true, true, "If you do, search your library for "));§this.addAbility(ability);§this.addAbility(new EntersBattlefieldAllTriggeredAbility(Zone.GRAVEYARD, new ReturnSourceFromGraveyardToHandEffect(), filter, false));§}§public BloodSpeaker (final BloodSpeaker card) {§super(card);§}§@Override§public BloodSpeaker copy() {§return new BloodSpeaker(this);§}§}§
public class BloodthirstyOgre extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("you control a Demon");§static {§filter.add(new SubtypePredicate("Demon"));§}§public BloodthirstyOgre(UUID ownerId) {§super(ownerId, 104, "Bloodthirsty Ogre", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{B}");§this.expansionSetCode = "CHK";§this.subtype.add("Ogre");§this.subtype.add("Warrior");§this.subtype.add("Shaman");§this.power = new MageInt(3);§this.toughness = new MageInt(1);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new AddCountersSourceEffect(CounterType.DEVOTION.createInstance()),new TapSourceCost()));§DynamicValue devotionCounters = new SignInversionDynamicValue(new CountersCount(CounterType.DEVOTION));§Ability ability = new ActivateIfConditionActivatedAbility(Zone.BATTLEFIELD,§new BoostTargetEffect(devotionCounters,devotionCounters, Duration.EndOfTurn, true),§new TapSourceCost(),§new PermanentsOnTheBattlefieldCondition(filter));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public BloodthirstyOgre(final BloodthirstyOgre card) {§super(card);§}§@Override§public BloodthirstyOgre copy() {§return new BloodthirstyOgre(this);§}§}§
public class BudokaGardener extends CardImpl {§public BudokaGardener(UUID ownerId) {§super(ownerId, 202, "Budoka Gardener", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "CHK";§this.subtype.add("Human");§this.subtype.add("Monk");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.flipCard = true;§this.flipCardName = "Dokai, Weaver of Life";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new PutLandFromHandOntoBattlefieldEffect(), new TapSourceCost());§ability.addEffect(new BudokaGardenerEffect());§this.addAbility(ability);§}§public BudokaGardener(final BudokaGardener card) {§super(card);§}§@Override§public BudokaGardener copy() {§return new BudokaGardener(this);§}§}§class BudokaGardenerEffect extends OneShotEffect {§BudokaGardenerEffect() {§super(Outcome.PutLandInPlay);§staticText = "If you control ten or more lands, flip {this}";§}§BudokaGardenerEffect(final BudokaGardenerEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§if (game.getBattlefield().count(DokaiWeaverofLifeToken.filterLands, source.getSourceId(), source.getControllerId(), game) >= 10) {§new FlipSourceEffect(new DokaiWeaverofLife()).apply(game, source);§}§return true;§}§return false;§}§@Override§public BudokaGardenerEffect copy() {§return new BudokaGardenerEffect(this);§}§}§class DokaiWeaverofLife extends Token {§DokaiWeaverofLife() {§super("Dokai, Weaver of Life", "");§supertype.add("Legendary");§cardType.add(CardType.CREATURE);§color.setGreen(true);§subtype.add("Human");§subtype.add("Monk");§power = new MageInt(3);§toughness = new MageInt(3);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new CreateTokenEffect(new DokaiWeaverofLifeToken()), new ManaCostsImpl("{4}{G}{G}"));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§}§}§class DokaiWeaverofLifeToken extends Token {§final static FilterControlledPermanent filterLands = new FilterControlledLandPermanent("lands you control");§DokaiWeaverofLifeToken() {§super("Elemental", "a X/X green Elemental creature token onto the battlefield, where X is the number of lands you control");§cardType.add(CardType.CREATURE);§color.setGreen(true);§subtype.add("Elemental");§power = new MageInt(0);§toughness = new MageInt(0);§DynamicValue controlledLands = new PermanentsOnBattlefieldCount(filterLands);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostSourceEffect(controlledLands, controlledLands, Duration.WhileOnBattlefield)));§}§}§
public class BurrGrafter extends CardImpl {§public BurrGrafter(UUID ownerId) {§super(ownerId, 203, "Burr Grafter", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{G}");§this.expansionSetCode = "CHK";§this.subtype.add("Spirit");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostTargetEffect(2, 2, Duration.EndOfTurn), new SacrificeSourceCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§this.addAbility(new SoulshiftAbility(3));§}§public BurrGrafter(final BurrGrafter card) {§super(card);§}§@Override§public BurrGrafter copy() {§return new BurrGrafter(this);§}§}§
public class BushiTenderfoot extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature that was dealt damage this turn");§static {§filter.add(new WasDealtDamageThisTurnPredicate());§}§public BushiTenderfoot(UUID ownerId) {§super(ownerId, 2, "Bushi Tenderfoot", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{W}");§this.expansionSetCode = "CHK";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.flipCard = true;§this.flipCardName = "Kenzo the Hardhearted";§Effect effect = new FlipSourceEffect(new KenzoTheHardhearted());§effect.setText("flip {this}");§this.addAbility(new DiesAndDealtDamageThisTurnTriggeredAbility(effect));§}§public BushiTenderfoot(final BushiTenderfoot card) {§super(card);§}§@Override§public BushiTenderfoot copy() {§return new BushiTenderfoot(this);§}§}§class KenzoTheHardhearted extends Token {§KenzoTheHardhearted() {§super("Kenzo the Hardhearted", "");§supertype.add("Legendary");§cardType.add(CardType.CREATURE);§color.setWhite(true);§subtype.add("Human");§subtype.add("Samurai");§power = new MageInt(3);§toughness = new MageInt(4);§this.addAbility(DoubleStrikeAbility.getInstance());§this.addAbility(new BushidoAbility(2));§}§}§
public class CageOfHands extends CardImpl {§public CageOfHands (UUID ownerId) {§super(ownerId, 3, "Cage of Hands", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{W}");§this.expansionSetCode = "CHK";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.Neutral));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new CageOfHandsEffect()));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new ReturnToHandSourceEffect(true), new ManaCostsImpl("{1}{W}")));§}§public CageOfHands (final CageOfHands card) {§super(card);§}§@Override§public CageOfHands copy() {§return new CageOfHands(this);§}§}§class CageOfHandsEffect extends RestrictionEffect {§public CageOfHandsEffect() {§super(Duration.WhileOnBattlefield);§staticText = "Enchanted creature can't attack or block";§}§public CageOfHandsEffect(final CageOfHandsEffect effect) {§super(effect);§}§@Override§public boolean applies(Permanent permanent, Ability source, Game game) {§if (permanent.getAttachments().contains((source.getSourceId()))) {§return true;§}§return false;§}§@Override§public boolean canAttack(Game game) {§return false;§}§@Override§public boolean canBlock(Permanent attacker, Permanent blocker, Ability source, Game game) {§return false;§}§@Override§public CageOfHandsEffect copy() {§return new CageOfHandsEffect(this);§}§}§
public class CallousDeceiver extends CardImpl {§public CallousDeceiver(UUID ownerId) {§super(ownerId, 53, "Callous Deceiver", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{U}");§this.expansionSetCode = "CHK";§this.subtype.add("Spirit");§this.power = new MageInt(1);§this.toughness = new MageInt(3);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new LookLibraryControllerEffect(), new GenericManaCost(1)));§this.addAbility(new LimitedTimesPerTurnActivatedAbility(Zone.BATTLEFIELD, new CallousDeceiverEffect(), new ManaCostsImpl("{2}")));§}§public CallousDeceiver(final CallousDeceiver card) {§super(card);§}§@Override§public CallousDeceiver copy() {§return new CallousDeceiver(this);§}§}§class CallousDeceiverEffect extends OneShotEffect {§public CallousDeceiverEffect() {§super(Outcome.BoostCreature);§this.staticText = "Reveal the top card of your library. If it's a land card, {this} gets +1/+0 and gains flying until end of turn";§}§public CallousDeceiverEffect(final CallousDeceiverEffect effect) {§super(effect);§}§@Override§public CallousDeceiverEffect copy() {§return new CallousDeceiverEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§MageObject sourceObject = source.getSourceObject(game);§if (controller != null && sourceObject != null) {§Cards cards = new CardsImpl();§Card card = controller.getLibrary().getFromTop(game);§if (card != null) {§cards.add(card);§controller.revealCards(sourceObject.getIdName(), cards, game);§if (card.getCardType().contains(CardType.LAND)) {§game.addEffect(new BoostSourceEffect(1, 0, Duration.EndOfTurn), source);§game.addEffect(new GainAbilitySourceEffect(FlyingAbility.getInstance(), Duration.EndOfTurn), source);§}§}§return true;§}§return false;§}§}§
public class CallToGlory extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Samurai");§static {§filter.add(new SubtypePredicate("Samurai"));§}§public CallToGlory(UUID ownerId) {§super(ownerId, 4, "Call to Glory", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{W}");§this.expansionSetCode = "CHK";§this.getSpellAbility().addEffect(new CalltoGloryFirstEffect());§this.getSpellAbility().addEffect(new BoostControlledEffect(1, 1, Duration.EndOfTurn, filter, false));§}§public CallToGlory(final CallToGlory card) {§super(card);§}§@Override§public CallToGlory copy() {§return new CallToGlory(this);§}§}§class CalltoGloryFirstEffect extends OneShotEffect {§public CalltoGloryFirstEffect() {§super(Outcome.Untap);§staticText = "Untap all creatures you control";§}§public CalltoGloryFirstEffect(final CalltoGloryFirstEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§for (Permanent creature : game.getBattlefield().getAllActivePermanents(new FilterCreaturePermanent(), player.getId(), game)) {§creature.untap(game);§}§return true;§}§return false;§}§@Override§public CalltoGloryFirstEffect copy() {§return new CalltoGloryFirstEffect(this);§}§}§
public class CandlesGlow extends CardImpl {§public CandlesGlow(UUID ownerId) {§super(ownerId, 5, "Candles' Glow", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{1}{W}");§this.expansionSetCode = "CHK";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new CandlesGlowPreventDamageTargetEffect(Duration.EndOfTurn));§this.getSpellAbility().addTarget(new TargetCreatureOrPlayer());§this.addAbility(new SpliceOntoArcaneAbility("{1}{W}"));§}§public CandlesGlow(final CandlesGlow card) {§super(card);§}§@Override§public CandlesGlow copy() {§return new CandlesGlow(this);§}§}§class CandlesGlowPreventDamageTargetEffect extends PreventionEffectImpl {§private int amount = 3;§public CandlesGlowPreventDamageTargetEffect(Duration duration) {§super(duration);§staticText = "Prevent the next 3 damage that would be dealt to target creature or player this turn. You gain life equal to the damage prevented this way";§}§public CandlesGlowPreventDamageTargetEffect(final CandlesGlowPreventDamageTargetEffect effect) {§super(effect);§this.amount = effect.amount;§}§@Override§public CandlesGlowPreventDamageTargetEffect copy() {§return new CandlesGlowPreventDamageTargetEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§GameEvent preventEvent = new GameEvent(GameEvent.EventType.PREVENT_DAMAGE, source.getFirstTarget(), source.getSourceId(), source.getControllerId(), event.getAmount(), false);§if (!game.replaceEvent(preventEvent)) {§int prevented;§if (event.getAmount() >= this.amount) {§int damage = amount;§event.setAmount(event.getAmount() - amount);§this.used = true;§game.fireEvent(GameEvent.getEvent(GameEvent.EventType.PREVENTED_DAMAGE, source.getFirstTarget(), source.getSourceId(), source.getControllerId(), damage));§prevented = damage;§} else {§int damage = event.getAmount();§event.setAmount(0);§amount -= damage;§game.fireEvent(GameEvent.getEvent(GameEvent.EventType.PREVENTED_DAMAGE, source.getFirstTarget(), source.getSourceId(), source.getControllerId(), damage));§prevented = damage;§}§if (prevented > 0) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§controller.gainLife(prevented, game);§game.informPlayers(new StringBuilder("Candles' Glow: Prevented ").append(prevented).append(" damage ").toString());§game.informPlayers(new StringBuilder("Candles' Glow: ").append(controller.getLogName()).append(" gained ").append(prevented).append("life").toString());§}§}§}§return false;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§if (!this.used && super.applies(event, source, game)) {§if (source.getTargets().getFirstTarget().equals(event.getTargetId())) {§return true;§}§}§return false;§}§}§
public class Cleanfall extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("enchantments");§static {§filter.add(new CardTypePredicate(CardType.ENCHANTMENT));§}§public Cleanfall(UUID ownerId) {§super(ownerId, 6, "Cleanfall", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{2}{W}");§this.expansionSetCode = "CHK";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new DestroyAllEffect(filter));§}§public Cleanfall(final Cleanfall card) {§super(card);§}§@Override§public Cleanfall copy() {§return new Cleanfall(this);§}§}§
public class CloudcrestLake extends CardImpl {§public CloudcrestLake(UUID ownerId) {§super(ownerId, 274, "Cloudcrest Lake", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "CHK";§this.addAbility(new ColorlessManaAbility());§Ability whiteManaAbility = new WhiteManaAbility();§whiteManaAbility.addEffect(new DontUntapInControllersNextUntapStepSourceEffect());§this.addAbility(whiteManaAbility);§Ability blueManaAbility = new BlueManaAbility();§blueManaAbility.addEffect(new DontUntapInControllersNextUntapStepSourceEffect());§this.addAbility(blueManaAbility);§}§public CloudcrestLake(final CloudcrestLake card) {§super(card);§}§@Override§public CloudcrestLake copy() {§return new CloudcrestLake(this);§}§}§
public class CommuneWithNature extends CardImpl {§private static final FilterCard filter = new FilterCard("a creature card");§static {§filter.add(new CardTypePredicate(CardType.CREATURE));§}§public CommuneWithNature (UUID ownerId) {§super(ownerId, 204, "Commune with Nature", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{G}");§this.expansionSetCode = "CHK";§this.getSpellAbility().addEffect(new LookLibraryAndPickControllerEffect(new StaticValue(5), false, new StaticValue(1), filter, false));§}§public CommuneWithNature (final CommuneWithNature card) {§super(card);§}§@Override§public CommuneWithNature copy() {§return new CommuneWithNature(this);§}§}§
public class ConsumingVortex extends CardImpl {§public ConsumingVortex(UUID ownerId) {§super(ownerId, 54, "Consuming Vortex", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{U}");§this.expansionSetCode = "CHK";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new ReturnToHandTargetEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.addAbility(new SpliceOntoArcaneAbility("{3}{U}"));§}§public ConsumingVortex(final ConsumingVortex card) {§super(card);§}§@Override§public ConsumingVortex copy() {§return new ConsumingVortex(this);§}§}§
public class CounselOfTheSoratami extends CardImpl {§public CounselOfTheSoratami (UUID ownerId) {§super(ownerId, 55, "Counsel of the Soratami", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{2}{U}");§this.expansionSetCode = "CHK";§this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(2));§}§public CounselOfTheSoratami (final CounselOfTheSoratami card) {§super(card);§}§@Override§public CounselOfTheSoratami copy() {§return new CounselOfTheSoratami(this);§}§}§
public class CranialExtraction extends CardImpl {§public CranialExtraction(UUID ownerId) {§super(ownerId, 105, "Cranial Extraction", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{3}{B}");§this.expansionSetCode = "CHK";§this.subtype.add("Arcane");§/* Name a nonland card. Search target player's graveyard, hand, and library for§* all cards with that name and exile them. Then that player shuffles his or her library. */§this.getSpellAbility().addTarget(new TargetPlayer());§this.getSpellAbility().addEffect(new CranialExtractionEffect());§}§public CranialExtraction(final CranialExtraction card) {§super(card);§}§@Override§public CranialExtraction copy() {§return new CranialExtraction(this);§}§}§class CranialExtractionEffect extends SearchTargetGraveyardHandLibraryForCardNameAndExileEffect {§CranialExtractionEffect() {§super(false, "target player's", "all cards with that name");§}§CranialExtractionEffect(final CranialExtractionEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(this.getTargetPointer().getFirst(game, source));§Player controller = game.getPlayer(source.getControllerId());§if (player != null && controller != null) {§Choice cardChoice = new ChoiceImpl();§cardChoice.setChoices(CardRepository.instance.getNonLandNames());§cardChoice.clearChoice();§cardChoice.setMessage("Name a nonland card");§while (!controller.choose(Outcome.Exile, cardChoice, game)) {§if (!controller.canRespond()) {§return false;§}§}§String cardName = cardChoice.getChoice();§MageObject sourceObject = game.getObject(source.getSourceId());§if (sourceObject != null) {§game.informPlayers(sourceObject.getName() + " named card: [" + cardName + "]");§}§super.applySearchAndExile(game, source, cardName, player.getId());§}§return true;§}§@Override§public CranialExtractionEffect copy() {§return new CranialExtractionEffect(this);§}§@Override§public String getText(Mode mode) {§return "Name a nonland card. " + super.getText(mode);§}§}§
public class CruelDeceiver extends CardImpl {§public CruelDeceiver(UUID ownerId) {§super(ownerId, 106, "Cruel Deceiver", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{B}");§this.expansionSetCode = "CHK";§this.subtype.add("Spirit");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new LookLibraryControllerEffect(), new GenericManaCost(1)));§this.addAbility(new LimitedTimesPerTurnActivatedAbility(Zone.BATTLEFIELD, new CruelDeceiverEffect(), new ManaCostsImpl("{2}")));§}§public CruelDeceiver(final CruelDeceiver card) {§super(card);§}§@Override§public CruelDeceiver copy() {§return new CruelDeceiver(this);§}§}§class CruelDeceiverEffect extends OneShotEffect {§public CruelDeceiverEffect() {§super(Outcome.AddAbility);§this.staticText = "Reveal the top card of your library. If it's a land card, {this} gets +2/+2 and gains trample until end of turn";§}§public CruelDeceiverEffect(final CruelDeceiverEffect effect) {§super(effect);§}§@Override§public CruelDeceiverEffect copy() {§return new CruelDeceiverEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§Cards cards = new CardsImpl();§Card card = player.getLibrary().getFromTop(game);§cards.add(card);§player.revealCards("Cruel Deceiver", cards, game);§if (card != null && card.getCardType().contains(CardType.LAND)) {§game.addEffect(new BoostSourceEffect(2,2,Duration.EndOfTurn), source);§game.addEffect(new GainAbilitySourceEffect(TrampleAbility.getInstance(),Duration.EndOfTurn), source);§}§return true;§}§return false;§}§}§
public class CrushingPain extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature that was dealt damage this turn");§static {§filter.add(new WasDealtDamageThisTurnPredicate());§}§public CrushingPain (UUID ownerId) {§super(ownerId, 162, "Crushing Pain", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{R}");§this.expansionSetCode = "CHK";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new DamageTargetEffect(6));§this.getSpellAbility().addTarget(new TargetCreaturePermanent(filter));§}§public CrushingPain (final CrushingPain card) {§super(card);§}§@Override§public CrushingPain copy() {§return new CrushingPain(this);§}§}§
public class CursedRonin extends CardImpl {§public CursedRonin (UUID ownerId) {§super(ownerId, 107, "Cursed Ronin", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{B}");§this.expansionSetCode = "CHK";§this.subtype.add("Human");§this.subtype.add("Samurai");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new BushidoAbility(1));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(1, 1, Duration.EndOfTurn), new ColoredManaCost(ColoredManaSymbol.B)));§}§public CursedRonin (final CursedRonin card) {§super(card);§}§@Override§public CursedRonin copy() {§return new CursedRonin(this);§}§}§
public class CutTheTethers extends CardImpl {§public CutTheTethers(UUID ownerId) {§super(ownerId, 56, "Cut the Tethers", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{2}{U}{U}");§this.expansionSetCode = "CHK";§this.getSpellAbility().addEffect(new CutTheTethersEffect());§}§public CutTheTethers(final CutTheTethers card) {§super(card);§}§@Override§public CutTheTethers copy() {§return new CutTheTethers(this);§}§}§class CutTheTethersEffect extends OneShotEffect {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Spirit creatures");§static {§filter.add(new SubtypePredicate("Spirit"));§}§public CutTheTethersEffect() {§super(Outcome.ReturnToHand);§this.staticText = "For each Spirit, return it to its owner's hand unless that player pays {3}";§}§public CutTheTethersEffect(final CutTheTethersEffect effect) {§super(effect);§}§@Override§public CutTheTethersEffect copy() {§return new CutTheTethersEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§for (Permanent creature: game.getState().getBattlefield().getActivePermanents(filter, source.getControllerId(), source.getSourceId(), game)) {§Player player = game.getPlayer(creature.getControllerId());§if (player != null) {§boolean paid = false;§if (player.chooseUse(outcome, new StringBuilder("Pay {3} to keep ").append(creature.getName()).append(" on the battlefield?").toString(), source, game)) {§Cost cost = new GenericManaCost(3);§if (!cost.pay(source, game, source.getSourceId(), creature.getControllerId(), false, null)) {§paid = true;§}§if (!paid) {§creature.moveToZone(Zone.HAND, source.getSourceId(), game, true);§}§}§}§}§return true;§}§}§
public class DanceOfShadows extends CardImpl {§static private FilterCreaturePermanent filter = new FilterCreaturePermanent("Creatures you control");§public DanceOfShadows (UUID ownerId) {§super(ownerId, 108, "Dance of Shadows", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{3}{B}{B}");§this.expansionSetCode = "CHK";§this.subtype.add("Arcane");§Effect effect = new BoostControlledEffect(1, 0, Duration.EndOfTurn, filter);§effect.setText("Creatures you control get +1/+0");§this.getSpellAbility().addEffect(effect);§effect = new BoostControlledEffect(1, 0, Duration.EndOfTurn, filter);§effect.setText("and gain fear until end of turn");§this.getSpellAbility().addEffect(new GainAbilityControlledEffect(FearAbility.getInstance(), Duration.EndOfTurn, filter));§}§public DanceOfShadows (final DanceOfShadows card) {§super(card);§}§@Override§public DanceOfShadows copy() {§return new DanceOfShadows(this);§}§}§
public class DevouringGreed extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("any number of Spirits");§static {§filter.add(new SubtypePredicate("Spirit"));§}§public DevouringGreed(UUID ownerId) {§super(ownerId, 110, "Devouring Greed", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{2}{B}{B}");§this.expansionSetCode = "CHK";§this.subtype.add("Arcane");§this.getSpellAbility().addCost(new SacrificeTargetCost(new TargetControlledCreaturePermanent(0, Integer.MAX_VALUE, filter, true)));§this.getSpellAbility().addEffect(new DevouringGreedEffect());§this.getSpellAbility().addTarget(new TargetPlayer());§}§public DevouringGreed(final DevouringGreed card) {§super(card);§}§@Override§public DevouringGreed copy() {§return new DevouringGreed(this);§}§}§class DevouringGreedEffect extends OneShotEffect {§public DevouringGreedEffect() {§super(Outcome.LoseLife);§this.staticText = "Target player loses 2 life plus 2 life for each Spirit sacrificed this way. You gain that much life";§}§public DevouringGreedEffect(final DevouringGreedEffect effect) {§super(effect);§}§@Override§public DevouringGreedEffect copy() {§return new DevouringGreedEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§int numberSpirits = 0;§for (Cost cost :source.getCosts()) {§if (cost instanceof SacrificeTargetCost) {§numberSpirits += ((SacrificeTargetCost) cost).getPermanents().size();§}§}§int amount = 2 + (numberSpirits * 2);§Player targetPlayer = game.getPlayer(getTargetPointer().getFirst(game, source));§Player sourcePlayer = game.getPlayer(source.getControllerId());§if (targetPlayer != null && sourcePlayer != null) {§targetPlayer.loseLife(amount, game);§sourcePlayer.gainLife(amount, game);§return true;§}§return false;§}§}§
public class DevouringRage extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("any number of Spirits");§static {§filter.add(new SubtypePredicate("Spirit"));§}§public DevouringRage(UUID ownerId) {§super(ownerId, 164, "Devouring Rage", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{4}{R}");§this.expansionSetCode = "CHK";§this.subtype.add("Arcane");§this.getSpellAbility().addCost(new SacrificeTargetCost(new TargetControlledCreaturePermanent(0, Integer.MAX_VALUE, filter, true)));§this.getSpellAbility().addEffect(new DevouringRageEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public DevouringRage(final DevouringRage card) {§super(card);§}§@Override§public DevouringRage copy() {§return new DevouringRage(this);§}§}§class DevouringRageEffect extends OneShotEffect {§public DevouringRageEffect() {§super(Outcome.LoseLife);§this.staticText = "Target creature gets +3/+0 until end of turn. For each Spirit sacrificed this way, that creature gets an additional +3/+0 until end of turn";§}§public DevouringRageEffect(final DevouringRageEffect effect) {§super(effect);§}§@Override§public DevouringRageEffect copy() {§return new DevouringRageEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§int numberSpirits = 0;§for (Cost cost :source.getCosts()) {§if (cost instanceof SacrificeTargetCost) {§numberSpirits = ((SacrificeTargetCost) cost).getPermanents().size();§}§}§int amount = 3 + (numberSpirits * 3);§Permanent targetCreature = game.getPermanent(getTargetPointer().getFirst(game, source));§if (targetCreature != null) {§ContinuousEffect effect = new BoostTargetEffect(amount, 0, Duration.EndOfTurn);§effect.setTargetPointer(new FixedTarget(targetCreature.getId()));§game.addEffect(effect, source);§return true;§}§return false;§}§}§
public class DosanTheFallingLeaf extends CardImpl {§public DosanTheFallingLeaf(UUID ownerId) {§super(ownerId, 205, "Dosan the Falling Leaf", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{G}{G}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Monk");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new DosanTheFallingLeafEffect()));§}§public DosanTheFallingLeaf(final DosanTheFallingLeaf card) {§super(card);§}§@Override§public DosanTheFallingLeaf copy() {§return new DosanTheFallingLeaf(this);§}§}§class DosanTheFallingLeafEffect extends ContinuousRuleModifyingEffectImpl {§DosanTheFallingLeafEffect() {§super(Duration.WhileOnBattlefield, Outcome.Detriment);§staticText = "Players can cast spells only during their own turns";§}§DosanTheFallingLeafEffect(final DosanTheFallingLeafEffect effect) {§super(effect);§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§return event.getType() == GameEvent.EventType.CAST_SPELL && !game.getActivePlayerId().equals(event.getPlayerId());§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public DosanTheFallingLeafEffect copy() {§return new DosanTheFallingLeafEffect(this);§}§}§
public class DrippingTongueZubera extends CardImpl {§public DrippingTongueZubera (UUID ownerId) {§super(ownerId, 206, "Dripping-Tongue Zubera", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "CHK";§this.subtype.add("Zubera");§this.subtype.add("Spirit");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§this.addAbility(new DiesTriggeredAbility(new CreateTokenEffect(new SpiritToken(), new ZuberasDiedDynamicValue()), false), new ZuberasDiedWatcher());§}§public DrippingTongueZubera (final DrippingTongueZubera card) {§super(card);§}§@Override§public DrippingTongueZubera copy() {§return new DrippingTongueZubera(this);§}§}§
public class Earthshaker extends CardImpl {§private static final FilterSpiritOrArcaneCard filter = new FilterSpiritOrArcaneCard();§private static final FilterCreaturePermanent creatureFilter = new FilterCreaturePermanent("creature without flying");§static {§filter.add(Predicates.not(new AbilityPredicate(FlyingAbility.class)));§}§public Earthshaker(UUID ownerId) {§super(ownerId, 165, "Earthshaker", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{R}{R}");§this.expansionSetCode = "CHK";§this.subtype.add("Spirit");§this.power = new MageInt(4);§this.toughness = new MageInt(5);§this.addAbility(new SpellCastControllerTriggeredAbility(new DamageAllEffect(new StaticValue(2) , creatureFilter), filter, false));§}§public Earthshaker(final Earthshaker card) {§super(card);§}§@Override§public Earthshaker copy() {§return new Earthshaker(this);§}§}§
public class EerieProcession extends CardImpl {§private static final FilterCard filter = new FilterCard("Arcane card");§static {§filter.add(new SubtypePredicate("Arcane"));§}§public EerieProcession(UUID ownerId) {§super(ownerId, 58, "Eerie Procession", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{2}{U}");§this.expansionSetCode = "CHK";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new SearchLibraryPutInHandEffect(new TargetCardInLibrary(filter), true));§}§public EerieProcession(final EerieProcession card) {§super(card);§}§@Override§public EerieProcession copy() {§return new EerieProcession(this);§}§}§
public class EiganjoCastle extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("legendary creature");§static {§filter.add(new SupertypePredicate("Legendary"));§}§public EiganjoCastle(UUID ownerId) {§super(ownerId, 275, "Eiganjo Castle", Rarity.RARE, new CardType[]{CardType.LAND}, null);§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.addAbility(new WhiteManaAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new PreventDamageToTargetEffect(Duration.EndOfTurn, 2), new ColoredManaCost(ColoredManaSymbol.W));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetPermanent(filter));§this.addAbility(ability);§}§public EiganjoCastle(final EiganjoCastle card) {§super(card);§}§@Override§public EiganjoCastle copy() {§return new EiganjoCastle(this);§}§}§
public class EightAndAHalfTails extends CardImpl {§private static final Filter filter = new FilterCard("white");§static {§filter.add(new ColorPredicate(ObjectColor.WHITE));§}§public EightAndAHalfTails(UUID ownerId) {§super(ownerId, 8, "Eight-and-a-Half-Tails", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{W}{W}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Fox");§this.subtype.add("Cleric");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilityTargetEffect(new ProtectionAbility(filter), Duration.EndOfTurn), new ManaCostsImpl("{1}{W}"));§Target target = new TargetControlledPermanent();§ability.addTarget(target);§this.addAbility(ability);§ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,§new BecomesColorTargetEffect(ObjectColor.WHITE, Duration.EndOfTurn, "Target spell or permanent becomes white until end of turn"), new ManaCostsImpl("{1}"));§target = new TargetSpellOrPermanent();§ability.addTarget(target);§this.addAbility(ability);§}§public EightAndAHalfTails(final EightAndAHalfTails card) {§super(card);§}§@Override§public EightAndAHalfTails copy() {§return new EightAndAHalfTails(this);§}§}§
public class EmberFistZubera extends CardImpl {§public EmberFistZubera (UUID ownerId) {§super(ownerId, 166, "Ember-Fist Zubera", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{R}");§this.expansionSetCode = "CHK";§this.subtype.add("Zubera");§this.subtype.add("Spirit");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§Ability ability = new DiesTriggeredAbility(new DamageTargetEffect(new ZuberasDiedDynamicValue()));§ability.addTarget(new TargetCreatureOrPlayer());§this.addAbility(ability, new ZuberasDiedWatcher());§}§public EmberFistZubera (final EmberFistZubera card) {§super(card);§}§@Override§public EmberFistZubera copy() {§return new EmberFistZubera(this);§}§}§
public class EtherealHaze extends CardImpl {§public EtherealHaze (UUID ownerId) {§super(ownerId, 9, "Ethereal Haze", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{W}");§this.expansionSetCode = "CHK";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new PreventAllDamageByAllEffect(new FilterCreaturePermanent("creatures"), Duration.EndOfTurn, false));§}§public EtherealHaze (final EtherealHaze card) {§super(card);§}§@Override§public EtherealHaze copy() {§return new EtherealHaze(this);§}§}§
public class EyeOfNowhere extends CardImpl {§public EyeOfNowhere (UUID ownerId) {§super(ownerId, 59, "Eye of Nowhere", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{U}{U}");§this.expansionSetCode = "CHK";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new ReturnToHandTargetEffect());§this.getSpellAbility().addTarget(new TargetPermanent());§}§public EyeOfNowhere (final EyeOfNowhere card) {§super(card);§}§@Override§public EyeOfNowhere copy() {§return new EyeOfNowhere(this);§}§}§
public class FeastOfWorms extends CardImpl {§public FeastOfWorms (UUID ownerId) {§super(ownerId, 207, "Feast of Worms", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{3}{G}{G}");§this.expansionSetCode = "CHK";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new DestroyTargetEffect());§this.getSpellAbility().addTarget(new TargetLandPermanent());§this.getSpellAbility().addEffect(new FeastOfWormsEffect());§}§public FeastOfWorms (final FeastOfWorms card) {§super(card);§}§@Override§public FeastOfWorms copy() {§return new FeastOfWorms(this);§}§}§class FeastOfWormsEffect extends OneShotEffect {§FeastOfWormsEffect() {§super(Outcome.Sacrifice);§staticText = "If that land was legendary, its controller sacrifices another land";§}§FeastOfWormsEffect(FeastOfWormsEffect effect) {§super(effect);§}§@Override§public FeastOfWormsEffect copy() {§return new FeastOfWormsEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getPermanentOrLKIBattlefield(id);§Player targetPlayer = null;§if (permanent != null) {§targetPlayer = game.getPlayer(permanent.getControllerId());§}§if (targetPlayer != null && permanent != null && (permanent.getSupertype().get(0).equals("Legendary"))) {§FilterControlledPermanent filter = new FilterControlledLandPermanent("land to sacrifice");§filter.add(new ControllerIdPredicate(targetPlayer.getId()));§TargetControlledPermanent target = new TargetControlledPermanent(1, 1, filter, false);§if (target.canChoose(targetPlayer.getId(), game)) {§targetPlayer.chooseTarget(Outcome.Sacrifice, target, source, game);§Permanent land = game.getPermanent(target.getFirstTarget());§if (land != null) {§land.sacrifice(source.getSourceId(), game);§}§}§return true;§}§return false;§}§}§
public class FeralDeceiver extends CardImpl {§public FeralDeceiver(UUID ownerId) {§super(ownerId, 208, "Feral Deceiver", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{G}");§this.expansionSetCode = "CHK";§this.subtype.add("Spirit");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new LookLibraryControllerEffect(), new GenericManaCost(1)));§Ability ability = new FeralDeceiverAbility(Zone.BATTLEFIELD, new BoostSourceEffect(2,2,Duration.EndOfTurn), new ManaCostsImpl("{2}"));§ability.addEffect(new GainAbilitySourceEffect(TrampleAbility.getInstance(),Duration.EndOfTurn));§this.addAbility(ability);§}§public FeralDeceiver(final FeralDeceiver card) {§super(card);§}§@Override§public FeralDeceiver copy() {§return new FeralDeceiver(this);§}§}§class FeralDeceiverAbility extends LimitedTimesPerTurnActivatedAbility {§public FeralDeceiverAbility(Zone zone, Effect effect, Cost cost) {§super(zone, effect, cost);§}§public FeralDeceiverAbility(FeralDeceiverAbility ability) {§super(ability);§}§@Override§public FeralDeceiverAbility copy() {§return new FeralDeceiverAbility(this);§}§@Override§public boolean checkIfClause(Game game) {§Player player = game.getPlayer(this.getControllerId());§if (player != null) {§Cards cards = new CardsImpl();§Card card = player.getLibrary().getFromTop(game);§cards.add(card);§player.revealCards("Feral Deceiver", cards, game);§if (card != null && card.getCardType().contains(CardType.LAND)) {§return true;§}§}§return false;§}§@Override§public String getRule() {§return "{2}: Reveal the top card of your library. If it's a land card, {this} gets +2/+2 and gains trample until end of turn. Activate this ability only once each turn.";§}§}§
public class FieldOfReality extends CardImpl {§public FieldOfReality(UUID ownerId) {§super(ownerId, 60, "Field of Reality", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{U}");§this.expansionSetCode = "CHK";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));§this.addAbility(new EnchantAbility(auraTarget.getTargetName()));§this.addAbility(new SimpleEvasionAbility(new CantBeBlockedByCreaturesAttachedEffect(§Duration.WhileOnBattlefield, new FilterCreaturePermanent("Spirit", "Spirits"), AttachmentType.AURA)));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new ReturnToHandSourceEffect(true), new ManaCostsImpl("{1}{U}")));§}§public FieldOfReality(final FieldOfReality card) {§super(card);§}§@Override§public FieldOfReality copy() {§return new FieldOfReality(this);§}§}§
public class FloatingDreamZubera extends CardImpl {§public FloatingDreamZubera(UUID ownerId) {§super(ownerId, 61, "Floating-Dream Zubera", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{U}");§this.expansionSetCode = "CHK";§this.subtype.add("Zubera");§this.subtype.add("Spirit");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§this.addAbility(new DiesTriggeredAbility(new DrawCardSourceControllerEffect(new ZuberasDiedDynamicValue())), new ZuberasDiedWatcher());§}§public FloatingDreamZubera(final FloatingDreamZubera card) {§super(card);§}§@Override§public FloatingDreamZubera copy() {§return new FloatingDreamZubera(this);§}§}§class ZuberasDiedWatcher extends Watcher {§public int zuberasDiedThisTurn = 0;§public ZuberasDiedWatcher() {§super("ZuberasDied", WatcherScope.GAME);§}§public ZuberasDiedWatcher(final ZuberasDiedWatcher watcher) {§super(watcher);§this.zuberasDiedThisTurn = watcher.zuberasDiedThisTurn;§}§@Override§public ZuberasDiedWatcher copy() {§return new ZuberasDiedWatcher(this);§}§@Override§public void watch(GameEvent event, Game game) {§if (event.getType() == GameEvent.EventType.ZONE_CHANGE && ((ZoneChangeEvent) event).isDiesEvent()) {§MageObject card = game.getLastKnownInformation(event.getTargetId(), Zone.BATTLEFIELD);§if (card != null && card.hasSubtype("Zubera")) {§zuberasDiedThisTurn++;§}§}§}§@Override§public void reset() {§super.reset();§zuberasDiedThisTurn = 0;§}§}§class ZuberasDiedDynamicValue implements DynamicValue {§@Override§public int calculate(Game game, Ability sourceAbility, Effect effect) {§ZuberasDiedWatcher watcher = (ZuberasDiedWatcher) game.getState().getWatchers().get("ZuberasDied");§return watcher.zuberasDiedThisTurn;§}§@Override§public ZuberasDiedDynamicValue copy() {§return new ZuberasDiedDynamicValue();§}§@Override§public String toString() {§return "1";§}§@Override§public String getMessage() {§return "Zubera that died this turn";§}§}§
public class ForbiddenOrchard extends CardImpl {§public ForbiddenOrchard (UUID ownerId) {§super(ownerId, 276, "Forbidden Orchard", Rarity.RARE, new CardType[]{CardType.LAND}, null);§this.expansionSetCode = "CHK";§this.addAbility(new AnyColorManaAbility());§this.addAbility(new ForbiddenOrchardTriggeredAbility());§}§public ForbiddenOrchard (final ForbiddenOrchard card) {§super(card);§}§@Override§public ForbiddenOrchard copy() {§return new ForbiddenOrchard(this);§}§}§class ForbiddenOrchardTriggeredAbility extends TriggeredAbilityImpl {§public ForbiddenOrchardTriggeredAbility() {§super(Zone.BATTLEFIELD, new CreateTokenTargetEffect(new SpiritToken()));§this.addTarget(new TargetOpponent());§}§public ForbiddenOrchardTriggeredAbility(final ForbiddenOrchardTriggeredAbility ability) {§super(ability);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.TAPPED_FOR_MANA;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§return event.getSourceId().equals(getSourceId());§}§@Override§public String getRule() {§return new StringBuilder("Whenever you tap {this} for mana, ").append(super.getRule()).toString() ;§}§@Override§public ForbiddenOrchardTriggeredAbility copy() {§return new ForbiddenOrchardTriggeredAbility(this);§}§}§
public class Frostwielder extends CardImpl {§public Frostwielder(UUID ownerId) {§super(ownerId, 167, "Frostwielder", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{R}{R}");§this.expansionSetCode = "CHK";§this.subtype.add("Human");§this.subtype.add("Shaman");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(1), new TapSourceCost());§ability.addTarget(new TargetCreatureOrPlayer());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new DealtDamageToCreatureBySourceDies(this, Duration.WhileOnBattlefield)), new DamagedByWatcher());§}§public Frostwielder(final Frostwielder card) {§super(card);§}§@Override§public Frostwielder copy() {§return new Frostwielder(this);§}§}§
public class GaleForce extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature with flying");§static {§filter.add(new AbilityPredicate(FlyingAbility.class));§}§public GaleForce(UUID ownerId) {§super(ownerId, 209, "Gale Force", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{4}{G}");§this.expansionSetCode = "CHK";§this.getSpellAbility().addEffect(new DamageAllEffect(5, filter));§}§public GaleForce(final GaleForce card) {§super(card);§}§@Override§public GaleForce copy() {§return new GaleForce(this);§}§}§
public class GibberingKami extends CardImpl {§public GibberingKami(UUID ownerId) {§super(ownerId, 112, "Gibbering Kami", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{B}");§this.expansionSetCode = "CHK";§this.subtype.add("Spirit");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new SoulshiftAbility(3));§}§public GibberingKami(final GibberingKami card) {§super(card);§}§@Override§public GibberingKami copy() {§return new GibberingKami(this);§}§}§
public class GiftsUngiven extends CardImpl {§public GiftsUngiven(UUID ownerId) {§super(ownerId, 62, "Gifts Ungiven", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{3}{U}");§this.expansionSetCode = "CHK";§this.getSpellAbility().addEffect(new GiftsUngivenEffect());§this.getSpellAbility().addTarget(new TargetOpponent());§}§public GiftsUngiven(final GiftsUngiven card) {§super(card);§}§@Override§public GiftsUngiven copy() {§return new GiftsUngiven(this);§}§}§class GiftsUngivenEffect extends OneShotEffect {§public GiftsUngivenEffect() {§super(Outcome.DrawCard);§this.staticText = "Search your library for up to four cards with different names and reveal them. Target opponent chooses two of those cards. Put the chosen cards into your graveyard and the rest into your hand. Then shuffle your library";§}§public GiftsUngivenEffect(final GiftsUngivenEffect effect) {§super(effect);§}§@Override§public GiftsUngivenEffect copy() {§return new GiftsUngivenEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§Card sourceCard = game.getCard(source.getSourceId());§if (player == null || sourceCard == null) {§return false;§}§Player opponent = game.getPlayer(getTargetPointer().getFirst(game, source));§if (opponent == null) {§return false;§}§GiftsUngivenTarget target = new GiftsUngivenTarget();§if (player.searchLibrary(target, game)) {§if (target.getTargets().size() > 0) {§Cards cards = new CardsImpl();§for (UUID cardId : target.getTargets()) {§Card card = player.getLibrary().remove(cardId, game);§if (card != null) {§cards.add(card);§}§}§player.revealCards(sourceCard.getIdName(), cards, game);§CardsImpl cardsToKeep = new CardsImpl();§if (cards.size() > 2) {§cardsToKeep.addAll(cards);§TargetCard targetDiscard = new TargetCard(2, Zone.LIBRARY, new FilterCard("cards to put in graveyard"));§if (opponent.choose(Outcome.Discard, cards, targetDiscard, game)) {§cardsToKeep.removeAll(targetDiscard.getTargets());§cards.removeAll(cardsToKeep);§}§}§player.moveCards(cards, Zone.LIBRARY, Zone.GRAVEYARD, source, game);§player.moveCards(cardsToKeep, Zone.LIBRARY, Zone.HAND, source, game);§}§player.shuffleLibrary(game);§return true;§}§player.shuffleLibrary(game);§return false;§}§}§class GiftsUngivenTarget extends TargetCardInLibrary {§public GiftsUngivenTarget() {§super(0, 4, new FilterCard("cards with different names"));§}§public GiftsUngivenTarget(final GiftsUngivenTarget target) {§super(target);§}§@Override§public GiftsUngivenTarget copy() {§return new GiftsUngivenTarget(this);§}§@Override§public boolean canTarget(UUID id, Cards cards, Game game) {§Card card = cards.get(id, game);§if (card != null) {§for (UUID targetId : this.getTargets()) {§Card iCard = game.getCard(targetId);§if (iCard != null && iCard.getName().equals(card.getName())) {§return false;§}§}§return filter.match(card, game);§}§return false;§}§}§
public class GlimpseOfNature extends CardImpl {§public GlimpseOfNature (UUID ownerId) {§super(ownerId, 210, "Glimpse of Nature", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{G}");§this.expansionSetCode = "CHK";§this.getSpellAbility().addEffect(new CreateDelayedTriggeredAbilityEffect(new GlimpseOfNatureTriggeredAbility()));§}§public GlimpseOfNature (final GlimpseOfNature card) {§super(card);§}§@Override§public GlimpseOfNature copy() {§return new GlimpseOfNature(this);§}§}§class GlimpseOfNatureTriggeredAbility extends DelayedTriggeredAbility {§private static final FilterSpell filter = new FilterSpell();§static {§filter.add(new CardTypePredicate(CardType.CREATURE));§}§public GlimpseOfNatureTriggeredAbility() {§super(new DrawCardSourceControllerEffect(1), Duration.EndOfTurn, false);§}§public GlimpseOfNatureTriggeredAbility(GlimpseOfNatureTriggeredAbility ability) {§super(ability);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.SPELL_CAST;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (event.getPlayerId().equals(this.getControllerId())) {§Spell spell = game.getStack().getSpell(event.getTargetId());§if (spell != null && filter.match(spell, game)) {§return true;§}§}§return false;§}§@Override§public GlimpseOfNatureTriggeredAbility copy() {§return new GlimpseOfNatureTriggeredAbility(this);§}§@Override§public String getRule() {§return "Whenever you cast a creature spell this turn, " + modes.getText();§}§}§
public class GodoBanditWarlord extends CardImpl {§private static final FilterCard filter = new FilterCard("an Equipment card");§static {§filter.add(new CardTypePredicate(CardType.ARTIFACT));§filter.add(new SubtypePredicate("Equipment"));§}§public GodoBanditWarlord(UUID ownerId) {§super(ownerId, 169, "Godo, Bandit Warlord", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}{R}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Barbarian");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new EntersBattlefieldTriggeredAbility(new SearchLibraryPutInPlayEffect(new TargetCardInLibrary(filter), false, true), true));§FilterControlledCreaturePermanent untapFilter = new FilterControlledCreaturePermanent();§untapFilter.add(Predicates.or(new PermanentIdPredicate(this.getId()), new SubtypePredicate("Samurai")));§Ability ability = new GodoBanditWarlordAttacksTriggeredAbility(new UntapAllControllerEffect(untapFilter,"untap it and all Samurai you control"), false);§ability.addEffect(new AdditionalCombatPhaseEffect());§this.addAbility(ability);§}§public GodoBanditWarlord(final GodoBanditWarlord card) {§super(card);§}§@Override§public GodoBanditWarlord copy() {§return new GodoBanditWarlord(this);§}§}§class GodoBanditWarlordAttacksTriggeredAbility extends TriggeredAbilityImpl {§public GodoBanditWarlordAttacksTriggeredAbility(Effect effect, boolean optional) {§super(Zone.BATTLEFIELD, effect, optional);§}§public GodoBanditWarlordAttacksTriggeredAbility(final GodoBanditWarlordAttacksTriggeredAbility ability) {§super(ability);§}§@Override§public void reset(Game game) {§game.getState().setValue(CardUtil.getCardZoneString("amountAttacks", this.getSourceId(), game), 0);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.ATTACKER_DECLARED;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (event.getSourceId().equals(this.getSourceId()) ) {§Integer amountAttacks = (Integer) game.getState().getValue(CardUtil.getCardZoneString("amountAttacks", this.getSourceId(), game));§if (amountAttacks == null || amountAttacks < 1) {§if (amountAttacks == null) {§amountAttacks = 1;§} else {§++amountAttacks;§}§game.getState().setValue(CardUtil.getCardZoneString("amountAttacks", this.getSourceId(), game), amountAttacks);§return true;§}§}§return false;§}§@Override§public String getRule() {§return "Whenever {this} attacks for the first time each turn, " + super.getRule();§}§@Override§public GodoBanditWarlordAttacksTriggeredAbility copy() {§return new GodoBanditWarlordAttacksTriggeredAbility(this);§}§}§class AdditionalCombatPhaseEffect extends OneShotEffect {§public AdditionalCombatPhaseEffect() {§super(Outcome.Benefit);§staticText = "After this phase, there is an additional combat phase";§}§public AdditionalCombatPhaseEffect(final AdditionalCombatPhaseEffect effect) {§super(effect);§}§@Override§public AdditionalCombatPhaseEffect copy() {§return new AdditionalCombatPhaseEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§game.getState().getTurnMods().add(new TurnMod(source.getControllerId(), TurnPhase.COMBAT, null, false));§return true;§}§}§
public class GracefulAdept extends CardImpl {§public GracefulAdept(UUID ownerId) {§super(ownerId, 63, "Graceful Adept", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{U}");§this.expansionSetCode = "CHK";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(3);§Effect effect = new MaximumHandSizeControllerEffect(Integer.MAX_VALUE, Duration.WhileOnBattlefield, HandSizeModification.SET);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, effect));§}§public GracefulAdept(final GracefulAdept card) {§super(card);§}§@Override§public GracefulAdept copy() {§return new GracefulAdept(this);§}§}§
public class GuardianOfSolitude extends CardImpl {§private static final FilterSpiritOrArcaneCard filter = new FilterSpiritOrArcaneCard();§public GuardianOfSolitude(UUID ownerId) {§super(ownerId, 64, "Guardian of Solitude", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{U}");§this.expansionSetCode = "CHK";§this.subtype.add("Spirit");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§Ability ability = new SpellCastControllerTriggeredAbility(new GainAbilityTargetEffect(FlyingAbility.getInstance(), Duration.EndOfTurn), filter, false);§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public GuardianOfSolitude(final GuardianOfSolitude card) {§super(card);§}§@Override§public GuardianOfSolitude copy() {§return new GuardianOfSolitude(this);§}§}§
public class GutwrencherOni extends CardImpl {§private static final FilterPermanent filter = new FilterControlledCreaturePermanent("Ogre");§static {§filter.add(new SubtypePredicate("Ogre"));§}§public GutwrencherOni(UUID ownerId) {§super(ownerId, 113, "Gutwrencher Oni", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{B}{B}");§this.expansionSetCode = "CHK";§this.subtype.add("Demon");§this.subtype.add("Spirit");§this.power = new MageInt(5);§this.toughness = new MageInt(4);§this.addAbility(TrampleAbility.getInstance());§this.addAbility(new BeginningOfUpkeepTriggeredAbility(new ConditionalOneShotEffect(§new DiscardControllerEffect(1),§new PermanentsOnTheBattlefieldCondition(filter, PermanentsOnTheBattlefieldCondition.CountType.EQUAL_TO, 0),§"discard a card if you don't control an Ogre"), TargetController.YOU, false));§}§public GutwrencherOni(final GutwrencherOni card) {§super(card);§}§@Override§public GutwrencherOni copy() {§return new GutwrencherOni(this);§}§}§
public class HairStrungKoto extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("untapped creature you control");§static {§filter.add(Predicates.not(new TappedPredicate()));§}§public HairStrungKoto (UUID ownerId) {§super(ownerId, 252, "Hair-Strung Koto", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{6}");§this.expansionSetCode = "CHK";§/* Tap an untapped creature you control: Target player puts the top§* card of his or her library into his or her graveyard.§*/§SimpleActivatedAbility ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,§new PutLibraryIntoGraveTargetEffect(1),§new TapTargetCost(new TargetControlledCreaturePermanent(1, 1, filter, false)));§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§}§public HairStrungKoto (final HairStrungKoto card) {§super(card);§}§@Override§public HairStrungKoto copy() {§return new HairStrungKoto(this);§}§}§
public class HallOfTheBanditLord extends CardImpl {§public HallOfTheBanditLord(UUID ownerId) {§super(ownerId, 277, "Hall of the Bandit Lord", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.addAbility(new EntersBattlefieldTappedAbility());§Mana mana = Mana.ColorlessMana(1);§mana.setFlag(true);§ManaEffect effect = new BasicManaEffect(mana);§effect.setText("Add {C} to your mana pool. If that mana is spent on a creature spell, it gains haste");§Ability ability = new SimpleManaAbility(Zone.BATTLEFIELD, effect, new TapSourceCost());§ability.addCost(new PayLifeCost(3));§this.addAbility(ability, new HallOfTheBanditLordWatcher(ability));§}§public HallOfTheBanditLord(final HallOfTheBanditLord card) {§super(card);§}§@Override§public HallOfTheBanditLord copy() {§return new HallOfTheBanditLord(this);§}§}§class HallOfTheBanditLordWatcher extends Watcher {§private final Ability source;§private final List<UUID> creatures = new ArrayList<>();§HallOfTheBanditLordWatcher(Ability source) {§super("HallOfTheBanditLordWatcher", WatcherScope.CARD);§this.source = source;§}§HallOfTheBanditLordWatcher(final HallOfTheBanditLordWatcher watcher) {§super(watcher);§this.creatures.addAll(watcher.creatures);§this.source = watcher.source;§}§@Override§public HallOfTheBanditLordWatcher copy() {§return new HallOfTheBanditLordWatcher(this);§}§@Override§public void watch(GameEvent event, Game game) {§if (event.getType() == EventType.MANA_PAYED) {§MageObject target = game.getObject(event.getTargetId());§if (event.getSourceId() != null§&& event.getSourceId().equals(this.getSourceId())§&& target != null && target.getCardType().contains(CardType.CREATURE)§&& event.getFlag()) {§if (target instanceof Spell) {§this.creatures.add(((Spell) target).getCard().getId());§}§}§}§if (event.getType() == EventType.COUNTERED) {§if (creatures.contains(event.getTargetId())) {§creatures.remove(event.getSourceId());§}§}§if (event.getType() == EventType.ZONE_CHANGE) {§if (creatures.contains(event.getSourceId())) {§ZoneChangeEvent zEvent = (ZoneChangeEvent) event;§if (zEvent.getToZone() == Zone.STACK) {§creatures.remove(event.getSourceId());§}§}§}§if (event.getType() == EventType.ENTERS_THE_BATTLEFIELD) {§if (creatures.contains(event.getSourceId())) {§ContinuousEffect effect = new GainAbilityTargetEffect(HasteAbility.getInstance(), Duration.Custom);§effect.setTargetPointer(new FixedTarget(event.getSourceId()));§game.addEffect(effect, source);§creatures.remove(event.getSourceId());§}§}§}§@Override§public void reset() {§super.reset();§creatures.clear();§}§}§
public class HanabiBlast extends CardImpl {§public HanabiBlast (UUID ownerId) {§super(ownerId, 170, "Hanabi Blast", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{1}{R}{R}");§this.expansionSetCode = "CHK";§this.getSpellAbility().addEffect(new DamageTargetEffect(2));§this.getSpellAbility().addTarget(new TargetCreatureOrPlayer());§this.getSpellAbility().addEffect(ReturnToHandSpellEffect.getInstance());§this.getSpellAbility().addEffect(new DiscardControllerEffect(1, true));§}§public HanabiBlast (final HanabiBlast card) {§super(card);§}§@Override§public HanabiBlast copy() {§return new HanabiBlast(this);§}§}§
public class HanaKami extends CardImpl {§private static final FilterCard filter = new FilterCard("Arcane card from your graveyard");§static {§filter.add(new SubtypePredicate("Arcane"));§}§public HanaKami(UUID ownerId) {§super(ownerId, 211, "Hana Kami", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{G}");§this.expansionSetCode = "CHK";§this.subtype.add("Spirit");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ReturnToHandTargetEffect(), new ManaCostsImpl("{1}{G}"));§ability.addCost(new SacrificeSourceCost());§ability.addTarget(new TargetCardInYourGraveyard(filter));§this.addAbility(ability);§}§public HanaKami(final HanaKami card) {§super(card);§}§@Override§public HanaKami copy() {§return new HanaKami(this);§}§}§
public class Hankyu extends CardImpl {§public Hankyu(UUID ownerId) {§super(ownerId, 253, "Hankyu", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{1}");§this.expansionSetCode = "CHK";§this.subtype.add("Equipment");§/* Equipped creature has "{T}: Put an aim counter on Hankyu" and */§SimpleActivatedAbility ability1 = new SimpleActivatedAbility(Zone.BATTLEFIELD, new HankyuAddCounterEffect(this.getId()), new TapSourceCost());§ability1.setSourceId(this.getId()); §
public class HarshDeceiver extends CardImpl {§public HarshDeceiver(UUID ownerId) {§super(ownerId, 11, "Harsh Deceiver", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{W}");§this.expansionSetCode = "CHK";§this.subtype.add("Spirit");§this.power = new MageInt(1);§this.toughness = new MageInt(4);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new LookLibraryControllerEffect(), new GenericManaCost(1)));§Ability ability = new FeralDeceiverAbility(Zone.BATTLEFIELD, new UntapSourceEffect(), new ManaCostsImpl("{2}"));§ability.addEffect(new BoostSourceEffect(1,1,Duration.EndOfTurn));§this.addAbility(ability);§}§public HarshDeceiver(final HarshDeceiver card) {§super(card);§}§@Override§public HarshDeceiver copy() {§return new HarshDeceiver(this);§}§}§class HarshDeceiverAbility extends LimitedTimesPerTurnActivatedAbility {§public HarshDeceiverAbility(Zone zone, Effect effect, Cost cost) {§super(zone, effect, cost);§}§public HarshDeceiverAbility(HarshDeceiverAbility ability) {§super(ability);§}§@Override§public HarshDeceiverAbility copy() {§return new HarshDeceiverAbility(this);§}§@Override§public boolean checkIfClause(Game game) {§Player player = game.getPlayer(this.getControllerId());§if (player != null) {§Cards cards = new CardsImpl();§Card card = player.getLibrary().getFromTop(game);§cards.add(card);§player.revealCards("Harsh Deceiver", cards, game);§if (card != null && card.getCardType().contains(CardType.LAND)) {§return true;§}§}§return false;§}§@Override§public String getRule() {§return "{2}: Reveal the top card of your library. If it's a land card, untap {this} and it gets +1/+1 until end of turn. Activate this ability only once each turn.";§}§}§
public class HeartbeatOfSpring extends CardImpl {§public HeartbeatOfSpring(UUID ownerId) {§super(ownerId, 212, "Heartbeat of Spring", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{2}{G}");§this.expansionSetCode = "CHK";§this.addAbility(new TapForManaAllTriggeredManaAbility(§new AddManaOfAnyTypeProducedEffect(),§new FilterLandPermanent("a player taps a land"),§SetTargetPointer.PERMANENT));§}§public HeartbeatOfSpring(final HeartbeatOfSpring card) {§super(card);§}§@Override§public HeartbeatOfSpring copy() {§return new HeartbeatOfSpring(this);§}§}§
public class HearthKami extends CardImpl {§private final UUID originalId;§public HearthKami(UUID ownerId) {§super(ownerId, 171, "Hearth Kami", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{R}");§this.expansionSetCode = "CHK";§this.subtype.add("Spirit");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DestroyTargetEffect(), new ManaCostsImpl("{X}"));§ability.addCost(new SacrificeSourceCost());§ability.addTarget(new TargetPermanent(new FilterArtifactPermanent("artifact with converted mana cost X")));§originalId = ability.getOriginalId();§this.addAbility(ability);§}§@Override§public void adjustTargets(Ability ability, Game game) {§if (ability.getOriginalId().equals(originalId)) {§int xValue = ability.getManaCostsToPay().getX();§ability.getTargets().clear();§FilterArtifactPermanent filter = new FilterArtifactPermanent(new StringBuilder("artifact with converted mana cost ").append(xValue).toString());§filter.add(new ConvertedManaCostPredicate(Filter.ComparisonType.Equal, xValue));§Target target = new TargetPermanent(filter);§ability.addTarget(target);§}§}§public HearthKami(final HearthKami card) {§super(card);§this.originalId = card.originalId;§}§@Override§public HearthKami copy() {§return new HearthKami(this);§}§}§
public class HeWhoHungers extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("a Spirit");§static {§filter.add(new SubtypePredicate("Spirit"));§}§public HeWhoHungers(UUID ownerId) {§super(ownerId, 114, "He Who Hungers", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{B}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Spirit");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§/* {1}, Sacrifice a Spirit: Target opponent reveals his or her hand. You choose a card from it.§* That player discards that card. Activate this ability only any time you could cast a sorcery. */§Ability ability = new ActivateAsSorceryActivatedAbility(Zone.BATTLEFIELD, new DiscardCardYouChooseTargetEffect(), new ManaCostsImpl("{1}"));§ability.addTarget(new TargetOpponent());§ability.addCost(new SacrificeTargetCost(new TargetControlledPermanent(filter)));§this.addAbility(ability);§this.addAbility(new SoulshiftAbility(4));§}§public HeWhoHungers(final HeWhoHungers card) {§super(card);§}§@Override§public HeWhoHungers copy() {§return new HeWhoHungers(this);§}§}§
public class HideousLaughter extends CardImpl {§public HideousLaughter(UUID ownerId) {§super(ownerId, 115, "Hideous Laughter", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{2}{B}{B}");§this.expansionSetCode = "CHK";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new BoostAllEffect(-2,-2, Duration.EndOfTurn));§this.addAbility(new SpliceOntoArcaneAbility("{3}{B}{B}"));§}§public HideousLaughter(final HideousLaughter card) {§super(card);§}§@Override§public HideousLaughter copy() {§return new HideousLaughter(this);§}§}§
public class HikariTwilightGuardian extends CardImpl {§private static final FilterSpiritOrArcaneCard filter = new FilterSpiritOrArcaneCard();§public HikariTwilightGuardian(UUID ownerId) {§super(ownerId, 12, "Hikari, Twilight Guardian", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{W}{W}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Spirit");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§Effect effect = new ExileReturnBattlefieldOwnerNextEndStepSourceEffect();§effect.setText("you may exile {this}. If you do, return it to the battlefield under its owner's control at the beginning of the next end step");§this.addAbility(new SpellCastControllerTriggeredAbility(effect, filter, true));§}§public HikariTwilightGuardian(final HikariTwilightGuardian card) {§super(card);§}§@Override§public HikariTwilightGuardian copy() {§return new HikariTwilightGuardian(this);§}§}§
public class HisokasDefiance extends CardImpl {§private static final FilterSpell filter = new FilterSpell("Spirit or Arcane spell");§static {§filter.add(Predicates.or(new SubtypePredicate("Spirit"), new SubtypePredicate("Arcane")));§}§public HisokasDefiance(UUID ownerId) {§super(ownerId, 67, "Hisoka's Defiance", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{U}");§this.expansionSetCode = "CHK";§this.getSpellAbility().addTarget(new TargetSpell(filter));§this.getSpellAbility().addEffect(new CounterTargetEffect());§}§public HisokasDefiance(final HisokasDefiance card) {§super(card);§}§@Override§public HisokasDefiance copy() {§return new HisokasDefiance(this);§}§}§
public class HisokasGuard extends CardImpl {§public HisokasGuard(UUID ownerId) {§super(ownerId, 68, "Hisoka's Guard", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{U}");§this.expansionSetCode = "CHK";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new SkipUntapOptionalAbility());§FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent();§filter.add(new AnotherPredicate());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new HisokasGuardGainAbilityTargetEffect(), new ManaCostsImpl("{1}{U}"));§ability.addCost(new TapSourceCost());§Target target = new TargetControlledCreaturePermanent(1, 1, filter, true);§ability.addTarget(target);§this.addAbility(ability);§}§public HisokasGuard(final HisokasGuard card) {§super(card);§}§@Override§public HisokasGuard copy() {§return new HisokasGuard(this);§}§}§class HisokasGuardGainAbilityTargetEffect extends ContinuousEffectImpl {§protected Ability ability;§public HisokasGuardGainAbilityTargetEffect() {§super(Duration.WhileOnBattlefield, Layer.AbilityAddingRemovingEffects_6, SubLayer.NA, Outcome.AddAbility);§staticText = "Target creature you control other than {this} has shroud for as long as {this} remains tapped";§this.ability = ShroudAbility.getInstance();§}§public HisokasGuardGainAbilityTargetEffect(final HisokasGuardGainAbilityTargetEffect effect) {§super(effect);§this.ability = effect.ability.copy();§}§@Override§public HisokasGuardGainAbilityTargetEffect copy() {§return new HisokasGuardGainAbilityTargetEffect(this);§}§@Override§public void init(Ability source, Game game) {§Permanent guardedCreature = game.getPermanent(this.getTargetPointer().getFirst(game, source));§Permanent hisokasGuard = game.getPermanent(source.getSourceId());§if (guardedCreature != null && hisokasGuard != null) {§hisokasGuard.addConnectedCard("HisokasGuard", guardedCreature.getId());§}§}§@Override§public boolean apply(Game game, Ability source) {§Permanent hisokasGuard = game.getPermanent(source.getSourceId());§if (hisokasGuard != null && hisokasGuard.getConnectedCards("HisokasGuard").size() > 0) {§Permanent guardedCreature = game.getPermanent(hisokasGuard.getConnectedCards("HisokasGuard").get(0));§if (guardedCreature != null && hisokasGuard.isTapped()) {§guardedCreature.addAbility(ability, game);§return true;§} else {§if (!hisokasGuard.isTapped()) {§hisokasGuard.clearConnectedCards("HisokasGuard");§}§}§}§return false;§}§}§
public class HoldTheLine extends CardImpl {§private static final FilterBlockingCreature filter = new FilterBlockingCreature("Blocking creatures");§public HoldTheLine(UUID ownerId) {§super(ownerId, 13, "Hold the Line", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{1}{W}{W}");§this.expansionSetCode = "CHK";§this.getSpellAbility().addEffect(new BoostAllEffect(7, 7, Duration.EndOfTurn, filter, false));§}§public HoldTheLine(final HoldTheLine card) {§super(card);§}§@Override§public HoldTheLine copy() {§return new HoldTheLine(this);§}§}§
public class HondenOfCleansingFire extends CardImpl {§final static FilterControlledPermanent filter = new FilterControlledPermanent("Shrine");§static {§filter.add(new SubtypePredicate("Shrine"));§}§public HondenOfCleansingFire(UUID ownerId) {§super(ownerId, 14, "Honden of Cleansing Fire", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{3}{W}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Shrine");§this.addAbility(new BeginningOfUpkeepTriggeredAbility(new GainLifeEffect(new PermanentsOnBattlefieldCount(filter, 2)), TargetController.YOU, false));§}§public HondenOfCleansingFire(final HondenOfCleansingFire card) {§super(card);§}§@Override§public HondenOfCleansingFire copy() {§return new HondenOfCleansingFire(this);§}§}§
public class HondenOfInfiniteRage extends CardImpl {§final static FilterControlledPermanent filter = new FilterControlledPermanent("Shrine");§static {§filter.add(new SubtypePredicate("Shrine"));§}§public HondenOfInfiniteRage (UUID ownerId) {§super(ownerId, 172, "Honden of Infinite Rage", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{R}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Shrine");§Ability ability = new BeginningOfUpkeepTriggeredAbility(new DamageTargetEffect(new PermanentsOnBattlefieldCount(filter)), TargetController.YOU, false);§ability.addTarget(new TargetCreatureOrPlayer());§this.addAbility(ability);§}§public HondenOfInfiniteRage (final HondenOfInfiniteRage card) {§super(card);§}§@Override§public HondenOfInfiniteRage copy() {§return new HondenOfInfiniteRage(this);§}§}§
public class HondenOfLifesWeb extends CardImpl {§final static FilterControlledPermanent filter = new FilterControlledPermanent("Shrine");§static {§filter.add(new SubtypePredicate("Shrine"));§}§public HondenOfLifesWeb(UUID ownerId) {§super(ownerId, 213, "Honden of Life's Web", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{4}{G}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Shrine");§this.addAbility(new BeginningOfUpkeepTriggeredAbility(new CreateTokenEffect(new SpiritToken(), new PermanentsOnBattlefieldCount(filter)), TargetController.YOU, false));§}§public HondenOfLifesWeb(final HondenOfLifesWeb card) {§super(card);§}§@Override§public HondenOfLifesWeb copy() {§return new HondenOfLifesWeb(this);§}§}§
public class HondenOfNightsReach extends CardImpl {§final static FilterControlledPermanent filter = new FilterControlledPermanent("Shrine");§static {§filter.add(new SubtypePredicate("Shrine"));§}§public HondenOfNightsReach(UUID ownerId) {§super(ownerId, 116, "Honden of Night's Reach", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{3}{B}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Shrine");§Ability ability = new BeginningOfUpkeepTriggeredAbility(new DiscardTargetEffect(new PermanentsOnBattlefieldCount(filter)), TargetController.YOU, false);§ability.addTarget(new TargetOpponent());§this.addAbility(ability);§}§public HondenOfNightsReach(final HondenOfNightsReach card) {§super(card);§}§@Override§public HondenOfNightsReach copy() {§return new HondenOfNightsReach(this);§}§}§
public class HondenOfSeeingWinds extends CardImpl {§final static FilterControlledPermanent filter = new FilterControlledPermanent("Shrine");§static {§filter.add(new SubtypePredicate("Shrine"));§}§public HondenOfSeeingWinds(UUID ownerId) {§super(ownerId, 69, "Honden of Seeing Winds", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{4}{U}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Shrine");§this.addAbility(new BeginningOfUpkeepTriggeredAbility(new DrawCardSourceControllerEffect(new PermanentsOnBattlefieldCount(filter)), TargetController.YOU, false));§}§public HondenOfSeeingWinds(final HondenOfSeeingWinds card) {§super(card);§}§@Override§public HondenOfSeeingWinds copy() {§return new HondenOfSeeingWinds(this);§}§}§
public class HonorWornShaku extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("untapped legendary permanent");§static {§filter.add(Predicates.not(new TappedPredicate()));§filter.add(new SupertypePredicate("Legendary"));§}§public HonorWornShaku(UUID ownerId) {§super(ownerId, 254, "Honor-Worn Shaku", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "CHK";§this.addAbility(new ColorlessManaAbility());§Ability ability = new SimpleActivatedAbility(§Zone.BATTLEFIELD,§new UntapSourceEffect(),§new TapTargetCost(new TargetControlledPermanent(filter)));§this.addAbility(ability);§}§public HonorWornShaku(final HonorWornShaku card) {§super(card);§}§@Override§public HonorWornShaku copy() {§return new HonorWornShaku(this);§}§}§
public class HorizonSeed extends CardImpl {§private static final FilterSpiritOrArcaneCard filter = new FilterSpiritOrArcaneCard();§public HorizonSeed(UUID ownerId) {§super(ownerId, 15, "Horizon Seed", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{W}");§this.expansionSetCode = "CHK";§this.subtype.add("Spirit");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§Ability ability = new SpellCastControllerTriggeredAbility(new RegenerateTargetEffect(), filter, false);§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public HorizonSeed(final HorizonSeed card) {§super(card);§}§@Override§public HorizonSeed copy() {§return new HorizonSeed(this);§}§}§
public class HorobiDeathsWail extends CardImpl {§public HorobiDeathsWail(UUID ownerId) {§super(ownerId, 117, "Horobi, Death's Wail", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{B}{B}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Spirit");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new HorobiDeathsWailAbility(new DestroyTargetEffect()));§}§public HorobiDeathsWail(final HorobiDeathsWail card) {§super(card);§}§@Override§public HorobiDeathsWail copy() {§return new HorobiDeathsWail(this);§}§}§class HorobiDeathsWailAbility extends TriggeredAbilityImpl {§public HorobiDeathsWailAbility(Effect effect) {§super(Zone.BATTLEFIELD, effect);§}§public HorobiDeathsWailAbility(final HorobiDeathsWailAbility ability) {§super(ability);§}§@Override§public HorobiDeathsWailAbility copy() {§return new HorobiDeathsWailAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.TARGETED;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§Permanent creature = game.getPermanent(event.getTargetId());§if (creature != null && creature.getCardType().contains(CardType.CREATURE)) {§getEffects().get(0).setTargetPointer(new FixedTarget(event.getTargetId()));§return true;§}§return false;§}§@Override§public String getRule() {§return "Whenever a creature becomes the target of a spell or ability, destroy that creature.";§}§}§
public class HumbleBudoka extends CardImpl {§public HumbleBudoka (UUID ownerId) {§super(ownerId, 214, "Humble Budoka", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "CHK";§this.subtype.add("Human");§this.subtype.add("Monk");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(ShroudAbility.getInstance());§}§public HumbleBudoka (final HumbleBudoka card) {§super(card);§}§@Override§public HumbleBudoka copy() {§return new HumbleBudoka(this);§}§}§
public class HundredTalonKami extends CardImpl {§public HundredTalonKami (UUID ownerId) {§super(ownerId, 16, "Hundred-Talon Kami", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{W}");§this.expansionSetCode = "CHK";§this.subtype.add("Spirit");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new SoulshiftAbility(4));§}§public HundredTalonKami (final HundredTalonKami card) {§super(card);§}§@Override§public HundredTalonKami copy() {§return new HundredTalonKami(this);§}§}§
public class ImiStatue extends CardImpl {§public ImiStatue(UUID ownerId) {§super(ownerId, 255, "Imi Statue", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "CHK";§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new ImiStatueEffect()));§}§public ImiStatue(final ImiStatue card) {§super(card);§}§@Override§public ImiStatue copy() {§return new ImiStatue(this);§}§}§class ImiStatueEffect extends RestrictionUntapNotMoreThanEffect {§private static final FilterControlledPermanent filter = new FilterControlledArtifactPermanent("an artifact");§public ImiStatueEffect() {§super(Duration.WhileOnBattlefield, 1, filter);§staticText = "Players can't untap more than one artifact during their untap steps";§}§public ImiStatueEffect(final ImiStatueEffect effect) {§super(effect);§}§@Override§public boolean applies(Player player, Ability source, Game game) {§return true;§}§@Override§public ImiStatueEffect copy() {§return new ImiStatueEffect(this);§}§}§
public class InameDeathAspect extends CardImpl {§public InameDeathAspect(UUID ownerId) {§super(ownerId, 118, "Iname, Death Aspect", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{B}{B}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Spirit");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(new EntersBattlefieldTriggeredAbility(new InameDeathAspectEffect(), true));§}§public InameDeathAspect(final InameDeathAspect card) {§super(card);§}§@Override§public InameDeathAspect copy() {§return new InameDeathAspect(this);§}§}§class InameDeathAspectEffect extends SearchEffect {§private static final FilterCreatureCard filter = new FilterCreatureCard();§static {§filter.add(new SubtypePredicate("Spirit"));§}§public InameDeathAspectEffect() {§super(new TargetCardInLibrary(0, Integer.MAX_VALUE, filter), Outcome.Neutral);§staticText = "search your library for any number of Spirit cards and put them into your graveyard. If you do, shuffle your library";§}§public InameDeathAspectEffect(final InameDeathAspectEffect effect) {§super(effect);§}§@Override§public InameDeathAspectEffect copy() {§return new InameDeathAspectEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player != null && player.searchLibrary(target, game)) {§if (target.getTargets().size() > 0) {§player.moveCards(new CardsImpl(target.getTargets()), Zone.LIBRARY, Zone.GRAVEYARD, source, game);§}§player.shuffleLibrary(game);§return true;§}§return false;§}§}§
public class InameLifeAspect extends CardImpl {§private static final FilterCard filter = new FilterCard("Spirit cards from your graveyard");§static {§filter.add(new SubtypePredicate("Spirit"));§}§public InameLifeAspect(UUID ownerId) {§super(ownerId, 215, "Iname, Life Aspect", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{G}{G}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Spirit");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§Ability ability = new DiesTriggeredAbility(new InameLifeAspectEffect(), false);§ability.addTarget(new TargetCardInYourGraveyard(0, Integer.MAX_VALUE, filter));§this.addAbility(ability);§}§public InameLifeAspect(final InameLifeAspect card) {§super(card);§}§@Override§public InameLifeAspect copy() {§return new InameLifeAspect(this);§}§}§class InameLifeAspectEffect extends OneShotEffect {§public InameLifeAspectEffect() {§super(Outcome.Benefit);§this.staticText = "you may exile it. If you do, return any number of target Spirit cards from your graveyard to your hand";§}§public InameLifeAspectEffect(final InameLifeAspectEffect effect) {§super(effect);§}§@Override§public InameLifeAspectEffect copy() {§return new InameLifeAspectEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§MageObject sourceObject = game.getObject(source.getSourceId());§if (controller != null && sourceObject != null) {§if (controller.chooseUse(outcome, "Exile " + sourceObject.getLogName() + " to return Spirit cards?", source, game)) {§Effect effect = new ReturnToHandTargetEffect();§effect.setTargetPointer(getTargetPointer());§effect.getTargetPointer().init(game, source);§new ExileSourceEffect().apply(game, source);§return effect.apply(game, source);§}§return true;§}§return false;§}§}§
public class IndomitableWill extends CardImpl {§public IndomitableWill (UUID ownerId) {§super(ownerId, 17, "Indomitable Will", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{W}");§this.expansionSetCode = "CHK";§this.subtype.add("Aura");§this.addAbility(FlashAbility.getInstance());§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(1, 2, Duration.WhileOnBattlefield)));§}§public IndomitableWill (final IndomitableWill card) {§super(card);§}§@Override§public IndomitableWill copy() {§return new IndomitableWill(this);§}§}§
public class InitiateOfBlood extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature that was dealt damage this turn");§static {§filter.add(new WasDealtDamageThisTurnPredicate());§}§public InitiateOfBlood(UUID ownerId) {§super(ownerId, 173, "Initiate of Blood", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{R}");§this.expansionSetCode = "CHK";§this.subtype.add("Ogre");§this.subtype.add("Shaman");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.flipCard = true;§this.flipCardName = "Goka the Unjust";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(1), new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent(filter));§this.addAbility(ability);§this.addAbility(new DiesAndDealtDamageThisTurnTriggeredAbility(new FlipSourceEffect(new GokaTheUnjust())));§}§public InitiateOfBlood(final InitiateOfBlood card) {§super(card);§}§@Override§public InitiateOfBlood copy() {§return new InitiateOfBlood(this);§}§}§class GokaTheUnjust extends Token {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature that was dealt damage this turn");§static {§filter.add(new WasDealtDamageThisTurnPredicate());§}§GokaTheUnjust() {§super("Goka the Unjust", "");§supertype.add("Legendary");§cardType.add(CardType.CREATURE);§color.setRed(true);§subtype.add("Ogre");§subtype.add("Shaman");§power = new MageInt(4);§toughness = new MageInt(4);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(4), new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent(filter));§this.addAbility(ability);§}§}§
public class JadeIdol extends CardImpl {§private static final FilterSpiritOrArcaneCard filter = new FilterSpiritOrArcaneCard();§public JadeIdol(UUID ownerId) {§super(ownerId, 256, "Jade Idol", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{4}");§this.expansionSetCode = "CHK";§this.addAbility(new SpellCastControllerTriggeredAbility(new BecomesCreatureSourceEffect(new JadeIdolToken(), "", Duration.EndOfTurn), filter, false));§}§public JadeIdol(final JadeIdol card) {§super(card);§}§@Override§public JadeIdol copy() {§return new JadeIdol(this);§}§}§class JadeIdolToken extends Token {§JadeIdolToken() {§super("", "4/4 Spirit artifact creature");§cardType.add(CardType.ARTIFACT);§cardType.add(CardType.CREATURE);§subtype.add("Spirit");§power = new MageInt(4);§toughness = new MageInt(4);§}§}§
public class JourneyersKite extends CardImpl {§private static final FilterBasicLandCard filter = new FilterBasicLandCard();§public JourneyersKite (UUID ownerId) {§super(ownerId, 257, "Journeyer's Kite", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{2}");§this.expansionSetCode = "CHK";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,§new SearchLibraryPutInHandEffect(new TargetCardInLibrary(filter), true),§new GenericManaCost(3));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§}§public JourneyersKite (final JourneyersKite card) {§super(card);§}§@Override§public JourneyersKite copy() {§return new JourneyersKite(this);§}§}§
public class JoyousRespite extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledLandPermanent();§public JoyousRespite (UUID ownerId) {§super(ownerId, 216, "Joyous Respite", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{3}{G}");§this.expansionSetCode = "CHK";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new GainLifeEffect(new PermanentsOnBattlefieldCount(filter)));§}§public JoyousRespite (final JoyousRespite card) {§super(card);§}§@Override§public JoyousRespite copy() {§return new JoyousRespite(this);§}§}§
public class JuganTheRisingStar extends CardImpl {§public JuganTheRisingStar(UUID ownerId) {§super(ownerId, 217, "Jugan, the Rising Star", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{G}{G}{G}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Dragon");§this.subtype.add("Spirit");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new DiesTriggeredAbility(new DistributeCountersEffect(CounterType.P1P1, 5, false, "any number of target creatures"), true);§ability.addTarget(new TargetCreaturePermanentAmount(5));§this.addAbility(ability);§}§public JuganTheRisingStar(final JuganTheRisingStar card) {§super(card);§}§@Override§public JuganTheRisingStar copy() {§return new JuganTheRisingStar(this);§}§}§
public class JukaiMessenger extends CardImpl {§public JukaiMessenger (UUID ownerId) {§super(ownerId, 218, "Jukai Messenger", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{G}");§this.expansionSetCode = "CHK";§this.subtype.add("Human");§this.subtype.add("Monk");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new ForestwalkAbility());§}§public JukaiMessenger (final JukaiMessenger card) {§super(card);§}§@Override§public JukaiMessenger copy() {§return new JukaiMessenger(this);§}§}§
public class JunkyoBell extends CardImpl {§public JunkyoBell(UUID ownerId) {§super(ownerId, 258, "Junkyo Bell", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{4}");§this.expansionSetCode = "CHK";§PermanentsOnBattlefieldCount amount = new PermanentsOnBattlefieldCount(new FilterControlledCreaturePermanent());§Ability ability = new BeginningOfUpkeepTriggeredAbility(new BoostTargetEffect(amount, amount, Duration.EndOfTurn), TargetController.YOU, true);§ability.addTarget(new TargetControlledCreaturePermanent());§ability.addEffect(new JunkyoBellSacrificeEffect());§this.addAbility(ability);§}§public JunkyoBell(final JunkyoBell card) {§super(card);§}§@Override§public JunkyoBell copy() {§return new JunkyoBell(this);§}§private class JunkyoBellSacrificeEffect extends OneShotEffect {§public JunkyoBellSacrificeEffect() {§super(Outcome.Sacrifice);§this.staticText = "If you do, sacrifice that creature at the beginning of the next end step";§}§public JunkyoBellSacrificeEffect(final JunkyoBellSacrificeEffect effect) {§super(effect);§}§@Override§public JunkyoBellSacrificeEffect copy() {§return new JunkyoBellSacrificeEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent creature = game.getPermanent(source.getFirstTarget());§if (creature != null) {§SacrificeTargetEffect sacrificeEffect = new SacrificeTargetEffect("sacrifice boosted " + creature.getName(), source.getControllerId());§sacrificeEffect.setTargetPointer(new FixedTarget(creature, game));§DelayedTriggeredAbility delayedAbility = new AtTheBeginOfNextEndStepDelayedTriggeredAbility(sacrificeEffect);§game.addDelayedTriggeredAbility(delayedAbility, source);§return true;§}§return false;§}§}§}§
public class JushiApprentice extends CardImpl {§public JushiApprentice(UUID ownerId) {§super(ownerId, 70, "Jushi Apprentice", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{U}");§this.expansionSetCode = "CHK";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§this.flipCard = true;§this.flipCardName = "Tomoya the Revealer";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DrawCardSourceControllerEffect(1), new ManaCostsImpl("{2}{U}"));§ability.addCost(new TapSourceCost());§ability.addEffect(new ConditionalOneShotEffect(new FlipSourceEffect(new TomoyaTheRevealer()), new CardsInHandCondition(CountType.MORE_THAN, 8),§"If you have nine or more cards in hand, flip {this}"));§this.addAbility(ability);§}§public JushiApprentice(final JushiApprentice card) {§super(card);§}§@Override§public JushiApprentice copy() {§return new JushiApprentice(this);§}§}§class TomoyaTheRevealer extends Token {§TomoyaTheRevealer() {§super("Tomoya the Revealer", "");§supertype.add("Legendary");§cardType.add(CardType.CREATURE);§color.setBlue(true);§subtype.add("Human");§subtype.add("Wizard");§power = new MageInt(2);§toughness = new MageInt(3);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DrawCardTargetEffect(new CardsInControllerHandCount()), new ManaCostsImpl("{3}{U}{U}"));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§}§}§
public class KabutoMoth extends CardImpl {§public KabutoMoth(UUID ownerId) {§super(ownerId, 20, "Kabuto Moth", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "CHK";§this.subtype.add("Spirit");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostTargetEffect(1, 2, Duration.EndOfTurn), new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public KabutoMoth(final KabutoMoth card) {§super(card);§}§@Override§public KabutoMoth copy() {§return new KabutoMoth(this);§}§}§
public class KamiOfAncientLaw extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("enchantment");§static {§filter.add(new CardTypePredicate(CardType.ENCHANTMENT));§}§public KamiOfAncientLaw (UUID ownerId) {§super(ownerId, 21, "Kami of Ancient Law", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "CHK";§this.subtype.add("Spirit");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DestroyTargetEffect(), new SacrificeSourceCost());§ability.addTarget(new TargetPermanent(filter));§this.addAbility(ability);§}§public KamiOfAncientLaw (final KamiOfAncientLaw card) {§super(card);§}§@Override§public KamiOfAncientLaw copy() {§return new KamiOfAncientLaw(this);§}§}§
public class KamiOfFiresRoar extends CardImpl {§private static final FilterSpiritOrArcaneCard filter = new FilterSpiritOrArcaneCard();§public KamiOfFiresRoar(UUID ownerId) {§super(ownerId, 174, "Kami of Fire's Roar", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{R}");§this.expansionSetCode = "CHK";§this.subtype.add("Spirit");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§Ability ability = new SpellCastControllerTriggeredAbility(new CantBlockTargetEffect(Duration.EndOfTurn), filter, false);§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public KamiOfFiresRoar(final KamiOfFiresRoar card) {§super(card);§}§@Override§public KamiOfFiresRoar copy() {§return new KamiOfFiresRoar(this);§}§}§
public class KamiOfLunacy extends CardImpl {§public KamiOfLunacy(UUID ownerId) {§super(ownerId, 119, "Kami of Lunacy", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{B}{B}");§this.expansionSetCode = "CHK";§this.subtype.add("Spirit");§this.power = new MageInt(4);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new SoulshiftAbility(5));§}§public KamiOfLunacy(final KamiOfLunacy card) {§super(card);§}§@Override§public KamiOfLunacy copy() {§return new KamiOfLunacy(this);§}§}§
public class KamiOfOldStone extends CardImpl {§public KamiOfOldStone (UUID ownerId) {§super(ownerId, 22, "Kami of Old Stone", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{W}");§this.expansionSetCode = "CHK";§this.subtype.add("Spirit");§this.power = new MageInt(1);§this.toughness = new MageInt(7);§}§public KamiOfOldStone (final KamiOfOldStone card) {§super(card);§}§@Override§public KamiOfOldStone copy() {§return new KamiOfOldStone(this);§}§}§
public class KamiOfTheHunt extends CardImpl {§private static final FilterSpiritOrArcaneCard filter = new FilterSpiritOrArcaneCard();§public KamiOfTheHunt(UUID ownerId) {§super(ownerId, 219, "Kami of the Hunt", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{G}");§this.expansionSetCode = "CHK";§this.subtype.add("Spirit");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new SpellCastControllerTriggeredAbility(new BoostSourceEffect(1, 1, Duration.EndOfTurn), filter, false));§}§public KamiOfTheHunt(final KamiOfTheHunt card) {§super(card);§}§@Override§public KamiOfTheHunt copy() {§return new KamiOfTheHunt(this);§}§}§
public class KamiOfThePaintedRoad extends CardImpl {§private static final FilterSpiritOrArcaneCard filter = new FilterSpiritOrArcaneCard();§public KamiOfThePaintedRoad(UUID ownerId) {§super(ownerId, 23, "Kami of the Painted Road", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{W}");§this.expansionSetCode = "CHK";§this.subtype.add("Spirit");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new SpellCastControllerTriggeredAbility(new GainProtectionFromColorSourceEffect(Duration.EndOfTurn), filter, false));§}§public KamiOfThePaintedRoad(final KamiOfThePaintedRoad card) {§super(card);§}§@Override§public KamiOfThePaintedRoad copy() {§return new KamiOfThePaintedRoad(this);§}§}§
public class KamiOfThePalaceFields extends CardImpl {§public KamiOfThePalaceFields(UUID ownerId) {§super(ownerId, 24, "Kami of the Palace Fields", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{5}{W}");§this.expansionSetCode = "CHK";§this.subtype.add("Spirit");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(FirstStrikeAbility.getInstance());§this.addAbility(new SoulshiftAbility(5));§}§public KamiOfThePalaceFields(final KamiOfThePalaceFields card) {§super(card);§}§@Override§public KamiOfThePalaceFields copy() {§return new KamiOfThePalaceFields(this);§}§}§
public class KamiOfTheWaningMoon extends CardImpl {§private static final FilterSpiritOrArcaneCard filter = new FilterSpiritOrArcaneCard();§public KamiOfTheWaningMoon(UUID ownerId) {§super(ownerId, 120, "Kami of the Waning Moon", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{B}");§this.expansionSetCode = "CHK";§this.subtype.add("Spirit");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new SpellCastControllerTriggeredAbility(new GainAbilityTargetEffect(FearAbility.getInstance(), Duration.EndOfTurn), filter, false);§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public KamiOfTheWaningMoon(final KamiOfTheWaningMoon card) {§super(card);§}§@Override§public KamiOfTheWaningMoon copy() {§return new KamiOfTheWaningMoon(this);§}§}§
public class KamiOfTwistedReflection extends CardImpl {§public KamiOfTwistedReflection(UUID ownerId) {§super(ownerId, 71, "Kami of Twisted Reflection", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{U}{U}");§this.expansionSetCode = "CHK";§this.subtype.add("Spirit");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ReturnToHandTargetEffect(), new SacrificeSourceCost());§ability.addTarget(new TargetControlledCreaturePermanent());§this.addAbility(ability);§}§public KamiOfTwistedReflection(final KamiOfTwistedReflection card) {§super(card);§}§@Override§public KamiOfTwistedReflection copy() {§return new KamiOfTwistedReflection(this);§}§}§
public class KashiTribeReaver extends CardImpl {§public KashiTribeReaver(UUID ownerId) {§super(ownerId, 220, "Kashi-Tribe Reaver", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{G}");§this.expansionSetCode = "CHK";§this.subtype.add("Snake");§this.subtype.add("Warrior");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§Ability ability;§ability = new DealsDamageToACreatureTriggeredAbility(new TapTargetEffect("that creature"), true, false, true);§ability.addEffect(new DontUntapInControllersNextUntapStepTargetEffect("and it"));§this.addAbility(ability);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new RegenerateSourceEffect(), new ManaCostsImpl("{1}{G}")));§}§public KashiTribeReaver(final KashiTribeReaver card) {§super(card);§}§@Override§public KashiTribeReaver copy() {§return new KashiTribeReaver(this);§}§}§
public class KikiJikiMirrorBreaker extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("nonlegendary creature you control");§static {§filter.add(Predicates.not(new SupertypePredicate("Legendary")));§}§public KikiJikiMirrorBreaker(UUID ownerId) {§super(ownerId, 175, "Kiki-Jiki, Mirror Breaker", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{R}{R}{R}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Goblin");§this.subtype.add("Shaman");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(HasteAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new KikiJikiMirrorBreakerEffect(), new TapSourceCost());§ability.addTarget(new TargetControlledCreaturePermanent(1, 1, filter, false));§this.addAbility(ability);§}§public KikiJikiMirrorBreaker(final KikiJikiMirrorBreaker card) {§super(card);§}§@Override§public KikiJikiMirrorBreaker copy() {§return new KikiJikiMirrorBreaker(this);§}§}§class KikiJikiMirrorBreakerEffect extends OneShotEffect {§public KikiJikiMirrorBreakerEffect() {§super(Outcome.PutCreatureInPlay);§this.staticText = "Put a token that's a copy of target nonlegendary creature you control onto the battlefield. That token has haste. Sacrifice it at the beginning of the next end step";§}§public KikiJikiMirrorBreakerEffect(final KikiJikiMirrorBreakerEffect effect) {§super(effect);§}§@Override§public KikiJikiMirrorBreakerEffect copy() {§return new KikiJikiMirrorBreakerEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getPermanentOrLKIBattlefield(source.getFirstTarget());§if (permanent != null) {§PutTokenOntoBattlefieldCopyTargetEffect effect = new PutTokenOntoBattlefieldCopyTargetEffect(source.getControllerId(), null, true);§effect.setTargetPointer(new FixedTarget(permanent, game));§effect.apply(game, source);§for (Permanent addedToken : effect.getAddedPermanent()) {§SacrificeTargetEffect sacrificeEffect = new SacrificeTargetEffect("Sacrifice the token at the beginning of the next end step", source.getControllerId());§sacrificeEffect.setTargetPointer(new FixedTarget(addedToken.getId()));§DelayedTriggeredAbility delayedAbility = new AtTheBeginOfNextEndStepDelayedTriggeredAbility(sacrificeEffect);§delayedAbility.setSourceId(source.getSourceId());§delayedAbility.setControllerId(source.getControllerId());§delayedAbility.setSourceObject(source.getSourceObject(game), game);§game.addDelayedTriggeredAbility(delayedAbility);§}§return true;§}§return false;§}§}§
public class KikuNightsFlower extends CardImpl {§public KikuNightsFlower (UUID ownerId) {§super(ownerId, 121, "Kiku, Night's Flower", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{B}{B}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Assassin");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability;§ability = new SimpleActivatedAbility(§Zone.BATTLEFIELD,§new KikuNightsFlowerEffect(),§new ManaCostsImpl("{2}{B}{B}")§);§ability.addTarget(new TargetCreaturePermanent());§ability.addCost(new TapSourceCost());§this.addAbility(ability);§}§public KikuNightsFlower (final KikuNightsFlower card) {§super(card);§}§@Override§public KikuNightsFlower copy() {§return new KikuNightsFlower(this);§}§}§class KikuNightsFlowerEffect extends OneShotEffect {§public KikuNightsFlowerEffect() {§super(Outcome.Damage);§this.staticText = "Target creature deals damage to itself equal to its power";§}§public KikuNightsFlowerEffect(final KikuNightsFlowerEffect effect) {§super(effect);§}§@Override§public KikuNightsFlowerEffect copy() {§return new KikuNightsFlowerEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getPermanent(targetPointer.getFirst(game, source));§if (permanent != null) {§permanent.damage(permanent.getPower().getValue(), permanent.getId(), game, false, true);§return true;§}§return false;§}§}§
public class KitsuneBlademaster extends CardImpl {§public KitsuneBlademaster (UUID ownerId) {§super(ownerId, 25, "Kitsune Blademaster", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "CHK";§this.subtype.add("Fox");§this.subtype.add("Samurai");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FirstStrikeAbility.getInstance());§this.addAbility(new BushidoAbility(1));§}§public KitsuneBlademaster (final KitsuneBlademaster card) {§super(card);§}§@Override§public KitsuneBlademaster copy() {§return new KitsuneBlademaster(this);§}§}§
public class KitsuneDiviner extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("Spirit");§static {§filter.add(new SubtypePredicate("Spirit"));§}§public KitsuneDiviner (UUID ownerId) {§super(ownerId, 26, "Kitsune Diviner", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{W}");§this.expansionSetCode = "CHK";§this.subtype.add("Fox");§this.subtype.add("Cleric");§this.power = new MageInt(0);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new TapTargetEffect(), new TapSourceCost());§ability.addTarget(new TargetPermanent(filter));§this.addAbility(ability);§}§public KitsuneDiviner (final KitsuneDiviner card) {§super(card);§}§@Override§public KitsuneDiviner copy() {§return new KitsuneDiviner(this);§}§}§
public class KitsuneHealer extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("legendary creature");§static {§filter.add(new SupertypePredicate("Legendary"));§}§public KitsuneHealer(UUID ownerId) {§super(ownerId, 27, "Kitsune Healer", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{W}");§this.expansionSetCode = "CHK";§this.subtype.add("Fox");§this.subtype.add("Cleric");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability firstAbility = new SimpleActivatedAbility(Zone.BATTLEFIELD, new PreventDamageToTargetEffect(Duration.EndOfTurn, 1), new TapSourceCost());§firstAbility.addTarget(new TargetCreatureOrPlayer());§this.addAbility(firstAbility);§Ability secondAbility = new SimpleActivatedAbility(Zone.BATTLEFIELD, new PreventDamageToTargetEffect(Duration.EndOfTurn, Integer.MAX_VALUE), new TapSourceCost());§secondAbility.addTarget(new TargetCreaturePermanent(filter));§this.addAbility(secondAbility);§}§public KitsuneHealer(final KitsuneHealer card) {§super(card);§}§@Override§public KitsuneHealer copy() {§return new KitsuneHealer(this);§}§}§
public class KitsuneMystic extends CardImpl {§public KitsuneMystic(UUID ownerId) {§super(ownerId, 28, "Kitsune Mystic", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{W}");§this.expansionSetCode = "CHK";§this.subtype.add("Fox");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.flipCard = true;§this.flipCardName = "Autumn-Tail, Kitsune Sage";§this.addAbility(new ConditionalTriggeredAbility(§new OnEventTriggeredAbility(GameEvent.EventType.END_TURN_STEP_PRE, "beginning of the end step", true, new FlipSourceEffect(new AutumnTailKitsuneSage())),§new EnchantedCondition(2), "At the beginning of the end step, if {this} is enchanted by two or more Auras, flip it."));§}§public KitsuneMystic(final KitsuneMystic card) {§super(card);§}§@Override§public KitsuneMystic copy() {§return new KitsuneMystic(this);§}§}§class AutumnTailKitsuneSage extends Token {§private static final FilterEnchantmentPermanent filter = new FilterEnchantmentPermanent("Aura attached to a creature");§static {§filter.add(new AttachmentAttachedToCardTypePredicate(CardType.CREATURE));§filter.add(new SubtypePredicate("Aura"));§}§AutumnTailKitsuneSage() {§super("Autumn-Tail, Kitsune Sage", "");§supertype.add("Legendary");§cardType.add(CardType.CREATURE);§color.setWhite(true);§subtype.add("Fox");§subtype.add("Wizard");§power = new MageInt(4);§toughness = new MageInt(5);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new AutumnTailEffect(), new GenericManaCost(1));§ability.addTarget(new TargetPermanent(filter));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§}§class AttachmentAttachedToCardTypePredicate implements Predicate<Permanent> {§private final CardType cardType;§public AttachmentAttachedToCardTypePredicate(CardType cardType) {§this.cardType = cardType;§}§@Override§public boolean apply(Permanent input, Game game) {§if (input.getAttachedTo() != null) {§Permanent attachedTo = game.getPermanent(input.getAttachedTo());§if (attachedTo != null && attachedTo.getCardType().contains(cardType)) {§return true;§}§}§return false;§}§@Override§public String toString() {§return "AttachmentAttachedToCardType(" + cardType + ')';§}§}§class AutumnTailEffect extends OneShotEffect {§public AutumnTailEffect() {§super(Outcome.BoostCreature);§this.staticText = "Attach target Aura attached to a creature to another creature";§}§public AutumnTailEffect(final AutumnTailEffect effect) {§super(effect);§}§@Override§public AutumnTailEffect copy() {§return new AutumnTailEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent aura = game.getPermanent(source.getFirstTarget());§Permanent creature = game.getPermanent(source.getTargets().get(1).getFirstTarget());§if (aura != null && creature != null) {§Permanent oldCreature = game.getPermanent(aura.getAttachedTo());§if (oldCreature == null || oldCreature.equals(creature)) {§return false;§}§if (oldCreature.removeAttachment(aura.getId(), game)) {§return creature.addAttachment(aura.getId(), game);§}§}§return false;§}§}§
public class KitsuneRiftwalker extends CardImpl {§private static final FilterCard filter = new FilterCard("Spirits and from Arcane");§static {§filter.add(Predicates.or(new SubtypePredicate("Arcane"), new SubtypePredicate("Spirit")));§}§public KitsuneRiftwalker(UUID ownerId) {§super(ownerId, 29, "Kitsune Riftwalker", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{W}{W}");§this.expansionSetCode = "CHK";§this.subtype.add("Fox");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new ProtectionAbility(filter));§}§public KitsuneRiftwalker(final KitsuneRiftwalker card) {§super(card);§}§@Override§public KitsuneRiftwalker copy() {§return new KitsuneRiftwalker(this);§}§}§
public class KodamaOfTheNorthTree extends CardImpl {§public KodamaOfTheNorthTree (UUID ownerId) {§super(ownerId, 222, "Kodama of the North Tree", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{G}{G}{G}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Spirit");§this.power = new MageInt(6);§this.toughness = new MageInt(4);§this.addAbility(TrampleAbility.getInstance());§this.addAbility(ShroudAbility.getInstance());§}§public KodamaOfTheNorthTree (final KodamaOfTheNorthTree card) {§super(card);§}§@Override§public KodamaOfTheNorthTree copy() {§return new KodamaOfTheNorthTree(this);§}§}§
public class KodamaOfTheSouthTree extends CardImpl {§private static final FilterSpiritOrArcaneCard filter = new FilterSpiritOrArcaneCard();§public KodamaOfTheSouthTree(UUID ownerId) {§super(ownerId, 223, "Kodama of the South Tree", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{G}{G}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Spirit");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§Ability ability = new SpellCastControllerTriggeredAbility(new BoostControlledEffect(1, 1, Duration.EndOfTurn, new FilterCreaturePermanent(), true), filter, false);§ability.addEffect(new GainAbilityControlledEffect(TrampleAbility.getInstance(), Duration.EndOfTurn, new FilterCreaturePermanent(), true));§this.addAbility(ability);§}§public KodamaOfTheSouthTree(final KodamaOfTheSouthTree card) {§super(card);§}§@Override§public KodamaOfTheSouthTree copy() {§return new KodamaOfTheSouthTree(this);§}§}§
public class KodamasMight extends CardImpl {§public KodamasMight(UUID ownerId) {§super(ownerId, 224, "Kodama's Might", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{G}");§this.expansionSetCode = "CHK";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new BoostTargetEffect(2,2, Duration.EndOfTurn));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.addAbility(new SpliceOntoArcaneAbility("{G}"));§}§public KodamasMight(final KodamasMight card) {§super(card);§}§@Override§public KodamasMight copy() {§return new KodamasMight(this);§}§}§
public class KokushoTheEveningStar extends CardImpl {§public KokushoTheEveningStar(UUID ownerId) {§super(ownerId, 122, "Kokusho, the Evening Star", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{B}{B}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Dragon");§this.subtype.add("Spirit");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new DiesTriggeredAbility(new KokushoTheEveningStarEffect(), false));§}§public KokushoTheEveningStar(final KokushoTheEveningStar card) {§super(card);§}§@Override§public KokushoTheEveningStar copy() {§return new KokushoTheEveningStar(this);§}§}§class KokushoTheEveningStarEffect extends OneShotEffect {§public KokushoTheEveningStarEffect() {§super(Outcome.Damage);§staticText = "each opponent loses 5 life. You gain life equal to the life lost this way";§}§public KokushoTheEveningStarEffect(final KokushoTheEveningStarEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§int loseLife = 0;§for (UUID opponentId : game.getOpponents(source.getControllerId())) {§loseLife += game.getPlayer(opponentId).loseLife(5, game);§}§if (loseLife > 0)§game.getPlayer(source.getControllerId()).gainLife(loseLife, game);§return true;§}§@Override§public KokushoTheEveningStarEffect copy() {§return new KokushoTheEveningStarEffect(this);§}§}§
public class KondaLordOfEiganjo extends CardImpl {§public KondaLordOfEiganjo(UUID ownerId) {§super(ownerId, 30, "Konda, Lord of Eiganjo", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}{W}{W}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Samurai");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(VigilanceAbility.getInstance());§this.addAbility(new BushidoAbility(5));§this.addAbility(IndestructibleAbility.getInstance());§}§public KondaLordOfEiganjo(final KondaLordOfEiganjo card) {§super(card);§}§@Override§public KondaLordOfEiganjo copy() {§return new KondaLordOfEiganjo(this);§}§}§
public class KondasBanner extends CardImpl {§private static final FilterControlledCreaturePermanent legendaryFilter = new FilterControlledCreaturePermanent("Legendary creatures");§static {§legendaryFilter.add(new SupertypePredicate("Legendary"));§}§public KondasBanner(UUID ownerId) {§super(ownerId, 259, "Konda's Banner", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{2}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Equipment");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new InfoEffect("{this} can be attached only to a legendary creature")));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new KondasBannerColorBoostEffect()));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new KondasBannerTypeBoostEffect()));§this.addAbility(new EquipAbility(§Outcome.AddAbility,§new GenericManaCost(2),§new TargetControlledCreaturePermanent(1, 1, legendaryFilter, false)));§}§public KondasBanner(final KondasBanner card) {§super(card);§}§@Override§public KondasBanner copy() {§return new KondasBanner(this);§}§}§class KondasBannerTypeBoostEffect extends BoostAllEffect {§private static final String effectText = "Creatures that share a creature type with equipped creature get +1/+1";§KondasBannerTypeBoostEffect() {§super(1, 1, Duration.WhileOnBattlefield, new FilterCreaturePermanent(), false);§staticText = effectText;§}§KondasBannerTypeBoostEffect(KondasBannerTypeBoostEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent equipment = game.getPermanent(source.getSourceId());§if (equipment != null && equipment.getAttachedTo() != null) {§Permanent equipedCreature = game.getPermanent(equipment.getAttachedTo());§if (equipedCreature != null) {§for (Permanent perm : game.getBattlefield().getActivePermanents(filter, source.getControllerId(), source.getSourceId(), game)) {§if (CardUtil.shareSubtypes(perm, equipedCreature)) {§perm.addPower(power.calculate(game, source, this));§perm.addToughness(toughness.calculate(game, source, this));§}§}§return true;§}§}§return false;§}§@Override§public KondasBannerTypeBoostEffect copy() {§return new KondasBannerTypeBoostEffect(this);§}§}§class KondasBannerColorBoostEffect extends BoostAllEffect {§private static final String effectText = "Creatures that share a color with equipped creature get +1/+1.";§KondasBannerColorBoostEffect() {§super(1, 1, Duration.WhileOnBattlefield, new FilterCreaturePermanent(), false);§staticText = effectText;§}§KondasBannerColorBoostEffect(KondasBannerColorBoostEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent equipment = game.getPermanent(source.getSourceId());§if (equipment != null && equipment.getAttachedTo() != null) {§Permanent equipedCreature = game.getPermanent(equipment.getAttachedTo());§if (equipedCreature != null) {§for (Permanent perm : game.getBattlefield().getActivePermanents(filter, source.getControllerId(), source.getSourceId(), game)) {§if (equipedCreature.getColor(game).shares(perm.getColor(game))) {§perm.addPower(power.calculate(game, source, this));§perm.addToughness(toughness.calculate(game, source, this));§}§}§return true;§}§}§return false;§}§@Override§public KondasBannerColorBoostEffect copy() {§return new KondasBannerColorBoostEffect(this);§}§}§
public class KondasHatamoto extends CardImpl{§private static final FilterControlledPermanent filter = new FilterControlledPermanent("Legendary Samurai");§private static final String rule1 = "As long as you control a legendary Samurai, {this} gets +1/+2";§private static final String rule2 = "As long as you control a legendary Samurai, {this} has vigilance";§static {§filter.add(new SupertypePredicate("Legendary"));§filter.add(new SubtypePredicate("Samurai"));§}§public KondasHatamoto (UUID ownerId) {§super(ownerId, 31, "Konda's Hatamoto", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "CHK";§this.subtype.add("Human");§this.subtype.add("Samurai");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§this.addAbility(new BushidoAbility(1));§ConditionalContinuousEffect effect1 = new ConditionalContinuousEffect(new BoostSourceEffect(1, 2, Duration.WhileOnBattlefield), new PermanentsOnTheBattlefieldCondition(filter), rule1);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, effect1));§ConditionalContinuousEffect effect2 = new ConditionalContinuousEffect(new GainAbilitySourceEffect(VigilanceAbility.getInstance()), new PermanentsOnTheBattlefieldCondition(filter), rule2);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, effect2));§}§public KondasHatamoto (final KondasHatamoto card) {§super(card);§}§@Override§public KondasHatamoto copy() {§return new KondasHatamoto(this);§}§}§
public class KumanoMasterYamabushi extends CardImpl {§public KumanoMasterYamabushi(UUID ownerId) {§super(ownerId, 176, "Kumano, Master Yamabushi", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{R}{R}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Shaman");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(1), new ManaCostsImpl("{1}{R}") );§ability.addTarget(new TargetCreatureOrPlayer());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new DealtDamageToCreatureBySourceDies(this, Duration.WhileOnBattlefield)), new DamagedByWatcher());§}§public KumanoMasterYamabushi(final KumanoMasterYamabushi card) {§super(card);§}§@Override§public KumanoMasterYamabushi copy() {§return new KumanoMasterYamabushi(this);§}§}§
public class KumanosPupils extends CardImpl {§public KumanosPupils(UUID ownerId) {§super(ownerId, 177, "Kumano's Pupils", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{R}");§this.expansionSetCode = "CHK";§this.subtype.add("Human");§this.subtype.add("Shaman");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new DealtDamageToCreatureBySourceDies(this, Duration.WhileOnBattlefield)), new DamagedByWatcher());§}§public KumanosPupils(final KumanosPupils card) {§super(card);§}§@Override§public KumanosPupils copy() {§return new KumanosPupils(this);§}§}§
public class KuroPitlord extends CardImpl {§public KuroPitlord(UUID ownerId) {§super(ownerId, 123, "Kuro, Pitlord", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{6}{B}{B}{B}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Demon");§this.subtype.add("Spirit");§this.power = new MageInt(9);§this.toughness = new MageInt(9);§this.addAbility(new BeginningOfUpkeepTriggeredAbility(new SacrificeSourceUnlessPaysEffect(new ManaCostsImpl("{B}{B}{B}{B}")), TargetController.YOU, false));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostTargetEffect(-1, -1, Duration.EndOfTurn), new PayLifeCost(1));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public KuroPitlord(final KuroPitlord card) {§super(card);§}§@Override§public KuroPitlord copy() {§return new KuroPitlord(this);§}§}§
public class KusariGama extends CardImpl {§public KusariGama(UUID ownerId) {§super(ownerId, 260, "Kusari-Gama", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "CHK";§this.subtype.add("Equipment");§Ability gainedAbility = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(1,0, Duration.EndOfTurn), new GenericManaCost(2));§Effect effect = new GainAbilityAttachedEffect(gainedAbility, AttachmentType.EQUIPMENT);§effect.setText("Equipped creature has \"{2}: This creature gets +1/+0 until end of turn.\"");§Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, effect);§this.addAbility(ability);§this.addAbility(new KusariGamaAbility());§this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(3)));§}§public KusariGama(final KusariGama card) {§super(card);§}§@Override§public KusariGama copy() {§return new KusariGama(this);§}§}§class KusariGamaAbility extends TriggeredAbilityImpl {§private static final FilterCreaturePermanent filter = new FilterBlockingCreature();§public KusariGamaAbility() {§super(Zone.BATTLEFIELD, new KusariGamaDamageEffect());§}§public KusariGamaAbility(final KusariGamaAbility ability) {§super(ability);§}§@Override§public KusariGamaAbility copy() {§return new KusariGamaAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.DAMAGED_CREATURE;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§Permanent sourcePermanet = game.getPermanent(event.getSourceId());§Permanent targetPermanet = game.getPermanent(event.getTargetId());§if (sourcePermanet != null && targetPermanet != null && sourcePermanet.getAttachments().contains(this.getSourceId()) && filter.match(targetPermanet, game)) {§this.getEffects().get(0).setValue("damageAmount", event.getAmount());§this.getEffects().get(0).setValue("damagedCreatureId", targetPermanet.getId());§return true;§}§return false;§}§@Override§public String getRule() {§return "Whenever equipped creature deals damage to a blocking creature, {this} deals that much damage to each other creature defending player controls.";§}§}§class KusariGamaDamageEffect extends OneShotEffect {§public KusariGamaDamageEffect() {§super(Outcome.Damage);§this.staticText = "{this} deals that much damage to each other creature defending player controls";§}§public KusariGamaDamageEffect(final KusariGamaDamageEffect effect) {§super(effect);§}§@Override§public KusariGamaDamageEffect copy() {§return new KusariGamaDamageEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Integer damage = (Integer) this.getValue("damageAmount");§if (damage != null && damage.intValue() > 0) {§UUID damagedCreatureId = (UUID) this.getValue("damagedCreatureId");§Permanent creature = game.getPermanent(damagedCreatureId);§if (creature == null) {§creature = (Permanent) game.getLastKnownInformation(damagedCreatureId, Zone.BATTLEFIELD);§}§if (creature != null) {§for (UUID blockerId : game.getCombat().getBlockers()) {§if (!blockerId.equals(damagedCreatureId)) {§Permanent blockingCreature = game.getPermanent(blockerId);§if (blockingCreature != null && blockingCreature.getControllerId().equals(creature.getControllerId())) {§blockingCreature.damage(damage, source.getSourceId(), game, false, true);§}§}§}§}§}§return false;§}§}§
public class LavaSpike extends CardImpl {§public LavaSpike (UUID ownerId) {§super(ownerId, 178, "Lava Spike", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{R}");§this.expansionSetCode = "CHK";§this.subtype.add("Arcane");§this.getSpellAbility().addTarget(new TargetPlayer());§this.getSpellAbility().addEffect(new DamageTargetEffect(3));§}§public LavaSpike (final LavaSpike card) {§super(card);§}§@Override§public LavaSpike copy() {§return new LavaSpike(this);§}§}§
public class LiftedByClouds extends CardImpl {§public LiftedByClouds(UUID ownerId) {§super(ownerId, 73, "Lifted by Clouds", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{U}");§this.expansionSetCode = "CHK";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new GainAbilityTargetEffect(FlyingAbility.getInstance(), Duration.EndOfTurn));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.addAbility(new SpliceOntoArcaneAbility("{1}{U}"));§}§public LiftedByClouds(final LiftedByClouds card) {§super(card);§}§@Override§public LiftedByClouds copy() {§return new LiftedByClouds(this);§}§}§
public class LongForgottenGohei extends CardImpl {§private static final FilterCard arcaneFilter = new FilterCard("Arcane spells");§private static final FilterCreaturePermanent spiritFilter = new FilterCreaturePermanent("Spirit creatures");§static {§arcaneFilter.add(new SubtypePredicate("Arcane"));§spiritFilter.add(new SubtypePredicate("Spirit"));§}§public LongForgottenGohei(UUID ownerId) {§super(ownerId, 261, "Long-Forgotten Gohei", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "CHK";§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new SpellsCostReductionControllerEffect(arcaneFilter, 1)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostControlledEffect(1, 1, Duration.WhileOnBattlefield, spiritFilter, false)));§}§public LongForgottenGohei(final LongForgottenGohei card) {§super(card);§}§@Override§public LongForgottenGohei copy() {§return new LongForgottenGohei(this);§}§}§
public class Lure extends CardImpl {§public Lure (UUID ownerId) {§super(ownerId, 226, "Lure", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{G}{G}");§this.expansionSetCode = "CHK";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new MustBeBlockedByAllAttachedEffect(AttachmentType.AURA)));§}§public Lure (final Lure card) {§super(card);§}§@Override§public Lure copy() {§return new Lure(this);§}§}§
public class ManaSeism extends CardImpl {§public ManaSeism(UUID ownerId) {§super(ownerId, 179, "Mana Seism", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{1}{R}");§this.expansionSetCode = "CHK";§this.getSpellAbility().addEffect(new ManaSeismEffect());§}§public ManaSeism(final ManaSeism card) {§super(card);§}§@Override§public ManaSeism copy() {§return new ManaSeism(this);§}§}§class ManaSeismEffect extends OneShotEffect {§public ManaSeismEffect() {§super(Outcome.Neutral);§staticText = "Sacrifice any number of lands. Add {C} to your mana pool for each land sacrificed this way";§}§public ManaSeismEffect(final ManaSeismEffect effect) {§super(effect);§}§@Override§public ManaSeismEffect copy() {§return new ManaSeismEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player == null){§return false;§}§int amount = 0;§TargetControlledPermanent sacrificeLand = new TargetControlledPermanent(0, Integer.MAX_VALUE, new FilterControlledLandPermanent(), true);§if(player.chooseTarget(Outcome.Sacrifice, sacrificeLand, source, game)){§for(Object uuid : sacrificeLand.getTargets()){§Permanent land = game.getPermanent((UUID)uuid);§if(land != null){§land.sacrifice(source.getSourceId(), game);§amount++;§}§}§}§player.getManaPool().addMana(Mana.ColorlessMana(amount), game, source);§return true;§}§}§
public class MarrowGnawer extends CardImpl {§private static final FilterCreaturePermanent filterFear = new FilterCreaturePermanent("Rat creatures");§private static final FilterControlledCreaturePermanent filterSacrifice = new FilterControlledCreaturePermanent("a Rat");§private static final FilterControlledCreaturePermanent filter3 = new FilterControlledCreaturePermanent("the number of Rats you control");§static {§SubtypePredicate ratPredicate = new SubtypePredicate("Rat");§filterFear.add(ratPredicate);§filterSacrifice.add(ratPredicate);§filter3.add(ratPredicate);§}§public MarrowGnawer (UUID ownerId) {§super(ownerId, 124, "Marrow-Gnawer", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{B}{B}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Rat");§this.subtype.add("Rogue");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAllEffect(FearAbility.getInstance(), Duration.WhileOnBattlefield, filterFear)));§Ability ability;§ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new CreateTokenEffect(new RatToken(),new PermanentsOnBattlefieldCount(filter3)), new SacrificeTargetCost(new TargetControlledPermanent(filterSacrifice)));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§}§public MarrowGnawer (final MarrowGnawer card) {§super(card);§}§@Override§public MarrowGnawer copy() {§return new MarrowGnawer(this);§}§}§
public class MasakoTheHumorless extends CardImpl {§public MasakoTheHumorless(UUID ownerId) {§super(ownerId, 33, "Masako the Humorless", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Advisor");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(FlashAbility.getInstance());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BlockTappedEffect()));§}§public MasakoTheHumorless(final MasakoTheHumorless card) {§super(card);§}§@Override§public MasakoTheHumorless copy() {§return new MasakoTheHumorless(this);§}§}§class BlockTappedEffect extends AsThoughEffectImpl {§public BlockTappedEffect() {§super(AsThoughEffectType.BLOCK_TAPPED, Duration.WhileOnBattlefield, Outcome.Benefit);§staticText ="Tapped creatures you control can block as though they were untapped";§}§public BlockTappedEffect(final BlockTappedEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public BlockTappedEffect copy() {§return new BlockTappedEffect(this);§}§@Override§public boolean applies(UUID sourceId, Ability source, UUID affectedControllerId, Game game) {§Permanent permanent = game.getPermanent(sourceId);§if (permanent != null && permanent.getControllerId().equals(source.getControllerId())) {§return true;§}§return false;§}§}§
public class MatsuTribeDecoy extends CardImpl {§public MatsuTribeDecoy(UUID ownerId) {§super(ownerId, 227, "Matsu-Tribe Decoy", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{G}");§this.expansionSetCode = "CHK";§this.subtype.add("Snake");§this.subtype.add("Warrior");§this.power = new MageInt(1);§this.toughness = new MageInt(3);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new MustBeBlockedByTargetSourceEffect(), new ManaCostsImpl("{2}{G}"));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§Ability ability2;§ability2 = new DealsDamageToACreatureTriggeredAbility(new TapTargetEffect("that creature"), true, false, true);§ability2.addEffect(new DontUntapInControllersNextUntapStepTargetEffect("and it"));§this.addAbility(ability2);§}§public MatsuTribeDecoy(final MatsuTribeDecoy card) {§super(card);§}§@Override§public MatsuTribeDecoy copy() {§return new MatsuTribeDecoy(this);§}§}§
public class MelokuTheCloudedMirror extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledLandPermanent("land");§public MelokuTheCloudedMirror(UUID ownerId) {§super(ownerId, 74, "Meloku the Clouded Mirror", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{U}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Moonfolk");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new CreateTokenEffect(new MelokuTheCloudedMirrorToken(), 1), new GenericManaCost(1));§ability.addCost(new ReturnToHandChosenControlledPermanentCost(new TargetControlledPermanent(filter)));§this.addAbility(ability);§}§public MelokuTheCloudedMirror(final MelokuTheCloudedMirror card) {§super(card);§}§@Override§public MelokuTheCloudedMirror copy() {§return new MelokuTheCloudedMirror(this);§}§}§class MelokuTheCloudedMirrorToken extends Token {§MelokuTheCloudedMirrorToken() {§super("Illusion", "a 1/1 blue Illusion creature token with flying");§cardType.add(CardType.CREATURE);§color.setBlue(true);§subtype.add("Illusion");§power = new MageInt(1);§toughness = new MageInt(1);§addAbility(FlyingAbility.getInstance());§}§}§
public class MidnightCovenant extends CardImpl {§public MidnightCovenant(UUID ownerId) {§super(ownerId, 125, "Midnight Covenant", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{B}");§this.expansionSetCode = "CHK";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));§this.addAbility(new EnchantAbility(auraTarget.getTargetName()));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(1, 1, Duration.EndOfTurn), new ColoredManaCost(ColoredManaSymbol.B)), AttachmentType.AURA)));§}§public MidnightCovenant(final MidnightCovenant card) {§super(card);§}§@Override§public MidnightCovenant copy() {§return new MidnightCovenant(this);§}§}§
public class MinamoSchoolAtWatersEdge extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("legendary permanent");§static {§filter.add(new SupertypePredicate("Legendary"));§}§public MinamoSchoolAtWatersEdge (UUID ownerId) {§super(ownerId, 279, "Minamo, School at Water's Edge", Rarity.RARE, new CardType[]{CardType.LAND}, null);§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.addAbility(new BlueManaAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new UntapTargetEffect(), new ColoredManaCost(ColoredManaSymbol.U));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetPermanent(filter));§this.addAbility(ability);§}§public MinamoSchoolAtWatersEdge (final MinamoSchoolAtWatersEdge card) {§super(card);§}§@Override§public MinamoSchoolAtWatersEdge copy() {§return new MinamoSchoolAtWatersEdge(this);§}§}§
public class Mindblaze extends CardImpl {§public Mindblaze (UUID ownerId) {§super(ownerId, 180, "Mindblaze", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{5}{R}");§this.expansionSetCode = "CHK";§this.getSpellAbility().addEffect(new MindblazeEffect());§this.getSpellAbility().addTarget(new TargetPlayer());§}§public Mindblaze (final Mindblaze card) {§super(card);§}§@Override§public Mindblaze copy() {§return new Mindblaze(this);§}§}§class MindblazeEffect extends OneShotEffect {§MindblazeEffect() {§super(Outcome.Damage);§staticText = "Name a nonland card and choose a number greater than 0. Target player reveals his or her library. If that library contains exactly the chosen number of the named card, {this} deals 8 damage to that player. Then that player shuffles his or her library";§}§MindblazeEffect(final MindblazeEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(targetPointer.getFirst(game, source));§Player playerControls = game.getPlayer(source.getControllerId());§if (player != null && playerControls != null) {§Choice cardChoice = new ChoiceImpl();§cardChoice.setChoices(CardRepository.instance.getNonLandNames());§cardChoice.clearChoice();§Choice numberChoice = new ChoiceImpl();§numberChoice.setMessage("Choose a number greater than 0");§HashSet<String> numbers = new HashSet<String>();§for (int i = 1; i <= 4; i++) {§numbers.add(Integer.toString(i));§}§numberChoice.setChoices(numbers);§while (!playerControls.choose(Outcome.Neutral, cardChoice, game)) {§if (!playerControls.canRespond()) {§return false;§}§}§while (!playerControls.choose(Outcome.Neutral, numberChoice, game)) {§if (!playerControls.canRespond()) {§return false;§}§}§game.informPlayers("Mindblaze, named card: [" + cardChoice.getChoice() + "]");§game.informPlayers("Mindblaze, chosen number: [" + numberChoice.getChoice() + "]");§Cards cards = new CardsImpl();§cards.addAll(player.getLibrary().getCards(game));§playerControls.revealCards("Library", cards, game);§FilterCard filter = new FilterCard();§filter.add(new NamePredicate(cardChoice.getChoice()));§int count = Integer.parseInt(numberChoice.getChoice());§if (player.getLibrary().count(filter, game) == count) {§player.damage(8, source.getSourceId(), game.copy(), false, true);§}§player.shuffleLibrary(game);§}§return false;§}§@Override§public MindblazeEffect copy() {§return new MindblazeEffect(this);§}§}§
public class MoonringMirror extends CardImpl {§protected static final String VALUE_PREFIX = "ExileZones";§public MoonringMirror(UUID ownerId) {§super(ownerId, 262, "Moonring Mirror", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{5}");§this.expansionSetCode = "CHK";§this.addAbility(new DrawCardControllerTriggeredAbility(new MoonringMirrorExileEffect(), false));§this.addAbility(new BeginningOfUpkeepTriggeredAbility(new MoonringMirrorEffect(), TargetController.YOU, true));§}§public MoonringMirror(final MoonringMirror card) {§super(card);§}§@Override§public MoonringMirror copy() {§return new MoonringMirror(this);§}§}§class MoonringMirrorExileEffect extends OneShotEffect {§public MoonringMirrorExileEffect() {§super(Outcome.Discard);§staticText = "exile the top card of your library face down";§}§public MoonringMirrorExileEffect(final MoonringMirrorExileEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Card card = controller.getLibrary().getFromTop(game);§MageObject sourceObject = source.getSourceObject(game);§if (card != null && sourceObject != null) {§UUID exileZoneId = CardUtil.getExileZoneId(game, source.getSourceId(), source.getSourceObjectZoneChangeCounter());§card.setFaceDown(true, game);§controller.moveCardsToExile(card, source, game, false, exileZoneId, sourceObject.getIdName());§card.setFaceDown(true, game);§Set<UUID> exileZones = (Set<UUID>) game.getState().getValue(MoonringMirror.VALUE_PREFIX + source.getSourceId().toString());§if (exileZones == null) {§exileZones = new HashSet<>();§game.getState().setValue(MoonringMirror.VALUE_PREFIX + source.getSourceId().toString(), exileZones);§}§exileZones.add(exileZoneId);§return true;§}§}§return false;§}§@Override§public MoonringMirrorExileEffect copy() {§return new MoonringMirrorExileEffect(this);§}§}§class MoonringMirrorEffect extends OneShotEffect {§public MoonringMirrorEffect() {§super(Outcome.Benefit);§this.staticText = "you may exile all cards from your hand face down. If you do, put all other cards you own exiled with {this} into your hand";§}§public MoonringMirrorEffect(final MoonringMirrorEffect effect) {§super(effect);§}§@Override§public MoonringMirrorEffect copy() {§return new MoonringMirrorEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§MageObject sourceObject = source.getSourceObject(game);§if (controller != null && sourceObject != null) {§UUID exileZoneId = CardUtil.getExileZoneId(game, source.getSourceId(), source.getSourceObjectZoneChangeCounter());§Cards cardsToHand = null;§if (game.getExile().getExileZone(exileZoneId) != null && game.getExile().getExileZone(exileZoneId).size() > 0) {§cardsToHand = new CardsImpl(game.getExile().getExileZone(exileZoneId));§}§for (Card card : controller.getHand().getCards(game)) {§card.setFaceDown(true, game);§}§controller.moveCardsToExile(controller.getHand().getCards(game), source, game, false, exileZoneId, sourceObject.getIdName());§if (cardsToHand != null) {§controller.moveCards(cardsToHand.getCards(game), Zone.HAND, source, game, false, true, false, null);§}§if (game.getExile().getExileZone(exileZoneId) != null) {§for (Card card : game.getExile().getExileZone(exileZoneId).getCards(game)) {§card.setFaceDown(true, game);§}§}§return true;§}§return false;§}§}§
public class MossKami extends CardImpl {§public MossKami (UUID ownerId) {§super(ownerId, 228, "Moss Kami", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{5}{G}");§this.expansionSetCode = "CHK";§this.subtype.add("Spirit");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(TrampleAbility.getInstance());§}§public MossKami (final MossKami card) {§super(card);§}§@Override§public MossKami copy() {§return new MossKami(this);§}§}§
public class MothriderSamurai extends CardImpl {§public MothriderSamurai (UUID ownerId) {§super(ownerId, 34, "Mothrider Samurai", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{W}");§this.expansionSetCode = "CHK";§this.subtype.add("Human");§this.subtype.add("Samurai");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new BushidoAbility(1));§}§public MothriderSamurai (final MothriderSamurai card) {§super(card);§}§@Override§public MothriderSamurai copy() {§return new MothriderSamurai(this);§}§}§
public class MyojinOfCleansingFire extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("other creatures");§static {§filter.add(new AnotherPredicate());§}§public MyojinOfCleansingFire(UUID ownerId) {§super(ownerId, 35, "Myojin of Cleansing Fire", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}{W}{W}{W}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Spirit");§this.power = new MageInt(4);§this.toughness = new MageInt(6);§this.getSpellAbility().addWatcher(new CastFromHandWatcher());§this.addAbility(new EntersBattlefieldAbility(new ConditionalOneShotEffect(new AddCountersSourceEffect(CounterType.DIVINITY.createInstance()), new CastFromHandCondition(), ""), "{this} enters the battlefield with a divinity counter on it if you cast it from your hand"));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new ConditionalContinuousEffect(new GainAbilitySourceEffect(IndestructibleAbility.getInstance(), Duration.WhileOnBattlefield),§new SourceHasCounterCondition(CounterType.DIVINITY), "{this} is indestructible as long as it has a divinity counter on it")));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new DestroyAllEffect(filter), new RemoveCountersSourceCost(CounterType.DIVINITY.createInstance())));§}§public MyojinOfCleansingFire(final MyojinOfCleansingFire card) {§super(card);§}§@Override§public MyojinOfCleansingFire copy() {§return new MyojinOfCleansingFire(this);§}§}§
public class MyojinOfInfiniteRage extends CardImpl {§private static final FilterLandPermanent filter = new FilterLandPermanent("lands");§public MyojinOfInfiniteRage(UUID ownerId) {§super(ownerId, 181, "Myojin of Infinite Rage", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{7}{R}{R}{R}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Spirit");§this.power = new MageInt(7);§this.toughness = new MageInt(4);§this.getSpellAbility().addWatcher(new CastFromHandWatcher());§this.addAbility(new EntersBattlefieldAbility(new ConditionalOneShotEffect(new AddCountersSourceEffect(CounterType.DIVINITY.createInstance()), new CastFromHandCondition(), ""), "{this} enters the battlefield with a divinity counter on it if you cast it from your hand"));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new ConditionalContinuousEffect(new GainAbilitySourceEffect(IndestructibleAbility.getInstance(), Duration.WhileOnBattlefield),§new SourceHasCounterCondition(CounterType.DIVINITY), "{this} is indestructible as long as it has a divinity counter on it")));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new DestroyAllEffect(filter), new RemoveCountersSourceCost(CounterType.DIVINITY.createInstance())));§}§public MyojinOfInfiniteRage(final MyojinOfInfiniteRage card) {§super(card);§}§@Override§public MyojinOfInfiniteRage copy() {§return new MyojinOfInfiniteRage(this);§}§}§
public class MyojinOfLifesWeb extends CardImpl {§private static final FilterCard filter = new FilterCard("any number of creature cards from your hand");§static {§filter.add(new CardTypePredicate(CardType.CREATURE));§filter.add(new OwnerPredicate(TargetController.YOU));§}§public MyojinOfLifesWeb(UUID ownerId) {§super(ownerId, 229, "Myojin of Life's Web", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{6}{G}{G}{G}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Spirit");§this.power = new MageInt(8);§this.toughness = new MageInt(8);§this.getSpellAbility().addWatcher(new CastFromHandWatcher());§this.addAbility(new EntersBattlefieldAbility(new ConditionalOneShotEffect(new AddCountersSourceEffect(CounterType.DIVINITY.createInstance()), new CastFromHandCondition(), ""), "{this} enters the battlefield with a divinity counter on it if you cast it from your hand"));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD,§new ConditionalContinuousEffect(new GainAbilitySourceEffect(IndestructibleAbility.getInstance(), Duration.WhileOnBattlefield),§new SourceHasCounterCondition(CounterType.DIVINITY), "{this} is indestructible as long as it has a divinity counter on it")));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new PutOntoBattlefieldTargetEffect(false), new RemoveCountersSourceCost(CounterType.DIVINITY.createInstance()));§ability.addTarget(new TargetCardInHand(0, Integer.MAX_VALUE, filter));§this.addAbility(ability);§}§public MyojinOfLifesWeb(final MyojinOfLifesWeb card) {§super(card);§}§@Override§public MyojinOfLifesWeb copy() {§return new MyojinOfLifesWeb(this);§}§}§
public class MysticRestraints extends CardImpl {§public MysticRestraints(UUID ownerId) {§super(ownerId, 76, "Mystic Restraints", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{U}{U}");§this.expansionSetCode = "CHK";§this.subtype.add("Aura");§this.addAbility(FlashAbility.getInstance());§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.Detriment));§this.addAbility(new EnchantAbility(auraTarget.getTargetName()));§this.addAbility(new EntersBattlefieldTriggeredAbility(new TapEnchantedEffect()));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new DontUntapInControllersUntapStepEnchantedEffect()));§}§public MysticRestraints(final MysticRestraints card) {§super(card);§}§@Override§public MysticRestraints copy() {§return new MysticRestraints(this);§}§}§
public class NagaoBoundByHonor extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Samurai creatures");§static {§filter.add(new SubtypePredicate("Samurai"));§}§public NagaoBoundByHonor(UUID ownerId) {§super(ownerId, 36, "Nagao, Bound by Honor", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{W}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Samurai");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new BushidoAbility(1));§this.addAbility(new AttacksTriggeredAbility(new BoostControlledEffect(1, 1, Duration.EndOfTurn, filter, false), false));§}§public NagaoBoundByHonor(final NagaoBoundByHonor card) {§super(card);§}§@Override§public NagaoBoundByHonor copy() {§return new NagaoBoundByHonor(this);§}§}§
public class NaturesWill extends CardImpl {§public NaturesWill(UUID ownerId) {§super(ownerId, 230, "Nature's Will", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{2}{G}{G}");§this.expansionSetCode = "CHK";§this.addAbility(new NaturesWillTriggeredAbility());§}§public NaturesWill(final NaturesWill card) {§super(card);§}§@Override§public NaturesWill copy() {§return new NaturesWill(this);§}§}§class NaturesWillTriggeredAbility extends TriggeredAbilityImpl {§private boolean madeDamge = false;§private Set<UUID> damagedPlayers = new HashSet<UUID>();§public NaturesWillTriggeredAbility() {§super(Zone.BATTLEFIELD, new NaturesWillEffect(), false);§}§public NaturesWillTriggeredAbility(final NaturesWillTriggeredAbility ability) {§super(ability);§this.madeDamge = ability.madeDamge;§this.damagedPlayers = new HashSet<UUID>();§this.damagedPlayers.addAll(ability.damagedPlayers);§}§@Override§public NaturesWillTriggeredAbility copy() {§return new NaturesWillTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.DAMAGED_PLAYER || event.getType() == EventType.COMBAT_DAMAGE_STEP_POST;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (event.getType() == EventType.DAMAGED_PLAYER) {§DamagedPlayerEvent damageEvent = (DamagedPlayerEvent) event;§Permanent p = game.getPermanent(event.getSourceId());§if (damageEvent.isCombatDamage() && p != null && p.getControllerId().equals(this.getControllerId())) {§madeDamge = true;§damagedPlayers.add(event.getPlayerId());§}§}§if (event.getType().equals(EventType.COMBAT_DAMAGE_STEP_POST)) {§if (madeDamge) {§Set<UUID> damagedPlayersCopy = new HashSet<UUID>();§damagedPlayersCopy.addAll(damagedPlayers);§for(Effect effect: this.getEffects()) {§effect.setValue("damagedPlayers", damagedPlayersCopy);§}§damagedPlayers.clear();§madeDamge = false;§return true;§}§}§return false;§}§@Override§public String getRule() {§return "Whenever one or more creatures you control deal combat damage to a player, " + super.getRule();§}§}§class NaturesWillEffect extends OneShotEffect {§public NaturesWillEffect() {§super(Outcome.Benefit);§this.staticText = "tap all lands that player controls and untap all lands you control";§}§public NaturesWillEffect(final NaturesWillEffect effect) {§super(effect);§}§@Override§public NaturesWillEffect copy() {§return new NaturesWillEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Set<UUID> damagedPlayers = (HashSet<UUID>) this.getValue("damagedPlayers");§if (damagedPlayers == null) {§return false;§}§FilterLandPermanent filter = new FilterLandPermanent();§List<Permanent> lands = game.getBattlefield().getActivePermanents(filter, source.getControllerId(), source.getSourceId(), game);§for (Permanent land : lands) {§if (damagedPlayers.contains(land.getControllerId())) {§land.tap(game);§} else if (land.getControllerId().equals(source.getControllerId())) {§land.untap(game);§}§}§return false;§}§}§
public class NezumiBoneReader extends CardImpl {§public NezumiBoneReader (UUID ownerId) {§super(ownerId, 127, "Nezumi Bone-Reader", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{B}");§this.expansionSetCode = "CHK";§this.subtype.add("Rat");§this.subtype.add("Shaman");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new ActivateAsSorceryActivatedAbility(Zone.BATTLEFIELD, new DiscardTargetEffect(1),new SacrificeTargetCost(new TargetControlledCreaturePermanent()));§ability.addCost(new ManaCostsImpl("{B}"));§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§}§public NezumiBoneReader (final NezumiBoneReader card) {§super(card);§}§@Override§public NezumiBoneReader copy() {§return new NezumiBoneReader(this);§}§}§
public class NezumiCutthroat extends CardImpl {§public NezumiCutthroat(UUID ownerId) {§super(ownerId, 128, "Nezumi Cutthroat", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{B}");§this.expansionSetCode = "CHK";§this.subtype.add("Rat");§this.subtype.add("Warrior");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(FearAbility.getInstance());§this.addAbility(new CantBlockAbility());§}§public NezumiCutthroat(final NezumiCutthroat card) {§super(card);§}§@Override§public NezumiCutthroat copy() {§return new NezumiCutthroat(this);§}§}§
public class NezumiGraverobber extends CardImpl {§public NezumiGraverobber(UUID ownerId) {§super(ownerId, 129, "Nezumi Graverobber", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{B}");§this.expansionSetCode = "CHK";§this.subtype.add("Rat");§this.subtype.add("Rogue");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.flipCard = true;§this.flipCardName = "Nighteyes the Desecrator";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ExileTargetEffect(), new ManaCostsImpl("{1}{B}"));§Target target = new TargetCardInOpponentsGraveyard(new FilterCard("card from an opponent's graveyard"));§ability.addTarget(target);§ability.addEffect(new NezumiGraverobberFlipEffect());§this.addAbility(ability);§}§public NezumiGraverobber(final NezumiGraverobber card) {§super(card);§}§@Override§public NezumiGraverobber copy() {§return new NezumiGraverobber(this);§}§}§class NezumiGraverobberFlipEffect extends OneShotEffect {§NezumiGraverobberFlipEffect() {§super(Outcome.BecomeCreature);§staticText = "If no cards are in that graveyard, flip {this}";§}§NezumiGraverobberFlipEffect(final NezumiGraverobberFlipEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Card card = game.getCard(targetPointer.getFirst(game, source));§if (card != null) {§Player player = game.getPlayer(card.getOwnerId());§if (player != null) {§if (player.getGraveyard().size() == 0) {§return new FlipSourceEffect(new NighteyesTheDesecratorToken()).apply(game, source);§}§}§}§return false;§}§@Override§public NezumiGraverobberFlipEffect copy() {§return new NezumiGraverobberFlipEffect(this);§}§}§class NighteyesTheDesecratorToken extends Token {§NighteyesTheDesecratorToken() {§super("Nighteyes the Desecrator", "");§supertype.add("Legendary");§cardType.add(CardType.CREATURE);§color.setBlack(true);§subtype.add("Rat");§subtype.add("Wizard");§power = new MageInt(4);§toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ReturnFromGraveyardToBattlefieldTargetEffect(), new ManaCostsImpl("{4}{B}"));§ability.addTarget(new TargetCardInGraveyard(new FilterCreatureCard("creature card from a graveyard")));§this.addAbility(ability);§}§}§
public class NezumiRonin extends CardImpl {§public NezumiRonin (UUID ownerId) {§super(ownerId, 130, "Nezumi Ronin", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{B}");§this.expansionSetCode = "CHK";§this.subtype.add("Rat");§this.subtype.add("Samurai");§this.power = new MageInt(3);§this.toughness = new MageInt(1);§this.addAbility(new BushidoAbility(1));§}§public NezumiRonin (final NezumiRonin card) {§super(card);§}§@Override§public NezumiRonin copy() {§return new NezumiRonin(this);§}§}§
public class NezumiShortfang extends CardImpl {§public NezumiShortfang(UUID ownerId) {§super(ownerId, 131, "Nezumi Shortfang", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{B}");§this.expansionSetCode = "CHK";§this.subtype.add("Rat");§this.subtype.add("Rogue");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.flipCard = true;§this.flipCardName = "Stabwhisker the Odious";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DiscardTargetEffect(1), new ManaCostsImpl("{1}{B}"));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetOpponent());§ability.addEffect(new ConditionalOneShotEffect(§new FlipSourceEffect(new StabwhiskerTheOdious()),§new CardsInTargetOpponentHandCondition(CardsInTargetOpponentHandCondition.CountType.FEWER_THAN, 1),§"Then if that player has no cards in hand, flip {this}"));§this.addAbility(ability);§}§public NezumiShortfang(final NezumiShortfang card) {§super(card);§}§@Override§public NezumiShortfang copy() {§return new NezumiShortfang(this);§}§}§class StabwhiskerTheOdious extends Token {§StabwhiskerTheOdious() {§super("Stabwhisker the Odious", "");§supertype.add("Legendary");§cardType.add(CardType.CREATURE);§color.setBlack(true);§subtype.add("Rat");§subtype.add("Shaman");§power = new MageInt(3);§toughness = new MageInt(3);§this.addAbility(new BeginningOfUpkeepTriggeredAbility(§Zone.BATTLEFIELD, new StabwhiskerLoseLifeEffect(), TargetController.OPPONENT, false, true));§}§}§class StabwhiskerLoseLifeEffect extends OneShotEffect {§public StabwhiskerLoseLifeEffect() {§super(Outcome.LoseLife);§this.staticText = "that player loses 1 life for each card fewer than three in his or her hand";§}§public StabwhiskerLoseLifeEffect(final StabwhiskerLoseLifeEffect effect) {§super(effect);§}§@Override§public StabwhiskerLoseLifeEffect copy() {§return new StabwhiskerLoseLifeEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player opponent = game.getPlayer(getTargetPointer().getFirst(game, source));§if (opponent != null) {§int lifeLose = 3 - opponent.getHand().size();§if (lifeLose > 0 ) {§opponent.loseLife(lifeLose, game);§}§return true;§}§return false;§}§}§class CardsInTargetOpponentHandCondition implements Condition {§public static enum CountType { MORE_THAN, FEWER_THAN, EQUAL_TO };§private Condition condition;§private CountType type;§private int count;§public CardsInTargetOpponentHandCondition() {§this(CountType.EQUAL_TO, 0);§}§public CardsInTargetOpponentHandCondition (CountType type, int count ) {§this.type = type;§this.count = count;§}§public CardsInTargetOpponentHandCondition (CountType type, int count, Condition conditionToDecorate ) {§this(type, count);§this.condition = conditionToDecorate;§}§@Override§public boolean apply(Game game, Ability source) {§boolean conditionApplies = false;§Player opponent = game.getPlayer(source.getFirstTarget());§if (opponent == null) {§return false;§}§switch ( this.type ) {§case FEWER_THAN:§conditionApplies = opponent.getHand().size() < this.count;§break;§case MORE_THAN:§conditionApplies = opponent.getHand().size() > this.count;§break;§case EQUAL_TO:§conditionApplies = opponent.getHand().size() == this.count;§break;§}§if ( this.condition != null ) {§conditionApplies = conditionApplies && this.condition.apply(game, source);§}§return conditionApplies;§}§}§
public class NightDealings extends CardImpl {§public NightDealings(UUID ownerId) {§super(ownerId, 132, "Night Dealings", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{2}{B}{B}");§this.expansionSetCode = "CHK";§this.addAbility((new NightDealingsTriggeredAbility()));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new NightDealingsSearchEffect(), new ManaCostsImpl("{2}{B}{B}"));§ability.addCost(new RemoveVariableCountersSourceCost(CounterType.THEFT.createInstance(1)));§this.addAbility(ability);§}§public NightDealings(final NightDealings card) {§super(card);§}§@Override§public NightDealings copy() {§return new NightDealings(this);§}§private class NightDealingsTriggeredAbility extends TriggeredAbilityImpl {§public NightDealingsTriggeredAbility() {§super(Zone.BATTLEFIELD, new NightDealingsEffect());§}§public NightDealingsTriggeredAbility(final NightDealingsTriggeredAbility ability) {§super(ability);§}§@Override§public NightDealingsTriggeredAbility copy() {§return new NightDealingsTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.DAMAGED_PLAYER;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (this.getControllerId() != event.getTargetId()) {§UUID sourceControllerId = game.getControllerId(event.getSourceId());§if (sourceControllerId != null && sourceControllerId.equals(this.getControllerId())) {§this.getEffects().get(0).setValue("damageAmount", event.getAmount());§return true;§}§}§return false;§}§@Override§public String getRule() {§return "Whenever a source you control deals damage to another player, " + super.getRule();§}§}§private class NightDealingsEffect extends OneShotEffect {§public NightDealingsEffect() {§super(Outcome.Damage);§this.staticText = "put that many theft counters on {this}";§}§public NightDealingsEffect(final NightDealingsEffect effect) {§super(effect);§}§@Override§public NightDealingsEffect copy() {§return new NightDealingsEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Integer damageAmount = (Integer) this.getValue("damageAmount");§if (damageAmount != null) {§Permanent permanent = game.getPermanent(source.getSourceId());§if (permanent != null) {§permanent.addCounters(CounterType.THEFT.createInstance(damageAmount), game);§return true;§}§}§return false;§}§}§private class NightDealingsSearchEffect extends OneShotEffect {§public NightDealingsSearchEffect() {§super(Outcome.DrawCard);§this.staticText = "Search your library for a nonland card with converted mana cost X, reveal it, and put it into your hand. Then shuffle your library";§}§public NightDealingsSearchEffect(final NightDealingsSearchEffect effect) {§super(effect);§}§@Override§public NightDealingsSearchEffect copy() {§return new NightDealingsSearchEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player == null) {§return false;§}§int cmc = 0;§for (Cost cost : source.getCosts()) {§if (cost instanceof RemoveVariableCountersSourceCost) {§cmc = ((RemoveVariableCountersSourceCost) cost).getAmount();§}§}§FilterNonlandCard filter = new FilterNonlandCard("nonland card with converted mana cost X = " + cmc);§filter.add(new ConvertedManaCostPredicate(Filter.ComparisonType.Equal, cmc));§TargetCardInLibrary target = new TargetCardInLibrary(filter);§if (player.searchLibrary(target, game)) {§Card card = player.getLibrary().getCard(target.getFirstTarget(), game);§if (card != null) {§card.moveToZone(Zone.HAND, source.getSourceId(), game, false);§String name = "Reveal";§Cards cards = new CardsImpl();§cards.add(card);§Card sourceCard = game.getCard(source.getSourceId());§if (sourceCard != null) {§name = sourceCard.getName();§}§player.revealCards(name, cards, game);§game.informPlayers(player.getLogName() + " reveals " + card.getName());§}§player.shuffleLibrary(game);§return true;§}§player.shuffleLibrary(game);§return false;§}§}§}§
public class NightOfSoulsBetrayal extends CardImpl {§private static FilterCreaturePermanent filter = new FilterCreaturePermanent("All creatures");§public NightOfSoulsBetrayal (UUID ownerId) {§super(ownerId, 133, "Night of Souls' Betrayal", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{2}{B}{B}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostAllEffect(-1, -1, Duration.WhileOnBattlefield, filter, false)));§}§public NightOfSoulsBetrayal (final NightOfSoulsBetrayal card) {§super(card);§}§@Override§public NightOfSoulsBetrayal copy() {§return new NightOfSoulsBetrayal(this);§}§}§
public class NineRingedBo extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("spirit");§static {§filter.add(new SubtypePredicate("Spirit"));§}§public NineRingedBo(UUID ownerId) {§super(ownerId, 263, "Nine-Ringed Bo", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "CHK";§Ability ability = new ActivateAsSorceryActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(1), new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent(filter));§Effect effect = new DealtDamageToCreatureBySourceDies(this, Duration.EndOfTurn);§effect.setText("If that creature would die this turn, exile it instead");§ability.addEffect(effect);§this.addAbility(ability, new DamagedByWatcher());§}§public NineRingedBo(final NineRingedBo card) {§super(card);§}§@Override§public NineRingedBo copy() {§return new NineRingedBo(this);§}§}§
public class NoDachi extends CardImpl {§public NoDachi (UUID ownerId) {§super(ownerId, 264, "No-Dachi", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{2}");§this.expansionSetCode = "CHK";§this.subtype.add("Equipment");§this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(3)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(FirstStrikeAbility.getInstance(), AttachmentType.EQUIPMENT)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEquippedEffect(2, 0)));§}§public NoDachi (final NoDachi card) {§super(card);§}§@Override§public NoDachi copy() {§return new NoDachi(this);§}§}§
public class NumaiOutcast extends CardImpl {§public NumaiOutcast (UUID ownerId) {§super(ownerId, 134, "Numai Outcast", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{B}");§this.expansionSetCode = "CHK";§this.subtype.add("Human");§this.subtype.add("Samurai");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new BushidoAbility(2));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new RegenerateSourceEffect(), new ColoredManaCost(ColoredManaSymbol.B));§ability.addCost(new PayLifeCost(5));§this.addAbility(ability);§}§public NumaiOutcast (final NumaiOutcast card) {§super(card);§}§@Override§public NumaiOutcast copy() {§return new NumaiOutcast(this);§}§}§
public class OathkeeperTakenosDaisho extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("it's a Samurai card");§static {§filter.add(new SubtypePredicate("Samurai"));§}§public OathkeeperTakenosDaisho(UUID ownerId) {§super(ownerId, 265, "Oathkeeper, Takeno's Daisho", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Equipment");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEquippedEffect(3,1, Duration.WhileOnBattlefield)));§this.addAbility(new ConditionalTriggeredAbility(§new DiesAttachedTriggeredAbility(new ReturnToBattlefieldUnderYourControlAttachedEffect(),"equipped creature", false),§new OathkeeperEquippedMatchesFilterCondition(filter),§""));§this.addAbility(new PutIntoGraveFromBattlefieldSourceTriggeredAbility(new ExileEquippedEffect()));§this.addAbility(new EquipAbility( Outcome.BoostCreature, new ManaCostsImpl("{2}")));§}§public OathkeeperTakenosDaisho(final OathkeeperTakenosDaisho card) {§super(card);§}§@Override§public OathkeeperTakenosDaisho copy() {§return new OathkeeperTakenosDaisho(this);§}§}§class ExileEquippedEffect extends OneShotEffect {§public ExileEquippedEffect() {§super(Outcome.Exile);§staticText = "exile equipped creature";§}§public ExileEquippedEffect(final ExileEquippedEffect effect) {§super(effect);§}§@Override§public ExileEquippedEffect copy() {§return new ExileEquippedEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent equipment = (Permanent) game.getLastKnownInformation(source.getSourceId(), Zone.BATTLEFIELD);§if (equipment != null && equipment.getAttachedTo() != null) {§Permanent creature = game.getPermanent(equipment.getAttachedTo());§if (creature != null) {§return creature.moveToExile(null, "", source.getSourceId(), game);§}§}§return false;§}§}§class OathkeeperEquippedMatchesFilterCondition implements Condition {§private FilterCreaturePermanent filter;§public OathkeeperEquippedMatchesFilterCondition(FilterCreaturePermanent filter) {§this.filter = filter;§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getBattlefield().getPermanent(source.getSourceId());§if (permanent == null) {§permanent = (Permanent) game.getLastKnownInformation(source.getSourceId(), Zone.BATTLEFIELD);§}§if (permanent != null) {§Permanent attachedTo = null;§if (permanent.getAttachedTo() != null) {§attachedTo = game.getBattlefield().getPermanent(permanent.getAttachedTo());§if (attachedTo == null) {§attachedTo = (Permanent) game.getLastKnownInformation(permanent.getAttachedTo(), Zone.BATTLEFIELD);§}§}§if (attachedTo == null) {§for (Effect effect :source.getEffects()) {§attachedTo = (Permanent) effect.getValue("attachedTo");§}§}§if (attachedTo != null) {§if (filter.match(attachedTo, attachedTo.getId(),attachedTo.getControllerId(), game)) {§return true;§}§}§}§return false;§}§}§
public class OkinaTempleToTheGrandfathers extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("legendary creature");§static {§filter.add(new SupertypePredicate("Legendary"));§}§public OkinaTempleToTheGrandfathers(UUID ownerId) {§super(ownerId, 280, "Okina, Temple to the Grandfathers", Rarity.RARE, new CardType[]{CardType.LAND}, null);§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.addAbility(new GreenManaAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostTargetEffect(1, 1, Duration.EndOfTurn), new ColoredManaCost(ColoredManaSymbol.G));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetPermanent(filter));§this.addAbility(ability);§}§public OkinaTempleToTheGrandfathers(final OkinaTempleToTheGrandfathers card) {§super(card);§}§@Override§public OkinaTempleToTheGrandfathers copy() {§return new OkinaTempleToTheGrandfathers(this);§}§}§
public class OniPossession extends CardImpl {§private static final List<String> setSubtypes = new ArrayList<>();§static {§setSubtypes.add("Demon");§setSubtypes.add("Spirit");§}§public OniPossession(UUID ownerId) {§super(ownerId, 135, "Oni Possession", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{B}");§this.expansionSetCode = "CHK";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§Ability ability2 = new BeginningOfUpkeepTriggeredAbility(§new SacrificeControllerEffect(new FilterControlledCreaturePermanent(), 1, ""), TargetController.YOU, false);§this.addAbility(ability2);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(3, 3, Duration.WhileOnBattlefield)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(TrampleAbility.getInstance(), AttachmentType.AURA)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new SetCardSubtypeAttachedEffect(setSubtypes, Duration.WhileOnBattlefield, AttachmentType.AURA)));§}§public OniPossession(final OniPossession card) {§super(card);§}§@Override§public OniPossession copy() {§return new OniPossession(this);§}§}§
public class OrbweaverKumo extends CardImpl {§private static final FilterSpiritOrArcaneCard filter = new FilterSpiritOrArcaneCard();§public OrbweaverKumo(UUID ownerId) {§super(ownerId, 231, "Orbweaver Kumo", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{G}{G}");§this.expansionSetCode = "CHK";§this.subtype.add("Spirit");§this.power = new MageInt(3);§this.toughness = new MageInt(4);§this.addAbility(ReachAbility.getInstance());§this.addAbility(new SpellCastControllerTriggeredAbility(new GainAbilitySourceEffect(new ForestwalkAbility(), Duration.EndOfTurn), filter, false));§}§public OrbweaverKumo(final OrbweaverKumo card) {§super(card);§}§@Override§public OrbweaverKumo copy() {§return new OrbweaverKumo(this);§}§}§
public class OrderOfTheSacredBell extends CardImpl {§public OrderOfTheSacredBell (UUID ownerId) {§super(ownerId, 232, "Order of the Sacred Bell", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{G}");§this.expansionSetCode = "CHK";§this.subtype.add("Human");§this.subtype.add("Monk");§this.power = new MageInt(4);§this.toughness = new MageInt(3);§}§public OrderOfTheSacredBell (final OrderOfTheSacredBell card) {§super(card);§}§@Override§public OrderOfTheSacredBell copy() {§return new OrderOfTheSacredBell(this);§}§}§
public class OrochiHatchery extends CardImpl {§public OrochiHatchery(UUID ownerId) {§super(ownerId, 266, "Orochi Hatchery", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{X}{X}");§this.expansionSetCode = "CHK";§this.addAbility(new EntersBattlefieldAbility(new EntersBattlefieldWithXCountersEffect(CounterType.CHARGE.createInstance())));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new CreateTokenEffect(new SnakeToken(), new CountersCount(CounterType.CHARGE)), new GenericManaCost(5));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§}§public OrochiHatchery(final OrochiHatchery card) {§super(card);§}§@Override§public OrochiHatchery copy() {§return new OrochiHatchery(this);§}§}§
public class OrochiLeafcaller extends CardImpl {§public OrochiLeafcaller (UUID ownerId) {§super(ownerId, 234, "Orochi Leafcaller", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{G}");§this.expansionSetCode = "CHK";§this.subtype.add("Snake");§this.subtype.add("Shaman");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new AnyColorManaAbility(new ColoredManaCost(ColoredManaSymbol.G)));§}§public OrochiLeafcaller (final OrochiLeafcaller card) {§super(card);§}§@Override§public OrochiLeafcaller copy() {§return new OrochiLeafcaller(this);§}§}§
public class OrochiRanger extends CardImpl {§public OrochiRanger(UUID ownerId) {§super(ownerId, 235, "Orochi Ranger", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "CHK";§this.subtype.add("Snake");§this.subtype.add("Warrior");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§Ability ability;§ability = new DealsDamageToACreatureTriggeredAbility(new TapTargetEffect("that creature"), true, false, true);§ability.addEffect(new DontUntapInControllersNextUntapStepTargetEffect("and it"));§this.addAbility(ability);§}§public OrochiRanger(final OrochiRanger card) {§super(card);§}§@Override§public OrochiRanger copy() {§return new OrochiRanger(this);§}§}§
public class OrochiSustainer extends CardImpl {§public OrochiSustainer(UUID ownerId) {§super(ownerId, 236, "Orochi Sustainer", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "CHK";§this.subtype.add("Snake");§this.subtype.add("Shaman");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§this.addAbility(new GreenManaAbility());§}§public OrochiSustainer(final OrochiSustainer card) {§super(card);§}§@Override§public OrochiSustainer copy() {§return new OrochiSustainer(this);§}§}§
public class OtherworldlyJourney extends CardImpl {§public OtherworldlyJourney(UUID ownerId) {§super(ownerId, 37, "Otherworldly Journey", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{1}{W}");§this.expansionSetCode = "CHK";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new OtherworldlyJourneyEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public OtherworldlyJourney(final OtherworldlyJourney card) {§super(card);§}§@Override§public OtherworldlyJourney copy() {§return new OtherworldlyJourney(this);§}§}§class OtherworldlyJourneyEffect extends OneShotEffect {§private static final String effectText = "Exile target creature. At the beginning of the next end step, return that card to the battlefield under its owner's control with a +1/+1 counter on it";§OtherworldlyJourneyEffect() {§super(Outcome.Benefit);§staticText = effectText;§}§OtherworldlyJourneyEffect(OtherworldlyJourneyEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getPermanent(source.getFirstTarget());§if (permanent != null) {§if (permanent.moveToExile(source.getSourceId(), "Otherworldly Journey", source.getSourceId(), game)) {§ExileZone exile = game.getExile().getExileZone(source.getSourceId());§if (exile != null && !exile.isEmpty()) {§Card card = game.getCard(permanent.getId());§if (card != null) {§DelayedTriggeredAbility delayedAbility§= new AtTheBeginOfNextEndStepDelayedTriggeredAbility(new OtherworldlyJourneyReturnFromExileEffect(new MageObjectReference(card, game)));§delayedAbility.setSourceId(source.getSourceId());§delayedAbility.setControllerId(source.getControllerId());§delayedAbility.setSourceObject(source.getSourceObject(game), game);§game.addDelayedTriggeredAbility(delayedAbility);§}§}§return true;§}§}§return false;§}§@Override§public OtherworldlyJourneyEffect copy() {§return new OtherworldlyJourneyEffect(this);§}§}§class OtherworldlyJourneyReturnFromExileEffect extends OneShotEffect {§MageObjectReference objectToReturn;§public OtherworldlyJourneyReturnFromExileEffect(MageObjectReference objectToReturn) {§super(Outcome.PutCardInPlay);§this.objectToReturn = objectToReturn;§staticText = "return that card to the battlefield under its owner's control with a +1/+1 counter on it";§}§public OtherworldlyJourneyReturnFromExileEffect(final OtherworldlyJourneyReturnFromExileEffect effect) {§super(effect);§this.objectToReturn = effect.objectToReturn;§}§@Override§public OtherworldlyJourneyReturnFromExileEffect copy() {§return new OtherworldlyJourneyReturnFromExileEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Card card = game.getCard(objectToReturn.getSourceId());§if (card != null && objectToReturn.refersTo(card, game)) {§Player owner = game.getPlayer(card.getOwnerId());§if (owner != null) {§game.addEffect(new OtherworldlyJourneyEntersBattlefieldEffect(objectToReturn), source);§owner.moveCards(card, Zone.BATTLEFIELD, source, game, false, false, true, null);§}§}§return true;§}§}§class OtherworldlyJourneyEntersBattlefieldEffect extends ReplacementEffectImpl {§MageObjectReference objectToReturn;§public OtherworldlyJourneyEntersBattlefieldEffect(MageObjectReference objectToReturn) {§super(Duration.Custom, Outcome.BoostCreature);§this.objectToReturn = objectToReturn;§staticText = "that card returns to the battlefield with a +1/+1 counter on it";§}§public OtherworldlyJourneyEntersBattlefieldEffect(OtherworldlyJourneyEntersBattlefieldEffect effect) {§super(effect);§this.objectToReturn = effect.objectToReturn;§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return EventType.ENTERS_THE_BATTLEFIELD.equals(event.getType());§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§if (event.getType() == EventType.ENTERS_THE_BATTLEFIELD) {§return event.getTargetId().equals(objectToReturn.getSourceId());§}§return false;§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§Permanent permanent = ((EntersTheBattlefieldEvent) event).getTarget();§if (permanent != null) {§permanent.addCounters(CounterType.P1P1.createInstance(), game);§discard(); §
public class PainKami extends CardImpl {§public PainKami(UUID ownerId) {§super(ownerId, 183, "Pain Kami", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "CHK";§this.subtype.add("Spirit");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(new ManacostVariableValue()), new ManaCostsImpl("{X}{R}"));§ability.addCost(new SacrificeSourceCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public PainKami(final PainKami card) {§super(card);§}§@Override§public PainKami copy() {§return new PainKami(this);§}§}§
public class PainwrackerOni extends CardImpl {§public PainwrackerOni (UUID ownerId) {§super(ownerId, 136, "Painwracker Oni", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{B}{B}");§this.expansionSetCode = "CHK";§this.subtype.add("Demon");§this.subtype.add("Spirit");§this.power = new MageInt(5);§this.toughness = new MageInt(4);§this.addAbility(FearAbility.getInstance());§this.addAbility(new BeginningOfUpkeepTriggeredAbility(new PainwrackerOniEffect(new FilterControlledCreaturePermanent(), 1, ""), TargetController.YOU, false));§}§public PainwrackerOni (final PainwrackerOni card) {§super(card);§}§@Override§public PainwrackerOni copy() {§return new PainwrackerOni(this);§}§}§class PainwrackerOniEffect extends SacrificeControllerEffect {§public PainwrackerOniEffect(FilterPermanent filter, int count, String preText) {§super(filter, count, preText);§this.staticText = "sacrifice a creature if you don't control an Ogre";§}§public PainwrackerOniEffect(final PainwrackerOniEffect effect) {§super(effect);§}§@Override§public PainwrackerOniEffect copy() {§return new PainwrackerOniEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§if (game.getBattlefield().countAll(new FilterCreaturePermanent("Ogre", "Ogre"), source.getControllerId(), game) < 1) {§return super.apply(game, source);§}§return true;§}§}§
public class PartTheVeil extends CardImpl {§public PartTheVeil(UUID ownerId) {§super(ownerId, 77, "Part the Veil", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{3}{U}");§this.expansionSetCode = "CHK";§this.subtype.add("Arcane");§Effect effect = new ReturnToHandFromBattlefieldAllEffect(new FilterControlledCreaturePermanent());§effect.setText("Return all creatures you control to their owner's hand");§this.getSpellAbility().addEffect(effect);§}§public PartTheVeil(final PartTheVeil card) {§super(card);§}§@Override§public PartTheVeil copy() {§return new PartTheVeil(this);§}§}§
public class PeerThroughDepths extends CardImpl {§private static final FilterCard filter = new FilterCard("an instant or sorcery card");§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.SORCERY),§new CardTypePredicate(CardType.INSTANT)));§}§public PeerThroughDepths (UUID ownerId) {§super(ownerId, 78, "Peer Through Depths", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{U}");§this.expansionSetCode = "CHK";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new LookLibraryAndPickControllerEffect(new StaticValue(5), false, new StaticValue(1), filter, false));§}§public PeerThroughDepths (final PeerThroughDepths card) {§super(card);§}§@Override§public PeerThroughDepths copy() {§return new PeerThroughDepths(this);§}§}§
public class PinecrestRidge extends CardImpl {§public PinecrestRidge(UUID ownerId) {§super(ownerId, 281, "Pinecrest Ridge", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "CHK";§this.addAbility(new ColorlessManaAbility());§Ability redManaAbility = new RedManaAbility();§redManaAbility.addEffect(new DontUntapInControllersNextUntapStepSourceEffect());§this.addAbility(redManaAbility);§Ability greenManaAbility = new GreenManaAbility();§greenManaAbility.addEffect(new DontUntapInControllersNextUntapStepSourceEffect());§this.addAbility(greenManaAbility);§}§public PinecrestRidge(final PinecrestRidge card) {§super(card);§}§@Override§public PinecrestRidge copy() {§return new PinecrestRidge(this);§}§}§
public class PiousKitsune extends CardImpl {§public PiousKitsune(UUID ownerId) {§super(ownerId, 38, "Pious Kitsune", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "CHK";§this.subtype.add("Fox");§this.subtype.add("Cleric");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§this.addAbility(new BeginningOfUpkeepTriggeredAbility(new PiousKitsuneEffect(), TargetController.YOU, false));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainLifeEffect(1), new TapSourceCost());§ability.addCost(new RemoveCountersSourceCost(CounterType.DEVOTION.createInstance()));§this.addAbility(ability);§}§public PiousKitsune(final PiousKitsune card) {§super(card);§}§@Override§public PiousKitsune copy() {§return new PiousKitsune(this);§}§}§class PiousKitsuneEffect extends OneShotEffect {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature named Eight-and-a-Half-Tails");§static {§filter.add(new NamePredicate("Eight-and-a-Half-Tails"));§}§public PiousKitsuneEffect() {§super(Outcome.Benefit);§this.staticText = "put a devotion counter on Pious Kitsune. Then if a creature named Eight-and-a-Half-Tails is on the battlefield, you gain 1 life for each devotion counter on Pious Kitsune";§}§public PiousKitsuneEffect(final PiousKitsuneEffect effect) {§super(effect);§}§@Override§public PiousKitsuneEffect copy() {§return new PiousKitsuneEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§boolean result;§result = new AddCountersSourceEffect(CounterType.DEVOTION.createInstance()).apply(game, source);§if (game.getBattlefield().count(filter, source.getSourceId(), source.getControllerId(), game) > 0) {§Permanent permanent = game.getPermanent(source.getSourceId());§if (permanent != null) {§int life = permanent.getCounters().getCount(CounterType.DEVOTION);§if (life > 0) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§controller.gainLife(life, game);§}§}§}§}§return result;§}§}§
public class PsychicPuppetry extends CardImpl {§public PsychicPuppetry(UUID ownerId) {§super(ownerId, 80, "Psychic Puppetry", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{U}");§this.expansionSetCode = "CHK";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new MayTapOrUntapTargetEffect());§this.getSpellAbility().addTarget(new TargetPermanent());§this.addAbility(new SpliceOntoArcaneAbility("{U}"));§}§public PsychicPuppetry(final PsychicPuppetry card) {§super(card);§}§@Override§public PsychicPuppetry copy() {§return new PsychicPuppetry(this);§}§}§
public class PullUnder extends CardImpl {§public PullUnder (UUID ownerId) {§super(ownerId, 137, "Pull Under", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{5}{B}");§this.expansionSetCode = "CHK";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new BoostTargetEffect(-5, -5, Duration.EndOfTurn));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public PullUnder (final PullUnder card) {§super(card);§}§@Override§public PullUnder copy() {§return new PullUnder(this);§}§}§
public class QuietPurity extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("Enchantment");§static {§filter.add(new CardTypePredicate(CardType.ENCHANTMENT));§}§public QuietPurity(UUID ownerId) {§super(ownerId, 39, "Quiet Purity", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{W}");§this.expansionSetCode = "CHK";§this.subtype.add("Arcane");§this.getSpellAbility().addTarget(new TargetPermanent(filter));§this.getSpellAbility().addEffect(new DestroyTargetEffect());§}§public QuietPurity(final QuietPurity card) {§super(card);§}§@Override§public QuietPurity copy() {§return new QuietPurity(this);§}§}§
public class RagDealer extends CardImpl {§public RagDealer (UUID ownerId) {§super(ownerId, 138, "Rag Dealer", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{B}");§this.expansionSetCode = "CHK";§this.subtype.add("Human");§this.subtype.add("Rogue");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new RagDealerExileEffect(), new ManaCostsImpl("{2}{B}"));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetCardInASingleGraveyard(0, 3, new FilterCard("up to three target cards from a single graveyard")));§this.addAbility(ability);§}§public RagDealer (final RagDealer card) {§super(card);§}§@Override§public RagDealer copy() {§return new RagDealer(this);§}§}§class RagDealerExileEffect extends OneShotEffect {§public RagDealerExileEffect() {§super(Outcome.Exile);§this.staticText = "Exile up to three target cards from a single graveyard";§}§public RagDealerExileEffect(final RagDealerExileEffect effect) {§super(effect);§}§@Override§public RagDealerExileEffect copy() {§return new RagDealerExileEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§for (UUID targetID : source.getTargets().get(0).getTargets()) {§Card card = game.getCard(targetID);§if (card != null) {§card.moveToExile(null, "", source.getSourceId(), game);§}§}§return true;§}§}§
public class RaggedVeins extends CardImpl {§public RaggedVeins(UUID ownerId) {§super(ownerId, 139, "Ragged Veins", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{B}");§this.expansionSetCode = "CHK";§this.subtype.add("Aura");§this.addAbility(FlashAbility.getInstance());§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.Detriment));§this.addAbility(new EnchantAbility(auraTarget.getTargetName()));§Effect effect = new LoseLifeTargetEffect(new NumericSetToEffectValues("that much", "damage"));§effect.setText("its controller loses that much life");§this.addAbility(new DamageDealtToAttachedTriggeredAbility(Zone.BATTLEFIELD, effect, false, SetTargetPointer.PLAYER));§}§public RaggedVeins(final RaggedVeins card) {§super(card);§}§@Override§public RaggedVeins copy() {§return new RaggedVeins(this);§}§}§
public class ReachThroughMists extends CardImpl {§public ReachThroughMists (UUID ownerId) {§super(ownerId, 81, "Reach Through Mists", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{U}");§this.expansionSetCode = "CHK";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(1));§}§public ReachThroughMists (final ReachThroughMists card) {§super(card);§}§@Override§public ReachThroughMists copy() {§return new ReachThroughMists(this);§}§}§
public class Reciprocate extends CardImpl {§public Reciprocate(UUID ownerId) {§super(ownerId, 40, "Reciprocate", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{W}");§this.expansionSetCode = "CHK";§this.getSpellAbility().addEffect(new ExileTargetEffect());§this.getSpellAbility().addTarget(new ReciprocateTarget());§}§public Reciprocate(final Reciprocate card) {§super(card);§}§@Override§public Reciprocate copy() {§return new Reciprocate(this);§}§}§class ReciprocateTarget extends TargetPermanent {§public ReciprocateTarget() {§super(1, 1, new FilterCreaturePermanent(), false);§targetName = "creature that dealt damage to you this turn";§}§public ReciprocateTarget(final ReciprocateTarget target) {§super(target);§}§@Override§public boolean canTarget(UUID id, Ability source, Game game) {§PlayerDamagedBySourceWatcher watcher = (PlayerDamagedBySourceWatcher) game.getState().getWatchers().get("PlayerDamagedBySource", source.getControllerId());§if (watcher != null && watcher.hasSourceDoneDamage(id, game)) {§return super.canTarget(id, source, game);§}§return false;§}§@Override§public Set<UUID> possibleTargets(UUID sourceId, UUID sourceControllerId, Game game) {§Set<UUID> availablePossibleTargets = super.possibleTargets(sourceId, sourceControllerId, game);§Set<UUID> possibleTargets = new HashSet<UUID>();§PlayerDamagedBySourceWatcher watcher = (PlayerDamagedBySourceWatcher) game.getState().getWatchers().get("PlayerDamagedBySource", sourceControllerId);§for (UUID targetId : availablePossibleTargets) {§Permanent permanent = game.getPermanent(targetId);§if (permanent != null && watcher != null && watcher.hasSourceDoneDamage(targetId, game)) {§possibleTargets.add(targetId);§}§}§return possibleTargets;§}§@Override§public boolean canChoose(UUID sourceId, UUID sourceControllerId, Game game) {§int remainingTargets = this.minNumberOfTargets - targets.size();§if (remainingTargets == 0) {§return true;§}§int count = 0;§MageObject targetSource = game.getObject(sourceId);§PlayerDamagedBySourceWatcher watcher = (PlayerDamagedBySourceWatcher) game.getState().getWatchers().get("PlayerDamagedBySource", sourceControllerId);§for (Permanent permanent : game.getBattlefield().getActivePermanents(filter, sourceControllerId, sourceId, game)) {§if (!targets.containsKey(permanent.getId()) && permanent.canBeTargetedBy(targetSource, sourceControllerId, game)§&& watcher != null && watcher.hasSourceDoneDamage(permanent.getId(), game)) {§count++;§if (count >= remainingTargets) {§return true;§}§}§}§return false;§}§@Override§public ReciprocateTarget copy() {§return new ReciprocateTarget(this);§}§}§
public class RendSpirit extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("Spirit");§static {§filter.add(new SubtypePredicate("Spirit"));§}§public RendSpirit(UUID ownerId) {§super(ownerId, 141, "Rend Spirit", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{B}");§this.expansionSetCode = "CHK";§this.getSpellAbility().addTarget(new TargetPermanent(filter));§this.getSpellAbility().addEffect(new DestroyTargetEffect());§}§public RendSpirit(final RendSpirit card) {§super(card);§}§@Override§public RendSpirit copy() {§return new RendSpirit(this);§}§}§
public class ReverseTheSands extends CardImpl {§public ReverseTheSands(UUID ownerId) {§super(ownerId, 41, "Reverse the Sands", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{6}{W}{W}");§this.expansionSetCode = "CHK";§this.getSpellAbility().addEffect(new ReverseTheSandsEffect());§}§public ReverseTheSands(final ReverseTheSands card) {§super(card);§}§@Override§public ReverseTheSands copy() {§return new ReverseTheSands(this);§}§}§class ReverseTheSandsEffect extends OneShotEffect {§public ReverseTheSandsEffect() {§super(Outcome.Benefit);§this.staticText = "Redistribute any number of players' life totals";§}§public ReverseTheSandsEffect(final ReverseTheSandsEffect effect) {§super(effect);§}§@Override§public ReverseTheSandsEffect copy() {§return new ReverseTheSandsEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Choice lifeChoice = new ChoiceImpl(true);§Set<String> choices = new HashSet<String>();§for (UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {§Player player = game.getPlayer(playerId);§if (player != null) {§choices.add(new StringBuilder(Integer.toString(player.getLife())).append(" life of ").append(player.getLogName()).toString());§}§}§lifeChoice.setChoices(choices);§for (UUID playersId : game.getState().getPlayersInRange(controller.getId(), game)) {§Player player = game.getPlayer(playersId);§if (player != null) {§String selectedChoice;§if (choices.size() > 1) {§lifeChoice.setMessage("Which players life should get player " + player.getLogName());§controller.choose(Outcome.Detriment, lifeChoice, game);§selectedChoice = lifeChoice.getChoice();§} else {§selectedChoice = choices.iterator().next();§}§int index = selectedChoice.indexOf(" ");§if (index > 0) {§String lifeString = selectedChoice.substring(0, index);§int life = Integer.parseInt(lifeString);§player.setLife(life, game);§choices.remove(selectedChoice);§game.informPlayers(new StringBuilder("Player ").append(player.getLogName()).append(" life set to ").append(life).toString());§}§}§}§}§return false;§}§}§
public class Reweave extends CardImpl {§public Reweave(UUID ownerId) {§super(ownerId, 82, "Reweave", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{5}{U}");§this.expansionSetCode = "CHK";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new ReweaveEffect());§Target target = new TargetPermanent();§this.getSpellAbility().addTarget(target);§this.addAbility(new SpliceOntoArcaneAbility("{2}{U}{U}"));§}§public Reweave(final Reweave card) {§super(card);§}§@Override§public Reweave copy() {§return new Reweave(this);§}§}§class ReweaveEffect extends OneShotEffect {§private static final FilterPermanentCard filter = new FilterPermanentCard();§public ReweaveEffect() {§super(Outcome.Detriment);§this.staticText = "Target permanent's controller sacrifices it. If he or she does, that player reveals cards from the top of his or her library until he or she reveals a permanent card that shares a card type with the sacrificed permanent, puts that card onto the battlefield, then shuffles his or her library";§}§public ReweaveEffect(final ReweaveEffect effect) {§super(effect);§}§@Override§public ReweaveEffect copy() {§return new ReweaveEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getPermanent(getTargetPointer().getFirst(game, source));§MageObject sourceObject = source.getSourceObject(game);§if (permanent != null && sourceObject != null) {§if (permanent.sacrifice(source.getSourceId(), game)) {§Player permanentController = game.getPlayer(permanent.getControllerId());§if (permanentController != null) {§Library library = permanentController.getLibrary();§if (library.size() > 0) {§Cards cards = new CardsImpl();§Card card = null;§boolean cardFound = false;§if (library.size() > 0) {§do {§card = library.removeFromTop(game);§cards.add(card);§if (filter.match(card, game)) {§for (CardType cardType : permanent.getCardType()) {§if (card.getCardType().contains(cardType)) {§cardFound = true;§break;§}§}§}§} while (!cardFound && library.size() > 0);§permanentController.moveCards(card, Zone.BATTLEFIELD, source, game);§}§if (cards.size() > 0) {§permanentController.revealCards(sourceObject.getIdName(), cards, game);§if (cardFound && card != null) {§cards.remove(card);§}§library.addAll(cards.getCards(game), game);§permanentController.shuffleLibrary(game);§}§}§return true;§}§return false;§}§}§return true;§}§}§
public class RiverKaijin extends CardImpl {§public RiverKaijin (UUID ownerId) {§super(ownerId, 83, "River Kaijin", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{U}");§this.expansionSetCode = "CHK";§this.subtype.add("Spirit");§this.power = new MageInt(1);§this.toughness = new MageInt(4);§}§public RiverKaijin (final RiverKaijin card) {§super(card);§}§@Override§public RiverKaijin copy() {§return new RiverKaijin(this);§}§}§
public class RoninHoundmaster extends CardImpl {§public RoninHoundmaster (UUID ownerId) {§super(ownerId, 184, "Ronin Houndmaster", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "CHK";§this.subtype.add("Human");§this.subtype.add("Samurai");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(HasteAbility.getInstance());§this.addAbility(new BushidoAbility(1));§}§public RoninHoundmaster (final RoninHoundmaster card) {§super(card);§}§@Override§public RoninHoundmaster copy() {§return new RoninHoundmaster(this);§}§}§
public class Rootrunner extends CardImpl {§public Rootrunner(UUID ownerId) {§super(ownerId, 237, "Rootrunner", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{G}{G}");§this.expansionSetCode = "CHK";§this.subtype.add("Spirit");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new PutOnLibraryTargetEffect(true), new ManaCostsImpl("{G}{G}"));§ability.addCost(new SacrificeSourceCost());§ability.addTarget(new TargetLandPermanent());§this.addAbility(ability);§this.addAbility(new SoulshiftAbility(3));§}§public Rootrunner(final Rootrunner card) {§super(card);§}§@Override§public Rootrunner copy() {§return new Rootrunner(this);§}§}§
public class RyuseiTheFallingStar extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature without flying");§static {§filter.add(Predicates.not(new AbilityPredicate(FlyingAbility.class)));§}§public RyuseiTheFallingStar(UUID ownerID) {§super(ownerID, 185, "Ryusei, the Falling Star", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}{R}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Dragon");§this.subtype.add("Spirit");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new DiesTriggeredAbility(new DamageAllEffect(5, filter)));§}§public RyuseiTheFallingStar(final RyuseiTheFallingStar card) {§super(card);§}§@Override§public RyuseiTheFallingStar copy() {§return new RyuseiTheFallingStar(this);§}§}§
public class SachiDaughterOfSeshiro extends CardImpl {§private static final FilterCreaturePermanent snakeFilter = new FilterCreaturePermanent("Snakes");§private static final FilterCreaturePermanent shamanFilter = new FilterCreaturePermanent("Shamans");§static {§snakeFilter.add(new SubtypePredicate("Snake"));§shamanFilter.add(new SubtypePredicate("Shaman"));§}§public SachiDaughterOfSeshiro(UUID ownerId) {§super(ownerId, 238, "Sachi, Daughter of Seshiro", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{G}{G}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Snake");§this.subtype.add("Shaman");§this.power = new MageInt(1);§this.toughness = new MageInt(3);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostControlledEffect(0, 1, Duration.WhileOnBattlefield, snakeFilter, true)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityControlledEffect(§new SimpleManaAbility(Zone.BATTLEFIELD, new BasicManaEffect(Mana.GreenMana(2)), new TapSourceCost()), Duration.WhileOnBattlefield, shamanFilter, false)));§}§public SachiDaughterOfSeshiro(final SachiDaughterOfSeshiro card) {§super(card);§}§@Override§public SachiDaughterOfSeshiro copy() {§return new SachiDaughterOfSeshiro(this);§}§}§
public class SakuraTribeElder extends CardImpl {§final static FilterBasicLandCard filterLands = new FilterBasicLandCard();§public SakuraTribeElder(UUID ownerId) {§super(ownerId, 239, "Sakura-Tribe Elder", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "CHK";§this.subtype.add("Snake");§this.subtype.add("Shaman");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§TargetCardInLibrary target = new TargetCardInLibrary(filterLands);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new SearchLibraryPutInPlayEffect(target, true, Outcome.PutLandInPlay), new SacrificeSourceCost()));§}§public SakuraTribeElder(final SakuraTribeElder card) {§super(card);§}§@Override§public SakuraTribeElder copy() {§return new SakuraTribeElder(this);§}§}§
public class SamuraiEnforcers extends CardImpl {§public SamuraiEnforcers (UUID ownerId) {§super(ownerId, 42, "Samurai Enforcers", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{W}{W}");§this.expansionSetCode = "CHK";§this.subtype.add("Human");§this.subtype.add("Samurai");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(new BushidoAbility(2));§}§public SamuraiEnforcers (final SamuraiEnforcers card) {§super(card);§}§@Override§public SamuraiEnforcers copy() {§return new SamuraiEnforcers(this);§}§}§
public class SamuraiOfThePaleCurtain extends CardImpl {§public SamuraiOfThePaleCurtain (UUID ownerId) {§super(ownerId, 43, "Samurai of the Pale Curtain", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{W}{W}");§this.expansionSetCode = "CHK";§this.subtype.add("Fox");§this.subtype.add("Samurai");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new BushidoAbility(1));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new SamuraiOfThePaleCurtainEffect()));§}§public SamuraiOfThePaleCurtain (final SamuraiOfThePaleCurtain card) {§super(card);§}§@Override§public SamuraiOfThePaleCurtain copy() {§return new SamuraiOfThePaleCurtain(this);§}§}§class SamuraiOfThePaleCurtainEffect extends ReplacementEffectImpl {§public SamuraiOfThePaleCurtainEffect() {§super(Duration.WhileOnBattlefield, Outcome.Exile);§staticText = "If a permanent would be put into a graveyard, exile it instead";§}§public SamuraiOfThePaleCurtainEffect(final SamuraiOfThePaleCurtainEffect effect) {§super(effect);§}§@Override§public SamuraiOfThePaleCurtainEffect copy() {§return new SamuraiOfThePaleCurtainEffect(this);§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§Permanent permanent = ((ZoneChangeEvent)event).getTarget();§if (permanent != null) {§return permanent.moveToExile(null, "", source.getSourceId(), game);§}§return false;§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == EventType.ZONE_CHANGE;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§ZoneChangeEvent zEvent = (ZoneChangeEvent)event;§return zEvent.getToZone() == Zone.GRAVEYARD;§}§}§
public class ScuttlingDeath extends CardImpl {§public ScuttlingDeath(UUID ownerId) {§super(ownerId, 142, "Scuttling Death", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{B}");§this.expansionSetCode = "CHK";§this.subtype.add("Spirit");§this.power = new MageInt(4);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostTargetEffect(-1, -1, Duration.EndOfTurn), new SacrificeSourceCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§this.addAbility(new SoulshiftAbility(4));§}§public ScuttlingDeath(final ScuttlingDeath card) {§super(card);§}§@Override§public ScuttlingDeath copy() {§return new ScuttlingDeath(this);§}§}§
public class SeizanPerverterOfTruth extends CardImpl {§public SeizanPerverterOfTruth (UUID ownerId) {§super(ownerId, 143, "Seizan, Perverter of Truth", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{B}{B}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Demon");§this.subtype.add("Spirit");§this.power = new MageInt(6);§this.toughness = new MageInt(5);§Effect effect = new LoseLifeTargetEffect(2);§effect.setText("that player loses 2 life");§Ability ability = new BeginningOfUpkeepTriggeredAbility(effect, TargetController.ANY, false);§effect = new DrawCardTargetEffect(2);§effect.setText("and draws two cards");§ability.addEffect(effect);§this.addAbility(ability);§}§public SeizanPerverterOfTruth (final SeizanPerverterOfTruth card) {§super(card);§}§@Override§public SeizanPerverterOfTruth copy() {§return new SeizanPerverterOfTruth(this);§}§}§
public class SenseiGoldenTail extends CardImpl {§public SenseiGoldenTail (UUID ownerId) {§super(ownerId, 44, "Sensei Golden-Tail", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.supertype.add("Legendary");§this.expansionSetCode = "CHK";§this.subtype.add("Fox");§this.subtype.add("Samurai");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new BushidoAbility(1));§Ability ability = new ActivateAsSorceryActivatedAbility(Zone.BATTLEFIELD, new AddCountersTargetEffect(new Counter("Training")), new ManaCostsImpl("{1}{W}"));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent());§ability.addEffect(new GainAbilityTargetEffect(new BushidoAbility(1),Duration.Custom));§ability.addEffect(new AddCardSubTypeTargetEffect("Samurai",Duration.Custom));§this.addAbility(ability);§}§public SenseiGoldenTail (final SenseiGoldenTail card) {§super(card);§}§@Override§public SenseiGoldenTail copy() {§return new SenseiGoldenTail(this);§}§}§
public class SenseisDiviningTop extends CardImpl {§public SenseisDiviningTop(UUID ownerId) {§super(ownerId, 268, "Sensei's Divining Top", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{1}");§this.expansionSetCode = "CHK";§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new LookLibraryControllerEffect(3),new ManaCostsImpl("{1}")));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DrawCardSourceControllerEffect(1),new TapSourceCost());§ability.addEffect(new SenseisDiviningTopEffect());§this.addAbility(ability);§}§public SenseisDiviningTop(final SenseisDiviningTop card) {§super(card);§}§@Override§public SenseisDiviningTop copy() {§return new SenseisDiviningTop(this);§}§}§class SenseisDiviningTopEffect extends OneShotEffect {§public SenseisDiviningTopEffect() {§super(Outcome.ReturnToHand);§staticText = ", then put Sensei's Divining Top on top of its owner's library";§}§public SenseisDiviningTopEffect(final SenseisDiviningTopEffect effect) {§super(effect);§}§@Override§public SenseisDiviningTopEffect copy() {§return new SenseisDiviningTopEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getPermanent(source.getSourceId());§if (permanent != null) {§return permanent.moveToZone(Zone.LIBRARY, source.getSourceId(), game, true);§}§return false;§}§}§
public class SerpentSkin extends CardImpl {§public SerpentSkin (UUID ownerId) {§super(ownerId, 240, "Serpent Skin", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{G}");§this.expansionSetCode = "CHK";§this.subtype.add("Aura");§this.addAbility(FlashAbility.getInstance());§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(1, 1, Duration.WhileOnBattlefield)));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new RegenerateAttachedEffect(AttachmentType.AURA),new ColoredManaCost(ColoredManaSymbol.G)));§}§public SerpentSkin (final SerpentSkin card) {§super(card);§}§@Override§public SerpentSkin copy() {§return new SerpentSkin(this);§}§}§
public class SeshiroTheAnointed extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Snakes");§static {§filter.add(new SubtypePredicate("Snake"));§}§public SeshiroTheAnointed(UUID ownerId) {§super(ownerId, 241, "Seshiro the Anointed", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{G}{G}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Snake");§this.subtype.add("Monk");§this.power = new MageInt(3);§this.toughness = new MageInt(4);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostControlledEffect(2, 2, Duration.WhileOnBattlefield, filter, true)));§this.addAbility(new SeshiroTheAnointedAbility());§}§public SeshiroTheAnointed(final SeshiroTheAnointed card) {§super(card);§}§@Override§public SeshiroTheAnointed copy() {§return new SeshiroTheAnointed(this);§}§}§class SeshiroTheAnointedAbility extends TriggeredAbilityImpl {§public SeshiroTheAnointedAbility() {§super(Zone.BATTLEFIELD, new DrawCardSourceControllerEffect(1), true);§}§public SeshiroTheAnointedAbility(final SeshiroTheAnointedAbility ability) {§super(ability);§}§@Override§public SeshiroTheAnointedAbility copy() {§return new SeshiroTheAnointedAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.DAMAGED_PLAYER;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§DamagedPlayerEvent damageEvent = (DamagedPlayerEvent)event;§Permanent p = game.getPermanent(event.getSourceId());§if (damageEvent.isCombatDamage() && p != null && p.hasSubtype("Snake") && p.getControllerId().equals(controllerId)) {§return true;§}§return false;§}§@Override§public String getRule() {§return "Whenever a Snake you control deals combat damage to a player, you may draw a card.";§}§}§
public class ShellOfTheLastKappa extends CardImpl {§private static final FilterSpell filter = new FilterSpell("instant or sorcery spell that targets you");§static {§filter.add(new TargetYouPredicate());§filter.add(Predicates.or(new CardTypePredicate(CardType.INSTANT), new CardTypePredicate(CardType.SORCERY)));§}§public ShellOfTheLastKappa(UUID ownerId) {§super(ownerId, 269, "Shell of the Last Kappa", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ShellOfTheLastKappaEffect(), new ManaCostsImpl("{3}"));§ability.addCost(new TapSourceCost());§Target target = new TargetSpell(filter);§ability.addTarget(target);§this.addAbility(ability);§ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ShellOfTheLastKappaCastEffect(), new ManaCostsImpl("{3}"));§ability.addCost(new TapSourceCost());§ability.addCost(new SacrificeSourceCost());§this.addAbility(ability);§}§public ShellOfTheLastKappa(final ShellOfTheLastKappa card) {§super(card);§}§@Override§public ShellOfTheLastKappa copy() {§return new ShellOfTheLastKappa(this);§}§}§class ShellOfTheLastKappaEffect extends OneShotEffect {§public ShellOfTheLastKappaEffect() {§super(Outcome.Exile);§this.staticText = "Exile target instant or sorcery spell that targets you";§}§public ShellOfTheLastKappaEffect(final ShellOfTheLastKappaEffect effect) {§super(effect);§}§@Override§public ShellOfTheLastKappaEffect copy() {§return new ShellOfTheLastKappaEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Spell spell = game.getStack().getSpell(targetPointer.getFirst(game, source));§if (spell != null) {§Permanent sourcePermanent = game.getPermanent(source.getSourceId());§if (sourcePermanent == null) {§sourcePermanent = (Permanent) game.getLastKnownInformation(source.getSourceId(), Zone.BATTLEFIELD);§}§if (sourcePermanent != null) {§game.getStack().counter(spell.getId(), source.getSourceId(), game);§Card card = spell.getCard();§card.moveToExile(CardUtil.getCardExileZoneId(game, source), sourcePermanent.getName(), id, game);§}§}§return false;§}§}§class ShellOfTheLastKappaCastEffect extends OneShotEffect {§public ShellOfTheLastKappaCastEffect() {§super(Outcome.PlayForFree);§this.staticText = "You may cast a card exiled with {this} without paying its mana cost";§}§public ShellOfTheLastKappaCastEffect(final ShellOfTheLastKappaCastEffect effect) {§super(effect);§}§@Override§public ShellOfTheLastKappaCastEffect copy() {§return new ShellOfTheLastKappaCastEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§TargetCardInExile target = new TargetCardInExile(new FilterCard(), CardUtil.getCardExileZoneId(game, source));§if (controller.choose(Outcome.PlayForFree, game.getExile().getExileZone(CardUtil.getCardExileZoneId(game, source)), target, game)) {§Card card = game.getCard(target.getFirstTarget());§if (card != null) {§game.getExile().removeCard(card, game);§return controller.cast(card.getSpellAbility(), game, true);§}§}§}§return false;§}§}§class TargetYouPredicate implements ObjectPlayerPredicate<ObjectPlayer<StackObject>> {§@Override§public boolean apply(ObjectPlayer<StackObject> input, Game game) {§UUID controllerId = input.getPlayerId();§if (controllerId == null) {§return false;§}§for (Target target : input.getObject().getStackAbility().getTargets()) {§for (UUID targetId : target.getTargets()) {§if (controllerId.equals(targetId)) {§return true;§}§}§}§return false;§}§@Override§public String toString() {§return "spell that targets you";§}§}§
public class ShisatoWhisperingHunter extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("Snake");§static {§filter.add(new SubtypePredicate("Snake"));§}§public ShisatoWhisperingHunter(UUID ownerId) {§super(ownerId, 242, "Shisato, Whispering Hunter", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{G}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Snake");§this.subtype.add("Warrior");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new BeginningOfUpkeepTriggeredAbility(new SacrificeControllerEffect(filter, 1,""), TargetController.YOU, false));§this.addAbility(new DealsCombatDamageToAPlayerTriggeredAbility(new SkipNextPlayerUntapStepEffect("that "),false, true));§}§public ShisatoWhisperingHunter(final ShisatoWhisperingHunter card) {§super(card);§}§@Override§public ShisatoWhisperingHunter copy() {§return new ShisatoWhisperingHunter(this);§}§}§
public class ShizoDeathsStorehouse extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("legendary creature");§static {§filter.add(new SupertypePredicate("Legendary"));§}§public ShizoDeathsStorehouse(UUID ownerId) {§super(ownerId, 283, "Shizo, Death's Storehouse", Rarity.RARE, new CardType[]{CardType.LAND}, null);§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.addAbility(new BlackManaAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilityTargetEffect(FearAbility.getInstance(), Duration.EndOfTurn), new ColoredManaCost(ColoredManaSymbol.B));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetPermanent(filter));§this.addAbility(ability);§}§public ShizoDeathsStorehouse(final ShizoDeathsStorehouse card) {§super(card);§}§@Override§public ShizoDeathsStorehouse copy() {§return new ShizoDeathsStorehouse(this);§}§}§
public class Sideswipe extends CardImpl {§private static final FilterSpell filter = new FilterSpell("Arcane spell");§static {§filter.add(new SubtypePredicate("Arcane"));§}§public Sideswipe(UUID ownerId) {§super(ownerId, 187, "Sideswipe", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{1}{R}");§this.expansionSetCode = "CHK";§Effect effect = new ChooseNewTargetsTargetEffect(false, false);§effect.setText("You may change any targets of target Arcane spell");§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addTarget(new TargetSpell(filter));§}§public Sideswipe(final Sideswipe card) {§super(card);§}§@Override§public Sideswipe copy() {§return new Sideswipe(this);§}§}§
public class SiftThroughSands extends CardImpl {§private static final String rule = "If you've cast a spell named Peer Through Depths and a spell named Reach Through Mists this turn, you may search your library for a card named The Unspeakable, put it onto the battlefield, then shuffle your library";§private static final FilterCreatureCard filter = new FilterCreatureCard("a card named The Unspeakable");§static {§filter.add(new NamePredicate("The Unspeakable"));§}§public SiftThroughSands(UUID ownerId) {§super(ownerId, 84, "Sift Through Sands", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{U}{U}");§this.expansionSetCode = "CHK";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(2));§Effect effect = new DiscardControllerEffect(1);§effect.setText(", then discard a card");§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addEffect(new ConditionalOneShotEffect(new SearchLibraryPutInPlayEffect(new TargetCardInLibrary(filter), false, true), new SiftThroughSandsCondition(), rule));§this.getSpellAbility().addWatcher(new SiftThroughSandsWatcher());§}§public SiftThroughSands(final SiftThroughSands card) {§super(card);§}§@Override§public SiftThroughSands copy() {§return new SiftThroughSands(this);§}§}§class SiftThroughSandsCondition implements Condition {§@Override§public boolean apply(Game game, Ability source) {§SiftThroughSandsWatcher watcher = (SiftThroughSandsWatcher) game.getState().getWatchers().get("SiftThroughSandsWatcher", source.getControllerId());§if (watcher != null) {§return watcher.conditionMet();§}§return false;§}§}§class SiftThroughSandsWatcher extends Watcher {§boolean castPeerThroughDepths = false;§boolean castReachThroughMists = false;§public SiftThroughSandsWatcher() {§super("SiftThroughSandsWatcher", WatcherScope.PLAYER);§}§public SiftThroughSandsWatcher(final SiftThroughSandsWatcher watcher) {§super(watcher);§this.castPeerThroughDepths = watcher.castPeerThroughDepths;§this.castReachThroughMists = watcher.castReachThroughMists;§}§@Override§public SiftThroughSandsWatcher copy() {§return new SiftThroughSandsWatcher(this);§}§@Override§public void watch(GameEvent event, Game game) {§if (condition == true) { §
public class SilentChantZubera extends CardImpl {§public SilentChantZubera (UUID ownerId) {§super(ownerId, 45, "Silent-Chant Zubera", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "CHK";§this.subtype.add("Zubera");§this.subtype.add("Spirit");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§Ability ability = new DiesTriggeredAbility(new GainLifeEffect(new SilentChantZuberaDynamicValue()));§this.addAbility(ability, new ZuberasDiedWatcher());§}§public SilentChantZubera (final SilentChantZubera card) {§super(card);§}§@Override§public SilentChantZubera copy() {§return new SilentChantZubera(this);§}§}§class SilentChantZuberaDynamicValue implements DynamicValue {§@Override§public int calculate(Game game, Ability sourceAbility, Effect effect) {§ZuberasDiedWatcher watcher = (ZuberasDiedWatcher) game.getState().getWatchers().get("ZuberasDied");§return watcher.zuberasDiedThisTurn * 2;§}§@Override§public SilentChantZuberaDynamicValue copy() {§return new SilentChantZuberaDynamicValue();§}§@Override§public String toString() {§return "2";§}§@Override§public String getMessage() {§return "Zubera that died this turn";§}§}§
public class SireOfTheStorm extends CardImpl {§private static final FilterSpiritOrArcaneCard filter = new FilterSpiritOrArcaneCard();§public SireOfTheStorm(UUID ownerId) {§super(ownerId, 85, "Sire of the Storm", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{U}{U}");§this.expansionSetCode = "CHK";§this.subtype.add("Spirit");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new SpellCastControllerTriggeredAbility(new DrawCardSourceControllerEffect(1), filter, true));§}§public SireOfTheStorm(final SireOfTheStorm card) {§super(card);§}§@Override§public SireOfTheStorm copy() {§return new SireOfTheStorm(this);§}§}§
public class Soilshaper extends CardImpl {§private static final FilterSpiritOrArcaneCard filter = new FilterSpiritOrArcaneCard();§public Soilshaper(UUID ownerId) {§super(ownerId, 243, "Soilshaper", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "CHK";§this.subtype.add("Spirit");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SpellCastControllerTriggeredAbility(new BecomesCreatureTargetEffect(new SoilshaperToken(), false, true, Duration.EndOfTurn), filter, false);§ability.addTarget(new TargetLandPermanent());§this.addAbility(ability);§}§public Soilshaper(final Soilshaper card) {§super(card);§}§@Override§public Soilshaper copy() {§return new Soilshaper(this);§}§}§class SoilshaperToken extends Token {§public SoilshaperToken() {§super("", "3/3 creature");§this.cardType.add(CardType.CREATURE);§this.power = new MageInt(3);§this.toughness = new MageInt(3);§}§}§
public class SokenzanBruiser extends CardImpl {§public SokenzanBruiser (UUID ownerId) {§super(ownerId, 188, "Sokenzan Bruiser", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{R}");§this.expansionSetCode = "CHK";§this.subtype.add("Ogre");§this.subtype.add("Warrior");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new MountainwalkAbility());§}§public SokenzanBruiser (final SokenzanBruiser card) {§super(card);§}§@Override§public SokenzanBruiser copy() {§return new SokenzanBruiser(this);§}§}§
public class SoratamiCloudskater extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledLandPermanent("a land");§public SoratamiCloudskater(UUID ownerId) {§super(ownerId, 86, "Soratami Cloudskater", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{U}");§this.expansionSetCode = "CHK";§this.subtype.add("Moonfolk");§this.subtype.add("Rogue");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DrawDiscardControllerEffect(), new GenericManaCost(2));§ability.addCost(new ReturnToHandChosenControlledPermanentCost(new TargetControlledPermanent(1, 1, filter, true)));§this.addAbility(ability);§}§public SoratamiCloudskater(final SoratamiCloudskater card) {§super(card);§}§@Override§public SoratamiCloudskater copy() {§return new SoratamiCloudskater(this);§}§}§
public class SoratamiMirrorGuard extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledLandPermanent("a land");§private static final FilterCreaturePermanent filterCreature = new FilterCreaturePermanent("creature with power 2 or less");§static {§filterCreature.add(new PowerPredicate(Filter.ComparisonType.LessThan, 3));§}§public SoratamiMirrorGuard(UUID ownerId) {§super(ownerId, 87, "Soratami Mirror-Guard", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{U}");§this.expansionSetCode = "CHK";§this.subtype.add("Moonfolk");§this.subtype.add("Wizard");§this.power = new MageInt(3);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new CantBeBlockedTargetEffect(), new GenericManaCost(2));§ability.addCost(new ReturnToHandChosenControlledPermanentCost(new TargetControlledPermanent(filter)));§ability.addTarget(new TargetCreaturePermanent(filterCreature));§this.addAbility(ability);§}§public SoratamiMirrorGuard(final SoratamiMirrorGuard card) {§super(card);§}§@Override§public SoratamiMirrorGuard copy() {§return new SoratamiMirrorGuard(this);§}§}§
public class SoratamiMirrorMage extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledLandPermanent("lands");§public SoratamiMirrorMage(UUID ownerId) {§super(ownerId, 88, "Soratami Mirror-Mage", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{U}");§this.expansionSetCode = "CHK";§this.subtype.add("Moonfolk");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ReturnToHandTargetEffect(), new GenericManaCost(3));§ability.addCost(new ReturnToHandChosenControlledPermanentCost(new TargetControlledPermanent(3, 3, filter, true)));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public SoratamiMirrorMage(final SoratamiMirrorMage card) {§super(card);§}§@Override§public SoratamiMirrorMage copy() {§return new SoratamiMirrorMage(this);§}§}§
public class SoratamiRainshaper extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledLandPermanent("a land");§public SoratamiRainshaper(UUID ownerId) {§super(ownerId, 89, "Soratami Rainshaper", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{U}");§this.expansionSetCode = "CHK";§this.subtype.add("Moonfolk");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilityTargetEffect(ShroudAbility.getInstance(), Duration.EndOfTurn), new GenericManaCost(3));§ability.addCost(new ReturnToHandChosenControlledPermanentCost(new TargetControlledPermanent(filter)));§ability.addTarget(new TargetControlledCreaturePermanent());§this.addAbility(ability);§}§public SoratamiRainshaper(final SoratamiRainshaper card) {§super(card);§}§@Override§public SoratamiRainshaper copy() {§return new SoratamiRainshaper(this);§}§}§
public class SoratamiSavant extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledLandPermanent("a land");§public SoratamiSavant(UUID ownerId) {§super(ownerId, 90, "Soratami Savant", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{U}{U}");§this.expansionSetCode = "CHK";§this.subtype.add("Moonfolk");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new CounterUnlessPaysEffect(new GenericManaCost(3)), new GenericManaCost(3));§ability.addCost(new ReturnToHandChosenControlledPermanentCost(new TargetControlledPermanent(filter)));§ability.addTarget(new TargetSpell());§this.addAbility(ability);§}§public SoratamiSavant(final SoratamiSavant card) {§super(card);§}§@Override§public SoratamiSavant copy() {§return new SoratamiSavant(this);§}§}§
public class SoratamiSeer extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledLandPermanent("lands");§public SoratamiSeer(UUID ownerId) {§super(ownerId, 91, "Soratami Seer", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{U}");§this.expansionSetCode = "CHK";§this.subtype.add("Moonfolk");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new SoratamiSeerEffect(), new GenericManaCost(4));§ability.addCost(new ReturnToHandChosenControlledPermanentCost(new TargetControlledPermanent(2, 2, filter, false)));§this.addAbility(ability);§}§public SoratamiSeer(final SoratamiSeer card) {§super(card);§}§@Override§public SoratamiSeer copy() {§return new SoratamiSeer(this);§}§}§class SoratamiSeerEffect extends OneShotEffect {§public SoratamiSeerEffect() {§super(Outcome.DrawCard);§staticText = "Discard all the cards in your hand, then draw that many cards";§}§public SoratamiSeerEffect(final SoratamiSeerEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§int amount = player.getHand().getCards(game).size();§for (Card c : player.getHand().getCards(game)) {§player.discard(c, source, game);§}§player.drawCards(amount, game);§return true;§}§return false;§}§@Override§public SoratamiSeerEffect copy() {§return new SoratamiSeerEffect(this);§}§}§
public class SosukeSonOfSeshiro extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Snake creatures");§static {§filter.add(new SubtypePredicate("Snake"));§}§public SosukeSonOfSeshiro(UUID ownerId) {§super(ownerId, 244, "Sosuke, Son of Seshiro", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{G}{G}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Snake");§this.subtype.add("Warrior");§this.power = new MageInt(3);§this.toughness = new MageInt(4);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostControlledEffect(1, 0, Duration.WhileOnBattlefield, filter, true)));§Effect effect = new CreateDelayedTriggeredAbilityEffect(§new AtTheEndOfCombatDelayedTriggeredAbility(new DestroyTargetEffect()), true);§effect.setText("destroy that creature at end of combat");§this.addAbility(new SosukeSonOfSeshiroTriggeredAbility(effect));§}§public SosukeSonOfSeshiro(final SosukeSonOfSeshiro card) {§super(card);§}§@Override§public SosukeSonOfSeshiro copy() {§return new SosukeSonOfSeshiro(this);§}§}§class SosukeSonOfSeshiroTriggeredAbility extends TriggeredAbilityImpl {§SosukeSonOfSeshiroTriggeredAbility(Effect effect) {§super(Zone.BATTLEFIELD, effect);§}§SosukeSonOfSeshiroTriggeredAbility(final SosukeSonOfSeshiroTriggeredAbility ability) {§super(ability);§}§@Override§public SosukeSonOfSeshiroTriggeredAbility copy() {§return new SosukeSonOfSeshiroTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.DAMAGED_CREATURE;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (((DamagedCreatureEvent) event).isCombatDamage()) {§Permanent sourceCreature = game.getPermanent(event.getSourceId());§Permanent targetCreature = game.getPermanent(event.getTargetId());§if (sourceCreature != null && sourceCreature.getControllerId().equals(this.getControllerId())§&& targetCreature != null && sourceCreature.hasSubtype("Warrior")) {§this.getEffects().get(0).setTargetPointer(new FixedTarget(targetCreature.getId()));§return true;§}§}§return false;§}§@Override§public String getRule() {§return "Whenever a Warrior you control deals combat damage to a creature, destroy that creature at end of combat.";§}§}§
public class SoullessRevival extends CardImpl {§public SoullessRevival(UUID ownerId) {§super(ownerId, 144, "Soulless Revival", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{B}");§this.expansionSetCode = "CHK";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new ReturnFromGraveyardToHandTargetEffect());§this.getSpellAbility().addTarget(new TargetCardInYourGraveyard(new FilterCreatureCard("creature card from your graveyard")));§this.addAbility(new SpliceOntoArcaneAbility("{1}{B}"));§}§public SoullessRevival(final SoullessRevival card) {§super(card);§}§@Override§public SoullessRevival copy() {§return new SoullessRevival(this);§}§}§
public class SoulOfMagma extends CardImpl {§private static final FilterSpiritOrArcaneCard filter = new FilterSpiritOrArcaneCard();§public SoulOfMagma(UUID ownerId) {§super(ownerId, 189, "Soul of Magma", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{R}{R}");§this.expansionSetCode = "CHK";§this.subtype.add("Spirit");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new SpellCastControllerTriggeredAbility(new DamageTargetEffect(1), filter, false);§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public SoulOfMagma(final SoulOfMagma card) {§super(card);§}§@Override§public SoulOfMagma copy() {§return new SoulOfMagma(this);§}§}§
public class Squelch extends CardImpl {§public Squelch(UUID ownerId) {§super(ownerId, 92, "Squelch", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{1}{U}");§this.expansionSetCode = "CHK";§this.getSpellAbility().addEffect(new CounterTargetEffect());§this.getSpellAbility().addTarget(new TargetActivatedAbility());§this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(1));§}§public Squelch(final Squelch card) {§super(card);§}§@Override§public Squelch copy() {§return new Squelch(this);§}§}§
public class StudentOfElements extends CardImpl {§public StudentOfElements(UUID ownerId) {§super(ownerId, 93, "Student of Elements", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{U}");§this.expansionSetCode = "CHK";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.flipCard = true;§this.flipCardName = "Tobita, Master of Winds";§this.addAbility(new StudentOfElementsHasFlyingAbility());§}§public StudentOfElements(final StudentOfElements card) {§super(card);§}§@Override§public StudentOfElements copy() {§return new StudentOfElements(this);§}§}§class StudentOfElementsHasFlyingAbility extends StateTriggeredAbility {§public StudentOfElementsHasFlyingAbility() {§super(Zone.BATTLEFIELD, new FlipSourceEffect(new TobitaMasterOfWinds()));§}§public StudentOfElementsHasFlyingAbility(final StudentOfElementsHasFlyingAbility ability) {§super(ability);§}§@Override§public StudentOfElementsHasFlyingAbility copy() {§return new StudentOfElementsHasFlyingAbility(this);§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§Permanent permanent = game.getPermanent(getSourceId());§if(permanent != null && permanent.getAbilities().contains(FlyingAbility.getInstance())){§return true;§}§return false;§}§@Override§public String getRule() {§return "When {this} has flying, flip it.";§}§}§class TobitaMasterOfWinds extends Token {§TobitaMasterOfWinds() {§super("Tobita, Master of Winds", "");§supertype.add("Legendary");§cardType.add(CardType.CREATURE);§color.setBlue(true);§subtype.add("Human");§subtype.add("Wizard");§power = new MageInt(3);§toughness = new MageInt(3);§this.addAbility(new SimpleStaticAbility(§Zone.BATTLEFIELD, new GainAbilityControlledEffect(FlyingAbility.getInstance(), Duration.WhileOnBattlefield, new FilterCreaturePermanent())));§}§}§
public class SwallowingPlague extends CardImpl {§public SwallowingPlague (UUID ownerId) {§super(ownerId, 146, "Swallowing Plague", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{X}{B}{B}");§this.expansionSetCode = "CHK";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new DamageTargetEffect(new ManacostVariableValue()));§this.getSpellAbility().addEffect(new GainLifeEffect(new ManacostVariableValue()));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public SwallowingPlague (final SwallowingPlague card) {§super(card);§}§@Override§public SwallowingPlague copy() {§return new SwallowingPlague(this);§}§}§
public class TakenoSamuraiGeneral extends CardImpl {§public TakenoSamuraiGeneral(UUID ownerId) {§super(ownerId, 46, "Takeno, Samurai General", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}{W}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Samurai");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new BushidoAbility(2));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new TakenoSamuraiGeneralEffect()));§}§public TakenoSamuraiGeneral(final TakenoSamuraiGeneral card) {§super(card);§}§@Override§public TakenoSamuraiGeneral copy() {§return new TakenoSamuraiGeneral(this);§}§}§class TakenoSamuraiGeneralEffect extends ContinuousEffectImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent();§static {§filter.add(new SubtypePredicate("Samurai"));§}§public TakenoSamuraiGeneralEffect() {§super(Duration.WhileOnBattlefield, Layer.PTChangingEffects_7, SubLayer.ModifyPT_7c, Outcome.BoostCreature);§staticText = "Each other Samurai creature you control gets +1/+1 for each point of bushido it has";§}§public TakenoSamuraiGeneralEffect(final TakenoSamuraiGeneralEffect effect) {§super(effect);§}§@Override§public TakenoSamuraiGeneralEffect copy() {§return new TakenoSamuraiGeneralEffect(this);§}§@Override§public void init(Ability source, Game game) {§super.init(source, game);§if (this.affectedObjectsSet) {§for (Permanent perm: game.getBattlefield().getAllActivePermanents(filter, source.getControllerId(), game)) {§if (!perm.getId().equals(source.getSourceId())) {§for (Ability ability : perm.getAbilities()) {§if (ability instanceof BushidoAbility) {§affectedObjectList.add(new MageObjectReference(perm, game));§}§}§}§}§}§}§@Override§public boolean apply(Game game, Ability source) {§if (this.affectedObjectsSet) {§for (Iterator<MageObjectReference> it = affectedObjectList.iterator(); it.hasNext();) { §
public class TatsumasaTheDragonsFang extends CardImpl {§public TatsumasaTheDragonsFang(UUID ownerId) {§super(ownerId, 270, "Tatsumasa, the Dragon's Fang", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{6}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Equipment");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEquippedEffect(5, 5)));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new TatsumaTheDragonsFangEffect(), new GenericManaCost(6));§ability.addCost(new ExileSourceCost(true));§this.addAbility(ability);§this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(3)));§}§public TatsumasaTheDragonsFang(final TatsumasaTheDragonsFang card) {§super(card);§}§@Override§public TatsumasaTheDragonsFang copy() {§return new TatsumasaTheDragonsFang(this);§}§}§class TatsumaTheDragonsFangEffect extends OneShotEffect {§public TatsumaTheDragonsFangEffect() {§super(Outcome.PutCreatureInPlay);§this.staticText = "Put a 5/5 blue Dragon Spirit creature token with flying onto the battlefield. Return Tatsumasa to the battlefield under its owner's control when that token dies";§}§public TatsumaTheDragonsFangEffect(final TatsumaTheDragonsFangEffect effect) {§super(effect);§}§@Override§public TatsumaTheDragonsFangEffect copy() {§return new TatsumaTheDragonsFangEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§CreateTokenEffect effect = new CreateTokenEffect(new TatsumaDragonToken());§effect.apply(game, source);§for (UUID tokenId : effect.getLastAddedTokenIds()) { §
public class TellerOfTales extends CardImpl {§private static final FilterSpiritOrArcaneCard filter = new FilterSpiritOrArcaneCard();§public TellerOfTales(UUID ownerId) {§super(ownerId, 95, "Teller of Tales", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{U}{U}");§this.expansionSetCode = "CHK";§this.subtype.add("Spirit");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new SpellCastControllerTriggeredAbility(new MayTapOrUntapTargetEffect(),filter, true);§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public TellerOfTales(final TellerOfTales card) {§super(card);§}§@Override§public TellerOfTales copy() {§return new TellerOfTales(this);§}§}§
public class TenzaGodosMaul extends CardImpl {§private static final String rule1 = "As long as it's legendary, it gets an additional +2/+2";§private static final String rule2 = "As long as it's red, it has trample.";§private static final FilterCreaturePermanent legendaryFilter = new FilterCreaturePermanent("legendary");§private static final FilterCreaturePermanent redFilter = new FilterCreaturePermanent("red");§static {§legendaryFilter.add(new SupertypePredicate("Legendary"));§redFilter.add(new ColorPredicate(ObjectColor.RED));§}§public TenzaGodosMaul(UUID ownerId) {§super(ownerId, 271, "Tenza, Godo's Maul", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Equipment");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEquippedEffect(1, 1)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new ConditionalContinuousEffect(§new BoostEquippedEffect(2, 2),§new EquippedMatchesFilterCondition(legendaryFilter), rule1)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new ConditionalContinuousEffect(§new GainAbilityAttachedEffect(TrampleAbility.getInstance(), AttachmentType.EQUIPMENT),§new EquippedMatchesFilterCondition(redFilter), rule2)));§this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(1), new TargetControlledCreaturePermanent()));§}§public TenzaGodosMaul(final TenzaGodosMaul card) {§super(card);§}§@Override§public TenzaGodosMaul copy() {§return new TenzaGodosMaul(this);§}§}§
public class TerashisCry extends CardImpl {§public TerashisCry(UUID ownerId) {§super(ownerId, 47, "Terashi's Cry", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{3}{W}");§this.expansionSetCode = "CHK";§this.subtype.add("Arcane");§Target target = new TargetCreaturePermanent(0,3);§target.setTargetName("up to three");§this.getSpellAbility().addEffect(new TapTargetEffect());§this.getSpellAbility().addTarget(target);§}§public TerashisCry(final TerashisCry card) {§super(card);§}§@Override§public TerashisCry copy() {§return new TerashisCry(this);§}§}§
public class TheUnspeakable extends CardImpl {§private static final FilterCard filter = new FilterCard("Arcane card from your graveyard");§static {§filter.add(new SubtypePredicate("Arcane"));§}§public TheUnspeakable(UUID ownerId) {§super(ownerId, 98, "The Unspeakable", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{6}{U}{U}{U}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Spirit");§this.power = new MageInt(6);§this.toughness = new MageInt(7);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(TrampleAbility.getInstance());§Ability ability = new DealsCombatDamageToAPlayerTriggeredAbility(new ReturnToHandTargetEffect(), true);§ability.addTarget(new TargetCardInYourGraveyard(filter));§this.addAbility(ability);§}§public TheUnspeakable(final TheUnspeakable card) {§super(card);§}§@Override§public TheUnspeakable copy() {§return new TheUnspeakable(this);§}§}§
public class ThiefOfHope extends CardImpl {§private static final FilterSpiritOrArcaneCard filter = new FilterSpiritOrArcaneCard();§public ThiefOfHope(UUID ownerId) {§super(ownerId, 147, "Thief of Hope", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{B}");§this.expansionSetCode = "CHK";§this.subtype.add("Spirit");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new SpellCastControllerTriggeredAbility(new LoseLifeTargetEffect(1), filter, false);§ability.addEffect(new GainLifeEffect(1));§ability.addTarget(new TargetOpponent());§this.addAbility(ability);§this.addAbility(new SoulshiftAbility(2));§}§public ThiefOfHope(final ThiefOfHope card) {§super(card);§}§@Override§public ThiefOfHope copy() {§return new ThiefOfHope(this);§}§}§
public class Thoughtbind extends CardImpl {§private static final FilterSpell filter = new FilterSpell("spell with converted mana cost 4 or less");§static {§filter.add(new ConvertedManaCostPredicate(Filter.ComparisonType.LessThan, 5));§}§public Thoughtbind(UUID ownerId) {§super(ownerId, 96, "Thoughtbind", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{U}");§this.expansionSetCode = "CHK";§this.getSpellAbility().addEffect(new CounterTargetEffect());§this.getSpellAbility().addTarget(new TargetSpell(filter));§}§public Thoughtbind(final Thoughtbind card) {§super(card);§}§@Override§public Thoughtbind copy() {§return new Thoughtbind(this);§}§}§
public class ThousandleggedKami extends CardImpl {§public ThousandleggedKami(UUID ownerId) {§super(ownerId, 246, "Thousand-legged Kami", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{6}{G}{G}");§this.expansionSetCode = "CHK";§this.subtype.add("Spirit");§this.power = new MageInt(6);§this.toughness = new MageInt(6);§this.addAbility(new SoulshiftAbility(7));§}§public ThousandleggedKami(final ThousandleggedKami card) {§super(card);§}§@Override§public ThousandleggedKami copy() {§return new ThousandleggedKami(this);§}§}§
public class ThroughTheBreach extends CardImpl {§public ThroughTheBreach(UUID ownerId) {§super(ownerId, 193, "Through the Breach", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{4}{R}");§this.expansionSetCode = "CHK";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new ThroughTheBreachEffect());§this.addAbility(new SpliceOntoArcaneAbility(new ManaCostsImpl("{2}{R}{R}")));§}§public ThroughTheBreach(final ThroughTheBreach card) {§super(card);§}§@Override§public ThroughTheBreach copy() {§return new ThroughTheBreach(this);§}§}§class ThroughTheBreachEffect extends OneShotEffect {§private static final String choiceText = "Put a creature card from your hand onto the battlefield?";§public ThroughTheBreachEffect() {§super(Outcome.Benefit);§this.staticText = "You may put a creature card from your hand onto the battlefield. That creature gains haste. Sacrifice that creature at the beginning of the next end step";§}§public ThroughTheBreachEffect(final ThroughTheBreachEffect effect) {§super(effect);§}§@Override§public ThroughTheBreachEffect copy() {§return new ThroughTheBreachEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§if (controller.chooseUse(Outcome.PutCreatureInPlay, choiceText, source, game)) {§TargetCardInHand target = new TargetCardInHand(new FilterCreatureCard());§if (controller.choose(Outcome.PutCreatureInPlay, target, source.getSourceId(), game)) {§Card card = game.getCard(target.getFirstTarget());§if (card != null) {§if (controller.moveCards(card, Zone.BATTLEFIELD, source, game)) {§Permanent permanent = game.getPermanent(card.getId());§if (permanent != null) {§ContinuousEffect effect = new GainAbilityTargetEffect(HasteAbility.getInstance(), Duration.Custom);§effect.setTargetPointer(new FixedTarget(permanent, game));§game.addEffect(effect, source);§SacrificeTargetEffect sacrificeEffect = new SacrificeTargetEffect("sacrifice " + card.getName(), source.getControllerId());§sacrificeEffect.setTargetPointer(new FixedTarget(permanent, game));§DelayedTriggeredAbility delayedAbility = new AtTheBeginOfNextEndStepDelayedTriggeredAbility(sacrificeEffect);§game.addDelayedTriggeredAbility(delayedAbility, source);§return true;§}§}§}§return false;§}§}§return true;§}§return false;§}§}§
public class TideOfWar extends CardImpl {§public TideOfWar(UUID ownerId) {§super(ownerId, 194, "Tide of War", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{4}{R}{R}");§this.expansionSetCode = "CHK";§this.addAbility(new BlocksTriggeredAbility(new TideOfWarEffect(), false));§}§public TideOfWar(final TideOfWar card) {§super(card);§}§@Override§public TideOfWar copy() {§return new TideOfWar(this);§}§}§class BlocksTriggeredAbility extends TriggeredAbilityImpl {§public BlocksTriggeredAbility(Effect effect, boolean optional) {§super(Zone.BATTLEFIELD, effect, optional);§}§public BlocksTriggeredAbility(final BlocksTriggeredAbility ability) {§super(ability);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.DECLARED_BLOCKERS;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§for (CombatGroup combatGroup: game.getCombat().getGroups()) {§if (!combatGroup.getBlockers().isEmpty()) {§return true;§}§}§return false;§}§@Override§public String getRule() {§return "Whenever one or more creatures block, " + super.getRule();§}§@Override§public BlocksTriggeredAbility copy() {§return new BlocksTriggeredAbility(this);§}§}§class TideOfWarEffect extends OneShotEffect {§public TideOfWarEffect() {§super(Outcome.Benefit);§this.staticText = "flip a coin. If you win the flip, each blocking creature is sacrificed by its controller. If you lose the flip, each blocked creature is sacrificed by its controller";§}§public TideOfWarEffect(final TideOfWarEffect effect) {§super(effect);§}§@Override§public TideOfWarEffect copy() {§return new TideOfWarEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Set<UUID> toSacrifice = new HashSet<UUID>();§if (controller.flipCoin(game)) {§for (CombatGroup combatGroup: game.getCombat().getGroups()) {§for (UUID blockerId: combatGroup.getBlockers()) {§toSacrifice.add(blockerId);§}§}§} else {§for (CombatGroup combatGroup: game.getCombat().getGroups()) {§if (!combatGroup.getBlockers().isEmpty()) {§for (UUID attackerId: combatGroup.getAttackers()) {§toSacrifice.add(attackerId);§}§}§}§}§for(UUID creatureId: toSacrifice) {§Permanent creature = game.getPermanent(creatureId);§if (creature != null) {§creature.sacrifice(source.getSourceId(), game);§Player player = game.getPlayer(creature.getControllerId());§if (player != null) {§game.informPlayers(new StringBuilder(player.getLogName()).append(" sacrifices ").append(creature.getName()).toString());§}§}§}§return true;§}§return false;§}§}§
public class TimeOfNeed extends CardImpl {§private static final FilterCard filter = new FilterCard("legendary creature card");§static {§filter.add(new CardTypePredicate(CardType.CREATURE));§filter.add(new SupertypePredicate("Legendary"));§}§public TimeOfNeed(UUID ownerId) {§super(ownerId, 247, "Time of Need", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{1}{G}");§this.expansionSetCode = "CHK";§TargetCardInLibrary target = new TargetCardInLibrary(filter);§this.getSpellAbility().addEffect(new SearchLibraryPutInHandEffect(target, true));§}§public TimeOfNeed(final TimeOfNeed card) {§super(card);§}§@Override§public TimeOfNeed copy() {§return new TimeOfNeed(this);§}§}§
public class TranquilGarden extends CardImpl {§public TranquilGarden(UUID ownerId) {§super(ownerId, 284, "Tranquil Garden", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "CHK";§this.addAbility(new ColorlessManaAbility());§Ability greenManaAbility = new GreenManaAbility();§greenManaAbility.addEffect(new DontUntapInControllersNextUntapStepSourceEffect());§this.addAbility(greenManaAbility);§Ability whiteManaAbility = new WhiteManaAbility();§whiteManaAbility.addEffect(new DontUntapInControllersNextUntapStepSourceEffect());§this.addAbility(whiteManaAbility);§}§public TranquilGarden(final TranquilGarden card) {§super(card);§}§@Override§public TranquilGarden copy() {§return new TranquilGarden(this);§}§}§
public class UbaMask extends CardImpl {§public final static String UBA_MASK_VALUE_KEY = "ubaMaskExiledCards";§public UbaMask(UUID ownerId) {§super(ownerId, 272, "Uba Mask", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{4}");§this.expansionSetCode = "CHK";§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new UbaMaskReplacementEffect()));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new UbaMaskPlayEffect()));§}§public UbaMask(final UbaMask card) {§super(card);§}§@Override§public UbaMask copy() {§return new UbaMask(this);§}§}§class UbaMaskReplacementEffect extends ReplacementEffectImpl {§UbaMaskReplacementEffect() {§super(Duration.WhileOnBattlefield, Outcome.Neutral);§this.staticText = "If a player would draw a card, that player exiles that card face up instead";§}§UbaMaskReplacementEffect(final UbaMaskReplacementEffect effect) {§super(effect);§}§@Override§public UbaMaskReplacementEffect copy() {§return new UbaMaskReplacementEffect(this);§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§if (event.getType().equals(GameEvent.EventType.PLAY_TURN)) {§game.getState().setValue(UbaMask.UBA_MASK_VALUE_KEY, null);§return false;§}§MageObject sourceObject = source.getSourceObject(game);§Player player = game.getPlayer(event.getPlayerId());§if (player != null && sourceObject != null) {§Card card = player.getLibrary().getFromTop(game);§if (card != null) {§player.moveCardsToExile(card, source, game, true, source.getId(), sourceObject.getIdName());§Map<UUID, HashSet<MageObjectReference>> exiledCards = (Map) game.getState().getValue(UbaMask.UBA_MASK_VALUE_KEY);§if (exiledCards == null) {§exiledCards = new HashMap<>();§game.getState().setValue(UbaMask.UBA_MASK_VALUE_KEY, exiledCards);§}§HashSet<MageObjectReference> exiledCardsByPlayer = exiledCards.get(event.getPlayerId());§if (exiledCardsByPlayer == null) {§exiledCardsByPlayer = new HashSet<>();§exiledCards.put(event.getPlayerId(), exiledCardsByPlayer);§}§exiledCardsByPlayer.add(new MageObjectReference(card.getId(), game));§}§}§return true;§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.DRAW_CARD || event.getType() == GameEvent.EventType.PLAY_TURN;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§return true;§}§}§class UbaMaskPlayEffect extends AsThoughEffectImpl {§public UbaMaskPlayEffect() {§super(AsThoughEffectType.PLAY_FROM_NOT_OWN_HAND_ZONE, Duration.EndOfGame, Outcome.Benefit);§staticText = "Each player may play cards he or she exiled with {this} this turn";§}§public UbaMaskPlayEffect(final UbaMaskPlayEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public UbaMaskPlayEffect copy() {§return new UbaMaskPlayEffect(this);§}§@Override§public boolean applies(UUID objectId, Ability source, UUID affectedControllerId, Game game) {§Card card = game.getCard(objectId);§if (card != null && affectedControllerId.equals(card.getOwnerId()) && game.getState().getZone(card.getId()) == Zone.EXILED) {§Map<UUID, HashSet<MageObjectReference>> exiledCards = (Map) game.getState().getValue(UbaMask.UBA_MASK_VALUE_KEY);§if (exiledCards != null) {§Set<MageObjectReference> exiledCardsByPlayer = exiledCards.get(affectedControllerId);§if (exiledCardsByPlayer != null) {§return exiledCardsByPlayer.contains(new MageObjectReference(card, game));§}§}§}§return false;§}§}§
public class UncontrollableAnger extends CardImpl {§public UncontrollableAnger(UUID ownerId) {§super(ownerId, 195, "Uncontrollable Anger", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{R}{R}");§this.expansionSetCode = "CHK";§this.subtype.add("Aura");§this.addAbility(FlashAbility.getInstance());§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(2, 2, Duration.WhileOnBattlefield));§Effect effect = new AttacksIfAbleAttachedEffect(Duration.WhileOnBattlefield, AttachmentType.AURA);§effect.setText("and attacks each turn if able");§ability.addEffect(effect);§this.addAbility(ability);§}§public UncontrollableAnger(final UncontrollableAnger card) {§super(card);§}§@Override§public UncontrollableAnger copy() {§return new UncontrollableAnger(this);§}§}§
public class UnearthlyBlizzard extends CardImpl {§public UnearthlyBlizzard(UUID ownerId) {§super(ownerId, 196, "Unearthly Blizzard", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{2}{R}");§this.expansionSetCode = "CHK";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new CantBlockTargetEffect(Duration.EndOfTurn));§this.getSpellAbility().addTarget(new TargetCreaturePermanent(0, 3));§}§public UnearthlyBlizzard(final UnearthlyBlizzard card) {§super(card);§}§@Override§public UnearthlyBlizzard copy() {§return new UnearthlyBlizzard(this);§}§}§
public class UyoSilentProphet extends CardImpl {§private static final FilterSpell filter = new FilterSpell("instant or sorcery spell");§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.INSTANT),§new CardTypePredicate(CardType.SORCERY)));§}§public UyoSilentProphet(UUID ownerId) {§super(ownerId, 99, "Uyo, Silent Prophet", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{U}{U}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Moonfolk");§this.subtype.add("Wizard");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new CopyTargetSpellEffect(), new GenericManaCost(2));§ability.addCost(new ReturnToHandChosenControlledPermanentCost(new TargetControlledPermanent(2, 2, new FilterControlledLandPermanent("lands"), false)));§ability.addTarget(new TargetSpell(filter));§this.addAbility(ability);§}§public UyoSilentProphet(final UyoSilentProphet card) {§super(card);§}§@Override§public UyoSilentProphet copy() {§return new UyoSilentProphet(this);§}§}§
public class VassalsDuty extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("legendary creature you control");§static {§filter.add(new SupertypePredicate("Legendary"));§}§public VassalsDuty(UUID ownerId) {§super(ownerId, 48, "Vassal's Duty", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{3}{W}");§this.expansionSetCode = "CHK";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new VassalsDutyPreventDamageTargetEffect(Duration.EndOfTurn, 1), new GenericManaCost(1));§ability.addTarget(new TargetControlledCreaturePermanent(1, 1, filter, false));§this.addAbility(ability);§}§public VassalsDuty(final VassalsDuty card) {§super(card);§}§@Override§public VassalsDuty copy() {§return new VassalsDuty(this);§}§}§class VassalsDutyPreventDamageTargetEffect extends RedirectionEffect {§public VassalsDutyPreventDamageTargetEffect(Duration duration, int amount) {§super(duration, amount, true);§staticText = "The next " + amount + " damage that would be dealt to target legendary creature you control this turn is dealt to you instead";§}§public VassalsDutyPreventDamageTargetEffect(final VassalsDutyPreventDamageTargetEffect effect) {§super(effect);§}§@Override§public VassalsDutyPreventDamageTargetEffect copy() {§return new VassalsDutyPreventDamageTargetEffect(this);§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§if (event.getTargetId().equals(getTargetPointer().getFirst(game, source))) {§TargetPlayer target = new TargetPlayer();§target.add(source.getControllerId(), game);§redirectTarget = target;§return true;§}§return false;§}§}§
public class VenerableKumo extends CardImpl {§public VenerableKumo(UUID ownerId) {§super(ownerId, 248, "Venerable Kumo", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{G}");§this.expansionSetCode = "CHK";§this.subtype.add("Spirit");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(ReachAbility.getInstance());§this.addAbility(new SoulshiftAbility(4));§}§public VenerableKumo(final VenerableKumo card) {§super(card);§}§@Override§public VenerableKumo copy() {§return new VenerableKumo(this);§}§}§
public class Vigilance extends CardImpl {§public Vigilance (UUID ownerId) {§super(ownerId, 49, "Vigilance", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{W}");§this.expansionSetCode = "CHK";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(VigilanceAbility.getInstance(), AttachmentType.AURA)));§}§public Vigilance (final Vigilance card) {§super(card);§}§@Override§public Vigilance copy() {§return new Vigilance(this);§}§}§
public class VillainousOgre extends CardImpl {§private static final String rule = "As long as you control a Demon, {this} has {B}: Regenerate Villainous Ogre";§private static final FilterControlledPermanent filter = new FilterControlledPermanent("Demon");§static {§filter.add(new SubtypePredicate("Demon"));§}§public VillainousOgre(UUID ownerId) {§super(ownerId, 148, "Villainous Ogre", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{B}");§this.expansionSetCode = "CHK";§this.subtype.add("Ogre");§this.subtype.add("Warrior");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§this.addAbility(new CantBlockAbility());§this.addAbility(new ConditionalGainActivatedAbility(§Zone.BATTLEFIELD,§new RegenerateSourceEffect(),§new ColoredManaCost(ColoredManaSymbol.B),§new PermanentsOnTheBattlefieldCondition(filter),§rule));§}§public VillainousOgre(final VillainousOgre card) {§super(card);§}§@Override§public VillainousOgre copy() {§return new VillainousOgre(this);§}§}§
public class VineKami extends CardImpl {§public VineKami(UUID ownerId) {§super(ownerId, 249, "Vine Kami", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{6}{G}");§this.expansionSetCode = "CHK";§this.subtype.add("Spirit");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(new MenaceAbility());§this.addAbility(new SoulshiftAbility(6));§}§public VineKami(final VineKami card) {§super(card);§}§@Override§public VineKami copy() {§return new VineKami(this);§}§}§
public class WakingNightmare extends CardImpl {§public WakingNightmare (UUID ownerId) {§super(ownerId, 149, "Waking Nightmare", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{2}{B}");§this.expansionSetCode = "CHK";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new DiscardTargetEffect(2));§this.getSpellAbility().addTarget(new TargetPlayer());§}§public WakingNightmare (final WakingNightmare card) {§super(card);§}§@Override§public WakingNightmare copy() {§return new WakingNightmare(this);§}§}§
public class WanderingOnes extends CardImpl {§public WanderingOnes (UUID ownerId) {§super(ownerId, 100, "Wandering Ones", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{U}");§this.expansionSetCode = "CHK";§this.subtype.add("Spirit");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§}§public WanderingOnes (final WanderingOnes card) {§super(card);§}§@Override§public WanderingOnes copy() {§return new WanderingOnes(this);§}§}§
public class WaterveilCavern extends CardImpl {§public WaterveilCavern(UUID ownerId) {§super(ownerId, 286, "Waterveil Cavern", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "CHK";§this.addAbility(new ColorlessManaAbility());§Ability blueManaAbility = new BlueManaAbility();§blueManaAbility.addEffect(new DontUntapInControllersNextUntapStepSourceEffect());§this.addAbility(blueManaAbility);§Ability blackManaAbility = new BlackManaAbility();§blackManaAbility.addEffect(new DontUntapInControllersNextUntapStepSourceEffect());§this.addAbility(blackManaAbility);§}§public WaterveilCavern(final WaterveilCavern card) {§super(card);§}§@Override§public WaterveilCavern copy() {§return new WaterveilCavern(this);§}§}§
public class WearAway extends CardImpl {§public WearAway(UUID ownerId) {§super(ownerId, 250, "Wear Away", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{G}{G}");§this.expansionSetCode = "CHK";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new DestroyTargetEffect());§Target target = new TargetPermanent(new FilterArtifactOrEnchantmentPermanent());§this.getSpellAbility().addTarget(target);§this.addAbility(new SpliceOntoArcaneAbility("{3}{G}"));§}§public WearAway(final WearAway card) {§super(card);§}§@Override§public WearAway copy() {§return new WearAway(this);§}§}§
public class WickedAkuba extends CardImpl {§private static final FilterPlayer filter = new FilterPlayer("player dealt damage by Wicked Akuba this turn");§static {§filter.add(new WickedAkubaPredicate());§}§public WickedAkuba(UUID ownerId) {§super(ownerId, 150, "Wicked Akuba", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{B}{B}");§this.expansionSetCode = "CHK";§this.subtype.add("Spirit");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new LoseLifeTargetEffect(1), new ColoredManaCost(ColoredManaSymbol.B));§ability.addTarget(new TargetPlayer(1, 1, false, filter));§this.addAbility(ability);§}§public WickedAkuba(final WickedAkuba card) {§super(card);§}§@Override§public WickedAkuba copy() {§return new WickedAkuba(this);§}§}§class WickedAkubaPredicate implements ObjectSourcePlayerPredicate<ObjectSourcePlayer<Player>> {§@Override§public boolean apply(ObjectSourcePlayer<Player> input, Game game) {§PlayerDamagedBySourceWatcher watcher = (PlayerDamagedBySourceWatcher) game.getState().getWatchers().get("PlayerDamagedBySource", input.getObject().getId());§if (watcher != null) {§return watcher.hasSourceDoneDamage(input.getSourceId(), game);§}§return false;§}§@Override§public String toString() {§return "(Player dealt damage by {source} this turn)";§}§}§
public class YamabushisFlame extends CardImpl {§public YamabushisFlame(UUID ownerId) {§super(ownerId, 198, "Yamabushi's Flame", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{R}");§this.expansionSetCode = "CHK";§this.getSpellAbility().addEffect(new DamageTargetEffect(3));§this.getSpellAbility().addTarget(new TargetCreatureOrPlayer());§this.getSpellAbility().addEffect(new DealtDamageToCreatureBySourceDies(this, Duration.EndOfTurn));§this.getSpellAbility().addWatcher(new DamagedByWatcher());§}§public YamabushisFlame(final YamabushisFlame card) {§super(card);§}§@Override§public YamabushisFlame copy() {§return new YamabushisFlame(this);§}§}§
public class YamabushisStorm extends CardImpl {§public YamabushisStorm(UUID ownerId) {§super(ownerId, 199, "Yamabushi's Storm", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{1}{R}");§this.expansionSetCode = "CHK";§this.getSpellAbility().addEffect(new DamageAllEffect(1, new FilterCreaturePermanent()));§this.getSpellAbility().addEffect(new DealtDamageToCreatureBySourceDies(this, Duration.EndOfTurn));§this.getSpellAbility().addWatcher(new DamagedByWatcher());§}§public YamabushisStorm(final YamabushisStorm card) {§super(card);§}§@Override§public YamabushisStorm copy() {§return new YamabushisStorm(this);§}§}§
public class YoseiTheMorningStar extends CardImpl {§public YoseiTheMorningStar(UUID ownerId) {§super(ownerId, 50, "Yosei, the Morning Star", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{W}{W}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Dragon");§this.subtype.add("Spirit");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new DiesTriggeredAbility(new SkipNextPlayerUntapStepEffect());§ability.addTarget(new TargetPlayer());§ability.addTarget(new YoseiTheMorningStarTarget());§ability.addEffect(new YoseiTheMorningStarTapEffect());§this.addAbility(ability);§}§public YoseiTheMorningStar(final YoseiTheMorningStar card) {§super(card);§}§@Override§public YoseiTheMorningStar copy() {§return new YoseiTheMorningStar(this);§}§}§class YoseiTheMorningStarTarget extends TargetPermanent {§private static final FilterPermanent filterTemplate = new FilterPermanent("up to five target permanents that player controls that will be tapped");§public YoseiTheMorningStarTarget() {§super(0, 5, filterTemplate, false);§}§public YoseiTheMorningStarTarget(final YoseiTheMorningStarTarget target) {§super(target);§}§@Override§public boolean canTarget(UUID controllerId, UUID id, Ability source, Game game) {§Player player = game.getPlayer(source.getFirstTarget());§if (player != null) {§this.filter = filterTemplate.copy();§this.filter.add(new ControllerIdPredicate(player.getId()));§return super.canTarget(controllerId, id, source, game);§}§return false;§}§@Override§public YoseiTheMorningStarTarget copy() {§return new YoseiTheMorningStarTarget(this);§}§}§class YoseiTheMorningStarTapEffect extends OneShotEffect {§public YoseiTheMorningStarTapEffect() {§super(Outcome.Tap);§staticText = "Tap up to five target permanents that player controls";§}§public YoseiTheMorningStarTapEffect(final YoseiTheMorningStarTapEffect effect) {§super(effect);§}§@Override§public YoseiTheMorningStarTapEffect copy() {§return new YoseiTheMorningStarTapEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Targets targets = source.getTargets();§Target target1 = targets.get(1);§for (UUID target: target1.getTargets()) {§Permanent permanent = game.getPermanent(target);§if (permanent != null) {§permanent.tap(game);§} else {§return false;§}§}§return true;§}§@Override§public String getText(Mode mode) {§return staticText;§}§}§
public class ZoZuThePunisher extends CardImpl {§private static final FilterCard filter = new FilterCard("legendary spell");§static {§filter.add(new SupertypePredicate("Legendary"));§}§public ZoZuThePunisher(UUID ownerId) {§super(ownerId, 200, "Zo-Zu the Punisher", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{R}{R}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Goblin");§this.subtype.add("Warrior");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new ZoZuThePunisherAbility());§}§public ZoZuThePunisher(final ZoZuThePunisher card) {§super(card);§}§@Override§public ZoZuThePunisher copy() {§return new ZoZuThePunisher(this);§}§}§class ZoZuThePunisherAbility extends TriggeredAbilityImpl {§public ZoZuThePunisherAbility() {§super(Zone.BATTLEFIELD, new DamageTargetEffect(2));§}§ZoZuThePunisherAbility(final ZoZuThePunisherAbility ability) {§super(ability);§}§@Override§public ZoZuThePunisherAbility copy() {§return new ZoZuThePunisherAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.ENTERS_THE_BATTLEFIELD;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§Permanent permanent = game.getPermanent(event.getTargetId());§if (permanent != null && permanent.getCardType().contains(CardType.LAND)) {§Player player = game.getPlayer(permanent.getControllerId());§if (player != null) {§for (Effect effect : this.getEffects()) {§effect.setTargetPointer(new FixedTarget(player.getId()));§}§return true;§}§}§return false;§}§@Override§public String getRule() {§return "Whenever a land enters the battlefield, Zo-Zu the Punisher deals 2 damage to that land's controller.";§}§}§
public class ObsianusGolem extends CardImpl {§public ObsianusGolem(UUID ownerId) {§super(ownerId, 303, "Obsianus Golem", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{6}");§this.expansionSetCode = "6ED";§this.subtype.add("Golem");§this.power = new MageInt(4);§this.toughness = new MageInt(6);§}§public ObsianusGolem(final ObsianusGolem card) {§super(card);§}§@Override§public ObsianusGolem copy() {§return new ObsianusGolem(this);§}§}§
public class RegalUnicorn extends CardImpl {§public RegalUnicorn(UUID ownerId) {§super(ownerId, 35, "Regal Unicorn", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "6ED";§this.subtype.add("Unicorn");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§}§public RegalUnicorn(final RegalUnicorn card) {§super(card);§}§@Override§public RegalUnicorn copy() {§return new RegalUnicorn(this);§}§}§
public class AdarkarValkyrie extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("another creature");§static {§filter.add(new AnotherPredicate());§}§public AdarkarValkyrie(UUID ownerId) {§super(ownerId, 1, "Adarkar Valkyrie", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{W}{W}");§this.expansionSetCode = "CSP";§this.supertype.add("Snow");§this.subtype.add("Angel");§this.power = new MageInt(4);§this.toughness = new MageInt(5);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(VigilanceAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new AdarkarValkyrieEffect(), new TapSourceCost());§Target target = new TargetCreaturePermanent(filter);§ability.addTarget(target);§this.addAbility(ability);§}§public AdarkarValkyrie(final AdarkarValkyrie card) {§super(card);§}§@Override§public AdarkarValkyrie copy() {§return new AdarkarValkyrie(this);§}§}§class AdarkarValkyrieEffect extends OneShotEffect {§public AdarkarValkyrieEffect() {§super(Outcome.PutCreatureInPlay);§this.staticText = "When target creature other than {this} dies this turn, return that card to the battlefield under your control";§}§public AdarkarValkyrieEffect(final AdarkarValkyrieEffect effect) {§super(effect);§}§@Override§public AdarkarValkyrieEffect copy() {§return new AdarkarValkyrieEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§DelayedTriggeredAbility delayedAbility = new AdarkarValkyrieDelayedTriggeredAbility(new FixedTarget(this.getTargetPointer().getFirst(game, source)));§game.addDelayedTriggeredAbility(delayedAbility, source);§return false;§}§}§class AdarkarValkyrieDelayedTriggeredAbility extends DelayedTriggeredAbility {§protected FixedTarget fixedTarget;§public AdarkarValkyrieDelayedTriggeredAbility(FixedTarget fixedTarget) {§super(new ReturnToBattlefieldUnderYourControlTargetEffect(), Duration.EndOfTurn);§this.getEffects().get(0).setTargetPointer(fixedTarget);§this.fixedTarget = fixedTarget;§}§public AdarkarValkyrieDelayedTriggeredAbility(final AdarkarValkyrieDelayedTriggeredAbility ability) {§super(ability);§this.fixedTarget = ability.fixedTarget;§}§@Override§public AdarkarValkyrieDelayedTriggeredAbility copy() {§return new AdarkarValkyrieDelayedTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.ZONE_CHANGE;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (((ZoneChangeEvent) event).isDiesEvent()) {§if (fixedTarget.getFirst(game, this).equals(event.getTargetId())) {§return true;§}§}§return false;§}§@Override§public String getRule() {§return "When target creature other than Adarkar Valkyrie dies this turn, " + super.getRule();§}§}§
public class ArcumDagsson extends CardImpl {§private static final FilterPermanent filter = new FilterArtifactPermanent("artifact creature");§static {§filter.add(new CardTypePredicate(CardType.CREATURE));§}§public ArcumDagsson(UUID ownerId) {§super(ownerId, 27, "Arcum Dagsson", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{U}");§this.expansionSetCode = "CSP";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Artificer");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ArcumDagssonEffect(), new TapSourceCost());§ability.addTarget(new TargetPermanent(filter));§this.addAbility(ability);§}§public ArcumDagsson(final ArcumDagsson card) {§super(card);§}§@Override§public ArcumDagsson copy() {§return new ArcumDagsson(this);§}§}§class ArcumDagssonEffect extends OneShotEffect {§private static final FilterCard filter = new FilterArtifactCard("noncreature artifact card");§static {§filter.add(Predicates.not(new CardTypePredicate(CardType.CREATURE)));§}§ArcumDagssonEffect() {§super(Outcome.Removal);§this.staticText = "Target artifact creature's controller sacrifices it. That player may search his or her library for a noncreature artifact card, put it onto the battlefield, then shuffle his or her library";§}§ArcumDagssonEffect(final ArcumDagssonEffect effect) {§super(effect);§}§@Override§public ArcumDagssonEffect copy() {§return new ArcumDagssonEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent artifactCreature = game.getPermanent(this.getTargetPointer().getFirst(game, source));§if (artifactCreature != null) {§Player player = game.getPlayer(artifactCreature.getControllerId());§if (player != null) {§artifactCreature.sacrifice(source.getSourceId(), game);§if (player.chooseUse(Outcome.PutCardInPlay, "Search your library for a noncreature artifact card?", source, game)) {§TargetCardInLibrary target = new TargetCardInLibrary(filter);§if (player.searchLibrary(target, game)) {§Card card = game.getCard(target.getFirstTarget());§if (card != null) {§player.moveCards(card, Zone.BATTLEFIELD, source, game);§}§}§player.shuffleLibrary(game);§}§return true;§}§}§return false;§}§}§
public class AurochsHerd extends CardImpl {§private static final FilterCard filter1 = new FilterCard("Aurocs card");§private static final FilterAttackingCreature filter2 = new FilterAttackingCreature("other attacking Aurochs");§static {§filter1.add(new SubtypePredicate("Aurochs"));§filter2.add(new SubtypePredicate("Aurochs"));§filter2.add(new AnotherPredicate());§}§public AurochsHerd(UUID ownerId) {§super(ownerId, 103, "Aurochs Herd", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{5}{G}");§this.expansionSetCode = "CSP";§this.subtype.add("Aurochs");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(TrampleAbility.getInstance());§this.addAbility(new EntersBattlefieldTriggeredAbility(new SearchLibraryPutInHandEffect(§new TargetCardInLibrary(filter1), true), true));§PermanentsOnBattlefieldCount value = new PermanentsOnBattlefieldCount(filter2, 1);§this.addAbility(new AttacksTriggeredAbility(new BoostSourceEffect(value, new StaticValue(0), Duration.EndOfTurn, true), false));§}§public AurochsHerd(final AurochsHerd card) {§super(card);§}§@Override§public AurochsHerd copy() {§return new AurochsHerd(this);§}§}§
public class BalduvianRage extends CardImpl {§public BalduvianRage(UUID ownerId) {§super(ownerId, 76, "Balduvian Rage", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{X}{R}");§this.expansionSetCode = "CSP";§this.getSpellAbility().addEffect(new BoostTargetEffect(new ManacostVariableValue(), new StaticValue(0), Duration.EndOfTurn));§this.getSpellAbility().addTarget(new TargetCreaturePermanent(new FilterAttackingCreature()));§this.getSpellAbility().addEffect(new CreateDelayedTriggeredAbilityEffect(new AtTheBeginOfNextUpkeepDelayedTriggeredAbility(new DrawCardSourceControllerEffect(1)),false));§}§public BalduvianRage(final BalduvianRage card) {§super(card);§}§@Override§public BalduvianRage copy() {§return new BalduvianRage(this);§}§}§
public class BlizzardSpecter extends CardImpl {§public BlizzardSpecter(UUID ownerId) {§super(ownerId, 126, "Blizzard Specter", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{U}{B}");§this.expansionSetCode = "CSP";§this.supertype.add("Snow");§this.subtype.add("Specter");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new DealsCombatDamageToAPlayerTriggeredAbility(new ReturnToHandEffect(), false, true);§Mode mode = new Mode();§mode.getEffects().add(new DiscardTargetEffect(1, false));§ability.addMode(mode);§this.addAbility(ability);§}§public BlizzardSpecter(final BlizzardSpecter card) {§super(card);§}§@Override§public BlizzardSpecter copy() {§return new BlizzardSpecter(this);§}§}§class ReturnToHandEffect extends OneShotEffect {§public ReturnToHandEffect() {§super(Outcome.ReturnToHand);§staticText = "That player returns a permanent he or she controls to its owner's hand";§}§public ReturnToHandEffect(final ReturnToHandEffect effect) {§super(effect);§}§@Override§public ReturnToHandEffect copy() {§return new ReturnToHandEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player targetPlayer = game.getPlayer(targetPointer.getFirst(game, source));§if (targetPlayer == null) {§return false;§}§Target target = new TargetControlledPermanent(1, 1, new FilterControlledPermanent(), true);§if (target.canChoose(targetPlayer.getId(), game)) {§targetPlayer.chooseTarget(Outcome.ReturnToHand, target, source, game);§Permanent permanent = game.getPermanent(target.getFirstTarget());§if (permanent != null) {§targetPlayer.moveCards(permanent, null, Zone.HAND, source, game);§}§}§return true;§}§}§
public class BorealCentaur extends CardImpl {§public BorealCentaur(UUID ownerId) {§super(ownerId, 104, "Boreal Centaur", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "CSP";§this.supertype.add("Snow");§this.subtype.add("Centaur");§this.subtype.add("Warrior");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new LimitedTimesPerTurnActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(1, 1, Duration.EndOfTurn), new ManaCostsImpl("{S}")));§}§public BorealCentaur(final BorealCentaur card) {§super(card);§}§@Override§public BorealCentaur copy() {§return new BorealCentaur(this);§}§}§
public class BorealDruid extends CardImpl {§public BorealDruid(UUID ownerId) {§super(ownerId, 105, "Boreal Druid", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{G}");§this.expansionSetCode = "CSP";§this.supertype.add("Snow");§this.subtype.add("Elf");§this.subtype.add("Druid");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new ColorlessManaAbility());§}§public BorealDruid(final BorealDruid card) {§super(card);§}§@Override§public BorealDruid copy() {§return new BorealDruid(this);§}§}§
public class BorealGriffin extends CardImpl {§public BorealGriffin(UUID ownerId) {§super(ownerId, 2, "Boreal Griffin", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{W}{W}");§this.expansionSetCode = "CSP";§this.supertype.add("Snow");§this.subtype.add("Griffin");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilitySourceEffect(§FirstStrikeAbility.getInstance(), Duration.EndOfTurn), new ManaCostsImpl("{S}")));§}§public BorealGriffin(final BorealGriffin card) {§super(card);§}§@Override§public BorealGriffin copy() {§return new BorealGriffin(this);§}§}§
public class BorealShelf extends CardImpl {§public BorealShelf(UUID ownerId) {§super(ownerId, 144, "Boreal Shelf", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "CSP";§this.supertype.add("Snow");§this.addAbility(new EntersBattlefieldTappedAbility());§this.addAbility(new WhiteManaAbility());§this.addAbility(new BlueManaAbility());§}§public BorealShelf(final BorealShelf card) {§super(card);§}§@Override§public BorealShelf copy() {§return new BorealShelf(this);§}§}§
public class BraidOfFire extends CardImpl {§public BraidOfFire(UUID ownerId) {§super(ownerId, 78, "Braid of Fire", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{1}{R}");§this.expansionSetCode = "CSP";§this.addAbility(new CumulativeUpkeepAbility(new BraidOfFireCost()));§}§public BraidOfFire(final BraidOfFire card) {§super(card);§}§@Override§public BraidOfFire copy() {§return new BraidOfFire(this);§}§}§class BraidOfFireCost extends CostImpl {§public BraidOfFireCost() {§this.text = "Add {R} to your mana pool";§}§public BraidOfFireCost(BraidOfFireCost cost) {§super(cost);§}§@Override§public boolean pay(Ability ability, Game game, UUID sourceId, UUID controllerId, boolean noMana, Cost costToPay) {§Player player = game.getPlayer(controllerId);§player.getManaPool().addMana(Mana.RedMana(1), game, ability);§paid = true;§return true;§}§@Override§public boolean canPay(Ability ability, UUID sourceId, UUID controllerId, Game game) {§return game.getPlayer(controllerId) != null;§}§@Override§public BraidOfFireCost copy() {§return new BraidOfFireCost(this);§}§}§
public class BullAurochs extends CardImpl {§private static final FilterAttackingCreature filter = new FilterAttackingCreature("other attacking Aurochs");§static {§filter.add(new SubtypePredicate("Aurochs"));§filter.add(new AnotherPredicate());§}§public BullAurochs(UUID ownerId) {§super(ownerId, 107, "Bull Aurochs", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "CSP";§this.subtype.add("Aurochs");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(TrampleAbility.getInstance());§PermanentsOnBattlefieldCount value = new PermanentsOnBattlefieldCount(filter, 1);§this.addAbility(new AttacksTriggeredAbility(new BoostSourceEffect(value, new StaticValue(0), Duration.EndOfTurn, true), false));§}§public BullAurochs(final BullAurochs card) {§super(card);§}§@Override§public BullAurochs copy() {§return new BullAurochs(this);§}§}§
public class ChillingShade extends CardImpl {§public ChillingShade(UUID ownerId) {§super(ownerId, 53, "Chilling Shade", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{B}");§this.expansionSetCode = "CSP";§this.supertype.add("Snow");§this.subtype.add("Shade");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(1, 1, Duration.EndOfTurn), new ManaCostsImpl("{S}")));§}§public ChillingShade(final ChillingShade card) {§super(card);§}§@Override§public ChillingShade copy() {§return new ChillingShade(this);§}§}§
public class ChillToTheBone extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("nonsnow creature");§static {§filter.add(Predicates.not(new SupertypePredicate("Snow")));§}§public ChillToTheBone(UUID ownerId) {§super(ownerId, 52, "Chill to the Bone", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{3}{B}");§this.expansionSetCode = "CSP";§this.getSpellAbility().addEffect(new DestroyTargetEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent(filter));§}§public ChillToTheBone(final ChillToTheBone card) {§super(card);§}§@Override§public ChillToTheBone copy() {§return new ChillToTheBone(this);§}§}§
public class ColdsteelHeart extends CardImpl {§public ColdsteelHeart(UUID ownerId) {§super(ownerId, 136, "Coldsteel Heart", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{2}");§this.expansionSetCode = "CSP";§this.supertype.add("Snow");§this.addAbility(new EntersBattlefieldTappedAbility());§this.addAbility(new EntersBattlefieldAbility(new ChooseColorEffect(Outcome.Neutral), null, "As {this} enters the battlefield, choose a color.", null));§this.addAbility(new SimpleManaAbility(Zone.BATTLEFIELD, new ColdsteelHeartManaEffect(), new TapSourceCost()));§}§public ColdsteelHeart(final ColdsteelHeart card) {§super(card);§}§@Override§public ColdsteelHeart copy() {§return new ColdsteelHeart(this);§}§}§class ColdsteelHeartManaEffect extends ManaEffect {§public ColdsteelHeartManaEffect() {§super();§staticText = "Add one mana of the chosen color to your mana pool";§}§public ColdsteelHeartManaEffect(final ColdsteelHeartManaEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§player.getManaPool().addMana(getMana(game, source), game, source);§}§return true;§}§@Override§public Mana getMana(Game game, Ability source) {§ObjectColor color = (ObjectColor) game.getState().getValue(source.getSourceId() + "_color");§if (color != null) {§return new Mana(ColoredManaSymbol.lookup(color.toString().charAt(0)));§} else {§return null;§}§}§@Override§public ColdsteelHeartManaEffect copy() {§return new ColdsteelHeartManaEffect(this);§}§}§
public class Commandeer extends CardImpl {§private static final FilterCard filter = new FilterCard("two blue cards");§private static final FilterSpell filterSpell = new FilterSpell("noncreature spell");§static {§filter.add(new ColorPredicate(ObjectColor.BLUE));§filterSpell.add(Predicates.not(new CardTypePredicate(CardType.CREATURE)));§}§public Commandeer(UUID ownerId) {§super(ownerId, 29, "Commandeer", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{5}{U}{U}");§this.expansionSetCode = "CSP";§this.addAbility(new AlternativeCostSourceAbility(new ExileFromHandCost(new TargetCardInHand(2, filter))));§this.getSpellAbility().addEffect(new CommandeerEffect());§this.getSpellAbility().addTarget(new TargetSpell(filterSpell));§}§public Commandeer(final Commandeer card) {§super(card);§}§@Override§public Commandeer copy() {§return new Commandeer(this);§}§}§class CommandeerEffect extends OneShotEffect {§public CommandeerEffect() {§super(Outcome.Benefit);§this.staticText = "Gain control of target noncreature spell. You may choose new targets for it";§}§public CommandeerEffect(final CommandeerEffect effect) {§super(effect);§}§@Override§public CommandeerEffect copy() {§return new CommandeerEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§Spell spell = game.getStack().getSpell(targetPointer.getFirst(game, source));§if (controller != null && spell != null) {§spell.setControllerId(controller.getId());§spell.chooseNewTargets(game, controller.getId(), false, false, null);§return true;§}§return false;§}§}§
public class Controvert extends CardImpl {§public Controvert(UUID ownerId) {§super(ownerId, 30, "Controvert", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{2}{U}{U}");§this.expansionSetCode = "CSP";§this.getSpellAbility().addEffect(new CounterTargetEffect());§this.getSpellAbility().addTarget(new TargetSpell());§this.addAbility(new RecoverAbility(new ManaCostsImpl("{2}{U}{U}"), this));§}§public Controvert(final Controvert card) {§super(card);§}§@Override§public Controvert copy() {§return new Controvert(this);§}§}§
public class Counterbalance extends CardImpl {§public Counterbalance(UUID ownerId) {§super(ownerId, 31, "Counterbalance", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{U}{U}");§this.expansionSetCode = "CSP";§this.addAbility(new SpellCastOpponentTriggeredAbility(Zone.BATTLEFIELD, new CounterbalanceEffect(), new FilterSpell(), true, SetTargetPointer.SPELL));§}§public Counterbalance(final Counterbalance card) {§super(card);§}§@Override§public Counterbalance copy() {§return new Counterbalance(this);§}§}§class CounterbalanceEffect extends OneShotEffect {§public CounterbalanceEffect() {§super(Outcome.Neutral);§this.staticText = "you may reveal the top card of your library. If you do, counter that spell if it has the same converted mana cost as the revealed card";§}§public CounterbalanceEffect(final CounterbalanceEffect effect) {§super(effect);§}§@Override§public CounterbalanceEffect copy() {§return new CounterbalanceEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§Permanent sourcePermanent = game.getPermanentOrLKIBattlefield(source.getSourceId());§if (controller != null && sourcePermanent != null) {§Spell spell = (Spell) game.getStack().getStackObject(targetPointer.getFirst(game, source));§if (spell != null) {§Card topcard = controller.getLibrary().getFromTop(game);§if (topcard != null) {§CardsImpl cards = new CardsImpl();§cards.add(topcard);§controller.revealCards(sourcePermanent.getName(), cards, game);§if (CardUtil.convertedManaCostsIsEqual(topcard, spell)) {§return game.getStack().counter(spell.getId(), source.getSourceId(), game);§}§}§return true;§}§}§return false;§}§}§
public class DarienKingOfKjeldor extends CardImpl {§public DarienKingOfKjeldor(UUID ownerId) {§super(ownerId, 4, "Darien, King of Kjeldor", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{W}{W}");§this.expansionSetCode = "CSP";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new DarienKingOfKjeldorTriggeredAbility());§}§public DarienKingOfKjeldor(final DarienKingOfKjeldor card) {§super(card);§}§@Override§public DarienKingOfKjeldor copy() {§return new DarienKingOfKjeldor(this);§}§}§class DarienKingOfKjeldorTriggeredAbility extends TriggeredAbilityImpl {§public DarienKingOfKjeldorTriggeredAbility() {§super(Zone.BATTLEFIELD, new DarienKingOfKjeldorEffect(), true);§}§public DarienKingOfKjeldorTriggeredAbility(final DarienKingOfKjeldorTriggeredAbility ability) {§super(ability);§}§@Override§public DarienKingOfKjeldorTriggeredAbility copy() {§return new DarienKingOfKjeldorTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.DAMAGED_PLAYER;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if ((event.getTargetId().equals(this.getControllerId()))) {§this.getEffects().get(0).setValue("damageAmount", event.getAmount());§return true;§}§return false;§}§@Override§public String getRule() {§return "Whenever you are dealt damage, you may put that many 1/1 white Soldier creature tokens onto the battlefield.";§}§}§class DarienKingOfKjeldorEffect extends OneShotEffect {§public DarienKingOfKjeldorEffect() {§super(Outcome.Benefit);§}§public DarienKingOfKjeldorEffect(final DarienKingOfKjeldorEffect effect) {§super(effect);§}§@Override§public DarienKingOfKjeldorEffect copy() {§return new DarienKingOfKjeldorEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§int damage = (Integer) this.getValue("damageAmount");§return new CreateTokenEffect(new SoldierToken(), damage).apply(game, source);§}§return false;§}§}§
public class DarkDepths extends CardImpl {§public DarkDepths(UUID ownerId) {§super(ownerId, 145, "Dark Depths", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "CSP";§this.supertype.add("Legendary");§this.supertype.add("Snow");§this.addAbility(new EntersBattlefieldAbility(new AddCountersSourceEffect(CounterType.ICE.createInstance(10)), "with ten ice counters on it"));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new RemoveCounterSourceEffect(CounterType.ICE.createInstance(1)), new ManaCostsImpl("{3}")));§this.addAbility(new DarkDepthsAbility());§}§public DarkDepths(final DarkDepths card) {§super(card);§}§@Override§public DarkDepths copy() {§return new DarkDepths(this);§}§}§class DarkDepthsSacrificeEffect extends SacrificeSourceEffect {§private boolean sacrificed = false;§public DarkDepthsSacrificeEffect(){§super();§}§public DarkDepthsSacrificeEffect(final DarkDepthsSacrificeEffect effect) {§super(effect);§this.sacrificed = effect.sacrificed;§}§@Override§public DarkDepthsSacrificeEffect copy() {§return new DarkDepthsSacrificeEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§sacrificed = super.apply(game, source);§if (sacrificed) {§new CreateTokenEffect(new MaritLageToken()).apply(game, source);§}§return sacrificed;§}§public boolean isSacrificed() {§return sacrificed;§}§}§class DarkDepthsAbility extends StateTriggeredAbility {§public DarkDepthsAbility() {§super(Zone.BATTLEFIELD, new DarkDepthsSacrificeEffect());§}§public DarkDepthsAbility(final DarkDepthsAbility ability) {§super(ability);§}§@Override§public DarkDepthsAbility copy() {§return new DarkDepthsAbility(this);§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§Permanent permanent = game.getPermanent(getSourceId());§return permanent != null && permanent.getCounters().getCount(CounterType.ICE) == 0;§}§@Override§public String getRule() {§return "When {this} has no ice counters on it, sacrifice it. If you do, put a legendary 20/20 black Avatar creature token with flying and indestructible named Marit Lage onto the battlefield.";§}§}§class MaritLageToken extends Token {§public MaritLageToken() {§super("Marit Lage", "legendary 20/20 black Avatar creature token with flying and indestructible named Marit Lage");§this.setOriginalExpansionSetCode("CSP");§cardType.add(CardType.CREATURE);§subtype.add("Avatar");§supertype.add("Legendary");§color.setBlack(true);§power = new MageInt(20);§toughness = new MageInt(20);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(IndestructibleAbility.getInstance());§}§}§
public class Drelnoch extends CardImpl {§public Drelnoch(UUID ownerId) {§super(ownerId, 32, "Drelnoch", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{U}");§this.expansionSetCode = "CSP";§this.subtype.add("Yeti");§this.subtype.add("Mutant");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new BecomesBlockedTriggeredAbility(new DrawCardSourceControllerEffect(2), true));§}§public Drelnoch(final Drelnoch card) {§super(card);§}§@Override§public Drelnoch copy() {§return new Drelnoch(this);§}§}§
public class FrostMarsh extends CardImpl {§public FrostMarsh(UUID ownerId) {§super(ownerId, 146, "Frost Marsh", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "CSP";§this.supertype.add("Snow");§this.addAbility(new EntersBattlefieldTappedAbility());§this.addAbility(new BlueManaAbility());§this.addAbility(new BlackManaAbility());§}§public FrostMarsh(final FrostMarsh card) {§super(card);§}§@Override§public FrostMarsh copy() {§return new FrostMarsh(this);§}§}§
public class FrostRaptor extends CardImpl {§public FrostRaptor(UUID ownerId) {§super(ownerId, 34, "Frost Raptor", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{U}");§this.expansionSetCode = "CSP";§this.supertype.add("Snow");§this.subtype.add("Bird");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilitySourceEffect(§ShroudAbility.getInstance(), Duration.EndOfTurn), new ManaCostsImpl("{S}{S}")));§}§public FrostRaptor(final FrostRaptor card) {§super(card);§}§@Override§public FrostRaptor copy() {§return new FrostRaptor(this);§}§}§
public class FrozenSolid extends CardImpl {§public FrozenSolid(UUID ownerId) {§super(ownerId, 35, "Frozen Solid", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{U}{U}");§this.expansionSetCode = "CSP";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.Detriment));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new DontUntapInControllersUntapStepEnchantedEffect()));§this.addAbility(new DamageDealtToAttachedTriggeredAbility(new DestroyAttachedEffect("it"), false));§}§public FrozenSolid(final FrozenSolid card) {§super(card);§}§@Override§public FrozenSolid copy() {§return new FrozenSolid(this);§}§}§
public class FuryOfTheHorde extends CardImpl {§private static final FilterCard filter = new FilterCard("two red cards");§static {§filter.add(new ColorPredicate(ObjectColor.RED));§}§public FuryOfTheHorde(UUID ownerId) {§super(ownerId, 81, "Fury of the Horde", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{5}{R}{R}");§this.expansionSetCode = "CSP";§this.addAbility(new AlternativeCostSourceAbility(new ExileFromHandCost(new TargetCardInHand(2, filter))));§this.getSpellAbility().addEffect(new FuryOfTheHordeUntapEffect());§this.getSpellAbility().addEffect(new FuryOfTheHordeAddPhasesEffect());§this.getSpellAbility().addWatcher(new AttackedThisTurnWatcher());§}§public FuryOfTheHorde(final FuryOfTheHorde card) {§super(card);§}§@Override§public FuryOfTheHorde copy() {§return new FuryOfTheHorde(this);§}§}§class FuryOfTheHordeUntapEffect extends OneShotEffect {§public FuryOfTheHordeUntapEffect() {§super(Outcome.Benefit);§staticText = " Untap all creatures that attacked this turn";§}§public FuryOfTheHordeUntapEffect(final FuryOfTheHordeUntapEffect effect) {§super(effect);§}§@Override§public FuryOfTheHordeUntapEffect copy() {§return new FuryOfTheHordeUntapEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Watcher watcher = game.getState().getWatchers().get("AttackedThisTurn");§if (watcher != null && watcher instanceof AttackedThisTurnWatcher) {§Set<UUID> attackedThisTurn = ((AttackedThisTurnWatcher) watcher).getAttackedThisTurnCreatures();§for (UUID uuid : attackedThisTurn) {§Permanent permanent = game.getPermanent(uuid);§if (permanent != null && permanent.getCardType().contains(CardType.CREATURE)) {§permanent.untap(game);§}§}§return true;§}§return false;§}§}§class FuryOfTheHordeAddPhasesEffect extends OneShotEffect {§public FuryOfTheHordeAddPhasesEffect() {§super(Outcome.Benefit);§staticText = "After this main phase, there is an additional combat phase followed by an additional main phase";§}§public FuryOfTheHordeAddPhasesEffect(final FuryOfTheHordeAddPhasesEffect effect) {§super(effect);§}§@Override§public FuryOfTheHordeAddPhasesEffect copy() {§return new FuryOfTheHordeAddPhasesEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§if (TurnPhase.PRECOMBAT_MAIN.equals(game.getTurn().getPhaseType())§|| TurnPhase.POSTCOMBAT_MAIN.equals(game.getTurn().getPhaseType())) {§TurnMod combat = new TurnMod(source.getControllerId(), TurnPhase.COMBAT, TurnPhase.POSTCOMBAT_MAIN, false);§game.getState().getTurnMods().add(combat);§DelayedAddMainPhaseAbility delayedTriggeredAbility = new DelayedAddMainPhaseAbility();§delayedTriggeredAbility.setConnectedTurnMod(combat.getId());§game.addDelayedTriggeredAbility(delayedTriggeredAbility, source);§return true;§}§return false;§}§}§class DelayedAddMainPhaseAbility extends DelayedTriggeredAbility {§private UUID connectedTurnMod;§private boolean enabled;§public DelayedAddMainPhaseAbility() {§super(null, Duration.EndOfTurn);§this.usesStack = false; §
public class GarzaZolPlagueQueen extends CardImpl {§public GarzaZolPlagueQueen(UUID ownerId) {§super(ownerId, 129, "Garza Zol, Plague Queen", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{U}{B}{R}");§this.expansionSetCode = "CSP";§this.supertype.add("Legendary");§this.subtype.add("Vampire");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(HasteAbility.getInstance());§this.addAbility(new DiesAndDealtDamageThisTurnTriggeredAbility(new AddCountersSourceEffect(CounterType.P1P1.createInstance())));§this.addAbility(new DealsCombatDamageToAPlayerTriggeredAbility(new DrawCardSourceControllerEffect(1), true));§}§public GarzaZolPlagueQueen(final GarzaZolPlagueQueen card) {§super(card);§}§@Override§public GarzaZolPlagueQueen copy() {§return new GarzaZolPlagueQueen(this);§}§}§
public class GrimHarvest extends CardImpl {§private static FilterCreatureCard filter = new FilterCreatureCard("creature card from your graveyard");§public GrimHarvest(UUID ownerId) {§super(ownerId, 58, "Grim Harvest", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{B}");§this.expansionSetCode = "CSP";§this.getSpellAbility().addTarget(new TargetCardInYourGraveyard(filter));§this.getSpellAbility().addEffect(new ReturnToHandTargetEffect());§this.addAbility(new RecoverAbility(new ManaCostsImpl("{2}{B}"), this));§}§public GrimHarvest(final GrimHarvest card) {§super(card);§}§@Override§public GrimHarvest copy() {§return new GrimHarvest(this);§}§}§
public class GristleGrinner extends CardImpl {§public GristleGrinner(UUID ownerId) {§super(ownerId, 59, "Gristle Grinner", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{B}");§this.expansionSetCode = "CSP";§this.subtype.add("Zombie");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new DiesCreatureTriggeredAbility(new BoostSourceEffect(2, 2, Duration.EndOfTurn), false));§}§public GristleGrinner(final GristleGrinner card) {§super(card);§}§@Override§public GristleGrinner copy() {§return new GristleGrinner(this);§}§}§
public class GutlessGhoul extends CardImpl {§public GutlessGhoul(UUID ownerId) {§super(ownerId, 60, "Gutless Ghoul", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{B}");§this.expansionSetCode = "CSP";§this.supertype.add("Snow");§this.subtype.add("Zombie");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainLifeEffect(2), new ManaCostsImpl("{1}"));§ability.addCost(new SacrificeTargetCost(new TargetControlledCreaturePermanent(new FilterControlledCreaturePermanent("a creature"))));§this.addAbility(ability);§}§public GutlessGhoul(final GutlessGhoul card) {§super(card);§}§@Override§public GutlessGhoul copy() {§return new GutlessGhoul(this);§}§}§
public class HaakonStromgaldScourge extends CardImpl {§public HaakonStromgaldScourge(UUID ownerId) {§super(ownerId, 61, "Haakon, Stromgald Scourge", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{B}{B}");§this.expansionSetCode = "CSP";§this.supertype.add("Legendary");§this.subtype.add("Zombie");§this.subtype.add("Knight");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§Ability ability = new SimpleStaticAbility(Zone.ALL, new HaakonStromgaldScourgePlayEffect());§ability.addEffect(new HaakonStromgaldScourgePlayEffect2());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new HaakonPlayKnightsFromGraveyardEffect()));§this.addAbility(new DiesTriggeredAbility(new LoseLifeSourceControllerEffect(2)));§}§public HaakonStromgaldScourge(final HaakonStromgaldScourge card) {§super(card);§}§@Override§public HaakonStromgaldScourge copy() {§return new HaakonStromgaldScourge(this);§}§}§class HaakonStromgaldScourgePlayEffect extends AsThoughEffectImpl {§public HaakonStromgaldScourgePlayEffect() {§super(AsThoughEffectType.PLAY_FROM_NOT_OWN_HAND_ZONE, Duration.EndOfGame, Outcome.Benefit);§staticText = "You may cast {this} from your graveyard";§}§public HaakonStromgaldScourgePlayEffect(final HaakonStromgaldScourgePlayEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public HaakonStromgaldScourgePlayEffect copy() {§return new HaakonStromgaldScourgePlayEffect(this);§}§@Override§public boolean applies(UUID objectId, Ability source, UUID affectedControllerId, Game game) {§if (objectId.equals(source.getSourceId()) &&§affectedControllerId.equals(source.getControllerId())) {§Card card = game.getCard(source.getSourceId());§if (card != null && game.getState().getZone(source.getSourceId()) == Zone.GRAVEYARD) {§return true;§}§}§return false;§}§}§class HaakonStromgaldScourgePlayEffect2 extends ContinuousRuleModifyingEffectImpl {§public HaakonStromgaldScourgePlayEffect2() {§super(Duration.EndOfGame, Outcome.Detriment);§staticText = ", but not from anywhere else";§}§public HaakonStromgaldScourgePlayEffect2 (final HaakonStromgaldScourgePlayEffect2 effect) {§super(effect);§}§@Override§public HaakonStromgaldScourgePlayEffect2 copy() {§return new HaakonStromgaldScourgePlayEffect2(this);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.CAST_SPELL;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§Card card = game.getCard(event.getSourceId());§if (card != null && card.getId().equals(source.getSourceId())) {§Zone zone = game.getState().getZone(card.getId());§if (zone != null && (zone != Zone.GRAVEYARD)) {§return true;§}§}§return false;§}§}§class HaakonPlayKnightsFromGraveyardEffect extends AsThoughEffectImpl {§public HaakonPlayKnightsFromGraveyardEffect () {§super(AsThoughEffectType.PLAY_FROM_NOT_OWN_HAND_ZONE, Duration.WhileOnBattlefield, Outcome.Benefit);§staticText = "As long as {this} is on the battlefield, you may play Knight cards from your graveyard";§}§public HaakonPlayKnightsFromGraveyardEffect(final HaakonPlayKnightsFromGraveyardEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public HaakonPlayKnightsFromGraveyardEffect copy() {§return new HaakonPlayKnightsFromGraveyardEffect(this);§}§@Override§public boolean applies(UUID objectId, Ability source, UUID affectedControllerId, Game game) {§if (affectedControllerId.equals(source.getControllerId())) {§Card knightToCast = game.getCard(objectId);§if (knightToCast != null§&& knightToCast.hasSubtype("Knight")§&& knightToCast.getOwnerId().equals(source.getControllerId())§&& game.getState().getZone(objectId) == Zone.GRAVEYARD) {§return true;§}§}§return false;§}§}§
public class HeidarRimewindMaster extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("you control four or more snow permanents");§static {§filter.add(new SupertypePredicate("Snow"));§}§public HeidarRimewindMaster(UUID ownerId) {§super(ownerId, 36, "Heidar, Rimewind Master", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{U}");§this.expansionSetCode = "CSP";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§Ability ability = new ActivateIfConditionActivatedAbility(Zone.BATTLEFIELD,§new ReturnToHandTargetEffect(),§new GenericManaCost(2),§new PermanentsOnTheBattlefieldCondition(filter, CountType.MORE_THAN, 3));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetPermanent());§this.addAbility(ability);§}§public HeidarRimewindMaster(final HeidarRimewindMaster card) {§super(card);§}§@Override§public HeidarRimewindMaster copy() {§return new HeidarRimewindMaster(this);§}§}§
public class HibernationsEnd extends CardImpl {§public HibernationsEnd(UUID ownerId) {§super(ownerId, 110, "Hibernation's End", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{4}{G}");§this.expansionSetCode = "CSP";§this.addAbility(new CumulativeUpkeepAbility(new ManaCostsImpl("{1}")));§this.addAbility(new HibernationsEndAbility());§}§public HibernationsEnd(final HibernationsEnd card) {§super(card);§}§@Override§public HibernationsEnd copy() {§return new HibernationsEnd(this);§}§}§class HibernationsEndAbility extends TriggeredAbilityImpl {§public HibernationsEndAbility() {§super(Zone.BATTLEFIELD, new HibernationsEndEffect(), true);§}§public HibernationsEndAbility(final HibernationsEndAbility ability) {§super(ability);§}§@Override§public HibernationsEndAbility copy() {§return new HibernationsEndAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.PAID_CUMULATIVE_UPKEEP;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§return event.getSourceId() != null && event.getSourceId().equals(this.getSourceId());§}§@Override§public String getRule() {§return "Whenever you pay {this}'s cumulative upkeep, " + super.getRule();§}§}§class HibernationsEndEffect extends OneShotEffect {§public HibernationsEndEffect() {§super(Outcome.Benefit);§this.staticText = "search your library for a creature card with converted mana cost equal to the number of age counters on {this} and put it onto the battlefield. If you do, shuffle your library.";§}§public HibernationsEndEffect(final HibernationsEndEffect effect) {§super(effect);§}§@Override§public HibernationsEndEffect copy() {§return new HibernationsEndEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§Permanent sourcePermanent = game.getPermanentOrLKIBattlefield(source.getSourceId());§if (sourcePermanent != null && player != null) {§int newConvertedCost = sourcePermanent.getCounters().getCount("age");§FilterCard filter = new FilterCard("creature card with converted mana cost " + newConvertedCost);§filter.add(new ConvertedManaCostPredicate(Filter.ComparisonType.Equal, newConvertedCost));§filter.add(new CardTypePredicate(CardType.CREATURE));§TargetCardInLibrary target = new TargetCardInLibrary(filter);§return new SearchLibraryPutInPlayEffect(target).apply(game, source);§}§return false;§}§}§
public class HighlandWeald extends CardImpl {§public HighlandWeald(UUID ownerId) {§super(ownerId, 147, "Highland Weald", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "CSP";§this.supertype.add("Snow");§this.addAbility(new EntersBattlefieldTappedAbility());§this.addAbility(new RedManaAbility());§this.addAbility(new GreenManaAbility());§}§public HighlandWeald(final HighlandWeald card) {§super(card);§}§@Override§public HighlandWeald copy() {§return new HighlandWeald(this);§}§}§
public class Icefall extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("artifact or land");§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.ARTIFACT),§new CardTypePredicate(CardType.LAND)));§}§public Icefall(UUID ownerId) {§super(ownerId, 85, "Icefall", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{2}{R}{R}");§this.expansionSetCode = "CSP";§this.getSpellAbility().addTarget(new TargetPermanent(filter));§this.getSpellAbility().addEffect(new DestroyTargetEffect());§this.addAbility(new RecoverAbility(new ManaCostsImpl("{R}{R}"), this));§}§public Icefall(final Icefall card) {§super(card);§}§@Override§public Icefall copy() {§return new Icefall(this);§}§}§
public class IntoTheNorth extends CardImpl {§private static final FilterLandCard filter = new FilterLandCard("snow land card");§static {§filter.add(new SupertypePredicate("Snow"));§}§public IntoTheNorth(UUID ownerId) {§super(ownerId, 111, "Into the North", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{1}{G}");§this.expansionSetCode = "CSP";§this.getSpellAbility().addEffect(new SearchLibraryPutInPlayEffect(new TargetCardInLibrary(filter), true, Outcome.PutLandInPlay));§}§public IntoTheNorth(final IntoTheNorth card) {§super(card);§}§@Override§public IntoTheNorth copy() {§return new IntoTheNorth(this);§}§}§
public class Jokulmorder extends CardImpl {§public Jokulmorder(UUID ownerId) {§super(ownerId, 37, "Jokulmorder", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{U}{U}{U}");§this.expansionSetCode = "CSP";§this.subtype.add("Leviathan");§this.power = new MageInt(12);§this.toughness = new MageInt(12);§this.addAbility(TrampleAbility.getInstance());§this.addAbility(new EntersBattlefieldTappedAbility());§Effect effect = new SacrificeSourceUnlessPaysEffect(§new SacrificeTargetCost(new TargetControlledPermanent(5, 5, new FilterControlledLandPermanent("five lands"), true)));§effect.setText("sacrifice it unless you sacrifice five lands");§this.addAbility(new EntersBattlefieldTriggeredAbility(effect, false));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new DontUntapInControllersUntapStepSourceEffect()));§this.addAbility(new JokulmorderTriggeredAbility());§}§public Jokulmorder(final Jokulmorder card) {§super(card);§}§@Override§public Jokulmorder copy() {§return new Jokulmorder(this);§}§}§class JokulmorderTriggeredAbility extends TriggeredAbilityImpl {§JokulmorderTriggeredAbility() {§super(Zone.BATTLEFIELD, new UntapSourceEffect(), true);§}§JokulmorderTriggeredAbility(JokulmorderTriggeredAbility ability) {§super(ability);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.LAND_PLAYED;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§Permanent land = game.getPermanent(event.getTargetId());§return land.getSubtype().contains("Island")§&& land.getControllerId().equals(this.controllerId);§}§@Override§public JokulmorderTriggeredAbility copy() {§return new JokulmorderTriggeredAbility(this);§}§@Override§public String getRule() {§return "When you play an Island, you may untap {this}";§}§}§
public class JotunGrunt extends CardImpl {§public JotunGrunt(UUID ownerId) {§super(ownerId, 8, "Jotun Grunt", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "CSP";§this.subtype.add("Giant");§this.subtype.add("Soldier");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(new CumulativeUpkeepAbility(new JotunGruntCost()));§}§public JotunGrunt(final JotunGrunt card) {§super(card);§}§@Override§public JotunGrunt copy() {§return new JotunGrunt(this);§}§}§class JotunGruntCost extends CostImpl {§JotunGruntCost() {§this.addTarget(new TargetCardInASingleGraveyard(2, 2, new FilterCard()));§this.text = "Put two cards from a single graveyard on the bottom of their owner's library";§}§JotunGruntCost(final JotunGruntCost cost) {§super(cost);§}§@Override§public boolean pay(Ability ability, Game game, UUID sourceId, UUID controllerId, boolean noMana, Cost costToPay) {§Player controller = game.getPlayer(controllerId);§if (controller != null) {§if (targets.choose(Outcome.Removal, controllerId, sourceId, game)) {§for (UUID targetId: targets.get(0).getTargets()) {§Card card = game.getCard(targetId);§if (card == null || !game.getState().getZone(targetId).equals(Zone.GRAVEYARD)) {§return false;§}§paid |= controller.moveCardToLibraryWithInfo(card, sourceId, game, Zone.GRAVEYARD, false, true);§}§}§}§return paid;§}§@Override§public boolean canPay(Ability ability, UUID sourceId, UUID controllerId, Game game) {§return targets.canChoose(controllerId, game);§}§@Override§public JotunGruntCost copy() {§return new JotunGruntCost(this);§}§}§
public class JuniperOrderRanger extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("another creature");§static {§filter.add(new AnotherPredicate());§}§public JuniperOrderRanger(UUID ownerId) {§super(ownerId, 130, "Juniper Order Ranger", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{G}{W}");§this.expansionSetCode = "CSP";§this.subtype.add("Human");§this.subtype.add("Knight");§this.power = new MageInt(2);§this.toughness = new MageInt(4);§Ability ability = new EntersBattlefieldControlledTriggeredAbility(§Zone.BATTLEFIELD,§new AddCountersTargetEffect(CounterType.P1P1.createInstance()),§filter,§false,§SetTargetPointer.PERMANENT,§"Whenever another creature enters the battlefield under your control, put a +1/+1 counter on that creature and a +1/+1 counter on Juniper Order Ranger");§ability.addEffect(new AddCountersSourceEffect(CounterType.P1P1.createInstance()));§this.addAbility(ability);§}§public JuniperOrderRanger(final JuniperOrderRanger card) {§super(card);§}§@Override§public JuniperOrderRanger copy() {§return new JuniperOrderRanger(this);§}§}§
public class KjeldoranOutrider extends CardImpl {§public KjeldoranOutrider(UUID ownerId) {§super(ownerId, 12, "Kjeldoran Outrider", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "CSP";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(0, 1, Duration.EndOfTurn), new ManaCostsImpl("{W}")));§}§public KjeldoranOutrider(final KjeldoranOutrider card) {§super(card);§}§@Override§public KjeldoranOutrider copy() {§return new KjeldoranOutrider(this);§}§}§
public class KrovikanRot extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature with power 2 or less");§static {§filter.add(new PowerPredicate(Filter.ComparisonType.LessThan, 3));§}§public KrovikanRot(UUID ownerId) {§super(ownerId, 63, "Krovikan Rot", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{2}{B}");§this.expansionSetCode = "CSP";§this.getSpellAbility().addEffect(new DestroyTargetEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent(filter));§this.addAbility(new RecoverAbility(new ManaCostsImpl("{1}{B}{B}"), this));§}§public KrovikanRot(final KrovikanRot card) {§super(card);§}§@Override§public KrovikanRot copy() {§return new KrovikanRot(this);§}§}§
public class KrovikanScoundrel extends CardImpl {§public KrovikanScoundrel(UUID ownerId) {§super(ownerId, 64, "Krovikan Scoundrel", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{B}");§this.expansionSetCode = "CSP";§this.subtype.add("Human");§this.subtype.add("Rogue");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§}§public KrovikanScoundrel(final KrovikanScoundrel card) {§super(card);§}§@Override§public KrovikanScoundrel copy() {§return new KrovikanScoundrel(this);§}§}§
public class LightningSerpent extends CardImpl {§public LightningSerpent(UUID ownerId) {§super(ownerId, 88, "Lightning Serpent", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{X}{R}");§this.expansionSetCode = "CSP";§this.subtype.add("Elemental");§this.subtype.add("Serpent");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(TrampleAbility.getInstance());§this.addAbility(HasteAbility.getInstance());§this.addAbility(new EntersBattlefieldAbility(new EntersBattlefieldWithXCountersEffect(CounterType.P1P0.createInstance())));§this.addAbility(new BeginningOfEndStepTriggeredAbility(new SacrificeSourceEffect(), TargetController.ANY, false));§}§public LightningSerpent(final LightningSerpent card) {§super(card);§}§@Override§public LightningSerpent copy() {§return new LightningSerpent(this);§}§}§
public class LightningStorm extends CardImpl {§public LightningStorm(UUID ownerId) {§super(ownerId, 89, "Lightning Storm", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{1}{R}{R}");§this.expansionSetCode = "CSP";§Effect effect = new DamageTargetEffect(new LightningStormCountCondition(CounterType.CHARGE));§effect.setText("{this} deals X damage to target creature or player, where X is 3 plus the number of charge counters on it");§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addTarget(new TargetCreatureOrPlayer());§SimpleActivatedAbility ability = new SimpleActivatedAbility(Zone.STACK,§new LightningStormAddCounterEffect(),§new DiscardTargetCost(new TargetCardInHand(new FilterLandCard())));§ability.setMayActivate(TargetController.ANY);§ability.addEffect(new InfoEffect("Any player may activate this ability but only if {this} is on the stack"));§this.addAbility(ability);§}§public LightningStorm(final LightningStorm card) {§super(card);§}§@Override§public LightningStorm copy() {§return new LightningStorm(this);§}§}§class LightningStormCountCondition implements DynamicValue {§private final CounterType counter;§public LightningStormCountCondition(CounterType counter) {§this.counter = counter;§}§public LightningStormCountCondition(final LightningStormCountCondition countersCount) {§this.counter = countersCount.counter;§}§@Override§public int calculate(Game game, Ability sourceAbility, Effect effect) {§Spell spell = game.getStack().getSpell(sourceAbility.getSourceId());§if (spell != null) {§return spell.getCounters(game).getCount(counter) + 3;§}§return 0;§}§@Override§public DynamicValue copy() {§return new LightningStormCountCondition(this);§}§@Override§public String toString() {§return "X";§}§@Override§public String getMessage() {§return "3 plus the number of charge counters on it";§}§}§class LightningStormAddCounterEffect extends OneShotEffect {§public LightningStormAddCounterEffect() {§super(Outcome.Benefit);§this.staticText = "Put two charge counters on {this}. You may choose a new target for it.";§}§public LightningStormAddCounterEffect(final LightningStormAddCounterEffect effect) {§super(effect);§}§@Override§public LightningStormAddCounterEffect copy() {§return new LightningStormAddCounterEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Spell spell = game.getStack().getSpell(source.getSourceId());§if (spell != null) {§spell.addCounters(CounterType.CHARGE.createInstance(2), game);§return spell.chooseNewTargets(game, ((ActivatedAbilityImpl) source).getActivatorId(), false, false, null);§}§return false;§}§}§
public class LovisaColdeyes extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature you control that's a Barbarian, a Warrior, or a Berserker");§static {§filter.add(Predicates.or(new SubtypePredicate("Barbarian"), new SubtypePredicate("Warrior"), new SubtypePredicate("Berserker")));§}§public LovisaColdeyes(UUID ownerId) {§super(ownerId, 90, "Lovisa Coldeyes", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{R}{R}");§this.expansionSetCode = "CSP";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§Effect effect = new BoostControlledEffect(2, 2, Duration.WhileOnBattlefield, filter, false);§effect.setText("Each creature you control that's a Barbarian, a Warrior, or a Berserker gets +2/+2");§Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, effect);§effect = new GainAbilityControlledEffect(HasteAbility.getInstance(), Duration.WhileOnBattlefield, filter, false);§effect.setText("and has haste");§ability.addEffect(effect);§this.addAbility(ability);§}§public LovisaColdeyes(final LovisaColdeyes card) {§super(card);§}§@Override§public LovisaColdeyes copy() {§return new LovisaColdeyes(this);§}§}§
public class MartyrOfAshes extends CardImpl {§private static final FilterCard filterHand = new FilterCard("X red cards from your hand");§private static final FilterCreaturePermanent filterCreature = new FilterCreaturePermanent("creatures without flying");§static {§filterHand.add(new ColorPredicate(ObjectColor.RED));§filterCreature.add(Predicates.not(new AbilityPredicate(FlyingAbility.class)));§}§public MartyrOfAshes(UUID ownerId) {§super(ownerId, 92, "Martyr of Ashes", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{R}");§this.expansionSetCode = "CSP";§this.subtype.add("Human");§this.subtype.add("Shaman");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Effect effect = new DamageAllEffect(new RevealTargetFromHandCostCount(), filterCreature);§effect.setText("Martyr of Ashes deals X damage to each creature without flying.");§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new GenericManaCost(2));§ability.addCost(new RevealTargetFromHandCost(new TargetCardInHand(0, Integer.MAX_VALUE, filterHand)));§ability.addCost(new SacrificeSourceCost());§this.addAbility(ability);§}§public MartyrOfAshes(final MartyrOfAshes card) {§super(card);§}§@Override§public MartyrOfAshes copy() {§return new MartyrOfAshes(this);§}§}§
public class MartyrOfBones extends CardImpl {§private final UUID originalId;§public MartyrOfBones(UUID ownerId) {§super(ownerId, 65, "Martyr of Bones", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{B}");§this.expansionSetCode = "CSP";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Effect effect = new ExileTargetEffect(null, null, Zone.GRAVEYARD);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new GenericManaCost(1));§ability.addCost(new RevealVariableBlackCardsFromHandCost());§ability.addCost(new SacrificeSourceCost());§ability.addTarget(new TargetCardInASingleGraveyard(0, 1, new FilterCard("cards in a single graveyard")));§originalId = ability.getOriginalId();§this.addAbility(ability);§}§public MartyrOfBones(final MartyrOfBones card) {§super(card);§this.originalId = card.originalId;§}§@Override§public void adjustTargets(Ability ability, Game game) {§if (ability.getOriginalId().equals(originalId)) {§int amount = 0;§for (Cost cost : ability.getCosts()) {§if (cost instanceof RevealVariableBlackCardsFromHandCost) {§amount = ((VariableCost) cost).getAmount();§}§}§ability.getTargets().clear();§ability.addTarget(new TargetCardInASingleGraveyard(0, amount, new FilterCard()));§}§}§@Override§public MartyrOfBones copy() {§return new MartyrOfBones(this);§}§}§class RevealVariableBlackCardsFromHandCost extends VariableCostImpl {§private static final FilterCard filter = new FilterCard("X black cards from your hand");§static {§filter.add(new ColorPredicate(ObjectColor.BLACK));§}§RevealVariableBlackCardsFromHandCost() {§super("black cards to reveal");§this.text = new StringBuilder("Reveal ").append(xText).append(" black cards from {this}").toString();§}§RevealVariableBlackCardsFromHandCost(final RevealVariableBlackCardsFromHandCost cost) {§super(cost);§}§@Override§public RevealVariableBlackCardsFromHandCost copy() {§return new RevealVariableBlackCardsFromHandCost(this);§}§@Override§public Cost getFixedCostsFromAnnouncedValue(int xValue) {§return new RevealTargetFromHandCost(new TargetCardInHand(0, xValue, filter));§}§@Override§public int getMinValue(Ability source, Game game) {§return 0;§}§@Override§public int getMaxValue(Ability source, Game game) {§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§return player.getHand().getCards(filter, game).size();§}§return 0;§}§}§
public class MartyrOfFrost extends CardImpl {§private static final FilterCard filter = new FilterCard("X blue cards from your hand");§static {§filter.add(new ColorPredicate(ObjectColor.BLUE));§}§public MartyrOfFrost(UUID ownerId) {§super(ownerId, 40, "Martyr of Frost", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{U}");§this.expansionSetCode = "CSP";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Effect effect = new CounterUnlessPaysEffect(new RevealTargetFromHandCostCount());§effect.setText("Counter target spell unless its controller pays {X}.");§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new GenericManaCost(2));§ability.addCost(new RevealTargetFromHandCost(new TargetCardInHand(0, Integer.MAX_VALUE, filter)));§ability.addCost(new SacrificeSourceCost());§ability.addTarget(new TargetSpell());§this.addAbility(ability);§}§public MartyrOfFrost(final MartyrOfFrost card) {§super(card);§}§@Override§public MartyrOfFrost copy() {§return new MartyrOfFrost(this);§}§}§
public class MartyrOfSands extends CardImpl {§private static final FilterCard filter = new FilterCard("X white cards from your hand");§static {§filter.add(new ColorPredicate(ObjectColor.WHITE));§}§public MartyrOfSands(UUID ownerId) {§super(ownerId, 15, "Martyr of Sands", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{W}");§this.expansionSetCode = "CSP";§this.subtype.add("Human");§this.subtype.add("Cleric");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Effect effect = new GainLifeEffect(new MultipliedValue(new RevealTargetFromHandCostCount(), 3));§effect.setText("You gain three times X life.");§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new ManaCostsImpl("{1}"));§ability.addCost(new RevealTargetFromHandCost(new TargetCardInHand(0, Integer.MAX_VALUE, filter)));§ability.addCost(new SacrificeSourceCost());§this.addAbility(ability);§}§public MartyrOfSands(final MartyrOfSands card) {§super(card);§}§@Override§public MartyrOfSands copy() {§return new MartyrOfSands(this);§}§}§
public class MartyrOfSpores extends CardImpl {§private static final FilterCard filter = new FilterCard("X green cards from your hand");§static {§filter.add(new ColorPredicate(ObjectColor.GREEN));§}§public MartyrOfSpores(UUID ownerId) {§super(ownerId, 113, "Martyr of Spores", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{G}");§this.expansionSetCode = "CSP";§this.subtype.add("Human");§this.subtype.add("Shaman");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Effect effect = new BoostTargetEffect(new RevealTargetFromHandCostCount(), new RevealTargetFromHandCostCount(), Duration.EndOfTurn, true);§effect.setText("Target creature gets +X/+X until end of turn.");§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new GenericManaCost(1));§ability.addCost(new RevealTargetFromHandCost(new TargetCardInHand(0, Integer.MAX_VALUE, filter)));§ability.addCost(new SacrificeSourceCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public MartyrOfSpores(final MartyrOfSpores card) {§super(card);§}§@Override§public MartyrOfSpores copy() {§return new MartyrOfSpores(this);§}§}§
public class MishrasBauble extends CardImpl {§public MishrasBauble(UUID ownerId) {§super(ownerId, 138, "Mishra's Bauble", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{0}");§this.expansionSetCode = "CSP";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new LookLibraryTopCardTargetPlayerEffect(), new TapSourceCost());§ability.addCost(new SacrificeSourceCost());§ability.addEffect(new CreateDelayedTriggeredAbilityEffect(§new AtTheBeginOfNextUpkeepDelayedTriggeredAbility(new DrawCardSourceControllerEffect(1), Duration.OneUse), false));§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§}§public MishrasBauble(final MishrasBauble card) {§super(card);§}§@Override§public MishrasBauble copy() {§return new MishrasBauble(this);§}§}§
public class MouthOfRonom extends CardImpl {§public MouthOfRonom(UUID ownerId) {§super(ownerId, 148, "Mouth of Ronom", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "CSP";§this.supertype.add("Snow");§this.addAbility(new ColorlessManaAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(4), new ManaCostsImpl("{4}{S}"));§ability.addTarget(new TargetCreaturePermanent());§ability.addCost(new TapSourceCost());§ability.addCost(new SacrificeSourceCost());§this.addAbility(ability);§}§public MouthOfRonom(final MouthOfRonom card) {§super(card);§}§@Override§public MouthOfRonom copy() {§return new MouthOfRonom(this);§}§}§
public class MysticMelting extends CardImpl {§public MysticMelting(UUID ownerId) {§super(ownerId, 114, "Mystic Melting", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{3}{G}");§this.expansionSetCode = "CSP";§this.getSpellAbility().addEffect(new DestroyTargetEffect());§this.getSpellAbility().addTarget(new TargetPermanent(new FilterArtifactOrEnchantmentPermanent()));§this.getSpellAbility().addEffect(new CreateDelayedTriggeredAbilityEffect(§new AtTheBeginOfNextUpkeepDelayedTriggeredAbility(new DrawCardSourceControllerEffect(1)), false));§}§public MysticMelting(final MysticMelting card) {§super(card);§}§@Override§public MysticMelting copy() {§return new MysticMelting(this);§}§}§
public class OhranYeti extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("snow creature");§static {§filter.add(new SupertypePredicate("Snow"));§}§public OhranYeti(UUID ownerId) {§super(ownerId, 93, "Ohran Yeti", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{R}");§this.expansionSetCode = "CSP";§this.supertype.add("Snow");§this.subtype.add("Yeti");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilityTargetEffect(§FirstStrikeAbility.getInstance(), Duration.EndOfTurn), new ManaCostsImpl("{2}{S}"));§ability.addTarget(new TargetCreaturePermanent(filter));§this.addAbility(ability);§}§public OhranYeti(final OhranYeti card) {§super(card);§}§@Override§public OhranYeti copy() {§return new OhranYeti(this);§}§}§
public class OrcishBloodpainter extends CardImpl {§public OrcishBloodpainter(UUID ownerId) {§super(ownerId, 94, "Orcish Bloodpainter", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "CSP";§this.subtype.add("Orc");§this.subtype.add("Shaman");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(1), new TapSourceCost());§ability.addCost(new SacrificeSourceCost());§ability.addTarget(new TargetCreatureOrPlayer());§this.addAbility(ability);§}§public OrcishBloodpainter(final OrcishBloodpainter card) {§super(card);§}§@Override§public OrcishBloodpainter copy() {§return new OrcishBloodpainter(this);§}§}§
public class PhobianPhantasm extends CardImpl {§public PhobianPhantasm(UUID ownerId) {§super(ownerId, 66, "Phobian Phantasm", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{B}{B}");§this.expansionSetCode = "CSP";§this.subtype.add("Illusion");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(FearAbility.getInstance());§this.addAbility(new CumulativeUpkeepAbility(new ManaCostsImpl("{B}")));§}§public PhobianPhantasm(final PhobianPhantasm card) {§super(card);§}§@Override§public PhobianPhantasm copy() {§return new PhobianPhantasm(this);§}§}§
public class PhyrexianIronfoot extends CardImpl {§public PhyrexianIronfoot(UUID ownerId) {§super(ownerId, 139, "Phyrexian Ironfoot", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{3}");§this.expansionSetCode = "CSP";§this.supertype.add("Snow");§this.subtype.add("Construct");§this.power = new MageInt(3);§this.toughness = new MageInt(4);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new DontUntapInControllersUntapStepSourceEffect()));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new UntapSourceEffect(), new ManaCostsImpl("{1}{S}")));§}§public PhyrexianIronfoot(final PhyrexianIronfoot card) {§super(card);§}§@Override§public PhyrexianIronfoot copy() {§return new PhyrexianIronfoot(this);§}§}§
public class Resize extends CardImpl {§public Resize(UUID ownerId) {§super(ownerId, 117, "Resize", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{1}{G}");§this.expansionSetCode = "CSP";§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.getSpellAbility().addEffect(new BoostTargetEffect(3, 3, Duration.EndOfTurn));§this.addAbility(new RecoverAbility(new ManaCostsImpl("{1}{G}"), this));§}§public Resize(final Resize card) {§super(card);§}§@Override§public Resize copy() {§return new Resize(this);§}§}§
public class RimeboundDead extends CardImpl {§public RimeboundDead(UUID ownerId) {§super(ownerId, 69, "Rimebound Dead", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{B}");§this.expansionSetCode = "CSP";§this.supertype.add("Snow");§this.subtype.add("Skeleton");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new RegenerateSourceEffect(), new ManaCostsImpl("{S}")));§}§public RimeboundDead(final RimeboundDead card) {§super(card);§}§@Override§public RimeboundDead copy() {§return new RimeboundDead(this);§}§}§
public class RimeTransfusion extends CardImpl {§static final String rule = "and has \"{S}: This creature can't be blocked this turn except by snow creatures.\"";§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("except by snow creatures until end of turn");§static {§filter.add(Predicates.not(new SupertypePredicate("Snow")));§}§public RimeTransfusion(UUID ownerId) {§super(ownerId, 68, "Rime Transfusion", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{B}");§this.expansionSetCode = "CSP";§this.supertype.add("Snow");§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§SimpleStaticAbility ability2 = new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(2, 1, Duration.WhileOnBattlefield));§Ability gainedAbility = new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilitySourceEffect(new SimpleEvasionAbility(new CantBeBlockedByCreaturesSourceEffect(filter, Duration.EndOfTurn))),new ManaCostsImpl("{S}"));§ability2.addEffect(new GainAbilityAttachedEffect(gainedAbility, AttachmentType.AURA, Duration.WhileOnBattlefield, rule));§this.addAbility(ability2);§}§public RimeTransfusion(final RimeTransfusion card) {§super(card);§}§@Override§public RimeTransfusion copy() {§return new RimeTransfusion(this);§}§}§
public class RimewindCryomancer extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("you control four or more snow permanents");§static {§filter.add(new SupertypePredicate("Snow"));§}§public RimewindCryomancer(UUID ownerId) {§super(ownerId, 43, "Rimewind Cryomancer", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{U}");§this.expansionSetCode = "CSP";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§Ability ability = new ActivateIfConditionActivatedAbility(Zone.BATTLEFIELD,§new CounterTargetEffect(),§new GenericManaCost(1),§new PermanentsOnTheBattlefieldCondition(filter, CountType.MORE_THAN, 3));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetActivatedAbility());§this.addAbility(ability);§}§public RimewindCryomancer(final RimewindCryomancer card) {§super(card);§}§@Override§public RimewindCryomancer copy() {§return new RimewindCryomancer(this);§}§}§
public class RimewindTaskmage extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("you control four or more snow permanents");§static {§filter.add(new SupertypePredicate("Snow"));§}§public RimewindTaskmage(UUID ownerId) {§super(ownerId, 44, "Rimewind Taskmage", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{U}");§this.expansionSetCode = "CSP";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§Ability ability = new ActivateIfConditionActivatedAbility(Zone.BATTLEFIELD,§new MayTapOrUntapTargetEffect(),§new GenericManaCost(1),§new PermanentsOnTheBattlefieldCondition(filter, CountType.MORE_THAN, 3));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetPermanent());§this.addAbility(ability);§}§public RimewindTaskmage(final RimewindTaskmage card) {§super(card);§}§@Override§public RimewindTaskmage copy() {§return new RimewindTaskmage(this);§}§}§
public class RiteOfFlame extends CardImpl {§public RiteOfFlame(UUID ownerId) {§super(ownerId, 96, "Rite of Flame", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{R}");§this.expansionSetCode = "CSP";§this.getSpellAbility().addEffect(new RiteOfFlameManaEffect());§}§public RiteOfFlame(final RiteOfFlame card) {§super(card);§}§@Override§public RiteOfFlame copy() {§return new RiteOfFlame(this);§}§}§class RiteOfFlameManaEffect extends ManaEffect {§private static final FilterCard filter = new FilterCard();§static {§filter.add(new NamePredicate("Rite of Flame"));§}§RiteOfFlameManaEffect() {§super();§staticText = "Add {R}{R} to your mana pool, then add {R} to your mana pool for each card named Rite of Flame in each graveyard";§}§RiteOfFlameManaEffect(final RiteOfFlameManaEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if(controller != null){§int count = 0;§for(Player player : game.getPlayers().values()){§if(player != null){§count += player.getGraveyard().count(filter, game);§}§}§controller.getManaPool().addMana(Mana.RedMana(count + 2), game, source);§}§return false;§}§@Override§public RiteOfFlameManaEffect copy() {§return new RiteOfFlameManaEffect(this);§}§@Override§public Mana getMana(Game game, Ability source) {§return null;§}§}§
public class RonomHulk extends CardImpl {§private static final FilterCard filter = new FilterCard("snow");§static {§filter.add(new SupertypePredicate("Snow"));§}§public RonomHulk(UUID ownerId) {§super(ownerId, 119, "Ronom Hulk", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{G}");§this.expansionSetCode = "CSP";§this.subtype.add("Beast");§this.power = new MageInt(5);§this.toughness = new MageInt(6);§this.addAbility(new ProtectionAbility(filter));§this.addAbility(new CumulativeUpkeepAbility(new ManaCostsImpl("{1}")));§}§public RonomHulk(final RonomHulk card) {§super(card);§}§@Override§public RonomHulk copy() {§return new RonomHulk(this);§}§}§
public class RonomUnicorn extends CardImpl {§public RonomUnicorn(UUID ownerId) {§super(ownerId, 16, "Ronom Unicorn", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "CSP";§this.subtype.add("Unicorn");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DestroyTargetEffect(), new SacrificeSourceCost());§ability.addTarget(new TargetPermanent(new FilterArtifactOrEnchantmentPermanent()));§this.addAbility(ability);§}§public RonomUnicorn(final RonomUnicorn card) {§super(card);§}§@Override§public RonomUnicorn copy() {§return new RonomUnicorn(this);§}§}§
public class RuneSnag extends CardImpl {§private static final FilterCard filter = new FilterCard();§static {§filter.add(new NamePredicate("Rune Snag"));§}§public RuneSnag(UUID ownerId) {§super(ownerId, 46, "Rune Snag", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{U}");§this.expansionSetCode = "CSP";§Effect effect = new CounterUnlessPaysEffect(new IntPlusDynamicValue(2, new MultipliedValue(new CardsInAllGraveyardsCount(filter), 2)));§effect.setText("Counter target spell unless its controller pays {2} plus an additional {2} for each card named Rune Snag in each graveyard");§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addTarget(new TargetSpell());§}§public RuneSnag(final RuneSnag card) {§super(card);§}§@Override§public RuneSnag copy() {§return new RuneSnag(this);§}§}§
public class ScryingSheets extends CardImpl {§public ScryingSheets(UUID ownerId) {§super(ownerId, 149, "Scrying Sheets", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "CSP";§this.supertype.add("Snow");§this.addAbility(new ColorlessManaAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ScryingSheetsEffect(), new ManaCostsImpl<>("{1}{S}"));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§}§public ScryingSheets(final ScryingSheets card) {§super(card);§}§@Override§public ScryingSheets copy() {§return new ScryingSheets(this);§}§}§class ScryingSheetsEffect extends OneShotEffect {§ScryingSheetsEffect() {§super(Outcome.Benefit);§this.staticText = "Look at the top card of your library. If that card is snow, you may reveal it and put it into your hand";§}§ScryingSheetsEffect(final ScryingSheetsEffect effect) {§super(effect);§}§@Override§public ScryingSheetsEffect copy() {§return new ScryingSheetsEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§MageObject sourceObject = game.getObject(source.getSourceId());§if (controller != null && sourceObject != null) {§Card card = controller.getLibrary().getFromTop(game);§if (card != null) {§CardsImpl cards = new CardsImpl();§cards.add(card);§controller.lookAtCards(sourceObject.getIdName(), cards, game);§if (card.getSupertype().contains("Snow")) {§if (controller.chooseUse(outcome, "Reveal " + card.getLogName() + " and put it into your hand?", source, game)) {§controller.moveCards(card, null, Zone.HAND, source, game);§controller.revealCards(sourceObject.getIdName(), cards, game);§}§}§}§return true;§}§return false;§}§}§
public class ShelteringAncient extends CardImpl {§public ShelteringAncient(UUID ownerId) {§super(ownerId, 121, "Sheltering Ancient", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "CSP";§this.subtype.add("Treefolk");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(TrampleAbility.getInstance());§this.addAbility(new CumulativeUpkeepAbility(new ShelteringAncientCost()));§}§public ShelteringAncient(final ShelteringAncient card) {§super(card);§}§@Override§public ShelteringAncient copy() {§return new ShelteringAncient(this);§}§}§class ShelteringAncientCost extends CostImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent();§static {§filter.add(new ControllerPredicate(TargetController.OPPONENT));§}§ShelteringAncientCost() {§this.text = "Put a +1/+1 counter on a creature an opponent controls";§}§@Override§public boolean pay(Ability ability, Game game, UUID sourceId, UUID controllerId, boolean noMana, Cost costToPay) {§Player controller = game.getPlayer(controllerId);§if (controller != null) {§Target target = new TargetCreaturePermanent(1, 1, filter, true);§if (target.choose(Outcome.BoostCreature, controllerId, sourceId, game)) {§Permanent permanent = game.getPermanent(target.getFirstTarget());§if (permanent != null) {§permanent.addCounters(CounterType.P1P1.createInstance(), game);§this.paid = true;§return true;§}§}§}§return false;§}§@Override§public boolean canPay(Ability ability, UUID sourceId, UUID controllerId, Game game) {§return game.getBattlefield().contains(filter, sourceId, game, 1);§}§@Override§public ShelteringAncientCost copy() {§return new ShelteringAncientCost();§}§}§
public class SimianBrawler extends CardImpl {§public SimianBrawler(UUID ownerId) {§super(ownerId, 122, "Simian Brawler", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{G}");§this.expansionSetCode = "CSP";§this.subtype.add("Ape");§this.subtype.add("Warrior");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(1, 1, Duration.EndOfTurn),§new DiscardCardCost(new FilterLandCard("a land card"))));§}§public SimianBrawler(final SimianBrawler card) {§super(card);§}§@Override§public SimianBrawler copy() {§return new SimianBrawler(this);§}§}§
public class Skred extends CardImpl {§public Skred(UUID ownerId) {§super(ownerId, 97, "Skred", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{R}");§this.expansionSetCode = "CSP";§this.getSpellAbility().addEffect(new SkredDamageEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public Skred(final Skred card) {§super(card);§}§@Override§public Skred copy() {§return new Skred(this);§}§}§class SkredDamageEffect extends OneShotEffect {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("equal to the number of snow permanents you control.");§static {§filter.add(new SupertypePredicate("Snow"));§}§public SkredDamageEffect() {§super(Outcome.Damage);§this.staticText = "{this} deals damage to target creature equal to the number of snow permanents you control.";§}§public SkredDamageEffect(final SkredDamageEffect effect) {§super(effect);§}§@Override§public SkredDamageEffect copy() {§return new SkredDamageEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§int amount = game.getBattlefield().count(filter, source.getSourceId(), source.getControllerId(), game);§Permanent permanent = game.getPermanent(targetPointer.getFirst(game, source));§if(amount > 0) {§if (permanent != null) {§permanent.damage(amount, source.getSourceId(), game, false, true);§return true;§}§}§return false;§}§}§
public class SoulSpike extends CardImpl {§private static final FilterCard filter = new FilterCard("two black cards");§static {§filter.add(new ColorPredicate(ObjectColor.BLACK));§}§public SoulSpike(UUID ownerId) {§super(ownerId, 70, "Soul Spike", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{5}{B}{B}");§this.expansionSetCode = "CSP";§this.addAbility(new AlternativeCostSourceAbility(new ExileFromHandCost(new TargetCardInHand(2, filter))));§this.getSpellAbility().addTarget(new TargetCreatureOrPlayer());§this.getSpellAbility().addEffect(new DamageTargetEffect(4));§this.getSpellAbility().addEffect(new GainLifeEffect(4));§}§public SoulSpike(final SoulSpike card) {§super(card);§}§@Override§public SoulSpike copy() {§return new SoulSpike(this);§}§}§
public class SquallDrifter extends CardImpl {§public SquallDrifter(UUID ownerId) {§super(ownerId, 17, "Squall Drifter", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "CSP";§this.supertype.add("Snow");§this.subtype.add("Elemental");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new TapTargetEffect(), new ManaCostsImpl("{W}"));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public SquallDrifter(final SquallDrifter card) {§super(card);§}§@Override§public SquallDrifter copy() {§return new SquallDrifter(this);§}§}§
public class SteamSpitter extends CardImpl {§public SteamSpitter(UUID ownerId) {§super(ownerId, 124, "Steam Spitter", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{G}");§this.expansionSetCode = "CSP";§this.subtype.add("Spider");§this.power = new MageInt(1);§this.toughness = new MageInt(5);§this.addAbility(ReachAbility.getInstance());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(1, 0, Duration.EndOfTurn), new ManaCostsImpl("{R}")));§}§public SteamSpitter(final SteamSpitter card) {§super(card);§}§@Override§public SteamSpitter copy() {§return new SteamSpitter(this);§}§}§
public class StromgaldCrusader extends CardImpl {§private static final FilterCard filter = new FilterCard("White");§static {§filter.add(new ColorPredicate(ObjectColor.WHITE));§}§public StromgaldCrusader(UUID ownerId) {§super(ownerId, 71, "Stromgald Crusader", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{B}{B}");§this.expansionSetCode = "CSP";§this.subtype.add("Zombie");§this.subtype.add("Knight");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new ProtectionAbility(filter));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilitySourceEffect(FlyingAbility.getInstance(), Duration.EndOfTurn), new ManaCostsImpl("{B}")));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(1,0, Duration.EndOfTurn), new ManaCostsImpl("{B}{B}")));§}§public StromgaldCrusader(final StromgaldCrusader card) {§super(card);§}§@Override§public StromgaldCrusader copy() {§return new StromgaldCrusader(this);§}§}§
public class SunsBounty extends CardImpl {§public SunsBounty(UUID ownerId) {§super(ownerId, 18, "Sun's Bounty", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{W}");§this.expansionSetCode = "CSP";§this.getSpellAbility().addEffect(new GainLifeEffect(4));§this.addAbility(new RecoverAbility(new ManaCostsImpl("{1}{W}"), this));§}§public SunsBounty(final SunsBounty card) {§super(card);§}§@Override§public SunsBounty copy() {§return new SunsBounty(this);§}§}§
public class SurgingDementia extends CardImpl {§public SurgingDementia(UUID ownerId) {§super(ownerId, 72, "Surging Dementia", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{1}{B}");§this.expansionSetCode = "CSP";§this.addAbility(new RippleAbility(4));§this.getSpellAbility().getEffects().add(new DiscardTargetEffect(1));§this.getSpellAbility().getTargets().add(new TargetPlayer());§}§public SurgingDementia(final SurgingDementia card) {§super(card);§}§@Override§public SurgingDementia copy() {§return new SurgingDementia(this);§}§}§
public class SurgingFlame extends CardImpl {§public SurgingFlame(UUID ownerId) {§super(ownerId, 99, "Surging Flame", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{R}");§this.expansionSetCode = "CSP";§this.addAbility(new RippleAbility(4));§this.getSpellAbility().addEffect(new DamageTargetEffect(2));§this.getSpellAbility().addTarget(new TargetCreatureOrPlayer());§}§public SurgingFlame(final SurgingFlame card) {§super(card);§}§@Override§public SurgingFlame copy() {§return new SurgingFlame(this);§}§}§
public class SurgingMight extends CardImpl {§public SurgingMight(UUID ownerId) {§super(ownerId, 125, "Surging Might", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{G}");§this.expansionSetCode = "CSP";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(2, 2, Duration.WhileOnBattlefield)));§this.addAbility(new RippleAbility(4));§}§public SurgingMight(final SurgingMight card) {§super(card);§}§@Override§public SurgingMight copy() {§return new SurgingMight(this);§}§}§
public class SurgingSentinels extends CardImpl {§public SurgingSentinels(UUID ownerId) {§super(ownerId, 20, "Surging Sentinels", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "CSP";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(FirstStrikeAbility.getInstance());§this.addAbility(new RippleAbility(4));§}§public SurgingSentinels(final SurgingSentinels card) {§super(card);§}§@Override§public SurgingSentinels copy() {§return new SurgingSentinels(this);§}§}§
public class SwiftManeuver extends CardImpl {§public SwiftManeuver(UUID ownerId) {§super(ownerId, 21, "Swift Maneuver", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{W}");§this.expansionSetCode = "CSP";§this.getSpellAbility().addEffect(new PreventDamageToTargetEffect(Duration.EndOfTurn, 2));§this.getSpellAbility().addTarget(new TargetCreatureOrPlayer());§this.getSpellAbility().addEffect(new CreateDelayedTriggeredAbilityEffect(§new AtTheBeginOfNextUpkeepDelayedTriggeredAbility(new DrawCardSourceControllerEffect(1)), false));§}§public SwiftManeuver(final SwiftManeuver card) {§super(card);§}§@Override§public SwiftManeuver copy() {§return new SwiftManeuver(this);§}§}§
public class Thermopod extends CardImpl {§public Thermopod(UUID ownerId) {§super(ownerId, 100, "Thermopod", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{R}");§this.expansionSetCode = "CSP";§this.supertype.add("Snow");§this.subtype.add("Slug");§this.power = new MageInt(4);§this.toughness = new MageInt(3);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilitySourceEffect(§HasteAbility.getInstance(), Duration.EndOfTurn), new ManaCostsImpl("{S}")));§this.addAbility(new SimpleManaAbility(Zone.BATTLEFIELD, Mana.RedMana(1), new SacrificeTargetCost(§new TargetControlledCreaturePermanent(new FilterControlledCreaturePermanent("a creature")))));§}§public Thermopod(final Thermopod card) {§super(card);§}§@Override§public Thermopod copy() {§return new Thermopod(this);§}§}§
public class ThrummingStone extends CardImpl {§private static final FilterSpell anySpellFilter = new FilterSpell("Spells you cast");§public ThrummingStone(UUID ownerId) {§super(ownerId, 142, "Thrumming Stone", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{5}");§this.expansionSetCode = "CSP";§this.supertype.add("Legendary");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new ThrummingStoneGainAbilitySpellsEffect(new RippleAbility(4), anySpellFilter)));§}§public ThrummingStone(final ThrummingStone card) {§super(card);§}§@Override§public ThrummingStone copy() {§return new ThrummingStone(this);§}§}§class ThrummingStoneGainAbilitySpellsEffect extends ContinuousEffectImpl {§private final Ability ability;§private final FilterSpell filter;§public ThrummingStoneGainAbilitySpellsEffect(Ability ability, FilterSpell filter) {§super(Duration.WhileOnBattlefield, Layer.AbilityAddingRemovingEffects_6, SubLayer.NA, Outcome.AddAbility);§this.ability = ability;§this.filter = filter;§staticText = filter.getMessage() + " have " + ability.getRule();§}§public ThrummingStoneGainAbilitySpellsEffect(final ThrummingStoneGainAbilitySpellsEffect effect) {§super(effect);§this.ability = effect.ability.copy();§this.filter = effect.filter.copy();§}§@Override§public ThrummingStoneGainAbilitySpellsEffect copy() {§return new ThrummingStoneGainAbilitySpellsEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§Permanent permanent = game.getPermanent(source.getSourceId());§if (player != null && permanent != null) {§for (StackObject stackObject : game.getStack()) {§if ((stackObject instanceof Spell) && !stackObject.isCopy() && stackObject.getControllerId().equals(source.getControllerId())) {§Spell spell = (Spell) stackObject;§if (filter.match(spell, game)) {§if (!spell.getAbilities().contains(ability)) {§game.getState().addOtherAbility(spell.getCard(), ability);§}§}§}§}§return true;§}§return false;§}§}§
public class TresserhornSinks extends CardImpl {§public TresserhornSinks(UUID ownerId) {§super(ownerId, 150, "Tresserhorn Sinks", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "CSP";§this.supertype.add("Snow");§this.addAbility(new EntersBattlefieldTappedAbility());§this.addAbility(new BlackManaAbility());§this.addAbility(new RedManaAbility());§}§public TresserhornSinks(final TresserhornSinks card) {§super(card);§}§@Override§public TresserhornSinks copy() {§return new TresserhornSinks(this);§}§}§
public class UrsineFylgja extends CardImpl {§public UrsineFylgja(UUID ownerId) {§super(ownerId, 22, "Ursine Fylgja", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{W}");§this.expansionSetCode = "CSP";§this.subtype.add("Spirit");§this.subtype.add("Bear");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§Effect effect = new AddCountersSourceEffect(CounterType.HEALING.createInstance(4));§effect.setText("with four healing counters on it.");§this.addAbility(new EntersBattlefieldAbility(effect));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new PreventDamageToSourceEffect(Duration.EndOfTurn, 1),§new RemoveCountersSourceCost(CounterType.HEALING.createInstance(1))));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new AddCountersSourceEffect(CounterType.HEALING.createInstance(1)),§new ManaCostsImpl("{2}{W}")));§}§public UrsineFylgja(final UrsineFylgja card) {§super(card);§}§@Override§public UrsineFylgja copy() {§return new UrsineFylgja(this);§}§}§
public class WallOfShards extends CardImpl {§public WallOfShards(UUID ownerId) {§super(ownerId, 23, "Wall of Shards", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "CSP";§this.supertype.add("Snow");§this.subtype.add("Wall");§this.power = new MageInt(1);§this.toughness = new MageInt(8);§this.addAbility(DefenderAbility.getInstance());§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new CumulativeUpkeepAbility(new GainLifeOpponentCost(1) ));§}§public WallOfShards(final WallOfShards card) {§super(card);§}§@Override§public WallOfShards copy() {§return new WallOfShards(this);§}§}§
public class WhiteShieldCrusader extends CardImpl {§private static final FilterCard filter = new FilterCard("Black");§static {§filter.add(new ColorPredicate(ObjectColor.BLACK));§}§public WhiteShieldCrusader(UUID ownerId) {§super(ownerId, 24, "White Shield Crusader", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{W}{W}");§this.expansionSetCode = "CSP";§this.subtype.add("Human");§this.subtype.add("Knight");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new ProtectionAbility(filter));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilitySourceEffect(FlyingAbility.getInstance(), Duration.EndOfTurn), new ManaCostsImpl("{W}")));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(1,0, Duration.EndOfTurn), new ManaCostsImpl("{W}{W}")));§}§public WhiteShieldCrusader(final WhiteShieldCrusader card) {§super(card);§}§@Override§public WhiteShieldCrusader copy() {§return new WhiteShieldCrusader(this);§}§}§
public class WildernessElemental extends CardImpl {§private static final FilterLandPermanent filter = new FilterLandPermanent("nonbasic lands your opponents control");§static {§filter.add(Predicates.not(new SupertypePredicate("Basic")));§filter.add(new ControllerPredicate(TargetController.OPPONENT));§}§public WildernessElemental(UUID ownerId) {§super(ownerId, 134, "Wilderness Elemental", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{R}{G}");§this.expansionSetCode = "CSP";§this.subtype.add("Elemental");§this.power = new MageInt(0);§this.toughness = new MageInt(3);§this.addAbility(TrampleAbility.getInstance());§this.addAbility(new SimpleStaticAbility(Zone.ALL, new SetPowerSourceEffect(new PermanentsOnBattlefieldCount(filter), Duration.EndOfGame)));§}§public WildernessElemental(final WildernessElemental card) {§super(card);§}§@Override§public WildernessElemental copy() {§return new WildernessElemental(this);§}§}§
public class WoollyRazorback extends CardImpl {§public WoollyRazorback(UUID ownerId) {§super(ownerId, 25, "Woolly Razorback", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{W}{W}");§this.expansionSetCode = "CSP";§this.subtype.add("Boar");§this.subtype.add("Beast");§this.power = new MageInt(7);§this.toughness = new MageInt(7);§this.addAbility(new EntersBattlefieldAbility(new AddCountersSourceEffect(CounterType.ICE.createInstance(3)),§"with three ice counters on it"));§ConditionalReplacementEffect effect = new ConditionalReplacementEffect(new PreventCombatDamageBySourceEffect(Duration.WhileOnBattlefield),§new SourceHasCounterCondition(CounterType.ICE));§effect.setText("as long as {this} has an ice counter on it, prevent all combat damage it would deal");§Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new ConditionalReplacementEffect(effect));§ability.addEffect(new ConditionalContinuousEffect(new GainAbilitySourceEffect(DefenderAbility.getInstance()),§new SourceHasCounterCondition(CounterType.ICE), "and it has defender"));§this.addAbility(ability);§this.addAbility(new BlocksTriggeredAbility(new RemoveCounterSourceEffect(CounterType.ICE.createInstance()), false));§}§public WoollyRazorback(final WoollyRazorback card) {§super(card);§}§@Override§public WoollyRazorback copy() {§return new WoollyRazorback(this);§}§}§
public class ZurTheEnchanter extends CardImpl {§private static final FilterCard filter = new FilterCard("enchantment card with converted mana cost 3 or less");§static {§filter.add(new CardTypePredicate(CardType.ENCHANTMENT));§filter.add(new ConvertedManaCostPredicate(Filter.ComparisonType.LessThan, 4));§}§public ZurTheEnchanter(UUID ownerId) {§super(ownerId, 135, "Zur the Enchanter", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{W}{U}{B}");§this.expansionSetCode = "CSP";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new AttacksTriggeredAbility(new SearchLibraryPutInPlayEffect(new TargetCardInLibrary(filter), false), true));§}§public ZurTheEnchanter(final ZurTheEnchanter card) {§super(card);§}§@Override§public ZurTheEnchanter copy() {§return new ZurTheEnchanter(this);§}§}§
public class AcornCatapult extends CardImpl {§public AcornCatapult(UUID ownerId) {§super(ownerId, 241, "Acorn Catapult", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{4}");§this.expansionSetCode = "CMD";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(1), new ManaCostsImpl("{1}"));§ability.addCost(new TapSourceCost());§ability.addEffect(new AcornCatapultEffect());§ability.addTarget(new TargetCreatureOrPlayer());§this.addAbility(ability);§}§public AcornCatapult(final AcornCatapult card) {§super(card);§}§@Override§public AcornCatapult copy() {§return new AcornCatapult(this);§}§}§class AcornCatapultEffect extends OneShotEffect {§public AcornCatapultEffect() {§super(Outcome.PutCreatureInPlay);§staticText = "that creature's controller or that player puts a 1/1 green Squirrel creature token onto the battlefield";§}§public AcornCatapultEffect(final AcornCatapultEffect effect) {§super(effect);§}§@Override§public AcornCatapultEffect copy() {§return new AcornCatapultEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§UUID targetId = getTargetPointer().getFirst(game, source);§Player player = game.getPlayer(targetId);§if(player == null) {§Permanent permanent = game.getPermanent(targetId);§if(permanent != null) {§player = game.getPlayer(permanent.getControllerId());§}§}§if(player != null) {§new SquirrelToken().putOntoBattlefield(1, game, source.getSourceId(), player.getId());§return true;§}§return false;§}§}§
public class AEthersnipe extends CardImpl {§public AEthersnipe(UUID ownerId) {§super(ownerId, 39, "AEthersnipe", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{5}{U}");§this.expansionSetCode = "CMD";§this.subtype.add("Elemental");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§Ability ability = new EntersBattlefieldTriggeredAbility(new ReturnToHandTargetEffect());§Target target = new TargetNonlandPermanent();§ability.addTarget(target);§this.addAbility(ability);§this.addAbility(new EvokeAbility(this, "{1}{U}{U}"));§}§public AEthersnipe(final AEthersnipe card) {§super(card);§}§@Override§public AEthersnipe copy() {§return new AEthersnipe(this);§}§}§
public class AkromaAngelOfFury extends CardImpl {§private static final FilterCard protectionFilter = new FilterCard("white and from blue");§static {§protectionFilter.add(Predicates.or(new ColorPredicate(ObjectColor.WHITE),new ColorPredicate(ObjectColor.BLUE)));§}§public AkromaAngelOfFury(UUID ownerId) {§super(ownerId, 108, "Akroma, Angel of Fury", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}{R}{R}{R}");§this.expansionSetCode = "CMD";§this.supertype.add("Legendary");§this.subtype.add("Angel");§this.power = new MageInt(6);§this.toughness = new MageInt(6);§this.addAbility(new CantBeCounteredAbility());§this.addAbility(FlyingAbility.getInstance());§this.addAbility(TrampleAbility.getInstance());§this.addAbility(new ProtectionAbility(protectionFilter));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(1,0, Duration.EndOfTurn), new ManaCostsImpl("{R}")));§this.addAbility(new MorphAbility(this, new ManaCostsImpl("{3}{R}{R}{R}")));§}§public AkromaAngelOfFury(final AkromaAngelOfFury card) {§super(card);§}§@Override§public AkromaAngelOfFury copy() {§return new AkromaAngelOfFury(this);§}§}§
public class AllianceOfArms extends CardImpl {§public AllianceOfArms(UUID ownerId) {§super(ownerId, 4, "Alliance of Arms", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{W}");§this.expansionSetCode = "CMD";§this.getSpellAbility().addEffect(new AllianceOfArmsEffect());§}§public AllianceOfArms(final AllianceOfArms card) {§super(card);§}§@Override§public AllianceOfArms copy() {§return new AllianceOfArms(this);§}§}§class AllianceOfArmsEffect extends OneShotEffect {§public AllianceOfArmsEffect() {§super(Outcome.Detriment);§this.staticText = "<i>Join forces</i> - Starting with you, each player may pay any amount of mana. Each player puts X 1/1 white Soldier creature tokens onto the battlefield, where X is the total amount of mana paid this way";§}§public AllianceOfArmsEffect(final AllianceOfArmsEffect effect) {§super(effect);§}§@Override§public AllianceOfArmsEffect copy() {§return new AllianceOfArmsEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§int xSum = 0;§xSum += playerPaysXGenericMana(controller, source, game);§for(UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {§if (playerId != controller.getId()) {§Player player = game.getPlayer(playerId);§if (player != null) {§xSum += playerPaysXGenericMana(player, source, game);§}§}§}§if (xSum > 0) {§for(UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {§Effect effect = new CreateTokenTargetEffect(new SoldierToken(), xSum);§effect.setTargetPointer(new FixedTarget(playerId));§effect.apply(game, source);§}§}§controller.resetStoredBookmark(game);§return true;§}§return false;§}§protected static int playerPaysXGenericMana(Player player, Ability source, Game game) {§int xValue = 0;§boolean payed = false;§while (player.canRespond() && !payed) {§xValue = player.announceXMana(0, Integer.MAX_VALUE, "How much mana will you pay?", game, source);§if (xValue > 0) {§Cost cost = new GenericManaCost(xValue);§payed = cost.pay(source, game, source.getSourceId(), player.getId(), false, null);§} else {§payed = true;§}§}§game.informPlayers(new StringBuilder(player.getLogName()).append(" pays {").append(xValue).append("}.").toString());§return xValue;§}§}§
public class AustereCommand extends CardImpl {§private static final FilterCreaturePermanent filter3orLess = new FilterCreaturePermanent("creatures with converted mana cost 3 or less");§private static final FilterCreaturePermanent filter4orMore = new FilterCreaturePermanent("creatures with converted mana cost 4 or greater");§static {§filter3orLess.add(new ConvertedManaCostPredicate(Filter.ComparisonType.LessThan, 4));§filter4orMore.add(new ConvertedManaCostPredicate(Filter.ComparisonType.GreaterThan, 3));§}§public AustereCommand(UUID ownerId) {§super(ownerId, 8, "Austere Command", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{4}{W}{W}");§this.expansionSetCode = "CMD";§this.getSpellAbility().getModes().setMinModes(2);§this.getSpellAbility().getModes().setMaxModes(2);§this.getSpellAbility().addEffect(new DestroyAllEffect(new FilterArtifactPermanent("artifacts")));§Mode mode = new Mode();§mode.getEffects().add(new DestroyAllEffect(new FilterEnchantmentPermanent("enchantments")));§this.getSpellAbility().getModes().addMode(mode);§mode = new Mode();§mode.getEffects().add(new DestroyAllEffect(filter3orLess));§this.getSpellAbility().getModes().addMode(mode);§mode = new Mode();§mode.getEffects().add(new DestroyAllEffect(filter4orMore));§this.getSpellAbility().getModes().addMode(mode);§}§public AustereCommand(final AustereCommand card) {§super(card);§}§@Override§public AustereCommand copy() {§return new AustereCommand(this);§}§}§
public class AvatarOfSlaughter extends CardImpl {§public AvatarOfSlaughter(UUID ownerId) {§super(ownerId, 111, "Avatar of Slaughter", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{6}{R}{R}");§this.expansionSetCode = "CMD";§this.subtype.add("Avatar");§this.power = new MageInt(8);§this.toughness = new MageInt(8);§Effect effect = new GainAbilityAllEffect(DoubleStrikeAbility.getInstance(), Duration.WhileOnBattlefield, new FilterCreaturePermanent("creatures"));§effect.setText("All creatures have double strike");§Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, effect);§effect = new AttacksIfAbleAllEffect(new FilterCreaturePermanent("creatures"));§effect.setText("and attack each turn if able");§ability.addEffect(effect);§this.addAbility(ability, new AttackedThisTurnWatcher());§}§public AvatarOfSlaughter(final AvatarOfSlaughter card) {§super(card);§}§@Override§public AvatarOfSlaughter copy() {§return new AvatarOfSlaughter(this);§}§}§
public class BasandraBattleSeraph extends CardImpl {§public BasandraBattleSeraph(UUID ownerId) {§super(ownerId, 184, "Basandra, Battle Seraph", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{R}{W}");§this.expansionSetCode = "CMD";§this.supertype.add("Legendary");§this.subtype.add("Angel");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BasandraBattleSeraphEffect()));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new AttacksIfAbleTargetEffect(Duration.EndOfTurn), new ManaCostsImpl("{R}"));§ability.addEffect(new GainAbilityTargetEffect(AttacksThisTurnMarkerAbility.getInstance(), Duration.EndOfTurn, null));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public BasandraBattleSeraph(final BasandraBattleSeraph card) {§super(card);§}§@Override§public BasandraBattleSeraph copy() {§return new BasandraBattleSeraph(this);§}§}§class BasandraBattleSeraphEffect extends ContinuousRuleModifyingEffectImpl {§public BasandraBattleSeraphEffect() {§super(Duration.EndOfTurn, Outcome.Neutral);§staticText = "Players can't cast spells during combat";§}§public BasandraBattleSeraphEffect(final BasandraBattleSeraphEffect effect) {§super(effect);§}§@Override§public BasandraBattleSeraphEffect copy() {§return new BasandraBattleSeraphEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.CAST_SPELL;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§if (game.getPhase().getType() == TurnPhase.COMBAT) {§return true;§}§return false;§}§}§
public class BladewingTheRisen extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Dragon creatures");§private static final FilterPermanentCard filterCard = new FilterPermanentCard("Dragon permanent card from your graveyard");§static {§filter.add(new SubtypePredicate("Dragon"));§filterCard.add(new SubtypePredicate("Dragon"));§}§public BladewingTheRisen(UUID ownerId) {§super(ownerId, 185, "Bladewing the Risen", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{B}{B}{R}{R}");§this.expansionSetCode = "CMD";§this.supertype.add("Legendary");§this.subtype.add("Zombie");§this.subtype.add("Dragon");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new EntersBattlefieldTriggeredAbility(new ReturnFromGraveyardToBattlefieldTargetEffect(), true);§Target target = new TargetCardInYourGraveyard(filterCard);§ability.addTarget(target);§this.addAbility(ability);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostAllEffect(1,1, Duration.EndOfTurn, filter, false), new ManaCostsImpl("{B}{R}")));§}§public BladewingTheRisen(final BladewingTheRisen card) {§super(card);§}§@Override§public BladewingTheRisen copy() {§return new BladewingTheRisen(this);§}§}§
public class BreathOfDarigaaz extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature without flying");§static {§filter.add(Predicates.not(new AbilityPredicate(FlyingAbility.class)));§}§public BreathOfDarigaaz(UUID ownerId) {§super(ownerId, 112, "Breath of Darigaaz", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{1}{R}");§this.expansionSetCode = "CMD";§this.addAbility(new KickerAbility("{2}"));§this.getSpellAbility().addEffect(new ConditionalOneShotEffect(new DamageEverythingEffect(4, filter),§new DamageEverythingEffect(1, filter), KickedCondition.getInstance(),§"{this} deals 1 damage to each creature without flying and each player. If {this} was kicked, it deals 4 damage to each creature without flying and each player instead."));§}§public BreathOfDarigaaz(final BreathOfDarigaaz card) {§super(card);§}§@Override§public BreathOfDarigaaz copy() {§return new BreathOfDarigaaz(this);§}§}§
public class BrionStoutarm extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("creature other than Brion Stoutarm");§static {§filter.add(new AnotherPredicate());§}§public BrionStoutarm(UUID ownerId) {§super(ownerId, 187, "Brion Stoutarm", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{R}{W}");§this.expansionSetCode = "CMD";§this.supertype.add("Legendary");§this.subtype.add("Giant");§this.subtype.add("Warrior");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(LifelinkAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BrionStoutarmEffect(), new ManaCostsImpl("{R}"));§ability.addCost(new TapSourceCost());§ability.addCost(new SacrificeTargetCost(new TargetControlledCreaturePermanent(1, 1, filter, true)));§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§}§public BrionStoutarm(final BrionStoutarm card) {§super(card);§}§@Override§public BrionStoutarm copy() {§return new BrionStoutarm(this);§}§}§class BrionStoutarmEffect extends OneShotEffect {§public BrionStoutarmEffect() {§super(Outcome.Benefit);§this.staticText = "{this} deals damage equal to the sacrificed creature's power to target player";§}§public BrionStoutarmEffect(final BrionStoutarmEffect effect) {§super(effect);§}§@Override§public BrionStoutarmEffect copy() {§return new BrionStoutarmEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§int amount = 0;§for (Cost cost : source.getCosts()) {§if (cost instanceof SacrificeTargetCost && ((SacrificeTargetCost) cost).getPermanents().size() > 0) {§amount = ((SacrificeTargetCost) cost).getPermanents().get(0).getPower().getValue();§break;§}§}§if (amount > 0) {§Player player = game.getPlayer(source.getFirstTarget());§if (player != null) {§player.damage(amount, source.getSourceId(), game, false, true);§}§}§return true;§}§}§
public class BuriedAlive extends CardImpl {§public BuriedAlive(UUID ownerId) {§super(ownerId, 74, "Buried Alive", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{2}{B}");§this.expansionSetCode = "CMD";§this.getSpellAbility().addEffect(new BuriedAliveEffect());§}§public BuriedAlive(final BuriedAlive card) {§super(card);§}§@Override§public BuriedAlive copy() {§return new BuriedAlive(this);§}§}§class BuriedAliveEffect extends SearchEffect {§public BuriedAliveEffect() {§super(new TargetCardInLibrary(0, 3, new FilterCreatureCard()), Outcome.Detriment);§staticText = "Search your library for up to three creature cards and put them into your graveyard. Then shuffle your library";§}§public BuriedAliveEffect(final BuriedAliveEffect effect) {§super(effect);§}§@Override§public BuriedAliveEffect copy() {§return new BuriedAliveEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§if (controller.searchLibrary(target, game)) {§controller.moveCards(new CardsImpl(target.getTargets()), Zone.LIBRARY, Zone.GRAVEYARD, source, game);§}§controller.shuffleLibrary(game);§return true;§}§return false;§}§}§
public class CallTheSkybreaker extends CardImpl {§public CallTheSkybreaker(UUID ownerId) {§super(ownerId, 188, "Call the Skybreaker", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{5}{U/R}{U/R}");§this.expansionSetCode = "CMD";§this.getSpellAbility().addEffect(new CreateTokenEffect(new ElementalToken()));§this.addAbility(new RetraceAbility(this));§}§public CallTheSkybreaker(final CallTheSkybreaker card) {§super(card);§}§@Override§public CallTheSkybreaker copy() {§return new CallTheSkybreaker(this);§}§}§class ElementalToken extends Token {§public ElementalToken() {§super("Elemental", "a 5/5 blue and red Elemental creature token with flying");§cardType.add(CardType.CREATURE);§color.setBlue(true);§color.setRed(true);§subtype.add("Elemental");§power = new MageInt(5);§toughness = new MageInt(5);§this.addAbility(FlyingAbility.getInstance());§}§}§
public class CelestialForce extends CardImpl {§public CelestialForce(UUID ownerId) {§super(ownerId, 10, "Celestial Force", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}{W}{W}{W}");§this.expansionSetCode = "CMD";§this.subtype.add("Elemental");§this.power = new MageInt(7);§this.toughness = new MageInt(7);§this.addAbility(new BeginningOfUpkeepTriggeredAbility(new GainLifeEffect(3), TargetController.ANY, false));§}§public CelestialForce(final CelestialForce card) {§super(card);§}§@Override§public CelestialForce copy() {§return new CelestialForce(this);§}§}§
public class ChampionsHelm extends CardImpl {§private static final String staticText = "As long as equipped creature is legendary, it has hexproof";§public ChampionsHelm(UUID ownerId) {§super(ownerId, 244, "Champion's Helm", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "CMD";§this.subtype.add("Equipment");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEquippedEffect(2, 2)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new ConditionalContinuousEffect(§new GainAbilityAttachedEffect(HexproofAbility.getInstance(), AttachmentType.EQUIPMENT),§new EquippedHasSupertypeCondition("Legendary"), staticText)));§this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(1)));§}§public ChampionsHelm(final ChampionsHelm card) {§super(card);§}§@Override§public ChampionsHelm copy() {§return new ChampionsHelm(this);§}§}§
public class ChorusOfTheConclave extends CardImpl {§public ChorusOfTheConclave(UUID ownerId) {§super(ownerId, 189, "Chorus of the Conclave", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{G}{G}{W}{W}");§this.expansionSetCode = "CMD";§this.supertype.add("Legendary");§this.subtype.add("Dryad");§this.power = new MageInt(3);§this.toughness = new MageInt(8);§this.addAbility(new ForestwalkAbility());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new ChorusOfTheConclaveReplacementEffect()));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new ChorusOfTheConclaveReplacementEffect2()));§}§public ChorusOfTheConclave(final ChorusOfTheConclave card) {§super(card);§}§@Override§public ChorusOfTheConclave copy() {§return new ChorusOfTheConclave(this);§}§}§class ChorusOfTheConclaveReplacementEffect extends ReplacementEffectImpl {§public ChorusOfTheConclaveReplacementEffect() {§super(Duration.WhileOnBattlefield, Outcome.Benefit);§staticText = "As an additional cost to cast creature spells, you may pay any amount of mana";§}§public ChorusOfTheConclaveReplacementEffect(final ChorusOfTheConclaveReplacementEffect effect) {§super(effect);§}§@Override§public ChorusOfTheConclaveReplacementEffect copy() {§return new ChorusOfTheConclaveReplacementEffect(this);§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.CAST_SPELL;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§if (event.getPlayerId().equals(source.getControllerId())) {§MageObject spellObject = game.getObject(event.getSourceId());§if (spellObject != null) {§return spellObject.getCardType().contains(CardType.CREATURE);§}§}§return false;§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§int xCost = 0;§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§if (controller.chooseUse(Outcome.Benefit, "Do you wish to pay the additonal cost to add +1/+1 counters to the creature you cast?", source, game)) {§xCost += playerPaysXGenericMana(controller, source, game);§Object object = game.getState().getValue("spellX" + source.getSourceId());§Map<String, Integer> spellX;§if (object != null && object instanceof Map) {§spellX = (Map<String, Integer>) object;§} else {§spellX = new HashMap<>();§}§spellX.put(event.getSourceId().toString() + game.getState().getZoneChangeCounter(event.getSourceId()), xCost);§game.getState().setValue("spellX" + source.getSourceId(), spellX);§}§}§return false;§}§protected static int playerPaysXGenericMana(Player player, Ability source, Game game) {§int xValue = 0;§boolean payed = false;§while (!payed) {§xValue = player.announceXMana(0, Integer.MAX_VALUE, "How much mana will you pay?", game, source);§if (xValue > 0) {§Cost cost = new GenericManaCost(xValue);§payed = cost.pay(source, game, source.getSourceId(), player.getId(), false, null);§} else {§payed = true;§}§}§game.informPlayers(player.getLogName() + " pays {" + xValue + "}");§return xValue;§}§}§class ChorusOfTheConclaveReplacementEffect2 extends ReplacementEffectImpl {§public ChorusOfTheConclaveReplacementEffect2() {§super(Duration.WhileOnBattlefield, Outcome.Benefit);§staticText = "If you do, that creature enters the battlefield with that many additional +1/+1 counters on it";§}§public ChorusOfTheConclaveReplacementEffect2(final ChorusOfTheConclaveReplacementEffect2 effect) {§super(effect);§}§@Override§public ChorusOfTheConclaveReplacementEffect2 copy() {§return new ChorusOfTheConclaveReplacementEffect2(this);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.ENTERS_THE_BATTLEFIELD;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§Map<String, Integer> spellX = (Map<String, Integer>) game.getState().getValue("spellX" + source.getSourceId());§return spellX != null§&& event.getSourceId() != null§&& spellX.containsKey(event.getSourceId().toString() + (game.getState().getZoneChangeCounter(event.getSourceId()) - 1));§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§Permanent creature = ((EntersTheBattlefieldEvent) event).getTarget();§Map<String, Integer> spellX = (Map<String, Integer>) game.getState().getValue("spellX" + source.getSourceId());§MageObject sourceObject = source.getSourceObject(game);§if (sourceObject != null && creature != null && spellX != null) {§String key = event.getSourceId().toString() + (game.getState().getZoneChangeCounter(event.getSourceId()) - 1);§int xValue = spellX.get(key);§if (xValue > 0) {§creature.addCounters(CounterType.P1P1.createInstance(xValue), game);§game.informPlayers(sourceObject.getLogName() + ": " + creature.getLogName() + " enters the battlefield with " + xValue + " +1/+1 counter" + (xValue > 1 ? "s" : "") + " on it");§}§spellX.remove(key);§}§return false;§}§}§
public class ChromeshellCrab extends CardImpl {§private static final String rule = "you may exchange control of target creature you control and target creature an opponent controls";§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature an opponent controls");§static {§filter.add(new ControllerPredicate(TargetController.OPPONENT));§}§public ChromeshellCrab(UUID ownerId) {§super(ownerId, 41, "Chromeshell Crab", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{U}");§this.expansionSetCode = "CMD";§this.subtype.add("Crab");§this.subtype.add("Beast");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new MorphAbility(this, new ManaCostsImpl("{4}{U}")));§Effect effect = new ExchangeControlTargetEffect(Duration.EndOfGame, rule, false, true);§effect.setText("exchange control of target creature you control and target creature an opponent controls");§Ability ability = new TurnedFaceUpSourceTriggeredAbility(effect, false, true);§ability.addTarget(new TargetControlledCreaturePermanent());§ability.addTarget(new TargetCreaturePermanent(filter));§this.addAbility(ability);§}§public ChromeshellCrab(final ChromeshellCrab card) {§super(card);§}§@Override§public ChromeshellCrab copy() {§return new ChromeshellCrab(this);§}§}§
public class CollectiveVoyage extends CardImpl {§public CollectiveVoyage(UUID ownerId) {§super(ownerId, 147, "Collective Voyage", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{G}");§this.expansionSetCode = "CMD";§this.getSpellAbility().addEffect(new CollectiveVoyageEffect());§}§public CollectiveVoyage(final CollectiveVoyage card) {§super(card);§}§@Override§public CollectiveVoyage copy() {§return new CollectiveVoyage(this);§}§}§class CollectiveVoyageEffect extends OneShotEffect {§public CollectiveVoyageEffect() {§super(Outcome.Detriment);§this.staticText = "<i>Join forces</i> - Starting with you, each player may pay any amount of mana. Each player searches his or her library for up to X basic land cards, where X is the total amount of mana paid this way, puts them onto the battlefield tapped, then shuffles his or her library";§}§public CollectiveVoyageEffect(final CollectiveVoyageEffect effect) {§super(effect);§}§@Override§public CollectiveVoyageEffect copy() {§return new CollectiveVoyageEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§int xSum = 0;§xSum += playerPaysXGenericMana(controller, source, game);§for(UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {§if (playerId != controller.getId()) {§Player player = game.getPlayer(playerId);§if (player != null) {§xSum += playerPaysXGenericMana(player, source, game);§}§}§}§for(UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {§Player player = game.getPlayer(playerId);§if (player != null) {§TargetCardInLibrary target = new TargetCardInLibrary(0, xSum, new FilterBasicLandCard());§if (player.searchLibrary(target, game)) {§for (UUID cardId : target.getTargets()) {§Card card = player.getLibrary().getCard(cardId, game);§if (card != null) {§card.putOntoBattlefield(game, Zone.LIBRARY, source.getSourceId(), player.getId(), true);§}§}§player.shuffleLibrary(game);§}§}§}§controller.resetStoredBookmark(game);§return true;§}§return false;§}§protected static int playerPaysXGenericMana(Player player, Ability source, Game game) {§int xValue = 0;§boolean payed = false;§while (player.canRespond() && !payed) {§xValue = player.announceXMana(0, Integer.MAX_VALUE, "How much mana will you pay?", game, source);§if (xValue > 0) {§Cost cost = new GenericManaCost(xValue);§payed = cost.pay(source, game, source.getSourceId(), player.getId(), false, null);§} else {§payed = true;§}§}§game.informPlayers(new StringBuilder(player.getLogName()).append(" pays {").append(xValue).append("}.").toString());§return xValue;§}§}§
public class CourtHussar extends CardImpl {§public CourtHussar(UUID ownerId) {§super(ownerId, 43, "Court Hussar", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{U}");§this.expansionSetCode = "CMD";§this.subtype.add("Vedalken");§this.subtype.add("Knight");§this.power = new MageInt(1);§this.toughness = new MageInt(3);§this.addAbility(VigilanceAbility.getInstance());§this.addAbility(new EntersBattlefieldTriggeredAbility(§new LookLibraryAndPickControllerEffect(new StaticValue(3), false, new StaticValue(1), new FilterCard(), Zone.LIBRARY, false, false),§false));§this.addAbility(new EntersBattlefieldTriggeredAbility(new SacrificeSourceUnlessConditionEffect(new ManaWasSpentCondition(ColoredManaSymbol.W)), false), new ManaSpentToCastWatcher());§}§public CourtHussar(final CourtHussar card) {§super(card);§}§@Override§public CourtHussar copy() {§return new CourtHussar(this);§}§}§
public class DamiaSageOfStone extends CardImpl {§public DamiaSageOfStone(UUID ownerId) {§super(ownerId, 191, "Damia, Sage of Stone", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{4}{G}{U}{B}");§this.expansionSetCode = "CMD";§this.supertype.add("Legendary");§this.subtype.add("Gorgon");§this.subtype.add("Wizard");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(DeathtouchAbility.getInstance());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new SkipDrawStepEffect()));§this.addAbility(new DamiaSageOfStoneTriggeredAbility());§}§public DamiaSageOfStone(final DamiaSageOfStone card) {§super(card);§}§@Override§public DamiaSageOfStone copy() {§return new DamiaSageOfStone(this);§}§}§class DamiaSageOfStoneTriggeredAbility extends BeginningOfUpkeepTriggeredAbility {§DamiaSageOfStoneTriggeredAbility() {§super(new DrawCardSourceControllerEffect(new IntPlusDynamicValue(7, new MultipliedValue(new CardsInControllerHandCount(), -1))), TargetController.YOU, false);§}§DamiaSageOfStoneTriggeredAbility(final DamiaSageOfStoneTriggeredAbility ability) {§super(ability);§}§@Override§public DamiaSageOfStoneTriggeredAbility copy() {§return new DamiaSageOfStoneTriggeredAbility(this);§}§@Override§public boolean checkInterveningIfClause(Game game) {§Player player = game.getPlayer(this.getControllerId());§if (player != null) {§return player.getHand().size() < 7;§}§return false;§}§@Override§public String getRule() {§return "At the beginning of your upkeep, if you have fewer than seven cards in hand, draw cards equal to the difference";§}§}§
public class DeathByDragons extends CardImpl {§public DeathByDragons(UUID ownerId) {§super(ownerId, 118, "Death by Dragons", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{4}{R}{R}");§this.expansionSetCode = "CMD";§this.getSpellAbility().addEffect(new DeathByDragonsEffect());§this.getSpellAbility().addTarget(new TargetPlayer());§}§public DeathByDragons(final DeathByDragons card) {§super(card);§}§@Override§public DeathByDragons copy() {§return new DeathByDragons(this);§}§}§class DeathByDragonsEffect extends OneShotEffect {§public DeathByDragonsEffect() {§super(Outcome.Detriment);§this.staticText = "Each player other than target player puts a 5/5 red Dragon creature token with flying onto the battlefield";§}§public DeathByDragonsEffect(final DeathByDragonsEffect effect) {§super(effect);§}§@Override§public DeathByDragonsEffect copy() {§return new DeathByDragonsEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§for (UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {§if (!playerId.equals(this.getTargetPointer().getFirst(game, source))) {§Token token = new DragonToken2();§token.putOntoBattlefield(1, game, source.getSourceId(), playerId);§}§}§return true;§}§return false;§}§}§
public class DesecratorHag extends CardImpl {§public DesecratorHag(UUID ownerId) {§super(ownerId, 193, "Desecrator Hag", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{B/G}{B/G}");§this.expansionSetCode = "CMD";§this.subtype.add("Hag");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new EntersBattlefieldTriggeredAbility(new DesecratorHagEffect(), false));§}§public DesecratorHag(final DesecratorHag card) {§super(card);§}§@Override§public DesecratorHag copy() {§return new DesecratorHag(this);§}§}§class DesecratorHagEffect extends OneShotEffect {§int creatureGreatestPower = 0;§Cards cards = new CardsImpl();§TargetCard target = new TargetCard(Zone.GRAVEYARD, new FilterCard());§public DesecratorHagEffect() {§super(Outcome.DrawCard);§this.staticText = "return to your hand the creature card in your graveyard with the greatest power. If two or more cards are tied for greatest power, you choose one of them";§}§public DesecratorHagEffect(final DesecratorHagEffect effect) {§super(effect);§}§@Override§public DesecratorHagEffect copy() {§return new DesecratorHagEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player you = game.getPlayer(source.getControllerId());§if (you != null) {§for (Card card : you.getGraveyard().getCards(game)) {§if (card.getCardType().contains(CardType.CREATURE)) {§if (card.getPower().getValue() > creatureGreatestPower) {§creatureGreatestPower = card.getPower().getValue();§cards.clear();§cards.add(card);§} else {§if (card.getPower().getValue() == creatureGreatestPower) {§cards.add(card);§}§}§}§}§if (cards.size() == 0) {§return true;§}§if (cards.size() > 1§&& you.choose(Outcome.DrawCard, cards, target, game)) {§if (target != null) {§Card card = game.getCard(target.getFirstTarget());§if (card != null) {§return you.moveCards(card, null, Zone.HAND, source, game);§}§}§} else {§return you.moveCards(cards, null, Zone.HAND, source, game);§}§}§return false;§}§}§
public class DreadshipReef extends CardImpl {§public DreadshipReef(UUID ownerId) {§super(ownerId, 271, "Dreadship Reef", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "CMD";§this.addAbility(new ColorlessManaAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new AddCountersSourceEffect(CounterType.STORAGE.createInstance()),new GenericManaCost(1));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,§new AddManaInAnyCombinationEffect(new RemovedCountersForCostValue(), ColoredManaSymbol.U, ColoredManaSymbol.B),§new GenericManaCost(1));§ability.addCost(new RemoveVariableCountersSourceCost(CounterType.STORAGE.createInstance()));§this.addAbility(ability);§}§public DreadshipReef(final DreadshipReef card) {§super(card);§}§@Override§public DreadshipReef copy() {§return new DreadshipReef(this);§}§}§
public class Faultgrinder extends CardImpl {§public Faultgrinder(UUID ownerId) {§super(ownerId, 122, "Faultgrinder", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{6}{R}");§this.expansionSetCode = "CMD";§this.subtype.add("Elemental");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(TrampleAbility.getInstance());§Ability ability = new EntersBattlefieldTriggeredAbility(new DestroyTargetEffect(),false);§Target target = new TargetLandPermanent();§ability.addTarget(target);§this.addAbility(ability);§this.addAbility(new EvokeAbility(this, "{4}{R}"));§}§public Faultgrinder(final Faultgrinder card) {§super(card);§}§@Override§public Faultgrinder copy() {§return new Faultgrinder(this);§}§}§
public class Fertilid extends CardImpl {§public Fertilid(UUID ownerId) {§super(ownerId, 154, "Fertilid", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{G}");§this.expansionSetCode = "CMD";§this.subtype.add("Elemental");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§this.addAbility(new EntersBattlefieldAbility(new AddCountersSourceEffect(CounterType.P1P1.createInstance(2)), "with two +1/+1 counters on it"));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,§new SearchLibraryPutInPlayTargetPlayerEffect(new TargetCardInLibrary(new FilterBasicLandCard()), true, true), new ManaCostsImpl("{1}{G}"));§ability.addCost(new RemoveCountersSourceCost(CounterType.P1P1.createInstance(1)));§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§}§public Fertilid(final Fertilid card) {§super(card);§}§@Override§public Fertilid copy() {§return new Fertilid(this);§}§}§
public class FierceEmpath extends CardImpl {§private static final FilterCreatureCard filter = new FilterCreatureCard("a creature card with converted mana cost 6 or greater");§static {§filter.add(new ConvertedManaCostPredicate(Filter.ComparisonType.GreaterThan, 5));§}§public FierceEmpath(UUID ownerId) {§super(ownerId, 155, "Fierce Empath", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{G}");§this.expansionSetCode = "CMD";§this.subtype.add("Elf");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new EntersBattlefieldTriggeredAbility(new SearchLibraryPutInHandEffect(§new TargetCardInLibrary(filter), true, true), true));§}§public FierceEmpath(final FierceEmpath card) {§super(card);§}§@Override§public FierceEmpath copy() {§return new FierceEmpath(this);§}§}§
public class Flusterstorm extends CardImpl {§private static final FilterSpell filter = new FilterSpell("instant or sorcery spell");§static {§filter.add(Predicates.or(new CardTypePredicate(CardType.INSTANT), new CardTypePredicate(CardType.SORCERY)));§}§public Flusterstorm(UUID ownerId) {§super(ownerId, 46, "Flusterstorm", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{U}");§this.expansionSetCode = "CMD";§this.getSpellAbility().addEffect(new CounterUnlessPaysEffect(new ManaCostsImpl("{1}")));§this.getSpellAbility().addTarget(new TargetSpell(filter));§this.addAbility(new StormAbility());§}§public Flusterstorm(final Flusterstorm card) {§super(card);§}§@Override§public Flusterstorm copy() {§return new Flusterstorm(this);§}§}§
public class FootbottomFeast extends CardImpl {§public FootbottomFeast(UUID ownerId) {§super(ownerId, 84, "Footbottom Feast", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{B}");§this.expansionSetCode = "CMD";§this.getSpellAbility().addEffect(new PutOnLibraryTargetEffect(true));§this.getSpellAbility().addTarget(new TargetCardInYourGraveyard(0, Integer.MAX_VALUE, new FilterCreatureCard("creature cards from your graveyard")));§this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(1));§}§public FootbottomFeast(final FootbottomFeast card) {§super(card);§}§@Override§public FootbottomFeast copy() {§return new FootbottomFeast(this);§}§}§
public class FungalReaches extends CardImpl {§public FungalReaches(UUID ownerId) {§super(ownerId, 274, "Fungal Reaches", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "CMD";§this.addAbility(new ColorlessManaAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new AddCountersSourceEffect(CounterType.STORAGE.createInstance()),new GenericManaCost(1));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,§new AddManaInAnyCombinationEffect(new RemovedCountersForCostValue(), ColoredManaSymbol.R, ColoredManaSymbol.G),§new GenericManaCost(1));§ability.addCost(new RemoveVariableCountersSourceCost(CounterType.STORAGE.createInstance()));§this.addAbility(ability);§}§public FungalReaches(final FungalReaches card) {§super(card);§}§@Override§public FungalReaches copy() {§return new FungalReaches(this);§}§}§
public class GhaveGuruOfSpores extends CardImpl {§final static FilterControlledPermanent filter = new FilterControlledPermanent("creature to sacrifice");§static {§filter.add(new CardTypePredicate(CardType.CREATURE));§}§public GhaveGuruOfSpores(UUID ownerId) {§super(ownerId, 200, "Ghave, Guru of Spores", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{2}{B}{G}{W}");§this.expansionSetCode = "CMD";§this.supertype.add("Legendary");§this.subtype.add("Fungus");§this.subtype.add("Shaman");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§this.addAbility(new EntersBattlefieldAbility(new AddCountersSourceEffect(CounterType.P1P1.createInstance(5))));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new CreateTokenEffect(new SaprolingToken()), new GenericManaCost(1));§ability.addCost(new RemoveCounterCost(new TargetControlledCreaturePermanent(1, 1, new FilterControlledCreaturePermanent(), true), CounterType.P1P1));§this.addAbility(ability);§Ability ability2 = new SimpleActivatedAbility(Zone.BATTLEFIELD, new AddCountersTargetEffect(CounterType.P1P1.createInstance()), new GenericManaCost(1));§ability2.addCost(new SacrificeTargetCost(new TargetControlledPermanent(filter)));§ability2.addTarget(new TargetCreaturePermanent());§this.addAbility(ability2);§}§public GhaveGuruOfSpores(final GhaveGuruOfSpores card) {§super(card);§}§@Override§public GhaveGuruOfSpores copy() {§return new GhaveGuruOfSpores(this);§}§}§
public class GwyllionHedgeMage extends CardImpl {§private static final FilterLandPermanent filter = new FilterLandPermanent("Plains");§private static final FilterLandPermanent filter2 = new FilterLandPermanent("Swamps");§static {§filter.add(new SubtypePredicate("Plains"));§filter2.add(new SubtypePredicate("Swamp"));§}§private final String rule1 = "When {this} enters the battlefield, if you control two or more Plains, you may put a 1/1 white Kithkin Soldier creature token onto the battlefield.";§private final String rule2 = "When {this} enters the battlefield, if you control two or more Swamps, you may put a -1/-1 counter on target creature.";§public GwyllionHedgeMage(UUID ownerId) {§super(ownerId, 202, "Gwyllion Hedge-Mage", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{W/B}");§this.expansionSetCode = "CMD";§this.subtype.add("Hag");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new ConditionalTriggeredAbility(new EntersBattlefieldTriggeredAbility(new CreateTokenEffect(new KithkinToken()), true), new PermanentsOnTheBattlefieldCondition(filter, CountType.MORE_THAN, 1), rule1);§this.addAbility(ability);§Ability ability2 = new ConditionalTriggeredAbility(§new EntersBattlefieldTriggeredAbility(new AddCountersTargetEffect(CounterType.M1M1.createInstance()), true),§new PermanentsOnTheBattlefieldCondition(filter2, CountType.MORE_THAN, 1),§rule2);§ability2.addTarget(new TargetCreaturePermanent());§this.addAbility(ability2);§}§public GwyllionHedgeMage(final GwyllionHedgeMage card) {§super(card);§}§@Override§public GwyllionHedgeMage copy() {§return new GwyllionHedgeMage(this);§}§}§
public class HornetQueen extends CardImpl {§public HornetQueen(UUID ownerId) {§super(ownerId, 159, "Hornet Queen", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{G}{G}{G}");§this.expansionSetCode = "CMD";§this.subtype.add("Insect");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(DeathtouchAbility.getInstance());§this.addAbility(new EntersBattlefieldTriggeredAbility(new CreateTokenEffect(new HornetQueenInsectToken(), 4), false));§}§public HornetQueen(final HornetQueen card) {§super(card);§}§@Override§public HornetQueen copy() {§return new HornetQueen(this);§}§}§class HornetQueenInsectToken extends Token {§public HornetQueenInsectToken() {§super("Insect", "1/1 green Insect creature token with flying and deathtouch");§setOriginalExpansionSetCode("M15");§cardType.add(CardType.CREATURE);§color.setGreen(true);§subtype.add("Insect");§power = new MageInt(1);§toughness = new MageInt(1);§addAbility(FlyingAbility.getInstance());§addAbility(DeathtouchAbility.getInstance());§}§}§
public class HydraOmnivore extends CardImpl {§public HydraOmnivore(UUID ownerId) {§super(ownerId, 161, "Hydra Omnivore", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{G}{G}");§this.expansionSetCode = "CMD";§this.subtype.add("Hydra");§this.power = new MageInt(8);§this.toughness = new MageInt(8);§this.addAbility(new DealsDamageToOpponentTriggeredAbility(new HydraOmnivoreEffect(), false, true, true));§}§public HydraOmnivore(final HydraOmnivore card) {§super(card);§}§@Override§public HydraOmnivore copy() {§return new HydraOmnivore(this);§}§}§class HydraOmnivoreEffect extends OneShotEffect {§public HydraOmnivoreEffect() {§super(Outcome.Benefit);§this.staticText = "it deals that much damage to each other opponent";§}§public HydraOmnivoreEffect(final HydraOmnivoreEffect effect) {§super(effect);§}§@Override§public HydraOmnivoreEffect copy() {§return new HydraOmnivoreEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§UUID damagedOpponent = this.getTargetPointer().getFirst(game, source);§int amount = (Integer) getValue("damage");§MageObject object = game.getObject(source.getSourceId());§if (object != null && amount > 0 && damagedOpponent != null) {§for (UUID playerId :game.getOpponents(source.getControllerId())) {§if (playerId != damagedOpponent) {§Player opponent = game.getPlayer(playerId);§if (opponent != null) {§int dealtDamage = opponent.damage(amount, source.getSourceId(), game, false, true);§game.informPlayers(object.getLogName() + " deals " + dealtDamage + " damage to " + opponent.getLogName());§}§}§}§return true;§}§return false;§}§}§
public class Invigorate extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("If you control a Forest");§static {§filter.add(new SubtypePredicate("Forest"));§}§public Invigorate(UUID ownerId) {§super(ownerId, 162, "Invigorate", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{G}");§this.expansionSetCode = "CMD";§this.addAbility(new AlternativeCostSourceAbility(new GainLifeOpponentCost(3), new PermanentsOnTheBattlefieldCondition(filter)));§this.getSpellAbility().addEffect(new BoostTargetEffect(4,4,Duration.EndOfTurn));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public Invigorate(final Invigorate card) {§super(card);§}§@Override§public Invigorate copy() {§return new Invigorate(this);§}§}§
public class KaaliaOfTheVast extends CardImpl {§public KaaliaOfTheVast(UUID ownerId) {§super(ownerId, 206, "Kaalia of the Vast", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{1}{W}{B}{R}");§this.expansionSetCode = "CMD";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Cleric");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new KaaliaOfTheVastAttacksAbility());§}§public KaaliaOfTheVast(final KaaliaOfTheVast card) {§super(card);§}§@Override§public KaaliaOfTheVast copy() {§return new KaaliaOfTheVast(this);§}§}§class KaaliaOfTheVastAttacksAbility extends TriggeredAbilityImpl {§public KaaliaOfTheVastAttacksAbility() {§super(Zone.BATTLEFIELD, new KaaliaOfTheVastEffect(), false);§}§public KaaliaOfTheVastAttacksAbility(final KaaliaOfTheVastAttacksAbility ability) {§super(ability);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.ATTACKER_DECLARED;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (event.getSourceId().equals(this.getSourceId())) {§Player opponent = game.getPlayer(event.getTargetId());§if (opponent != null) {§return true;§}§}§return false;§}§@Override§public String getRule() {§return "Whenever {this} attacks an opponent, you may put an Angel, Demon, or Dragon creature card from your hand onto the battlefield tapped and attacking that opponent.";§}§@Override§public KaaliaOfTheVastAttacksAbility copy() {§return new KaaliaOfTheVastAttacksAbility(this);§}§}§class KaaliaOfTheVastEffect extends OneShotEffect {§private static final FilterCreatureCard filter = new FilterCreatureCard("an Angel, Demon, or Dragon creature card");§static {§filter.add(Predicates.or(§new SubtypePredicate("Angel"),§new SubtypePredicate("Demon"),§new SubtypePredicate("Dragon")));§}§public KaaliaOfTheVastEffect() {§super(Outcome.PutCreatureInPlay);§this.staticText = "put an Angel, Demon, or Dragon creature card from your hand onto the battlefield tapped and attacking that opponent.";§}§public KaaliaOfTheVastEffect(final KaaliaOfTheVastEffect effect) {§super(effect);§}§@Override§public KaaliaOfTheVastEffect copy() {§return new KaaliaOfTheVastEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller == null || !controller.chooseUse(Outcome.PutCreatureInPlay, "Put an Angel, Demon, or Dragon creature card from your hand onto the battlefield tapped and attacking?", source, game)) {§return false;§}§TargetCardInHand target = new TargetCardInHand(filter);§if (target.canChoose(controller.getId(), game) && target.choose(getOutcome(), controller.getId(), source.getSourceId(), game)) {§if (target.getTargets().size() > 0) {§UUID cardId = target.getFirstTarget();§Card card = game.getCard(cardId);§if (card != null && game.getCombat() != null) {§UUID defenderId = game.getCombat().getDefendingPlayerId(source.getSourceId(), game);§if (defenderId != null) {§controller.moveCards(card, Zone.BATTLEFIELD, source, game, true, false, false, null);§Permanent creature = game.getPermanent(cardId);§if (creature != null) {§game.getCombat().addAttackerToCombat(card.getId(), defenderId, game);§return true;§}§}§}§}§}§return false;§}§}§
public class KaradorGhostChieftain extends CardImpl {§public KaradorGhostChieftain(UUID ownerId) {§super(ownerId, 207, "Karador, Ghost Chieftain", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{5}{B}{G}{W}");§this.expansionSetCode = "CMD";§this.supertype.add("Legendary");§this.subtype.add("Centaur");§this.subtype.add("Spirit");§this.power = new MageInt(3);§this.toughness = new MageInt(4);§this.addAbility(new SimpleStaticAbility(Zone.STACK, new KaradorGhostChieftainCostReductionEffect()));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new KaradorGhostChieftainContinuousEffect()), new KaradorGhostChieftainWatcher());§}§public KaradorGhostChieftain(final KaradorGhostChieftain card) {§super(card);§}§@Override§public KaradorGhostChieftain copy() {§return new KaradorGhostChieftain(this);§}§}§class KaradorGhostChieftainCostReductionEffect extends CostModificationEffectImpl {§KaradorGhostChieftainCostReductionEffect() {§super(Duration.WhileOnStack, Outcome.Benefit, CostModificationType.REDUCE_COST);§staticText = "{this} costs {1} less to cast for each creature card in your graveyard";§}§KaradorGhostChieftainCostReductionEffect(KaradorGhostChieftainCostReductionEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source, Ability abilityToModify) {§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§int reductionAmount = player.getGraveyard().count(new FilterCreatureCard(), game);§CardUtil.reduceCost(abilityToModify, reductionAmount);§return true;§}§return false;§}§@Override§public boolean applies(Ability abilityToModify, Ability source, Game game) {§if ((abilityToModify instanceof SpellAbility) && abilityToModify.getSourceId().equals(source.getSourceId())) {§return game.getCard(abilityToModify.getSourceId()) != null;§}§return false;§}§@Override§public KaradorGhostChieftainCostReductionEffect copy() {§return new KaradorGhostChieftainCostReductionEffect(this);§}§}§class KaradorGhostChieftainContinuousEffect extends ContinuousEffectImpl {§KaradorGhostChieftainContinuousEffect() {§super(Duration.WhileOnBattlefield, Layer.PlayerEffects, SubLayer.NA, Outcome.Benefit);§staticText = "During each of your turns, you may cast one creature card from your graveyard";§}§KaradorGhostChieftainContinuousEffect(final KaradorGhostChieftainContinuousEffect effect) {§super(effect);§}§@Override§public KaradorGhostChieftainContinuousEffect copy() {§return new KaradorGhostChieftainContinuousEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§for (Card card : player.getGraveyard().getCards(new FilterCreatureCard(), game)) {§ContinuousEffect effect = new KaradorGhostChieftainCastFromGraveyardEffect();§effect.setTargetPointer(new FixedTarget(card.getId()));§game.addEffect(effect, source);§}§return true;§}§return false;§}§}§class KaradorGhostChieftainCastFromGraveyardEffect extends AsThoughEffectImpl {§KaradorGhostChieftainCastFromGraveyardEffect() {§super(AsThoughEffectType.PLAY_FROM_NOT_OWN_HAND_ZONE, Duration.EndOfTurn, Outcome.Benefit);§staticText = "You may cast one creature card from your graveyard";§}§KaradorGhostChieftainCastFromGraveyardEffect(final KaradorGhostChieftainCastFromGraveyardEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public KaradorGhostChieftainCastFromGraveyardEffect copy() {§return new KaradorGhostChieftainCastFromGraveyardEffect(this);§}§@Override§public boolean applies(UUID objectId, Ability source, UUID affectedControllerId, Game game) {§if (objectId.equals(getTargetPointer().getFirst(game, source))) {§if (affectedControllerId.equals(source.getControllerId())) {§KaradorGhostChieftainWatcher watcher = (KaradorGhostChieftainWatcher) game.getState().getWatchers().get("KaradorGhostChieftainWatcher", source.getSourceId());§return !watcher.isAbilityUsed();§}§}§return false;§}§}§class KaradorGhostChieftainWatcher extends Watcher {§boolean abilityUsed = false;§KaradorGhostChieftainWatcher() {§super("KaradorGhostChieftainWatcher", WatcherScope.CARD);§}§KaradorGhostChieftainWatcher(final KaradorGhostChieftainWatcher watcher) {§super(watcher);§this.abilityUsed = watcher.abilityUsed;§}§@Override§public void watch(GameEvent event, Game game) {§if (event.getType() == GameEvent.EventType.SPELL_CAST && event.getZone() == Zone.GRAVEYARD) {§Spell spell = (Spell) game.getObject(event.getTargetId());§if (spell.getCardType().contains(CardType.CREATURE)) {§abilityUsed = true;§}§}§}§@Override§public KaradorGhostChieftainWatcher copy() {§return new KaradorGhostChieftainWatcher(this);§}§@Override§public void reset() {§super.reset();§abilityUsed = false;§}§public boolean isAbilityUsed() {§return abilityUsed;§}§}§
public class KodamasReach extends CardImpl {§public KodamasReach(UUID ownerId) {§super(ownerId, 163, "Kodama's Reach", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{2}{G}");§this.expansionSetCode = "CMD";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new KodamasReachEffect());§}§public KodamasReach(final KodamasReach card) {§super(card);§}§@Override§public KodamasReach copy() {§return new KodamasReach(this);§}§}§class KodamasReachEffect extends OneShotEffect {§protected static final FilterCard filter = new FilterCard("card to put on the battlefield tapped");§public KodamasReachEffect() {§super(Outcome.PutLandInPlay);§staticText = "Search your library for up to two basic land cards, reveal those cards, and put one onto the battlefield tapped and the other into your hand. Then shuffle your library";§}§public KodamasReachEffect(final KodamasReachEffect effect) {§super(effect);§}§@Override§public KodamasReachEffect copy() {§return new KodamasReachEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§MageObject sourceObject = game.getObject(source.getSourceId());§if (controller == null || sourceObject == null) {§return false;§}§TargetCardInLibrary target = new TargetCardInLibrary(0, 2, new FilterBasicLandCard());§if (controller.searchLibrary(target, game)) {§if (target.getTargets().size() > 0) {§Cards revealed = new CardsImpl();§for (UUID cardId : target.getTargets()) {§Card card = controller.getLibrary().getCard(cardId, game);§revealed.add(card);§}§controller.revealCards(sourceObject.getIdName(), revealed, game);§if (target.getTargets().size() == 2) {§TargetCard target2 = new TargetCard(Zone.LIBRARY, filter);§controller.choose(Outcome.Benefit, revealed, target2, game);§Card card = revealed.get(target2.getFirstTarget(), game);§if (card != null) {§controller.moveCards(card, Zone.BATTLEFIELD, source, game, true, false, false, null);§revealed.remove(card);§}§card = revealed.getCards(game).iterator().next();§if (card != null) {§controller.moveCards(card, Zone.HAND, source, game);§}§} else if (target.getTargets().size() == 1) {§Card card = revealed.getCards(game).iterator().next();§if (card != null) {§controller.moveCards(card, Zone.BATTLEFIELD, source, game, true, false, false, null);§}§}§}§controller.shuffleLibrary(game);§return true;§}§controller.shuffleLibrary(game);§return false;§}§}§
public class LashOut extends CardImpl {§public LashOut(UUID ownerId) {§super(ownerId, 127, "Lash Out", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{R}");§this.expansionSetCode = "CMD";§this.getSpellAbility().addEffect(new LashOutEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public LashOut(final LashOut card) {§super(card);§}§@Override§public LashOut copy() {§return new LashOut(this);§}§}§class LashOutEffect extends OneShotEffect {§public LashOutEffect() {§super(Outcome.Damage);§this.staticText = "Lash Out deals 3 damage to target creature. Clash with an opponent. If you win, Lash Out deals 3 damage to that creature's controller";§}§public LashOutEffect(final LashOutEffect effect) {§super(effect);§}§@Override§public LashOutEffect copy() {§return new LashOutEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§Permanent creature = game.getPermanent(getTargetPointer().getFirst(game, source));§if (controller != null && creature != null) {§creature.damage(3, source.getSourceId(), game, false, true);§if (ClashEffect.getInstance().apply(game, source)) {§Player creaturesController = game.getPlayer(creature.getControllerId());§if (creaturesController != null) {§creaturesController.damage(3, source.getSourceId(), game, false, true);§}§}§return true;§}§return false;§}§}§
public class MagmaticForce extends CardImpl {§public MagmaticForce(UUID ownerId) {§super(ownerId, 128, "Magmatic Force", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}{R}{R}{R}");§this.expansionSetCode = "CMD";§this.subtype.add("Elemental");§this.power = new MageInt(7);§this.toughness = new MageInt(7);§Ability ability = new BeginningOfUpkeepTriggeredAbility(Zone.BATTLEFIELD, new DamageTargetEffect(3), TargetController.ANY, false);§ability.addTarget(new TargetCreatureOrPlayer());§this.addAbility(ability);§}§public MagmaticForce(final MagmaticForce card) {§super(card);§}§@Override§public MagmaticForce copy() {§return new MagmaticForce(this);§}§}§
public class MagusOfTheVineyard extends CardImpl {§public MagusOfTheVineyard(UUID ownerId) {§super(ownerId, 166, "Magus of the Vineyard", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{G}");§this.expansionSetCode = "CMD";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new BeginningOfPreCombatMainTriggeredAbility(§Zone.BATTLEFIELD, new AddManaToManaPoolTargetControllerEffect(Mana.GreenMana(2), "that player's"), TargetController.ANY, false, true));§}§public MagusOfTheVineyard(final MagusOfTheVineyard card) {§super(card);§}§@Override§public MagusOfTheVineyard copy() {§return new MagusOfTheVineyard(this);§}§}§
public class ManaChargedDragon extends CardImpl {§public ManaChargedDragon(UUID ownerId) {§super(ownerId, 129, "Mana-Charged Dragon", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{R}{R}");§this.expansionSetCode = "CMD";§this.subtype.add("Dragon");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(TrampleAbility.getInstance());§this.addAbility(new ManaChargedDragonTriggeredAbility());§}§public ManaChargedDragon(final ManaChargedDragon card) {§super(card);§}§@Override§public ManaChargedDragon copy() {§return new ManaChargedDragon(this);§}§}§class ManaChargedDragonTriggeredAbility extends AttacksOrBlocksTriggeredAbility {§ManaChargedDragonTriggeredAbility() {§super(new ManaChargedDragonEffect(), false);§}§@Override§public String getRule() {§return "Join forces &mdash; Whenever {this} attacks or blocks, each player starting with you may pay any amount of mana. {this} gets +X/+0 until end of turn, where X is the total amount of mana paid this way";§}§}§class ManaChargedDragonEffect extends OneShotEffect {§protected static int playerPaysXGenericMana(Player player, Ability source, Game game) {§int xValue = 0;§boolean payed = false;§while (player.canRespond() && !payed) {§xValue = player.announceXMana(0, Integer.MAX_VALUE, "How much mana will you pay?", game, source);§if (xValue > 0) {§Cost cost = new GenericManaCost(xValue);§payed = cost.pay(source, game, source.getSourceId(), player.getId(), false, null);§} else {§payed = true;§}§}§game.informPlayers(new StringBuilder(player.getLogName()).append(" pays {").append(xValue).append("}.").toString());§return xValue;§}§ManaChargedDragonEffect() {§super(Outcome.BoostCreature);§this.staticText = "each player starting with you may pay any amount of mana. {this} gets +X/+0 until end of turn, where X is the total amount of mana paid this way";§}§ManaChargedDragonEffect(final ManaChargedDragonEffect effect) {§super(effect);§}§@Override§public ManaChargedDragonEffect copy() {§return new ManaChargedDragonEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§int xSum = 0;§xSum += playerPaysXGenericMana(controller, source, game);§for (UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {§if (playerId != controller.getId()) {§Player player = game.getPlayer(playerId);§if (player != null) {§xSum += playerPaysXGenericMana(player, source, game);§}§}§}§ContinuousEffect effect = new BoostSourceEffect(xSum, 0, Duration.EndOfTurn);§game.addEffect(effect, source);§controller.resetStoredBookmark(game);§return true;§}§return false;§}§}§
public class NinThePainArtist extends CardImpl {§public NinThePainArtist(UUID ownerId) {§super(ownerId, 213, "Nin, the Pain Artist", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{U}{R}");§this.expansionSetCode = "CMD";§this.supertype.add("Legendary");§this.subtype.add("Vedalken");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new NinThePainArtistEffect(), new ManaCostsImpl<>("{X}{U}{R}"));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public NinThePainArtist(final NinThePainArtist card) {§super(card);§}§@Override§public NinThePainArtist copy() {§return new NinThePainArtist(this);§}§}§class NinThePainArtistEffect extends OneShotEffect {§NinThePainArtistEffect() {§super(Outcome.Damage);§this.staticText = "{this} deals X damage to target creature. That creature's controller draws X cards.";§}§NinThePainArtistEffect(final NinThePainArtistEffect effect) {§super(effect);§}§@Override§public NinThePainArtistEffect copy() {§return new NinThePainArtistEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getPermanent(this.getTargetPointer().getFirst(game, source));§if (permanent != null) {§permanent.damage(source.getManaCostsToPay().getX(), source.getSourceId(), game, false, true);§Player player = game.getPlayer(permanent.getControllerId());§if (player != null) {§player.drawCards(source.getManaCostsToPay().getX(), game);§}§return true;§}§return false;§}§}§
public class NumotTheDevastator extends CardImpl {§public NumotTheDevastator(UUID ownerId) {§super(ownerId, 215, "Numot, the Devastator", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{R}{W}{U}");§this.expansionSetCode = "CMD";§this.supertype.add("Legendary");§this.subtype.add("Dragon");§this.power = new MageInt(6);§this.toughness = new MageInt(6);§this.addAbility(FlyingAbility.getInstance());§OneShotEffect effect = new DestroyTargetEffect();§effect.setText("destroy up to two target lands");§Ability ability = new DealsCombatDamageToAPlayerTriggeredAbility(§new DoIfCostPaid(effect, new ManaCostsImpl("{2}{R}")), false);§ability.addTarget(new TargetLandPermanent(0,2, new FilterLandPermanent("lands"), false));§this.addAbility(ability);§}§public NumotTheDevastator(final NumotTheDevastator card) {§super(card);§}§@Override§public NumotTheDevastator copy() {§return new NumotTheDevastator(this);§}§}§
public class OrosTheAvenger extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("nonwhite creature");§static {§filter.add(Predicates.not(new ColorPredicate(ObjectColor.WHITE)));§}§public OrosTheAvenger(UUID ownerId) {§super(ownerId, 216, "Oros, the Avenger", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{W}{B}{R}");§this.expansionSetCode = "CMD";§this.supertype.add("Legendary");§this.subtype.add("Dragon");§this.power = new MageInt(6);§this.toughness = new MageInt(6);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new DealsCombatDamageToAPlayerTriggeredAbility(§new DoIfCostPaid(new DamageAllEffect(3, filter), new ManaCostsImpl("{2}{W}")), false));§}§public OrosTheAvenger(final OrosTheAvenger card) {§super(card);§}§@Override§public OrosTheAvenger copy() {§return new OrosTheAvenger(this);§}§}§
public class PerilousResearch extends CardImpl {§public PerilousResearch(UUID ownerId) {§super(ownerId, 54, "Perilous Research", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{1}{U}");§this.expansionSetCode = "CMD";§this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(2));§this.getSpellAbility().addEffect(new PerilousResearchEffect());§}§public PerilousResearch(final PerilousResearch card) {§super(card);§}§@Override§public PerilousResearch copy() {§return new PerilousResearch(this);§}§}§class PerilousResearchEffect extends OneShotEffect {§public PerilousResearchEffect() {§super(Outcome.Sacrifice);§this.staticText = "then sacrifice a permanent";§}§public PerilousResearchEffect(final PerilousResearchEffect effect) {§super(effect);§}§@Override§public PerilousResearchEffect copy() {§return new PerilousResearchEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§Target target = new TargetControlledPermanent();§if (target.canChoose(player.getId(), game) && player.choose(Outcome.Sacrifice, target, source.getSourceId(), game)) {§Permanent permanent = game.getPermanent(target.getFirstTarget());§if (permanent != null) {§return permanent.sacrifice(source.getSourceId(), game);§}§}§}§return false;§}§}§
public class PollenLullaby extends CardImpl {§public PollenLullaby(UUID ownerId) {§super(ownerId, 26, "Pollen Lullaby", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{1}{W}");§this.expansionSetCode = "CMD";§this.getSpellAbility().addEffect(new PreventAllDamageByAllEffect(Duration.EndOfTurn, true));§this.getSpellAbility().addEffect(new DoIfClashWonEffect(new PollenLullabyEffect(), true, null));§}§public PollenLullaby(final PollenLullaby card) {§super(card);§}§@Override§public PollenLullaby copy() {§return new PollenLullaby(this);§}§}§class PollenLullabyEffect extends OneShotEffect {§public PollenLullabyEffect() {§super(Outcome.Tap);§staticText = "creatures that player controls don't untap during the player's next untap step";§}§public PollenLullabyEffect(final PollenLullabyEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(getTargetPointer().getFirst(game, source));§if (player != null) {§for (Permanent creature: game.getBattlefield().getAllActivePermanents(new FilterCreaturePermanent(), player.getId(), game)) {§creature.tap(game);§ContinuousEffect effect = new DontUntapInControllersNextUntapStepTargetEffect("This creature");§effect.setTargetPointer(new FixedTarget(creature.getId()));§game.addEffect(effect, source);§}§return true;§}§return false;§}§@Override§public PollenLullabyEffect copy() {§return new PollenLullabyEffect(this);§}§}§
public class PropheticBolt extends CardImpl {§public PropheticBolt(UUID ownerId) {§super(ownerId, 219, "Prophetic Bolt", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{3}{U}{R}");§this.expansionSetCode = "CMD";§this.getSpellAbility().addEffect(new DamageTargetEffect(4));§this.getSpellAbility().addTarget(new TargetCreatureOrPlayer());§this.getSpellAbility().addEffect(new LookLibraryAndPickControllerEffect(new StaticValue(4), false, new StaticValue(1), new FilterCard(), Zone.LIBRARY, false, false));§}§public PropheticBolt(final PropheticBolt card) {§super(card);§}§@Override§public PropheticBolt copy() {§return new PropheticBolt(this);§}§}§
public class ReturnToDust extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("artifact or enchantment");§static {§filter.add(Predicates.or(new CardTypePredicate(CardType.ARTIFACT),§new CardTypePredicate(CardType.ENCHANTMENT)));§}§public ReturnToDust(UUID ownerId) {§super(ownerId, 28, "Return to Dust", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{2}{W}{W}");§this.expansionSetCode = "CMD";§Effect effect = new ExileTargetEffect();§effect.setText("Exile target artifact or enchantment. If you cast this spell during your main phase, you may exile up to one other target artifact or enchantment");§this.getSpellAbility().addEffect(effect);§}§public ReturnToDust(final ReturnToDust card) {§super(card);§}§@Override§public void adjustTargets(Ability ability, Game game) {§if (ability instanceof SpellAbility) {§if (game.getActivePlayerId().equals(ability.getControllerId()) && game.isMainPhase()) {§ability.addTarget(new TargetPermanent(1, 2, filter, false));§}§else {§ability.addTarget(new TargetPermanent(filter));§}§}§}§@Override§public ReturnToDust copy() {§return new ReturnToDust(this);§}§}§
public class RighteousCause extends CardImpl {§public RighteousCause(UUID ownerId) {§super(ownerId, 29, "Righteous Cause", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{3}{W}{W}");§this.expansionSetCode = "CMD";§this.addAbility(new AttacksAllTriggeredAbility(new GainLifeEffect(1), false));§}§public RighteousCause(final RighteousCause card) {§super(card);§}§@Override§public RighteousCause copy() {§return new RighteousCause(this);§}§}§
public class RikuOfTwoReflections extends CardImpl {§private static final FilterSpell filter = new FilterSpell("an instant or sorcery spell");§private static final FilterControlledCreaturePermanent filterPermanent = new FilterControlledCreaturePermanent("another nontoken creature");§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.INSTANT),§new CardTypePredicate(CardType.SORCERY)));§filterPermanent.add(Predicates.not(new TokenPredicate()));§filterPermanent.add(new AnotherPredicate());§}§public RikuOfTwoReflections(UUID ownerId) {§super(ownerId, 220, "Riku of Two Reflections", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{2}{U}{R}{G}");§this.expansionSetCode = "CMD";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new SpellCastControllerTriggeredAbility(new DoIfCostPaid(new RikuOfTwoReflectionsCopyEffect(), new ManaCostsImpl("{U}{R}")), filter, false, true));§Effect effect = new DoIfCostPaid(new PutTokenOntoBattlefieldCopyTargetEffect(),§new ManaCostsImpl("{G}{U}"), "Put a token that's a copy of that creature onto the battlefield?");§effect.setText("you may pay {G}{U}. If you do, put a token that's a copy of that creature onto the battlefield");§this.addAbility(new EntersBattlefieldControlledTriggeredAbility(Zone.BATTLEFIELD, effect, filterPermanent, false, SetTargetPointer.PERMANENT, null));§}§public RikuOfTwoReflections(final RikuOfTwoReflections card) {§super(card);§}§@Override§public RikuOfTwoReflections copy() {§return new RikuOfTwoReflections(this);§}§}§class RikuOfTwoReflectionsCopyEffect extends OneShotEffect {§public RikuOfTwoReflectionsCopyEffect() {§super(Outcome.Copy);§staticText = "copy that spell. You may choose new targets for the copy";§}§public RikuOfTwoReflectionsCopyEffect(final RikuOfTwoReflectionsCopyEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Spell spell = game.getStack().getSpell(targetPointer.getFirst(game, source));§if (spell != null) {§Spell copy = spell.copySpell();§copy.setControllerId(source.getControllerId());§copy.setCopiedSpell(true);§game.getStack().push(copy);§copy.chooseNewTargets(game, source.getControllerId());§Player player = game.getPlayer(source.getControllerId());§String activateMessage = copy.getActivatedMessage(game);§if (activateMessage.startsWith(" casts ")) {§activateMessage = activateMessage.substring(6);§}§game.informPlayers(player.getLogName() + " copies " + activateMessage);§return true;§}§return false;§}§@Override§public RikuOfTwoReflectionsCopyEffect copy() {§return new RikuOfTwoReflectionsCopyEffect(this);§}§}§
public class RuhanOfTheFomori extends CardImpl {§public RuhanOfTheFomori(UUID ownerId) {§super(ownerId, 221, "Ruhan of the Fomori", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{1}{R}{W}{U}");§this.expansionSetCode = "CMD";§this.supertype.add("Legendary");§this.subtype.add("Giant");§this.subtype.add("Warrior");§this.power = new MageInt(7);§this.toughness = new MageInt(7);§this.addAbility(new BeginningOfCombatTriggeredAbility(new RuhanOfTheFomoriEffect(), TargetController.YOU, false));§}§public RuhanOfTheFomori(final RuhanOfTheFomori card) {§super(card);§}§@Override§public RuhanOfTheFomori copy() {§return new RuhanOfTheFomori(this);§}§}§class RuhanOfTheFomoriEffect extends OneShotEffect {§public RuhanOfTheFomoriEffect() {§super(Outcome.Benefit);§this.staticText = "choose an opponent at random. {this} attacks that player this combat if able";§}§public RuhanOfTheFomoriEffect(final RuhanOfTheFomoriEffect effect) {§super(effect);§}§@Override§public RuhanOfTheFomoriEffect copy() {§return new RuhanOfTheFomoriEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Random random = new Random();§List<UUID> opponents = new ArrayList<>();§opponents.addAll(game.getOpponents(controller.getId()));§Player opponent = game.getPlayer(opponents.get(random.nextInt(opponents.size())));§if (opponent != null) {§ContinuousEffect effect = new AttacksIfAbleTargetPlayerSourceEffect();§effect.setTargetPointer(new FixedTarget(opponent.getId()));§game.addEffect(effect, source);§return true;§}§}§return false;§}§}§class AttacksIfAbleTargetPlayerSourceEffect extends RequirementEffect {§public AttacksIfAbleTargetPlayerSourceEffect() {§super(Duration.EndOfTurn);§staticText = "{this} attacks that player this combat if able";§}§public AttacksIfAbleTargetPlayerSourceEffect(final AttacksIfAbleTargetPlayerSourceEffect effect) {§super(effect);§}§@Override§public AttacksIfAbleTargetPlayerSourceEffect copy() {§return new AttacksIfAbleTargetPlayerSourceEffect(this);§}§@Override§public boolean applies(Permanent permanent, Ability source, Game game) {§if (permanent.getId().equals(source.getSourceId())) {§return true;§}§return false;§}§@Override§public boolean mustAttack(Game game) {§return true;§}§@Override§public boolean mustBlock(Game game) {§return false;§}§@Override§public UUID mustAttackDefender(Ability source, Game game) {§return getTargetPointer().getFirst(game, source);§}§}§
public class ScatteringStroke extends CardImpl {§public ScatteringStroke(UUID ownerId) {§super(ownerId, 60, "Scattering Stroke", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{2}{U}{U}");§this.expansionSetCode = "CMD";§this.getSpellAbility().addEffect(new ScatteringStrokeEffect());§this.getSpellAbility().addTarget(new TargetSpell());§}§public ScatteringStroke(final ScatteringStroke card) {§super(card);§}§@Override§public ScatteringStroke copy() {§return new ScatteringStroke(this);§}§}§class ScatteringStrokeEffect extends OneShotEffect {§public ScatteringStrokeEffect() {§super(Outcome.Benefit);§this.staticText = "Counter target spell. Clash with an opponent. If you win, at the beginning of your next main phase, you may add {X} to your mana pool, where X is that spell's converted mana cost";§}§public ScatteringStrokeEffect(final ScatteringStrokeEffect effect) {§super(effect);§}§@Override§public ScatteringStrokeEffect copy() {§return new ScatteringStrokeEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Spell spell = (Spell) game.getStack().getStackObject(getTargetPointer().getFirst(game, source));§Player controller = game.getPlayer(source.getControllerId());§if (controller != null && spell != null) {§game.getStack().counter(spell.getId(), source.getSourceId(), game);§if (ClashEffect.getInstance().apply(game, source)) {§Effect effect = new AddManaToManaPoolSourceControllerEffect(new Mana(0, 0, 0, 0, 0, 0, 0, spell.getConvertedManaCost()));§AtTheBeginOfMainPhaseDelayedTriggeredAbility delayedAbility§= new AtTheBeginOfMainPhaseDelayedTriggeredAbility(effect, true, TargetController.YOU, AtTheBeginOfMainPhaseDelayedTriggeredAbility.PhaseSelection.NEXT_MAIN);§game.addDelayedTriggeredAbility(delayedAbility, source);§}§return true;§}§return false;§}§}§
public class ScavengingOoze extends CardImpl {§public ScavengingOoze(UUID ownerId) {§super(ownerId, 170, "Scavenging Ooze", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "CMD";§this.subtype.add("Ooze");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ScavengingOozeEffect(), new ManaCostsImpl("{G}"));§ability.addTarget(new TargetCardInGraveyard());§this.addAbility(ability);§}§public ScavengingOoze(final ScavengingOoze card) {§super(card);§}§@Override§public ScavengingOoze copy() {§return new ScavengingOoze(this);§}§}§class ScavengingOozeEffect extends OneShotEffect {§public ScavengingOozeEffect() {§super(Outcome.Benefit);§this.staticText = "Exile target card from a graveyard. If it was a creature card, put a +1/+1 counter on {this} and you gain 1 life";§}§public ScavengingOozeEffect(final ScavengingOozeEffect effect) {§super(effect);§}§@Override§public ScavengingOozeEffect copy() {§return new ScavengingOozeEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Card card = game.getCard(getTargetPointer().getFirst(game, source));§Player controller = game.getPlayer(source.getControllerId());§if (controller != null && card != null) {§controller.moveCardToExileWithInfo(card, null, "", source.getSourceId(), game, Zone.GRAVEYARD, true);§if (card.getCardType().contains(CardType.CREATURE)) {§Permanent sourcePermanent = game.getPermanent(source.getSourceId());§if (sourcePermanent != null) {§sourcePermanent.addCounters(CounterType.P1P1.createInstance(), game);§}§controller.gainLife(1, game);§}§return true;§}§return false;§}§}§
public class SewerNemesis extends CardImpl {§public SewerNemesis(UUID ownerId) {§super(ownerId, 98, "Sewer Nemesis", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{B}");§this.expansionSetCode = "CMD";§this.subtype.add("Horror");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§this.addAbility(new AsEntersBattlefieldAbility(new ChoosePlayerEffect(Outcome.Detriment)));§this.addAbility(new SimpleStaticAbility(Zone.ALL, new SetPowerToughnessSourceEffect(new CardsInTargetOpponentsGraveyardCount(), Duration.WhileOnBattlefield)));§this.addAbility(new SewerNemesisTriggeredAbility());§}§public SewerNemesis(final SewerNemesis card) {§super(card);§}§@Override§public SewerNemesis copy() {§return new SewerNemesis(this);§}§}§class CardsInTargetOpponentsGraveyardCount implements DynamicValue {§@Override§public int calculate(Game game, Ability sourceAbility, Effect effect) {§if (sourceAbility != null) {§UUID playerId = (UUID) game.getState().getValue(sourceAbility.getSourceId() + "_player");§Player chosenPlayer = game.getPlayer(playerId);§if (chosenPlayer != null) {§return chosenPlayer.getGraveyard().size();§}§}§return 0;§}§@Override§public DynamicValue copy() {§return new CardsInTargetOpponentsGraveyardCount();§}§@Override§public String getMessage() {§return "cards in the chosen player's graveyard";§}§@Override§public String toString() {§return "1";§}§}§class SewerNemesisTriggeredAbility extends TriggeredAbilityImpl {§public SewerNemesisTriggeredAbility() {§super(Zone.BATTLEFIELD, new PutTopCardOfLibraryIntoGraveTargetEffect(1), false);§}§public SewerNemesisTriggeredAbility(final SewerNemesisTriggeredAbility ability) {§super(ability);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.SPELL_CAST;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§UUID playerId = (UUID) game.getState().getValue(getSourceId() + "_player");§if (playerId.equals(event.getPlayerId())) {§this.getEffects().get(0).setTargetPointer(new FixedTarget(playerId));§return true;§}§return false;§}§@Override§public String getRule() {§return "Whenever the chosen player casts a spell, that player puts the top card of his or her library into his or her graveyard.";§}§@Override§public SewerNemesisTriggeredAbility copy() {§return new SewerNemesisTriggeredAbility(this);§}§}§
public class SharedTrauma extends CardImpl {§public SharedTrauma(UUID ownerId) {§super(ownerId, 99, "Shared Trauma", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{B}");§this.expansionSetCode = "CMD";§this.getSpellAbility().addEffect(new SharedTraumaEffect());§}§public SharedTrauma(final SharedTrauma card) {§super(card);§}§@Override§public SharedTrauma copy() {§return new SharedTrauma(this);§}§}§class SharedTraumaEffect extends OneShotEffect {§public SharedTraumaEffect() {§super(Outcome.Detriment);§this.staticText = "<i>Join forces</i> - Starting with you, each player may pay any amount of mana. Each player puts the top X cards of his or her library into his or her graveyard, where X is the total amount of mana paid this way";§}§public SharedTraumaEffect(final SharedTraumaEffect effect) {§super(effect);§}§@Override§public SharedTraumaEffect copy() {§return new SharedTraumaEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§int xSum = 0;§xSum += playerPaysXGenericMana(controller, source, game);§for(UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {§if (playerId != controller.getId()) {§Player player = game.getPlayer(playerId);§if (player != null) {§xSum += playerPaysXGenericMana(player, source, game);§}§}§}§if (xSum > 0) {§for(UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {§Effect effect = new PutTopCardOfLibraryIntoGraveTargetEffect(xSum);§effect.setTargetPointer(new FixedTarget(playerId));§effect.apply(game, source);§}§}§controller.resetStoredBookmark(game);§return true;§}§return false;§}§protected static int playerPaysXGenericMana(Player player, Ability source, Game game) {§int xValue = 0;§boolean payed = false;§while (player.canRespond() && !payed) {§xValue = player.announceXMana(0, Integer.MAX_VALUE, "How much mana will you pay?", game, source);§if (xValue > 0) {§Cost cost = new GenericManaCost(xValue);§payed = cost.pay(source, game, source.getSourceId(), player.getId(), false, null);§} else {§payed = true;§}§}§game.informPlayers(new StringBuilder(player.getLogName()).append(" pays {").append(xValue).append("}.").toString());§return xValue;§}§}§
public class Shriekmaw extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("nonartifact, nonblack creature");§static {§filter.add(Predicates.not(new CardTypePredicate(CardType.ARTIFACT)));§filter.add(Predicates.not(new ColorPredicate(ObjectColor.BLACK)));§}§public Shriekmaw(UUID ownerId) {§super(ownerId, 100, "Shriekmaw", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{B}");§this.expansionSetCode = "CMD";§this.subtype.add("Elemental");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§this.addAbility(FearAbility.getInstance());§Ability ability = new EntersBattlefieldTriggeredAbility(new DestroyTargetEffect(),false);§Target target = new TargetCreaturePermanent(filter);§ability.addTarget(target);§this.addAbility(ability);§this.addAbility(new EvokeAbility(this, "{1}{B}"));§}§public Shriekmaw(final Shriekmaw card) {§super(card);§}§@Override§public Shriekmaw copy() {§return new Shriekmaw(this);§}§}§
public class SoulSnare extends CardImpl {§public SoulSnare(UUID ownerId) {§super(ownerId, 32, "Soul Snare", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{W}");§this.expansionSetCode = "CMD";§Effect effect = new ExileTargetEffect();§effect.setText("Exile target creature that's attacking you or a planeswalker you control.");§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new ManaCostsImpl("{W}"));§ability.addCost(new SacrificeSourceCost());§ability.addTarget(new TargetCreaturePermanent(new SoulSnareFilter()));§this.addAbility(ability);§}§public SoulSnare(final SoulSnare card) {§super(card);§}§@Override§public SoulSnare copy() {§return new SoulSnare(this);§}§}§class SoulSnareFilter extends FilterAttackingCreature {§public SoulSnareFilter() {§super("creature that's attacking you or a planeswalker you control");§}§public SoulSnareFilter(final SoulSnareFilter filter) {§super(filter);§}§@Override§public SoulSnareFilter copy() {§return new SoulSnareFilter(this);§}§@Override§public boolean match(Permanent permanent, UUID sourceId, UUID playerId, Game game) {§if(!super.match(permanent, sourceId, playerId, game)) {§return false;§}§for(CombatGroup group : game.getCombat().getGroups()) {§for(UUID attacker : group.getAttackers()) {§if(attacker.equals(permanent.getId())) {§UUID defenderId = group.getDefenderId();§if(defenderId.equals(playerId)) {§return true;§}§else {§Permanent planeswalker = game.getPermanent(defenderId);§if(planeswalker != null && planeswalker.getCardType().contains(CardType.PLANESWALKER)§&& planeswalker.getControllerId().equals(playerId)) {§return true;§}§}§}§}§}§return false;§}§}§
public class Spawnwrithe extends CardImpl {§public Spawnwrithe(UUID ownerId) {§super(ownerId, 171, "Spawnwrithe", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{G}");§this.expansionSetCode = "CMD";§this.subtype.add("Elemental");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(TrampleAbility.getInstance());§this.addAbility(new DealsCombatDamageToAPlayerTriggeredAbility(new PutTokenOntoBattlefieldCopySourceEffect(), false));§}§public Spawnwrithe(final Spawnwrithe card) {§super(card);§}§@Override§public Spawnwrithe copy() {§return new Spawnwrithe(this);§}§}§
public class SpellCrumple extends CardImpl {§public SpellCrumple(UUID ownerId) {§super(ownerId, 63, "Spell Crumple", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{1}{U}{U}");§this.expansionSetCode = "CMD";§this.getSpellAbility().addTarget(new TargetSpell());§this.getSpellAbility().addEffect(new SpellCrumpleCounterEffect());§this.getSpellAbility().addEffect(new ReturnToLibrarySpellEffect(false));§}§public SpellCrumple(final SpellCrumple card) {§super(card);§}§@Override§public SpellCrumple copy() {§return new SpellCrumple(this);§}§}§class SpellCrumpleCounterEffect extends OneShotEffect {§public SpellCrumpleCounterEffect() {§super(Outcome.Benefit);§this.staticText = "Counter target spell. If that spell is countered this way, put it on the bottom of its owner's library instead of into that player's graveyard";§}§public SpellCrumpleCounterEffect(final SpellCrumpleCounterEffect effect) {§super(effect);§}§@Override§public SpellCrumpleCounterEffect copy() {§return new SpellCrumpleCounterEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§return game.getStack().counter(targetPointer.getFirst(game, source), source.getSourceId(), game, Zone.LIBRARY, false, ZoneDetail.BOTTOM);§}§return false;§}§}§
public class Squallmonger extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature with flying");§static {§filter.add(new AbilityPredicate(FlyingAbility.class));§}§public Squallmonger(UUID ownerId) {§super(ownerId, 173, "Squallmonger", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{G}");§this.expansionSetCode = "CMD";§this.subtype.add("Monger");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§SimpleActivatedAbility ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageAllEffect(1, filter), new ManaCostsImpl("{2}"));§Effect effect = new DamagePlayersEffect(1);§effect.setText("and each player");§ability.addEffect(effect);§ability.setMayActivate(TargetController.ANY);§ability.addEffect(new InfoEffect("Any player may activate this ability"));§this.addAbility(ability);§}§public Squallmonger(final Squallmonger card) {§super(card);§}§@Override§public Squallmonger copy() {§return new Squallmonger(this);§}§}§
public class StitchTogether extends CardImpl {§public StitchTogether(UUID ownerId) {§super(ownerId, 102, "Stitch Together", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{B}{B}");§this.expansionSetCode = "CMD";§Effect effect = new ConditionalOneShotEffect(§new ReturnFromGraveyardToBattlefieldTargetEffect(),§new ReturnFromGraveyardToHandTargetEffect(),§new CardsInControllerGraveCondition(7),§"Return target creature card from your graveyard to your hand. <br/><br/><i>Threshold</i> - Return that card from your graveyard to the battlefield instead if seven or more cards are in your graveyard.");§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addTarget(new TargetCardInYourGraveyard(new FilterCreatureCard("creature card from your graveyard")));§}§public StitchTogether(final StitchTogether card) {§super(card);§}§@Override§public StitchTogether copy() {§return new StitchTogether(this);§}§}§
public class Stranglehold extends CardImpl {§public Stranglehold(UUID ownerId) {§super(ownerId, 136, "Stranglehold", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{3}{R}");§this.expansionSetCode = "CMD";§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new OpponentsCantSearchLibarariesEffect()));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new StrangleholdSkipExtraTurnsEffect()));§}§public Stranglehold(final Stranglehold card) {§super(card);§}§@Override§public Stranglehold copy() {§return new Stranglehold(this);§}§}§class OpponentsCantSearchLibarariesEffect extends ContinuousRuleModifyingEffectImpl {§public OpponentsCantSearchLibarariesEffect() {§super(Duration.WhileOnBattlefield, Outcome.Benefit, true, false);§staticText = "Your opponents can't search libraries";§}§public OpponentsCantSearchLibarariesEffect(final OpponentsCantSearchLibarariesEffect effect) {§super(effect);§}§@Override§public OpponentsCantSearchLibarariesEffect copy() {§return new OpponentsCantSearchLibarariesEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public String getInfoMessage(Ability source, GameEvent event, Game game) {§MageObject mageObject = game.getObject(source.getSourceId());§if (mageObject != null) {§return "You can't search libraries (" + mageObject.getLogName() + " in play).";§}§return null;§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return EventType.SEARCH_LIBRARY.equals(event.getType());§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§Player controller = game.getPlayer(source.getControllerId());§return controller != null && controller.hasOpponent(event.getPlayerId(), game);§}§}§class StrangleholdSkipExtraTurnsEffect extends ReplacementEffectImpl {§public StrangleholdSkipExtraTurnsEffect() {§super(Duration.WhileOnBattlefield, Outcome.Detriment);§staticText = "If an opponent would begin an extra turn, that player skips that turn instead";§}§public StrangleholdSkipExtraTurnsEffect(final StrangleholdSkipExtraTurnsEffect effect) {§super(effect);§}§@Override§public StrangleholdSkipExtraTurnsEffect copy() {§return new StrangleholdSkipExtraTurnsEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§Player player = game.getPlayer(event.getPlayerId());§MageObject sourceObject = game.getObject(source.getSourceId());§if (player != null && sourceObject != null) {§game.informPlayers(sourceObject.getLogName() + ": Extra turn of " + player.getLogName() + " skipped");§}§return true;§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType().equals(GameEvent.EventType.EXTRA_TURN);§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§Player controller = game.getPlayer(source.getControllerId());§return controller != null && controller.hasOpponent(event.getPlayerId(), game);§}§}§
public class SvogthosTheRestlessTomb extends CardImpl {§public SvogthosTheRestlessTomb(UUID ownerId) {§super(ownerId, 289, "Svogthos, the Restless Tomb", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "CMD";§this.addAbility(new ColorlessManaAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BecomesCreatureSourceEffect(new SvogthosToken(), "land", Duration.EndOfTurn, false, true), new ManaCostsImpl<>("{3}{B}{G}"));§this.addAbility(ability);§}§public SvogthosTheRestlessTomb(final SvogthosTheRestlessTomb card) {§super(card);§}§@Override§public SvogthosTheRestlessTomb copy() {§return new SvogthosTheRestlessTomb(this);§}§}§class SvogthosToken extends Token {§public SvogthosToken() {§super("", "black and green Plant Zombie creature with \"This creature's power and toughness are each equal to the number of creature cards in your graveyard.\"");§cardType.add(CardType.CREATURE);§subtype.add("Plant");§subtype.add("Zombie");§color.setGreen(true);§color.setBlack(true);§power = new MageInt(0);§toughness = new MageInt(0);§CardsInControllerGraveyardCount count = new CardsInControllerGraveyardCount(new FilterCreatureCard("creature cards"));§this.addAbility(new SimpleStaticAbility(Zone.ALL, new SetPowerToughnessSourceEffect(count, Duration.EndOfGame)));§}§}§
public class SzadekLordOfSecrets extends CardImpl {§public SzadekLordOfSecrets(UUID ownerId) {§super(ownerId, 228, "Szadek, Lord of Secrets", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{U}{U}{B}{B}");§this.expansionSetCode = "CMD";§this.supertype.add("Legendary");§this.subtype.add("Vampire");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new SzadekLordOfSecretsEffect()));§}§public SzadekLordOfSecrets(final SzadekLordOfSecrets card) {§super(card);§}§@Override§public SzadekLordOfSecrets copy() {§return new SzadekLordOfSecrets(this);§}§}§class SzadekLordOfSecretsEffect extends ReplacementEffectImpl {§SzadekLordOfSecretsEffect() {§super(Duration.WhileOnBattlefield, Outcome.Benefit);§staticText = "If {this} would deal combat damage to a player, instead put that many +1/+1 counters on {this} and that player puts that many cards from the top of his or her library into his or her graveyard";§}§SzadekLordOfSecretsEffect(final SzadekLordOfSecretsEffect effect) {§super(effect);§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§DamagePlayerEvent damageEvent = (DamagePlayerEvent) event;§Player damagedPlayer = game.getPlayer(damageEvent.getTargetId());§if (damageEvent.isCombatDamage()) {§Permanent permanent = game.getPermanent(source.getSourceId());§if (permanent != null) {§permanent.addCounters(CounterType.P1P1.createInstance(damageEvent.getAmount()), game);§if (damagedPlayer != null) {§damagedPlayer.moveCards(damagedPlayer.getLibrary().getTopCards(game, damageEvent.getAmount()), Zone.LIBRARY, Zone.GRAVEYARD, source, game);§}§}§}§return true;§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.DAMAGE_PLAYER;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§if (event.getSourceId().equals(source.getSourceId())) {§DamagePlayerEvent damageEvent = (DamagePlayerEvent) event;§if (damageEvent.isCombatDamage()) {§return true;§}§}§return false;§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public SzadekLordOfSecretsEffect copy() {§return new SzadekLordOfSecretsEffect(this);§}§}§
public class TarielReckonerOfSouls extends CardImpl {§public TarielReckonerOfSouls(UUID ownerId) {§super(ownerId, 229, "Tariel, Reckoner of Souls", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{4}{W}{B}{R}");§this.expansionSetCode = "CMD";§this.supertype.add("Legendary");§this.subtype.add("Angel");§this.power = new MageInt(4);§this.toughness = new MageInt(7);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(VigilanceAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new TarielReckonerOfSoulsEffect(), new TapSourceCost());§ability.addTarget(new TargetOpponent());§this.addAbility(ability);§}§public TarielReckonerOfSouls(final TarielReckonerOfSouls card) {§super(card);§}§@Override§public TarielReckonerOfSouls copy() {§return new TarielReckonerOfSouls(this);§}§}§class TarielReckonerOfSoulsEffect extends OneShotEffect {§public TarielReckonerOfSoulsEffect() {§super(Outcome.PutCardInPlay);§this.staticText = "Choose a creature card at random from target opponent's graveyard. Put that card onto the battlefield under your control";§}§public TarielReckonerOfSoulsEffect(final TarielReckonerOfSoulsEffect effect) {§super(effect);§}§@Override§public TarielReckonerOfSoulsEffect copy() {§return new TarielReckonerOfSoulsEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§Player targetOpponent = game.getPlayer(getTargetPointer().getFirst(game, source));§if (controller != null && targetOpponent != null) {§Cards creatureCards = new CardsImpl();§for (Card card : targetOpponent.getGraveyard().getCards(new FilterCreatureCard(), game)) {§creatureCards.add(card);§}§if (!creatureCards.isEmpty()) {§Card card = creatureCards.getRandom(game);§controller.moveCards(card, Zone.BATTLEFIELD, source, game);§}§return true;§}§return false;§}§}§
public class TenebTheHarvester extends CardImpl {§public TenebTheHarvester(UUID ownerId) {§super(ownerId, 230, "Teneb, the Harvester", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{B}{G}{W}");§this.expansionSetCode = "CMD";§this.supertype.add("Legendary");§this.subtype.add("Dragon");§this.power = new MageInt(6);§this.toughness = new MageInt(6);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new DealsCombatDamageToAPlayerTriggeredAbility(§new DoIfCostPaid(new ReturnFromGraveyardToBattlefieldTargetEffect(), new ManaCostsImpl("{2}{B}")), false);§Target target = new TargetCardInGraveyard(new FilterCreatureCard("creature card from a graveyard"));§ability.addTarget(target);§this.addAbility(ability);§}§public TenebTheHarvester(final TenebTheHarvester card) {§super(card);§}§@Override§public TenebTheHarvester copy() {§return new TenebTheHarvester(this);§}§}§
public class TheMimeoplasm extends CardImpl {§public TheMimeoplasm(UUID ownerId) {§super(ownerId, 210, "The Mimeoplasm", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{2}{G}{U}{B}");§this.expansionSetCode = "CMD";§this.supertype.add("Legendary");§this.subtype.add("Ooze");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§this.addAbility(new AsEntersBattlefieldAbility(new TheMimeoplasmEffect(), "you may exile two creature cards from graveyards. If you do, it enters the battlefield as a copy of one of those cards with a number of additional +1/+1 counters on it equal to the power of the other card"));§}§public TheMimeoplasm(final TheMimeoplasm card) {§super(card);§}§@Override§public TheMimeoplasm copy() {§return new TheMimeoplasm(this);§}§}§class TheMimeoplasmEffect extends OneShotEffect {§TheMimeoplasmEffect() {§super(Outcome.Copy);§}§TheMimeoplasmEffect(final TheMimeoplasmEffect effect) {§super(effect);§}§@Override§public TheMimeoplasmEffect copy() {§return new TheMimeoplasmEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§Permanent permanent = game.getPermanentEntering(source.getSourceId());§if (controller != null && permanent != null) {§if (new CardsInAllGraveyardsCount(new FilterCreatureCard()).calculate(game, source, this) >= 2) {§if (controller.chooseUse(Outcome.Benefit, "Do you want to exile two creature cards from graveyards?", source, game)) {§TargetCardInGraveyard targetCopy = new TargetCardInGraveyard(new FilterCreatureCard("creature card to become a copy of"));§TargetCardInGraveyard targetCounters = new TargetCardInGraveyard(new FilterCreatureCard("creature card to determine amount of additional +1/+1 counters"));§if (controller.choose(Outcome.Copy, targetCopy, source.getSourceId(), game)) {§Card cardToCopy = game.getCard(targetCopy.getFirstTarget());§if (cardToCopy != null) {§if (controller.choose(Outcome.Copy, targetCounters, source.getSourceId(), game)) {§Card cardForCounters = game.getCard(targetCounters.getFirstTarget());§if (cardForCounters != null) {§Cards cardsToExile = new CardsImpl();§cardsToExile.add(cardToCopy);§cardsToExile.add(cardForCounters);§controller.moveCards(cardsToExile, Zone.EXILED, source, game);§CopyEffect copyEffect = new CopyEffect(Duration.Custom, cardToCopy, source.getSourceId());§game.addEffect(copyEffect, source);§permanent.addCounters(CounterType.P1P1.createInstance(cardForCounters.getPower().getValue()), game);§}§}§}§}§}§}§return true;§}§return false;§}§}§
public class TrenchGorger extends CardImpl {§public TrenchGorger(UUID ownerId) {§super(ownerId, 65, "Trench Gorger", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{6}{U}{U}");§this.expansionSetCode = "CMD";§this.subtype.add("Leviathan");§this.power = new MageInt(6);§this.toughness = new MageInt(6);§this.addAbility(TrampleAbility.getInstance());§this.addAbility(new EntersBattlefieldTriggeredAbility(new TrenchGorgerEffect(), true));§}§public TrenchGorger(final TrenchGorger card) {§super(card);§}§@Override§public TrenchGorger copy() {§return new TrenchGorger(this);§}§}§class TrenchGorgerEffect extends OneShotEffect {§public TrenchGorgerEffect() {§super(Outcome.BoostCreature);§this.staticText = "you may search your library for any number of land cards, exile them, then shuffle your library. If you do, {this}'s power and toughness each become equal to the number of cards exiled this way";§}§public TrenchGorgerEffect(final TrenchGorgerEffect effect) {§super(effect);§}§@Override§public TrenchGorgerEffect copy() {§return new TrenchGorgerEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§TargetCardInLibrary target = new TargetCardInLibrary(0, Integer.MAX_VALUE, new FilterLandCard("any number of land cards"));§target.choose(outcome, controller.getId(), controller.getId(), game);§int count = 0;§for (UUID cardId : target.getTargets()) {§Card card = game.getCard(cardId);§controller.moveCardToExileWithInfo(card, null, "", source.getSourceId(), game, Zone.LIBRARY, true);§count++;§}§controller.shuffleLibrary(game);§game.addEffect(new SetPowerToughnessSourceEffect(count, count, Duration.EndOfGame, SubLayer.SetPT_7b), source);§return true;§}§return false;§}§}§
public class TributeToTheWild extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("an artifact or enchantment");§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.ARTIFACT),§new CardTypePredicate(CardType.ENCHANTMENT)));§}§public TributeToTheWild(UUID ownerId) {§super(ownerId, 175, "Tribute to the Wild", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{1}{G}");§this.expansionSetCode = "CMD";§this.getSpellAbility().addEffect(new SacrificeOpponentsEffect(filter));§}§public TributeToTheWild(final TributeToTheWild card) {§super(card);§}§@Override§public TributeToTheWild copy() {§return new TributeToTheWild(this);§}§}§
public class VeteranExplorer extends CardImpl {§public VeteranExplorer(UUID ownerId) {§super(ownerId, 177, "Veteran Explorer", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{G}");§this.expansionSetCode = "CMD";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.subtype.add("Scout");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new DiesTriggeredAbility(new VeteranExplorerEffect()));§}§public VeteranExplorer(final VeteranExplorer card) {§super(card);§}§@Override§public VeteranExplorer copy() {§return new VeteranExplorer(this);§}§}§class VeteranExplorerEffect extends OneShotEffect {§public VeteranExplorerEffect() {§super(Outcome.Detriment);§this.staticText = "each player may search his or her library for up to two basic land cards and put them onto the battlefield. Then each player who searched his or her library this way shuffles it";§}§public VeteranExplorerEffect(final VeteranExplorerEffect effect) {§super(effect);§}§@Override§public VeteranExplorerEffect copy() {§return new VeteranExplorerEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§List<Player> usingPlayers = new ArrayList<>();§this.chooseAndSearchLibrary(usingPlayers, controller, source, game);§for (UUID playerId: game.getState().getPlayersInRange(controller.getId(), game)) {§if (!playerId.equals(controller.getId())) {§Player player = game.getPlayer(playerId);§if (player != null) {§this.chooseAndSearchLibrary(usingPlayers, player, source, game);§}§}§}§for (Player player: usingPlayers) {§player.shuffleLibrary(game);§}§return true;§}§return false;§}§private void chooseAndSearchLibrary(List<Player> usingPlayers, Player player, Ability source, Game game) {§if (player.chooseUse(Outcome.PutCardInPlay, "Search your library for up to two basic land cards and put them onto the battlefield?", source, game)) {§usingPlayers.add(player);§TargetCardInLibrary target = new TargetCardInLibrary(0, 2, new FilterBasicLandCard());§if (player.searchLibrary(target, game)) {§if (target.getTargets().size() > 0) {§for (UUID cardId: (List<UUID>)target.getTargets()) {§Card card = player.getLibrary().getCard(cardId, game);§if (card != null) {§card.putOntoBattlefield(game, Zone.LIBRARY, source.getSourceId(), player.getId());§}§}§}§}§}§}§}§
public class VishKalBloodArbiter extends CardImpl {§public VishKalBloodArbiter(UUID ownerId) {§super(ownerId, 234, "Vish Kal, Blood Arbiter", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{W}{B}{B}");§this.expansionSetCode = "CMD";§this.supertype.add("Legendary");§this.subtype.add("Vampire");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(LifelinkAbility.getInstance());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD,§new AddCountersSourceEffect(CounterType.P1P1.createInstance(0), new SacrificeCostCreaturesPower(), true),§new SacrificeTargetCost(new TargetControlledCreaturePermanent(1,1,new FilterControlledCreaturePermanent("a creature"), false))));§DynamicValue removedCounters = new SignInversionDynamicValue(new VishKalBloodArbiterDynamicValue());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostTargetEffect(removedCounters, removedCounters, Duration.EndOfTurn), new VishKalBloodArbiterCost(CounterType.P1P1.createInstance()));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public VishKalBloodArbiter(final VishKalBloodArbiter card) {§super(card);§}§@Override§public VishKalBloodArbiter copy() {§return new VishKalBloodArbiter(this);§}§}§class VishKalBloodArbiterCost extends CostImpl {§private int amount;§private String name;§public VishKalBloodArbiterCost(Counter counter) {§this.name = counter.getName();§this.amount = counter.getCount();§this.text = "Remove all " + name + " counters from {this}";§}§public VishKalBloodArbiterCost(VishKalBloodArbiterCost cost) {§super(cost);§this.amount = cost.amount;§this.name = cost.name;§}§@Override§public boolean canPay(Ability ability, UUID sourceId, UUID controllerId, Game game) {§return true;§}§@Override§public boolean pay(Ability ability, Game game, UUID sourceId, UUID controllerId, boolean noMana, Cost costToPay) {§Permanent permanent = game.getPermanent(sourceId);§if (permanent != null) {§this.amount = permanent.getCounters().getCount(name);§permanent.removeCounters(name, amount, game);§this.paid = true;§}§else§{§this.amount = 0;§}§return paid;§}§@Override§public VishKalBloodArbiterCost copy() {§return new VishKalBloodArbiterCost(this);§}§public int getAmount() {§return amount;§}§}§class VishKalBloodArbiterDynamicValue implements DynamicValue {§public VishKalBloodArbiterDynamicValue() {§}§public VishKalBloodArbiterDynamicValue(final VishKalBloodArbiterDynamicValue dynamicValue) {§}§@Override§public int calculate(Game game, Ability source, Effect effect) {§int count = 0;§for(Cost cost : source.getCosts()){§if(cost instanceof VishKalBloodArbiterCost){§count += ((VishKalBloodArbiterCost)cost).getAmount();§}§}§return count;§}§@Override§public VishKalBloodArbiterDynamicValue copy() {§return new VishKalBloodArbiterDynamicValue(this);§}§@Override§public String toString() {§return "1";§}§@Override§public String getMessage() {§return "the number of +1/+1 counters removed this way";§}§}§
public class VoroshTheHunter extends CardImpl {§public VoroshTheHunter(UUID ownerId) {§super(ownerId, 235, "Vorosh, the Hunter", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{G}{U}{B}");§this.expansionSetCode = "CMD";§this.supertype.add("Legendary");§this.subtype.add("Dragon");§this.power = new MageInt(6);§this.toughness = new MageInt(6);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new DealsCombatDamageToAPlayerTriggeredAbility(§new DoIfCostPaid(new AddCountersSourceEffect(CounterType.P1P1.createInstance(6), true), new ManaCostsImpl("{2}{G}")), false));§}§public VoroshTheHunter(final VoroshTheHunter card) {§super(card);§}§@Override§public VoroshTheHunter copy() {§return new VoroshTheHunter(this);§}§}§
public class VowOfDuty extends CardImpl {§public VowOfDuty(UUID ownerId) {§super(ownerId, 36, "Vow of Duty", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{W}");§this.expansionSetCode = "CMD";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(2,2,Duration.WhileOnBattlefield));§Effect effect = new GainAbilityAttachedEffect(VigilanceAbility.getInstance(), AttachmentType.AURA, Duration.WhileOnBattlefield);§effect.setText(", has vigilance");§ability.addEffect(effect);§effect = new CantAttackControllerAttachedEffect(AttachmentType.AURA);§effect.setText(", and can't attack you or a planeswalker you control");§ability.addEffect(effect);§this.addAbility(ability);§}§public VowOfDuty(final VowOfDuty card) {§super(card);§}§@Override§public VowOfDuty copy() {§return new VowOfDuty(this);§}§}§
public class VowOfFlight extends CardImpl {§public VowOfFlight(UUID ownerId) {§super(ownerId, 68, "Vow of Flight", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{U}");§this.expansionSetCode = "CMD";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(2,2,Duration.WhileOnBattlefield));§Effect effect = new GainAbilityAttachedEffect(FlyingAbility.getInstance(), AttachmentType.AURA, Duration.WhileOnBattlefield);§effect.setText(", has flying");§ability.addEffect(effect);§effect = new CantAttackControllerAttachedEffect(AttachmentType.AURA);§effect.setText(", and can't attack you or a planeswalker you control");§ability.addEffect(effect);§this.addAbility(ability);§}§public VowOfFlight(final VowOfFlight card) {§super(card);§}§@Override§public VowOfFlight copy() {§return new VowOfFlight(this);§}§}§
public class VowOfLightning extends CardImpl {§public VowOfLightning(UUID ownerId) {§super(ownerId, 138, "Vow of Lightning", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{R}");§this.expansionSetCode = "CMD";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(2,2,Duration.WhileOnBattlefield));§Effect effect = new GainAbilityAttachedEffect(FirstStrikeAbility.getInstance(), AttachmentType.AURA, Duration.WhileOnBattlefield);§effect.setText(", has first strike");§ability.addEffect(effect);§effect = new CantAttackControllerAttachedEffect(AttachmentType.AURA);§effect.setText(", and can't attack you or a planeswalker you control");§ability.addEffect(effect);§this.addAbility(ability);§}§public VowOfLightning(final VowOfLightning card) {§super(card);§}§@Override§public VowOfLightning copy() {§return new VowOfLightning(this);§}§}§
public class VowOfMalice extends CardImpl {§public VowOfMalice(UUID ownerId) {§super(ownerId, 107, "Vow of Malice", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{B}");§this.expansionSetCode = "CMD";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(2,2,Duration.WhileOnBattlefield));§Effect effect = new GainAbilityAttachedEffect(IntimidateAbility.getInstance(), AttachmentType.AURA, Duration.WhileOnBattlefield);§effect.setText(", has intimidate");§ability.addEffect(effect);§effect = new CantAttackControllerAttachedEffect(AttachmentType.AURA);§effect.setText(", and can't attack you or a planeswalker you control");§ability.addEffect(effect);§this.addAbility(ability);§}§public VowOfMalice(final VowOfMalice card) {§super(card);§}§@Override§public VowOfMalice copy() {§return new VowOfMalice(this);§}§}§
public class VowOfWildness extends CardImpl {§public VowOfWildness(UUID ownerId) {§super(ownerId, 178, "Vow of Wildness", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{G}");§this.expansionSetCode = "CMD";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.Detriment));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(3,3,Duration.WhileOnBattlefield));§Effect effect = new GainAbilityAttachedEffect(TrampleAbility.getInstance(), AttachmentType.AURA, Duration.WhileOnBattlefield);§effect.setText(", has trample");§ability.addEffect(effect);§effect = new CantAttackControllerAttachedEffect(AttachmentType.AURA);§effect.setText(", and can't attack you or a planeswalker you control");§ability.addEffect(effect);§this.addAbility(ability);§}§public VowOfWildness(final VowOfWildness card) {§super(card);§}§@Override§public VowOfWildness copy() {§return new VowOfWildness(this);§}§}§
public class WildRicochet extends CardImpl {§private static final FilterStackObject filter = new FilterStackObject("instant or sorcery spell");§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.INSTANT),§new CardTypePredicate(CardType.SORCERY)));§}§public WildRicochet(UUID ownerId) {§super(ownerId, 139, "Wild Ricochet", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{2}{R}{R}");§this.expansionSetCode = "CMD";§this.getSpellAbility().addEffect(new WildRicochetEffect());§this.getSpellAbility().addTarget(new TargetStackObject(filter));§}§public WildRicochet(final WildRicochet card) {§super(card);§}§@Override§public WildRicochet copy() {§return new WildRicochet(this);§}§}§class WildRicochetEffect extends OneShotEffect {§public WildRicochetEffect() {§super(Outcome.Neutral);§staticText = "You may choose new targets for target instant or sorcery spell. Then copy that spell. You may choose new targets for the copy";§}§public WildRicochetEffect(final WildRicochetEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Spell spell = game.getStack().getSpell(source.getFirstTarget());§Player you = game.getPlayer(source.getControllerId());§if (spell != null && you != null && you.chooseUse(Outcome.Benefit, "Do you wish to choose new targets for " + spell.getName() + "?", source, game)) {§spell.chooseNewTargets(game, you.getId());§}§if (spell != null) {§Spell copy = spell.copySpell();§copy.setControllerId(source.getControllerId());§copy.setCopiedSpell(true);§game.getStack().push(copy);§if (you != null && you.chooseUse(Outcome.Benefit, "Do you wish to choose new targets for the copied " + spell.getName() + "?", source, game)) {§return copy.chooseNewTargets(game, you.getId());§}§}§return false;§}§@Override§public WildRicochetEffect copy() {§return new WildRicochetEffect(this);§}§}§
public class WreckingBall extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("creature or land");§static {§filter.add(Predicates.or(new CardTypePredicate(CardType.CREATURE), new CardTypePredicate(CardType.LAND)));§}§public WreckingBall(UUID ownerId) {§super(ownerId, 238, "Wrecking Ball", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{B}{R}");§this.expansionSetCode = "CMD";§this.getSpellAbility().addEffect(new DestroyTargetEffect());§Target target = new TargetPermanent(filter);§this.getSpellAbility().addTarget(target);§}§public WreckingBall(final WreckingBall card) {§super(card);§}§@Override§public WreckingBall copy() {§return new WreckingBall(this);§}§}§
public class YavimayaElder extends CardImpl {§public YavimayaElder(UUID ownerId) {§super(ownerId, 179, "Yavimaya Elder", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{G}{G}");§this.expansionSetCode = "CMD";§this.subtype.add("Human");§this.subtype.add("Druid");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new DiesTriggeredAbility(new SearchLibraryPutInHandEffect(new TargetCardInLibrary(0, 2, new FilterBasicLandCard()), true), true));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DrawCardSourceControllerEffect(1), new GenericManaCost(2));§ability.addCost(new SacrificeSourceCost());§this.addAbility(ability);§}§public YavimayaElder(final YavimayaElder card) {§super(card);§}§@Override§public YavimayaElder copy() {§return new YavimayaElder(this);§}§}§
public class ZedruuTheGreathearted extends CardImpl {§public ZedruuTheGreathearted(UUID ownerId) {§super(ownerId, 240, "Zedruu the Greathearted", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{1}{R}{W}{U}");§this.expansionSetCode = "CMD";§this.supertype.add("Legendary");§this.subtype.add("Minotaur");§this.subtype.add("Monk");§this.power = new MageInt(2);§this.toughness = new MageInt(4);§Effect effect = new GainLifeEffect(new PermanentsYouOwnThatOpponentsControlCount());§effect.setText("you gain X life");§Ability ability = new BeginningOfUpkeepTriggeredAbility(effect, TargetController.YOU, false);§effect = new DrawCardSourceControllerEffect(new PermanentsYouOwnThatOpponentsControlCount());§effect.setText("and draw X cards, where X is the number of permanents you own that your opponents control");§ability.addEffect(effect);§this.addAbility(ability);§ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ZedruuTheGreatheartedEffect(), new ManaCostsImpl("{R}{W}{U}"));§ability.addTarget(new TargetOpponent());§ability.addTarget(new TargetControlledPermanent());§this.addAbility(ability);§}§public ZedruuTheGreathearted(final ZedruuTheGreathearted card) {§super(card);§}§@Override§public ZedruuTheGreathearted copy() {§return new ZedruuTheGreathearted(this);§}§class ZedruuTheGreatheartedEffect extends ContinuousEffectImpl {§private MageObjectReference targetPermanentReference;§public ZedruuTheGreatheartedEffect() {§super(Duration.Custom, Layer.ControlChangingEffects_2, SubLayer.NA, Outcome.GainControl);§this.staticText = "Target opponent gains control of target permanent you control";§}§public ZedruuTheGreatheartedEffect(final ZedruuTheGreatheartedEffect effect) {§super(effect);§this.targetPermanentReference = effect.targetPermanentReference;§}§@Override§public ZedruuTheGreatheartedEffect copy() {§return new ZedruuTheGreatheartedEffect(this);§}§@Override§public void init(Ability source, Game game) {§super.init(source, game);§targetPermanentReference = new MageObjectReference(source.getTargets().get(1).getFirstTarget(), game);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = targetPermanentReference.getPermanent(game);§if (permanent != null) {§return permanent.changeControllerId(source.getFirstTarget(), game);§} else {§discard();§}§return false;§}§}§}§
public class ActOfAuthority extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("artifact or enchantment");§static {§filter.add(Predicates.or(new CardTypePredicate(CardType.ARTIFACT), new CardTypePredicate(CardType.ENCHANTMENT)));§}§public ActOfAuthority(UUID ownerId) {§super(ownerId, 1, "Act of Authority", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{1}{W}{W}");§this.expansionSetCode = "C13";§Ability ability = new EntersBattlefieldTriggeredAbility(new ExileTargetEffect(), true);§ability.addTarget(new TargetPermanent(filter));§this.addAbility(ability);§ability = new BeginningOfUpkeepTriggeredAbility(new ActOfAuthorityEffect(), TargetController.YOU, true);§ability.addTarget(new TargetPermanent(filter));§this.addAbility(ability);§}§public ActOfAuthority(final ActOfAuthority card) {§super(card);§}§@Override§public ActOfAuthority copy() {§return new ActOfAuthority(this);§}§}§class ActOfAuthorityEffect extends OneShotEffect {§public ActOfAuthorityEffect() {§super(Outcome.Exile);§this.staticText = "you may exile target artifact or enchantment. If you do, its controller gains control of {this}";§}§public ActOfAuthorityEffect(final ActOfAuthorityEffect effect) {§super(effect);§}§@Override§public ActOfAuthorityEffect copy() {§return new ActOfAuthorityEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent targetPermanent = game.getPermanent(this.getTargetPointer().getFirst(game, source));§if (targetPermanent != null && new ExileTargetEffect().apply(game, source)) {§ContinuousEffect effect = new ActOfAuthorityGainControlEffect(Duration.Custom, targetPermanent.getControllerId());§effect.setTargetPointer(new FixedTarget(source.getSourceId()));§game.addEffect(effect, source);§return true;§}§return false;§}§}§class ActOfAuthorityGainControlEffect extends ContinuousEffectImpl {§UUID controller;§public ActOfAuthorityGainControlEffect(Duration duration, UUID controller) {§super(duration, Layer.ControlChangingEffects_2, SubLayer.NA, Outcome.GainControl);§this.controller = controller;§}§public ActOfAuthorityGainControlEffect(final ActOfAuthorityGainControlEffect effect) {§super(effect);§this.controller = effect.controller;§}§@Override§public ActOfAuthorityGainControlEffect copy() {§return new ActOfAuthorityGainControlEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getPermanent(source.getFirstTarget());§if (targetPointer != null) {§permanent = game.getPermanent(targetPointer.getFirst(game, source));§}§if (permanent != null) {§return permanent.changeControllerId(controller, game);§}§return false;§}§@Override§public String getText(Mode mode) {§return "Gain control of {this}";§}§}§
public class AEthermagesTouch extends CardImpl {§public AEthermagesTouch(UUID ownerId) {§super(ownerId, 176, "AEthermage's Touch", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{2}{W}{U}");§this.expansionSetCode = "C13";§this.getSpellAbility().addEffect(new AEthermagesTouchEffect());§}§public AEthermagesTouch(final AEthermagesTouch card) {§super(card);§}§@Override§public AEthermagesTouch copy() {§return new AEthermagesTouch(this);§}§}§class AEthermagesTouchEffect extends OneShotEffect {§private static final FilterCreatureCard filterPutOntoBattlefield = new FilterCreatureCard("a creature card to put onto the battlefield");§public AEthermagesTouchEffect() {§super(Outcome.DrawCard);§this.staticText = "Reveal the top four cards of your library. You may put a creature card from among them onto the battlefield. It gains \"At the beginning of your end step, return this creature to its owner's hand.\" Then put the rest of the cards revealed this way on the bottom of your library in any order";§}§public AEthermagesTouchEffect(final AEthermagesTouchEffect effect) {§super(effect);§}§@Override§public AEthermagesTouchEffect copy() {§return new AEthermagesTouchEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§Cards cards = new CardsImpl();§boolean properCardFound = false;§int count = Math.min(player.getLibrary().size(), 4);§for (int i = 0; i < count; i++) {§Card card = player.getLibrary().removeFromTop(game);§if (card != null) {§cards.add(card);§if (filterPutOntoBattlefield.match(card, source.getSourceId(), source.getControllerId(), game)) {§properCardFound = true;§}§}§}§if (!cards.isEmpty()) {§player.revealCards("AEthermage's Touch", cards, game);§TargetCard target = new TargetCard(Zone.LIBRARY, filterPutOntoBattlefield);§if (properCardFound && player.choose(Outcome.PutCreatureInPlay, cards, target, game)) {§Card card = game.getCard(target.getFirstTarget());§if (card != null) {§cards.remove(card);§if (card.putOntoBattlefield(game, Zone.LIBRARY, source.getSourceId(), source.getControllerId())) {§Ability ability = new BeginningOfEndStepTriggeredAbility(Zone.BATTLEFIELD, new ReturnToHandSourceEffect(true), TargetController.YOU, null, false);§ContinuousEffect effect = new GainAbilityTargetEffect(ability, Duration.Custom);§effect.setTargetPointer(new FixedTarget(card.getId()));§game.addEffect(effect, source);§}§}§}§player.putCardsOnBottomOfLibrary(cards, game, source, true);§}§return true;§}§return false;§}§}§
public class AngelOfFinality extends CardImpl {§public AngelOfFinality(UUID ownerId) {§super(ownerId, 4, "Angel of Finality", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{W}");§this.expansionSetCode = "C13";§this.subtype.add("Angel");§this.power = new MageInt(3);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new EntersBattlefieldTriggeredAbility(new ExileGraveyardAllTargetPlayerEffect());§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§}§public AngelOfFinality(final AngelOfFinality card) {§super(card);§}§@Override§public AngelOfFinality copy() {§return new AngelOfFinality(this);§}§}§
public class ArcaneDenial extends CardImpl {§public ArcaneDenial(UUID ownerId) {§super(ownerId, 28, "Arcane Denial", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{U}");§this.expansionSetCode = "C13";§this.getSpellAbility().addEffect(new ArcaneDenialEffect());§this.getSpellAbility().addTarget(new TargetSpell());§this.getSpellAbility().addEffect(new CreateDelayedTriggeredAbilityEffect(new AtTheBeginOfNextUpkeepDelayedTriggeredAbility(new DrawCardSourceControllerEffect(1)), false));§}§public ArcaneDenial(final ArcaneDenial card) {§super(card);§}§@Override§public ArcaneDenial copy() {§return new ArcaneDenial(this);§}§}§class ArcaneDenialEffect extends OneShotEffect {§public ArcaneDenialEffect() {§super(Outcome.Detriment);§staticText = "Counter target spell. Its controller may draw up to two cards at the beginning of the next turn's upkeep";§}§public ArcaneDenialEffect(final ArcaneDenialEffect effect) {§super(effect);§}§@Override§public ArcaneDenialEffect copy() {§return new ArcaneDenialEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = null;§boolean countered = false;§UUID targetId = this.getTargetPointer().getFirst(game, source);§if (targetId != null) {§controller = game.getPlayer(game.getControllerId(targetId));§}§if (targetId != null§&& game.getStack().counter(targetId, source.getSourceId(), game)) {§countered = true;§}§if (controller != null) {§Effect effect = new DrawCardTargetEffect(new StaticValue(2), false, true);§effect.setTargetPointer(new FixedTarget(controller.getId()));§effect.setText("Its controller may draw up to two cards");§DelayedTriggeredAbility ability = new AtTheBeginOfNextUpkeepDelayedTriggeredAbility(effect);§game.addDelayedTriggeredAbility(ability, source);§}§return countered;§}§}§
public class AzoriusHerald extends CardImpl {§public AzoriusHerald(UUID ownerId) {§super(ownerId, 6, "Azorius Herald", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "C13";§this.subtype.add("Spirit");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new CantBeBlockedSourceAbility());§this.addAbility(new EntersBattlefieldTriggeredAbility(new GainLifeEffect(4)));§this.addAbility(new EntersBattlefieldTriggeredAbility(new SacrificeSourceUnlessConditionEffect(new ManaWasSpentCondition(ColoredManaSymbol.U)), false), new ManaSpentToCastWatcher());§}§public AzoriusHerald(final AzoriusHerald card) {§super(card);§}§@Override§public AzoriusHerald copy() {§return new AzoriusHerald(this);§}§}§
public class BalefulForce extends CardImpl {§public BalefulForce(UUID ownerId) {§super(ownerId, 70, "Baleful Force", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}{B}{B}{B}");§this.expansionSetCode = "C13";§this.subtype.add("Elemental");§this.power = new MageInt(7);§this.toughness = new MageInt(7);§Ability ability = new BeginningOfUpkeepTriggeredAbility(new DrawCardSourceControllerEffect(1), TargetController.ANY, false);§Effect effect = new LoseLifeSourceControllerEffect(1);§effect.setText("and you lose 1 life");§ability.addEffect(effect);§this.addAbility(ability);§}§public BalefulForce(final BalefulForce card) {§super(card);§}§@Override§public BalefulForce copy() {§return new BalefulForce(this);§}§}§
public class BaneOfProgress extends CardImpl {§public BaneOfProgress(UUID ownerId) {§super(ownerId, 137, "Bane of Progress", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{G}{G}");§this.expansionSetCode = "C13";§this.subtype.add("Elemental");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new EntersBattlefieldTriggeredAbility(new BaneOfProgressEffect(), false));§}§public BaneOfProgress(final BaneOfProgress card) {§super(card);§}§@Override§public BaneOfProgress copy() {§return new BaneOfProgress(this);§}§}§class BaneOfProgressEffect extends OneShotEffect {§private static final FilterPermanent filter = new FilterPermanent();§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.ARTIFACT),§new CardTypePredicate(CardType.ENCHANTMENT)));§}§public BaneOfProgressEffect() {§super(Outcome.DestroyPermanent);§this.staticText = "destroy all artifacts and enchantments. Put a +1/+1 counter on {this} for each permanent destroyed this way";§}§public BaneOfProgressEffect(final BaneOfProgressEffect effect) {§super(effect);§}§@Override§public BaneOfProgressEffect copy() {§return new BaneOfProgressEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§int destroyedPermanents = 0;§for (Permanent permanent : game.getBattlefield().getActivePermanents(filter, source.getControllerId(), source.getSourceId(), game)) {§if (permanent.destroy(source.getSourceId(), game, false)) {§destroyedPermanents++;§}§}§if (destroyedPermanents > 0) {§return new AddCountersSourceEffect(CounterType.P1P1.createInstance(destroyedPermanents),true).apply(game, source);§}§return true;§}§}§
public class Borrowing100000Arrows extends CardImpl {§public Borrowing100000Arrows(UUID ownerId) {§super(ownerId, 33, "Borrowing 100,000 Arrows", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{2}{U}");§this.expansionSetCode = "C13";§this.getSpellAbility().addEffect(new Borrowing100000ArrowsEffect());§this.getSpellAbility().addTarget(new TargetOpponent());§}§public Borrowing100000Arrows(final Borrowing100000Arrows card) {§super(card);§}§@Override§public Borrowing100000Arrows copy() {§return new Borrowing100000Arrows(this);§}§}§class Borrowing100000ArrowsEffect extends OneShotEffect {§public Borrowing100000ArrowsEffect() {§super(Outcome.DrawCard);§this.staticText = "Draw a card for each tapped creature target opponent controls";§}§public Borrowing100000ArrowsEffect(final Borrowing100000ArrowsEffect effect) {§super(effect);§}§@Override§public Borrowing100000ArrowsEffect copy() {§return new Borrowing100000ArrowsEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player opponent = game.getPlayer(this.getTargetPointer().getFirst(game, source));§if (opponent != null) {§FilterCreaturePermanent filter = new FilterCreaturePermanent();§filter.add(new TappedPredicate());§filter.add(new ControllerIdPredicate(opponent.getId()));§return new DrawCardSourceControllerEffect(game.getBattlefield().count(filter, source.getSourceId(), source.getControllerId(), game)).apply(game, source);§}§return false;§}§}§
public class BrilliantPlan extends CardImpl {§public BrilliantPlan(UUID ownerId) {§super(ownerId, 34, "Brilliant Plan", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{4}{U}");§this.expansionSetCode = "C13";§this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(3));§}§public BrilliantPlan(final BrilliantPlan card) {§super(card);§}§@Override§public BrilliantPlan copy() {§return new BrilliantPlan(this);§}§}§
public class BroodingSaurian extends CardImpl {§public BroodingSaurian(UUID ownerId) {§super(ownerId, 138, "Brooding Saurian", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{G}{G}");§this.expansionSetCode = "C13";§this.subtype.add("Lizard");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(new BeginningOfEndStepTriggeredAbility(new BroodingSaurianControlEffect(), TargetController.ANY, false));§}§public BroodingSaurian(final BroodingSaurian card) {§super(card);§}§@Override§public BroodingSaurian copy() {§return new BroodingSaurian(this);§}§}§class BroodingSaurianControlEffect extends ContinuousEffectImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent();§static {§filter.add(Predicates.not(new TokenPredicate()));§}§public BroodingSaurianControlEffect() {§super(Duration.EndOfGame, Layer.ControlChangingEffects_2, SubLayer.NA, Outcome.GainControl);§this.staticText = "each player gains control of all nontoken permanents he or she owns";§}§public BroodingSaurianControlEffect(final BroodingSaurianControlEffect effect) {§super(effect);§}§@Override§public BroodingSaurianControlEffect copy() {§return new BroodingSaurianControlEffect(this);§}§@Override§public void init(Ability source, Game game) {§super.init(source, game);§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§for (UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {§FilterPermanent playerFilter = filter.copy();§playerFilter.add(new OwnerIdPredicate(playerId));§for (Permanent permanent :game.getBattlefield().getActivePermanents(playerFilter, playerId, game)) {§affectedObjectList.add(new MageObjectReference(permanent, game));§}§}§}§}§@Override§public boolean apply(Game game, Ability source) {§for (Iterator<MageObjectReference> it = affectedObjectList.iterator(); it.hasNext();) {§Permanent creature = it.next().getPermanent(game);§if (creature != null) {§if (!creature.getControllerId().equals(creature.getOwnerId())) {§creature.changeControllerId(creature.getOwnerId(), game);§}§} else {§it.remove();§}§}§if (affectedObjectList.isEmpty()) {§this.discard();§}§return true;§}§}§
public class CommandTower extends CardImpl {§public CommandTower(UUID ownerId) {§super(ownerId, 281, "Command Tower", Rarity.COMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "C13";§this.addAbility(new CommanderColorIdentityManaAbility());§}§public CommandTower(final CommandTower card) {§super(card);§}§@Override§public CommandTower copy() {§return new CommandTower(this);§}§}§
public class Crawlspace extends CardImpl {§public Crawlspace(UUID ownerId) {§super(ownerId, 240, "Crawlspace", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "C13";§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new ChangeMaxAttackedBySourceEffect(2)));§}§public Crawlspace(final Crawlspace card) {§super(card);§}§@Override§public Crawlspace copy() {§return new Crawlspace(this);§}§}§class ChangeMaxAttackedBySourceEffect extends ContinuousEffectImpl {§private final int maxAttackedBy;§public ChangeMaxAttackedBySourceEffect(int maxAttackedBy) {§super(Duration.WhileOnBattlefield, Outcome.Benefit);§this.maxAttackedBy = maxAttackedBy;§staticText = "No more than two creatures can attack you each combat";§}§public ChangeMaxAttackedBySourceEffect(final ChangeMaxAttackedBySourceEffect effect) {§super(effect);§this.maxAttackedBy = effect.maxAttackedBy;§}§@Override§public ChangeMaxAttackedBySourceEffect copy() {§return new ChangeMaxAttackedBySourceEffect(this);§}§@Override§public boolean apply(Layer layer, SubLayer sublayer, Ability source, Game game) {§switch (layer) {§case RulesEffects:§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§if (controller.getMaxAttackedBy()> maxAttackedBy) {§controller.setMaxAttackedBy(maxAttackedBy);§}§}§break;§}§return false;§}§@Override§public boolean apply(Game game, Ability source) {§return false;§}§@Override§public boolean hasLayer(Layer layer) {§return layer == Layer.RulesEffects;§}§}§
public class CrosissCharm extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("nonblack creature");§static {§filter.add(Predicates.not(new ColorPredicate(ObjectColor.BLACK)));§}§public CrosissCharm(UUID ownerId) {§super(ownerId, 181, "Crosis's Charm", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{U}{B}{R}");§this.expansionSetCode = "C13";§this.getSpellAbility().addEffect(new ReturnToHandTargetEffect());§this.getSpellAbility().addTarget(new TargetPermanent());§Mode mode = new Mode();§mode.getEffects().add(new DestroyTargetEffect(true));§mode.getTargets().add(new TargetCreaturePermanent(filter));§this.getSpellAbility().addMode(mode);§mode = new Mode();§mode.getEffects().add(new DestroyTargetEffect(true));§Target target = new TargetArtifactPermanent();§mode.getTargets().add(target);§this.getSpellAbility().addMode(mode);§}§public CrosissCharm(final CrosissCharm card) {§super(card);§}§@Override§public CrosissCharm copy() {§return new CrosissCharm(this);§}§}§
public class CurseOfChaos extends CardImpl {§public CurseOfChaos(UUID ownerId) {§super(ownerId, 105, "Curse of Chaos", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{R}");§this.expansionSetCode = "C13";§this.subtype.add("Aura");§this.subtype.add("Curse");§TargetPlayer auraTarget = new TargetPlayer();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.DrawCard));§this.addAbility(new EnchantAbility(auraTarget.getTargetName()));§this.addAbility(new CurseOfChaosTriggeredAbility());§}§public CurseOfChaos(final CurseOfChaos card) {§super(card);§}§@Override§public CurseOfChaos copy() {§return new CurseOfChaos(this);§}§}§class CurseOfChaosTriggeredAbility extends TriggeredAbilityImpl {§public CurseOfChaosTriggeredAbility() {§super(Zone.BATTLEFIELD, new CurseOfChaosEffect(), false); §
public class CurseOfShallowGraves extends CardImpl {§public CurseOfShallowGraves(UUID ownerId) {§super(ownerId, 71, "Curse of Shallow Graves", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{B}");§this.expansionSetCode = "C13";§this.subtype.add("Aura");§this.subtype.add("Curse");§TargetPlayer auraTarget = new TargetPlayer();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.Detriment));§this.addAbility(new EnchantAbility(auraTarget.getTargetName()));§this.addAbility(new CurseOfShallowTriggeredAbility());§}§public CurseOfShallowGraves(final CurseOfShallowGraves card) {§super(card);§}§@Override§public CurseOfShallowGraves copy() {§return new CurseOfShallowGraves(this);§}§}§class CurseOfShallowTriggeredAbility extends TriggeredAbilityImpl {§public CurseOfShallowTriggeredAbility() {§super(Zone.BATTLEFIELD, new CurseOfShallowEffect());§}§public CurseOfShallowTriggeredAbility(Effect effect, boolean optional, String text) {§super(Zone.BATTLEFIELD, effect, optional);§}§public CurseOfShallowTriggeredAbility(final CurseOfShallowTriggeredAbility ability) {§super(ability);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.DECLARED_ATTACKERS;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§Permanent enchantment = game.getPermanent(this.getSourceId());§if (enchantment != null§&& enchantment.getAttachedTo() != null§&& game.getCombat().getPlayerDefenders(game).contains(enchantment.getAttachedTo())) {§for (Effect effect : this.getEffects()) {§effect.setTargetPointer(new FixedTarget(game.getCombat().getAttackerId()));§}§return true;§}§return false;§}§@Override§public String getRule() {§return "Whenever a player attacks enchanted player with one or more creatures, that attacking player may put a 2/2 black Zombie creature token onto the battlefield tapped.";§}§@Override§public CurseOfShallowTriggeredAbility copy() {§return new CurseOfShallowTriggeredAbility(this);§}§}§class CurseOfShallowEffect extends OneShotEffect {§public CurseOfShallowEffect() {§super(Outcome.Benefit);§this.staticText = "that attacking player may put a 2/2 black Zombie creature token onto the battlefield tapped";§}§public CurseOfShallowEffect(final CurseOfShallowEffect effect) {§super(effect);§}§@Override§public CurseOfShallowEffect copy() {§return new CurseOfShallowEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player attacker = game.getPlayer(this.getTargetPointer().getFirst(game, source));§if (attacker != null && attacker.chooseUse(outcome, "Put a 2/2 black Zombie creature token onto the battlefield tapped?", source, game)) {§Effect effect = new CreateTokenTargetEffect(new ZombieToken(), new StaticValue(1), true, false);§effect.setTargetPointer(targetPointer);§return effect.apply(game, source);§}§return false;§}§}§
public class CurseOfTheForsaken extends CardImpl {§public CurseOfTheForsaken(UUID ownerId) {§super(ownerId, 8, "Curse of the Forsaken", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{W}");§this.expansionSetCode = "C13";§this.subtype.add("Aura");§this.subtype.add("Curse");§TargetPlayer auraTarget = new TargetPlayer();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.GainLife));§this.addAbility(new EnchantAbility(auraTarget.getTargetName()));§this.addAbility(new CurseOfTheForsakenTriggeredAbility());§}§public CurseOfTheForsaken(final CurseOfTheForsaken card) {§super(card);§}§@Override§public CurseOfTheForsaken copy() {§return new CurseOfTheForsaken(this);§}§}§class CurseOfTheForsakenTriggeredAbility extends TriggeredAbilityImpl {§public CurseOfTheForsakenTriggeredAbility() {§super(Zone.BATTLEFIELD, new GainLifeTargetEffect(1), false);§}§public CurseOfTheForsakenTriggeredAbility(Effect effect, boolean optional, String text) {§super(Zone.BATTLEFIELD, effect, optional);§}§public CurseOfTheForsakenTriggeredAbility(final CurseOfTheForsakenTriggeredAbility ability) {§super(ability);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.ATTACKER_DECLARED;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§Player defender = game.getPlayer(event.getTargetId());§if (defender == null) {§Permanent planeswalker = game.getPermanent(event.getTargetId());§if (planeswalker != null) {§defender = game.getPlayer(planeswalker.getControllerId());§}§}§if (defender != null) {§Permanent enchantment = game.getPermanent(this.getSourceId());§if (enchantment != null§&& enchantment.getAttachedTo() != null§&& enchantment.getAttachedTo().equals(defender.getId())) {§for (Effect effect: this.getEffects()) {§effect.setTargetPointer(new FixedTarget(event.getPlayerId()));§}§return true;§}§}§return false;§}§@Override§public String getRule() {§return "Whenever a creature attacks enchanted player, its controller gains 1 life.";§}§@Override§public CurseOfTheForsakenTriggeredAbility copy() {§return new CurseOfTheForsakenTriggeredAbility(this);§}§}§
public class DarksteelMutation extends CardImpl {§public DarksteelMutation(UUID ownerId) {§super(ownerId, 9, "Darksteel Mutation", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{W}");§this.expansionSetCode = "C13";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD,§new BecomesCreatureAttachedEffect(new DarksteelMutationInsectToken(),§"Enchanted creature is an Insect artifact creature with base power and toughness 0/1 and has indestructible, and it loses all other abilities, card types, and creature types.",§Duration.WhileOnBattlefield, BecomesCreatureAttachedEffect.LoseType.ALL)));§}§public DarksteelMutation(final DarksteelMutation card) {§super(card);§}§@Override§public DarksteelMutation copy() {§return new DarksteelMutation(this);§}§}§class DarksteelMutationInsectToken extends Token {§public DarksteelMutationInsectToken() {§super("Insect", "Insect artifact creature with base power and toughness 0/1");§cardType.add(CardType.ARTIFACT);§cardType.add(CardType.CREATURE);§subtype.add("Insect");§power = new MageInt(0);§toughness = new MageInt(1);§this.addAbility(IndestructibleAbility.getInstance());§}§}§
public class DeadwoodTreefolk extends CardImpl {§private static final FilterCreatureCard filter = new FilterCreatureCard("another creature card from your graveyard");§static {§filter.add(new AnotherCardPredicate());§}§public DeadwoodTreefolk(UUID ownerId) {§super(ownerId, 141, "Deadwood Treefolk", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{5}{G}");§this.expansionSetCode = "C13";§this.subtype.add("Treefolk");§this.power = new MageInt(3);§this.toughness = new MageInt(6);§Ability ability = new EntersBattlefieldAbility(new AddCountersSourceEffect(CounterType.TIME.createInstance(3)));§ability.setRuleVisible(false);§this.addAbility(ability);§this.addAbility(new VanishingUpkeepAbility(3));§this.addAbility(new VanishingSacrificeAbility());§ability = new EntersOrLeavesTheBattlefieldSourceTriggeredAbility(new ReturnFromGraveyardToHandTargetEffect(), false);§Target target = new TargetCardInYourGraveyard(filter);§ability.addTarget(target);§this.addAbility(ability);§}§public DeadwoodTreefolk(final DeadwoodTreefolk card) {§super(card);§}§@Override§public DeadwoodTreefolk copy() {§return new DeadwoodTreefolk(this);§}§}§
public class DecreeOfPain extends CardImpl {§public DecreeOfPain(UUID ownerId) {§super(ownerId, 72, "Decree of Pain", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{6}{B}{B}");§this.expansionSetCode = "C13";§this.getSpellAbility().addEffect(new DecreeOfPainEffect());§this.addAbility(new CyclingAbility(new ManaCostsImpl("{3}{B}{B}")));§Ability ability = new CycleTriggeredAbility(new BoostAllEffect(-2,-2, Duration.EndOfTurn));§this.addAbility(ability);§}§public DecreeOfPain(final DecreeOfPain card) {§super(card);§}§@Override§public DecreeOfPain copy() {§return new DecreeOfPain(this);§}§}§class DecreeOfPainEffect extends OneShotEffect {§public DecreeOfPainEffect() {§super(Outcome.DestroyPermanent);§this.staticText = "Destroy all creatures. They can't be regenerated. Draw a card for each creature destroyed this way";§}§public DecreeOfPainEffect(final DecreeOfPainEffect effect) {§super(effect);§}§@Override§public DecreeOfPainEffect copy() {§return new DecreeOfPainEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§int destroyedCreature = 0;§for(Permanent creature: game.getState().getBattlefield().getActivePermanents(new FilterCreaturePermanent(), controller.getId(), game)) {§if (creature.destroy(source.getSourceId(), game, true)) {§destroyedCreature++;§}§}§if (destroyedCreature > 0) {§controller.drawCards(destroyedCreature, game);§}§return true;§}§return false;§}§}§
public class DeepfireElemental extends CardImpl {§private final UUID originalId;§private static final FilterPermanent filter = new FilterPermanent("artifact or creature with converted mana cost X");§static {§filter.add(Predicates.or(new CardTypePredicate(CardType.ARTIFACT), new CardTypePredicate(CardType.CREATURE)));§}§public DeepfireElemental(UUID ownerId) {§super(ownerId, 185, "Deepfire Elemental", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{B}{R}");§this.expansionSetCode = "C13";§this.subtype.add("Elemental");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DestroyTargetEffect(), new ManaCostsImpl("{X}{X}{1}"));§ability.addTarget(new TargetPermanent(filter));§originalId = ability.getOriginalId();§this.addAbility(ability);§}§@Override§public void adjustTargets(Ability ability, Game game) {§if (ability.getOriginalId().equals(originalId)) {§ability.getTargets().clear();§FilterPermanent newFilter = filter.copy();§newFilter.setMessage(new StringBuilder("artifact or creature with converted mana cost {").append(ability.getManaCostsToPay().getX()).append("}").toString());§newFilter.add(new ConvertedManaCostPredicate(Filter.ComparisonType.Equal, ability.getManaCostsToPay().getX()));§Target target = new TargetPermanent(newFilter);§ability.addTarget(target);§}§}§public DeepfireElemental(final DeepfireElemental card) {§super(card);§this.originalId = card.originalId;§}§@Override§public DeepfireElemental copy() {§return new DeepfireElemental(this);§}§}§
public class DereviEmpyrialTactician extends CardImpl {§public DereviEmpyrialTactician(UUID ownerId) {§super(ownerId, 186, "Derevi, Empyrial Tactician", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{G}{W}{U}");§this.expansionSetCode = "C13";§this.supertype.add("Legendary");§this.subtype.add("Bird");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new DereviEmpyrialTacticianTriggeredAbility(new MayTapOrUntapTargetEffect());§ability.addTarget(new TargetPermanent());§this.addAbility(ability);§this.addAbility(new DereviEmpyrialTacticianAbility());§}§public DereviEmpyrialTactician(final DereviEmpyrialTactician card) {§super(card);§}§@Override§public DereviEmpyrialTactician copy() {§return new DereviEmpyrialTactician(this);§}§}§class DereviEmpyrialTacticianTriggeredAbility extends TriggeredAbilityImpl {§public DereviEmpyrialTacticianTriggeredAbility(Effect effect) {§super(Zone.BATTLEFIELD, effect);§}§public DereviEmpyrialTacticianTriggeredAbility(DereviEmpyrialTacticianTriggeredAbility ability) {§super(ability);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.ENTERS_THE_BATTLEFIELD || event.getType() == EventType.DAMAGED_PLAYER;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (event.getType() == GameEvent.EventType.ENTERS_THE_BATTLEFIELD§&& event.getTargetId().equals(getSourceId())) {§return true;§}§if (event.getType() == GameEvent.EventType.DAMAGED_PLAYER) {§if (((DamagedPlayerEvent) event).isCombatDamage()) {§Permanent creature = game.getPermanent(event.getSourceId());§if (creature != null && creature.getControllerId().equals(controllerId)) {§return true;§}§}§}§return false;§}§@Override§public String getRule() {§return "Whenever {this} enters the battlefield or a creature you control deals combat damage to a player, you may tap or untap target permanent";§}§@Override§public DereviEmpyrialTacticianTriggeredAbility copy() {§return new DereviEmpyrialTacticianTriggeredAbility(this);§}§}§class DereviEmpyrialTacticianAbility extends ActivatedAbilityImpl {§public DereviEmpyrialTacticianAbility() {§super(Zone.COMMAND, new PutCommanderOnBattlefieldEffect(), new ManaCostsImpl("{1}{G}{W}{U}"));§}§@Override§public boolean canActivate(UUID playerId, Game game) {§Zone currentZone = game.getState().getZone(this.getSourceId());§if (currentZone == null || !currentZone.equals(Zone.COMMAND)) {§return false;§}§return super.canActivate(playerId, game);§}§public DereviEmpyrialTacticianAbility(DereviEmpyrialTacticianAbility ability) {§super(ability);§}§@Override§public DereviEmpyrialTacticianAbility copy() {§return new DereviEmpyrialTacticianAbility(this);§}§}§class PutCommanderOnBattlefieldEffect extends OneShotEffect {§public PutCommanderOnBattlefieldEffect() {§super(Outcome.PutCreatureInPlay);§this.staticText = "Put Derevi onto the battlefield from the command zone";§}§public PutCommanderOnBattlefieldEffect(final PutCommanderOnBattlefieldEffect effect) {§super(effect);§}§@Override§public PutCommanderOnBattlefieldEffect copy() {§return new PutCommanderOnBattlefieldEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player == null) {§return false;§}§Card card = game.getCard(source.getSourceId());§if (card != null) {§card.putOntoBattlefield(game, Zone.COMMAND, source.getSourceId(), source.getControllerId());§return true;§}§return false;§}§}§
public class DivinerSpirit extends CardImpl {§public DivinerSpirit(UUID ownerId) {§super(ownerId, 40, "Diviner Spirit", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{U}");§this.expansionSetCode = "C13";§this.subtype.add("Spirit");§this.power = new MageInt(2);§this.toughness = new MageInt(4);§this.addAbility(new DealsDamageToAPlayerTriggeredAbility(new DivinerSpiritEffect(), false, true));§}§public DivinerSpirit(final DivinerSpirit card) {§super(card);§}§@Override§public DivinerSpirit copy() {§return new DivinerSpirit(this);§}§}§class DivinerSpiritEffect extends OneShotEffect {§public DivinerSpiritEffect() {§super(Outcome.DrawCard);§this.staticText = "you and that player each draw that many cards";§}§public DivinerSpiritEffect(final DivinerSpiritEffect effect) {§super(effect);§}§@Override§public DivinerSpiritEffect copy() {§return new DivinerSpiritEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player sourceController = game.getPlayer(source.getControllerId());§Player damagedPlayer = game.getPlayer(this.getTargetPointer().getFirst(game, source));§if (sourceController != null && damagedPlayer != null) {§int amount = (Integer) getValue("damage");§if (amount > 0) {§sourceController.drawCards(amount, game);§damagedPlayer.drawCards(amount, game);§return true;§}§}§return false;§}§}§
public class DjinnOfInfiniteDeceits extends CardImpl {§private static final String rule = "Exchange control of two target nonlegendary creatures";§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("nonlegendary creature");§static {§filter.add(Predicates.not(new SupertypePredicate("Legendary")));§}§public DjinnOfInfiniteDeceits(UUID ownerId) {§super(ownerId, 41, "Djinn of Infinite Deceits", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{U}{U}");§this.expansionSetCode = "C13";§this.subtype.add("Djinn");§this.power = new MageInt(2);§this.toughness = new MageInt(7);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new ActivateIfConditionActivatedAbility(§Zone.BATTLEFIELD,§new ExchangeControlTargetEffect(Duration.EndOfGame, rule),§new TapSourceCost(),§new InvertCondition(new IsPhaseCondition(TurnPhase.COMBAT)));§ability.addTarget(new TargetCreaturePermanent(2,2, filter, false));§this.addAbility(ability);§}§public DjinnOfInfiniteDeceits(final DjinnOfInfiniteDeceits card) {§super(card);§}§@Override§public DjinnOfInfiniteDeceits copy() {§return new DjinnOfInfiniteDeceits(this);§}§}§
public class DromarsCharm extends CardImpl {§public DromarsCharm(UUID ownerId) {§super(ownerId, 187, "Dromar's Charm", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{W}{U}{B}");§this.expansionSetCode = "C13";§this.getSpellAbility().addEffect(new GainLifeEffect(5));§Mode mode = new Mode();§mode.getEffects().add(new CounterTargetEffect());§mode.getTargets().add(new TargetSpell());§this.getSpellAbility().addMode(mode);§mode = new Mode();§mode.getEffects().add(new BoostTargetEffect(-2, -2, Duration.EndOfTurn));§mode.getTargets().add(new TargetCreaturePermanent());§this.getSpellAbility().addMode(mode);§}§public DromarsCharm(final DromarsCharm card) {§super(card);§}§@Override§public DromarsCharm copy() {§return new DromarsCharm(this);§}§}§
public class EndlessCockroaches extends CardImpl {§public EndlessCockroaches(UUID ownerId) {§super(ownerId, 75, "Endless Cockroaches", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{B}{B}");§this.expansionSetCode = "C13";§this.subtype.add("Insect");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new DiesTriggeredAbility(new ReturnToHandSourceEffect()));§}§public EndlessCockroaches(final EndlessCockroaches card) {§super(card);§}§@Override§public EndlessCockroaches copy() {§return new EndlessCockroaches(this);§}§}§
public class EndrekSahrMasterBreeder extends CardImpl {§private static final FilterSpell filter = new FilterSpell("a creature spell");§static {§filter.add(new CardTypePredicate(CardType.CREATURE));§}§public EndrekSahrMasterBreeder(UUID ownerId) {§super(ownerId, 76, "Endrek Sahr, Master Breeder", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{B}");§this.expansionSetCode = "C13";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new SpellCastControllerTriggeredAbility(new EndrekSahrMasterBreederEffect(), filter, false, true));§this.addAbility(new ControlsPermanentsControllerTriggeredAbility(§new FilterCreaturePermanent("Thrull", "seven or more Thrulls"), Filter.ComparisonType.GreaterThan, 6,§new SacrificeSourceEffect()));§}§public EndrekSahrMasterBreeder(final EndrekSahrMasterBreeder card) {§super(card);§}§@Override§public EndrekSahrMasterBreeder copy() {§return new EndrekSahrMasterBreeder(this);§}§}§class EndrekSahrMasterBreederEffect extends OneShotEffect {§public EndrekSahrMasterBreederEffect() {§super(Outcome.PutCreatureInPlay);§this.staticText = "put X 1/1 black Thrull creature tokens onto the battlefield, where X is that spell's converted mana cost";§}§public EndrekSahrMasterBreederEffect(final EndrekSahrMasterBreederEffect effect) {§super(effect);§}§@Override§public EndrekSahrMasterBreederEffect copy() {§return new EndrekSahrMasterBreederEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Spell spell = game.getStack().getSpell(targetPointer.getFirst(game, source));§if (spell == null) {§spell = (Spell) game.getLastKnownInformation(((FixedTarget) getTargetPointer()).getTarget(), Zone.STACK);§}§if (spell != null) {§int cmc = spell.getConvertedManaCost();§if (cmc > 0) {§return new CreateTokenEffect(new ThrullToken(), cmc).apply(game, source);§}§return true;§}§return false;§}§}§
public class EyeOfDoom extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("permanent with a doom counter on it");§static {§filter.add(new CounterPredicate(CounterType.DOOM));§}§public EyeOfDoom(UUID ownerId) {§super(ownerId, 243, "Eye of Doom", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{4}");§this.expansionSetCode = "C13";§this.addAbility(new EntersBattlefieldTriggeredAbility(new EyeOfDoomEffect(),false));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DestroyAllEffect(filter), new GenericManaCost(2));§ability.addCost(new TapSourceCost());§ability.addCost(new SacrificeSourceCost());§this.addAbility(ability);§}§public EyeOfDoom(final EyeOfDoom card) {§super(card);§}§@Override§public EyeOfDoom copy() {§return new EyeOfDoom(this);§}§}§class EyeOfDoomEffect extends OneShotEffect {§public EyeOfDoomEffect() {§super(Outcome.Detriment);§this.staticText = "each player chooses a nonland permanent and puts a doom counter on it";§}§public EyeOfDoomEffect(final EyeOfDoomEffect effect) {§super(effect);§}§@Override§public EyeOfDoomEffect copy() {§return new EyeOfDoomEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§List<Permanent> permanents = new ArrayList<>();§Target target = new TargetNonlandPermanent();§target.setNotTarget(false);§PlayerList playerList = game.getPlayerList().copy();§playerList.setCurrent(game.getActivePlayerId());§Player player = game.getPlayer(game.getActivePlayerId());§do {§target.clearChosen();§if (player.chooseTarget(outcome, target, source, game)) {§Permanent permanent = game.getPermanent(target.getFirstTarget());§if (permanent != null) {§permanents.add(permanent);§game.informPlayers((new StringBuilder(player.getLogName()).append(" chooses ").append(permanent.getName()).toString()));§}§}§player = playerList.getNext(game);§} while (!player.getId().equals(game.getActivePlayerId()));§for (Permanent permanent: permanents) {§permanent.addCounters(CounterType.DOOM.createInstance(), game);§}§return true;§}§}§
public class Famine extends CardImpl {§public Famine(UUID ownerId) {§super(ownerId, 77, "Famine", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{3}{B}{B}");§this.expansionSetCode = "C13";§this.getSpellAbility().addEffect(new DamageEverythingEffect(3));§}§public Famine(final Famine card) {§super(card);§}§@Override§public Famine copy() {§return new Famine(this);§}§}§
public class FellShepherd extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("another creature");§static {§filter.add(new AnotherPredicate());§}§public FellShepherd(UUID ownerId) {§super(ownerId, 78, "Fell Shepherd", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}{B}{B}");§this.expansionSetCode = "C13";§this.subtype.add("Avatar");§this.power = new MageInt(8);§this.toughness = new MageInt(6);§this.addAbility(new DealsCombatDamageToAPlayerTriggeredAbility(new FellShepherdEffect(), true), new FellShepherdWatcher());§SimpleActivatedAbility ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostTargetEffect(-2,-2, Duration.EndOfTurn), new ManaCostsImpl("{B}"));§ability.addCost(new SacrificeTargetCost(new TargetControlledCreaturePermanent(1, 1, filter, false)));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public FellShepherd(final FellShepherd card) {§super(card);§}§@Override§public FellShepherd copy() {§return new FellShepherd(this);§}§}§class FellShepherdWatcher extends Watcher {§private Set<UUID> creatureIds = new HashSet<UUID>();§public FellShepherdWatcher() {§super("YourCreaturesPutToGraveFromBattlefield", WatcherScope.PLAYER);§condition = true;§}§public FellShepherdWatcher(final FellShepherdWatcher watcher) {§super(watcher);§this.creatureIds.addAll(watcher.creatureIds);§}§@Override§public FellShepherdWatcher copy() {§return new FellShepherdWatcher(this);§}§public Set<UUID> getCreaturesIds() {§return creatureIds;§}§@Override§public void watch(GameEvent event, Game game) {§if (event.getType() == EventType.ZONE_CHANGE && ((ZoneChangeEvent) event).isDiesEvent()) {§MageObject card = game.getLastKnownInformation(event.getTargetId(), Zone.BATTLEFIELD);§if (card != null && ((Card)card).getOwnerId().equals(this.controllerId) && card.getCardType().contains(CardType.CREATURE)) {§creatureIds.add(card.getId());§}§}§}§@Override§public void reset() {§super.reset();§creatureIds.clear();§}§}§class FellShepherdEffect extends OneShotEffect {§public FellShepherdEffect() {§super(Outcome.ReturnToHand);§this.staticText = "return to your hand all creature cards that were put into your graveyard from the battlefield this turn";§}§public FellShepherdEffect(final FellShepherdEffect effect) {§super(effect);§}§@Override§public FellShepherdEffect copy() {§return new FellShepherdEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§FellShepherdWatcher watcher = (FellShepherdWatcher) game.getState().getWatchers().get("YourCreaturesPutToGraveFromBattlefield", source.getControllerId());§if (watcher != null) {§StringBuilder sb = new StringBuilder();§for (UUID creatureId : watcher.getCreaturesIds()) {§if (game.getState().getZone(creatureId).equals(Zone.GRAVEYARD)) {§Card card = game.getCard(creatureId);§if (card != null) {§card.moveToZone(Zone.HAND, source.getSourceId(), game, false);§sb.append(" ").append(card.getName());§}§}§}§if (sb.length()> 0) {§sb.insert(0, "Fell Shepherd - returning to hand:");§game.informPlayers(sb.toString());§}§return true;§}§return false;§}§}§
public class Flickerform extends CardImpl {§public Flickerform(UUID ownerId) {§super(ownerId, 12, "Flickerform", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{1}{W}");§this.expansionSetCode = "C13";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.Detriment));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new FlickerformEffect(), new ManaCostsImpl("{2}{W}{W}")));§}§public Flickerform(final Flickerform card) {§super(card);§}§@Override§public Flickerform copy() {§return new Flickerform(this);§}§}§class FlickerformEffect extends OneShotEffect {§private static final FilterEnchantmentPermanent filter = new FilterEnchantmentPermanent();§static {§filter.add(new SubtypePredicate("Aura"));§}§public FlickerformEffect() {§super(Outcome.Detriment);§this.staticText = "Exile enchanted creature and all Auras attached to it. At the beginning of the next end step, return that card to the battlefield under its owner's control. If you do, return the other cards exiled this way to the battlefield under their owners' control attached to that creature";§}§public FlickerformEffect(final FlickerformEffect effect) {§super(effect);§}§@Override§public FlickerformEffect copy() {§return new FlickerformEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent enchantment = game.getPermanent(source.getSourceId());§if (enchantment == null) {§enchantment = (Permanent) game.getLastKnownInformation(source.getSourceId(), Zone.BATTLEFIELD);§}§if (enchantment != null && enchantment.getAttachedTo() != null) {§Permanent enchantedCreature = game.getPermanent(enchantment.getAttachedTo());§if (enchantedCreature != null) {§UUID exileZoneId = UUID.randomUUID();§enchantedCreature.moveToExile(exileZoneId, enchantment.getName(), source.getSourceId(), game);§for (UUID attachementId : enchantedCreature.getAttachments()) {§Permanent attachment = game.getPermanent(attachementId);§if (attachment != null && filter.match(attachment, game)) {§attachment.moveToExile(exileZoneId, enchantment.getName(), source.getSourceId(), game);§}§}§if (!(enchantedCreature instanceof Token)) {§AtTheBeginOfNextEndStepDelayedTriggeredAbility delayedAbility = new AtTheBeginOfNextEndStepDelayedTriggeredAbility(§new FlickerformReturnEffect(enchantedCreature.getId(), exileZoneId));§game.addDelayedTriggeredAbility(delayedAbility, source);§}§return true;§}§}§return false;§}§}§class FlickerformReturnEffect extends OneShotEffect {§private static final FilterCard filterAura = new FilterCard();§static {§filterAura.add(new CardTypePredicate(CardType.ENCHANTMENT));§filterAura.add(new SubtypePredicate("Aura"));§}§private final UUID enchantedCardId;§private final UUID exileZoneId;§public FlickerformReturnEffect(UUID enchantedCardId, UUID exileZoneId) {§super(Outcome.Benefit);§this.enchantedCardId = enchantedCardId;§this.exileZoneId = exileZoneId;§this.staticText = "return that card to the battlefield under its owner's control. If you do, return the other cards exiled this way to the battlefield under their owners' control attached to that creature";§}§public FlickerformReturnEffect(final FlickerformReturnEffect effect) {§super(effect);§this.enchantedCardId = effect.enchantedCardId;§this.exileZoneId = effect.exileZoneId;§}§@Override§public FlickerformReturnEffect copy() {§return new FlickerformReturnEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§ExileZone exileZone = game.getExile().getExileZone(exileZoneId);§Card enchantedCard = exileZone.get(enchantedCardId, game);§if (enchantedCard != null) {§enchantedCard.putOntoBattlefield(game, Zone.EXILED, source.getSourceId(), enchantedCard.getOwnerId());§Permanent newPermanent = game.getPermanent(enchantedCardId);§if (newPermanent != null) {§for (Card enchantment : exileZone.getCards(game)) {§if (filterAura.match(enchantment, game)) {§boolean canTarget = false;§for (Target target : enchantment.getSpellAbility().getTargets()) {§Filter filter = target.getFilter();§if (filter.match(newPermanent, game)) {§canTarget = true;§break;§}§}§if (!canTarget) {§continue;§}§game.getState().setValue("attachTo:" + enchantment.getId(), newPermanent);§}§if (enchantment.putOntoBattlefield(game, Zone.EXILED, source.getSourceId(), enchantment.getOwnerId())) {§if (filterAura.match(enchantment, game)) {§newPermanent.addAttachment(enchantment.getId(), game);§}§}§}§}§return true;§}§return false;§}§}§
public class Foster extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("a creature you control");§static {§filter.add(new ControllerPredicate(TargetController.YOU));§}§public Foster(UUID ownerId) {§super(ownerId, 146, "Foster", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{2}{G}{G}");§this.expansionSetCode = "C13";§Ability ability = new DiesCreatureTriggeredAbility(§new DoIfCostPaid(new FosterEffect(), new GenericManaCost(1)),§false, filter);§this.addAbility(ability);§}§public Foster(final Foster card) {§super(card);§}§@Override§public Foster copy() {§return new Foster(this);§}§}§class FosterEffect extends OneShotEffect {§private static final FilterCreatureCard filter = new FilterCreatureCard();§public FosterEffect() {§super(Outcome.ReturnToHand);§this.staticText = "reveal cards from the top of your library until you reveal a creature card. Put that card into your hand and the rest into your graveyard";§}§public FosterEffect(final FosterEffect effect) {§super(effect);§}§@Override§public FosterEffect copy() {§return new FosterEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§MageObject sourceObject = source.getSourceObject(game);§if (controller == null || sourceObject == null) {§return false;§}§Cards cards = new CardsImpl();§Card cardFound = null;§while (controller.getLibrary().size() > 0) {§Card card = controller.getLibrary().removeFromTop(game);§if (card != null) {§cards.add(card);§if (filter.match(card, game)){§cardFound = card;§break;§}§}§}§if (!cards.isEmpty()) {§controller.revealCards(sourceObject.getName(), cards, game);§if (cardFound != null) {§controller.moveCards(cardFound, Zone.LIBRARY, Zone.HAND, source, game);§cards.remove(cardFound);§}§controller.moveCards(cards, Zone.LIBRARY, Zone.GRAVEYARD, source, game);§}§return true;§}§}§
public class FromTheAshes extends CardImpl {§public FromTheAshes(UUID ownerId) {§super(ownerId, 108, "From the Ashes", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{3}{R}");§this.expansionSetCode = "C13";§this.getSpellAbility().addEffect(new FromTheAshesEffect());§}§public FromTheAshes(final FromTheAshes card) {§super(card);§}§@Override§public FromTheAshes copy() {§return new FromTheAshes(this);§}§}§class FromTheAshesEffect extends OneShotEffect {§private static final FilterLandPermanent filter = new FilterLandPermanent("nonbasic lands");§static {§filter.add(new CardTypePredicate(CardType.LAND));§filter.add(Predicates.not(new SupertypePredicate("Basic")));§}§public FromTheAshesEffect() {§super(Outcome.Benefit);§this.staticText = "Destroy all nonbasic lands. For each land destroyed this way, its controller may search his or her library for a basic land card and put it onto the battlefield. Then each player who searched his or her library this way shuffles it";§}§public FromTheAshesEffect(final FromTheAshesEffect effect) {§super(effect);§}§@Override§public FromTheAshesEffect copy() {§return new FromTheAshesEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Map<UUID, Integer> playerAmount = new HashMap<>();§for (UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {§Player player = game.getPlayer(playerId);§if (player != null) {§int amount = 0;§for (Permanent permanent : game.getBattlefield().getAllActivePermanents(filter, playerId, game)) {§amount++;§permanent.destroy(source.getSourceId(), game, false);§}§playerAmount.put(playerId, amount);§}§}§for(Map.Entry<UUID, Integer> entry : playerAmount.entrySet()) {§Player player = game.getPlayer(entry.getKey());§if (player != null) {§TargetCardInLibrary target = new TargetCardInLibrary(0, entry.getValue(), new FilterBasicLandCard());§if (player.searchLibrary(target, game)) {§if (target.getTargets().size() > 0) {§for (UUID cardId: target.getTargets()) {§Card card = player.getLibrary().getCard(cardId, game);§if (card != null) {§card.putOntoBattlefield(game, Zone.LIBRARY, source.getSourceId(), player.getId(), false);§}§}§}§}§player.shuffleLibrary(game);§}§}§return true;§}§return false;§}§}§
public class HomewardPath extends CardImpl {§public HomewardPath(UUID ownerId) {§super(ownerId, 295, "Homeward Path", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "C13";§this.addAbility(new ColorlessManaAbility());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new HomewardPathControlEffect(), new TapSourceCost()));§}§public HomewardPath(final HomewardPath card) {§super(card);§}§@Override§public HomewardPath copy() {§return new HomewardPath(this);§}§}§class HomewardPathControlEffect extends ContinuousEffectImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent();§public HomewardPathControlEffect() {§super(Duration.EndOfGame, Layer.ControlChangingEffects_2, SubLayer.NA, Outcome.GainControl);§this.staticText = "Each player gains control of all creatures he or she owns";§}§public HomewardPathControlEffect(final HomewardPathControlEffect effect) {§super(effect);§}§@Override§public HomewardPathControlEffect copy() {§return new HomewardPathControlEffect(this);§}§@Override§public void init(Ability source, Game game) {§super.init(source, game);§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§for (UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {§FilterPermanent playerFilter = filter.copy();§playerFilter.add(new OwnerIdPredicate(playerId));§for (Permanent permanent :game.getBattlefield().getActivePermanents(playerFilter, playerId, game)) {§affectedObjectList.add(new MageObjectReference(permanent, game));§}§}§}§}§@Override§public boolean apply(Game game, Ability source) {§for (Iterator<MageObjectReference> it = affectedObjectList.iterator(); it.hasNext();) {§Permanent creature = it.next().getPermanent(game);§if (creature != null) {§if (!creature.getControllerId().equals(creature.getOwnerId())) {§creature.changeControllerId(creature.getOwnerId(), game);§}§} else {§it.remove();§}§}§if (affectedObjectList.isEmpty()) {§this.discard();§}§return true;§}§}§
public class HoodedHorror extends CardImpl {§public HoodedHorror(UUID ownerId) {§super(ownerId, 80, "Hooded Horror", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{B}");§this.expansionSetCode = "C13";§this.subtype.add("Horror");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(new SimpleEvasionAbility(new HoodedHorrorCantBeBlockedEffect()));§}§public HoodedHorror(final HoodedHorror card) {§super(card);§}§@Override§public HoodedHorror copy() {§return new HoodedHorror(this);§}§}§class HoodedHorrorCantBeBlockedEffect extends RestrictionEffect {§private final static FilterCreaturePermanent filter = new FilterCreaturePermanent();§public HoodedHorrorCantBeBlockedEffect() {§super(Duration.WhileOnBattlefield);§staticText = "{this} can't be blocked as long as defending player controls the most creatures or is tied for the most";§}§public HoodedHorrorCantBeBlockedEffect(final HoodedHorrorCantBeBlockedEffect effect) {§super(effect);§}§@Override§public boolean applies(Permanent permanent, Ability source, Game game) {§if (permanent.getId().equals(source.getSourceId()) && permanent.isAttacking()) {§return true;§}§return false;§}§@Override§public boolean canBeBlocked(Permanent attacker, Permanent blocker, Ability source, Game game) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§int maxCreatures = 0;§UUID playerIdWithMax = null;§for (UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {§int creatures = game.getBattlefield().countAll(filter, playerId, game);§if (creatures > maxCreatures || (creatures == maxCreatures && playerId.equals(blocker.getControllerId())) ) {§maxCreatures = creatures;§playerIdWithMax = playerId;§}§}§if (playerIdWithMax != null && playerIdWithMax.equals(blocker.getControllerId())) {§return false;§}§}§return true;§}§@Override§public HoodedHorrorCantBeBlockedEffect copy() {§return new HoodedHorrorCantBeBlockedEffect(this);§}§}§
public class HuaTuoHonoredPhysician extends CardImpl {§public HuaTuoHonoredPhysician(UUID ownerId) {§super(ownerId, 149, "Hua Tuo, Honored Physician", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{G}{G}");§this.expansionSetCode = "C13";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§Ability ability = new ActivateIfConditionActivatedAbility(Zone.BATTLEFIELD, new PutOnLibraryTargetEffect(true), new TapSourceCost(), MyTurnBeforeAttackersDeclaredCondition.getInstance());§ability.addTarget(new TargetCardInYourGraveyard(new FilterCreatureCard("creature card from your graveyard")));§this.addAbility(ability);§}§public HuaTuoHonoredPhysician(final HuaTuoHonoredPhysician card) {§super(card);§}§@Override§public HuaTuoHonoredPhysician copy() {§return new HuaTuoHonoredPhysician(this);§}§}§
public class HullBreach extends CardImpl {§public HullBreach(UUID ownerId) {§super(ownerId, 193, "Hull Breach", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{R}{G}");§this.expansionSetCode = "C13";§this.getSpellAbility().addEffect(new DestroyTargetEffect());§Target target = new TargetArtifactPermanent();§this.getSpellAbility().addTarget(target);§Mode mode = new Mode();§mode.getEffects().add(new DestroyTargetEffect());§target = new TargetPermanent(new FilterEnchantmentPermanent());§mode.getTargets().add(target);§this.getSpellAbility().addMode(mode);§mode = new Mode();§Effect effect = new DestroyTargetEffect(false, true);§effect.setText("destroy target artifact and target enchantment");§mode.getEffects().add(effect);§mode.getTargets().add(new TargetArtifactPermanent());§mode.getTargets().add(new TargetEnchantmentPermanent());§this.getSpellAbility().addMode(mode);§}§public HullBreach(final HullBreach card) {§super(card);§}§@Override§public HullBreach copy() {§return new HullBreach(this);§}§}§
public class IllusionistsGambit extends CardImpl {§public IllusionistsGambit(UUID ownerId) {§super(ownerId, 47, "Illusionist's Gambit", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{2}{U}{U}");§this.expansionSetCode = "C13";§this.addAbility(new CastOnlyDuringPhaseStepSourceAbility(PhaseStep.DECLARE_BLOCKERS, OnOpponentsTurnCondition.getInstance()));§this.getSpellAbility().addEffect(new IllusionistsGambitRemoveFromCombatEffect());§}§public IllusionistsGambit(final IllusionistsGambit card) {§super(card);§}§@Override§public IllusionistsGambit copy() {§return new IllusionistsGambit(this);§}§}§class IllusionistsGambitRemoveFromCombatEffect extends OneShotEffect {§public IllusionistsGambitRemoveFromCombatEffect() {§super(Outcome.Benefit);§this.staticText = "Remove all attacking creatures from combat and untap them. After this phase, there is an additional combat phase. Each of those creatures attacks that combat if able. They can't attack you or a planeswalker you control that combat";§}§public IllusionistsGambitRemoveFromCombatEffect(final IllusionistsGambitRemoveFromCombatEffect effect) {§super(effect);§}§@Override§public IllusionistsGambitRemoveFromCombatEffect copy() {§return new IllusionistsGambitRemoveFromCombatEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§List<UUID> attackers = game.getCombat().getAttackers();§for (UUID attackerId : attackers) {§Permanent creature = game.getPermanent(attackerId);§if (creature != null) {§creature.removeFromCombat(game);§creature.untap(game);§}§}§if (!attackers.isEmpty()) {§Phase phase = game.getTurn().getPhase();§game.getState().getTurnMods().add(new TurnMod(game.getActivePlayerId(), TurnPhase.COMBAT, null, false));§ContinuousEffect effect = new IllusionistsGambitRequirementEffect(attackers, phase);§game.addEffect(effect, source);§effect = new IllusionistsGambitRestrictionEffect(attackers, phase);§game.addEffect(effect, source);§}§return true;§}§}§class IllusionistsGambitRequirementEffect extends RequirementEffect {§private List attackers;§private Phase phase;§public IllusionistsGambitRequirementEffect(List attackers, Phase phase) {§super(Duration.Custom);§this.attackers = attackers;§this.phase = phase;§this.staticText = "Each of those creatures attacks that combat if able";§}§public IllusionistsGambitRequirementEffect(final IllusionistsGambitRequirementEffect effect) {§super(effect);§this.attackers = effect.attackers;§this.phase = effect.phase;§}§@Override§public IllusionistsGambitRequirementEffect copy() {§return new IllusionistsGambitRequirementEffect(this);§}§@Override§public boolean applies(Permanent permanent, Ability source, Game game) {§if (attackers.contains(permanent.getId())) {§return game.getOpponents(permanent.getControllerId()).size() > 1;§}§return false;§}§@Override§public boolean isInactive(Ability source, Game game) {§if (game.getTurn().getStepType().equals(PhaseStep.END_COMBAT)) {§if (!game.getTurn().getPhase().equals(phase)) {§return true;§}§}§return false;§}§@Override§public boolean mustAttack(Game game) {§return true;§}§@Override§public boolean mustBlock(Game game) {§return false;§}§}§class IllusionistsGambitRestrictionEffect extends RestrictionEffect {§private final List attackers;§private final Phase phase;§public IllusionistsGambitRestrictionEffect(List attackers, Phase phase) {§super(Duration.Custom, Outcome.Benefit);§this.attackers = attackers;§this.phase = phase;§staticText = "They can't attack you or a planeswalker you control that combat";§}§public IllusionistsGambitRestrictionEffect(final IllusionistsGambitRestrictionEffect effect) {§super(effect);§this.attackers = effect.attackers;§this.phase = effect.phase;§}§@Override§public boolean applies(Permanent permanent, Ability source, Game game) {§return attackers.contains(permanent.getId());§}§@Override§public boolean isInactive(Ability source, Game game) {§if (game.getTurn().getStepType().equals(PhaseStep.END_COMBAT)) {§if (!game.getTurn().getPhase().equals(phase)) {§return true;§}§}§return false;§}§@Override§public boolean canAttack(UUID defenderId, Ability source, Game game) {§if (defenderId.equals(source.getControllerId())) {§return false;§}§Permanent permanent = game.getPermanent(defenderId);§if (permanent != null && permanent.getControllerId().equals(source.getControllerId())§&& permanent.getCardType().contains(CardType.PLANESWALKER)) {§return false;§}§return true;§}§@Override§public IllusionistsGambitRestrictionEffect copy() {§return new IllusionistsGambitRestrictionEffect(this);§}§}§
public class IncendiaryCommand extends CardImpl {§public IncendiaryCommand(UUID ownerId) {§super(ownerId, 113, "Incendiary Command", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{3}{R}{R}");§this.expansionSetCode = "C13";§this.getSpellAbility().getModes().setMinModes(2);§this.getSpellAbility().getModes().setMaxModes(2);§this.getSpellAbility().addEffect(new DamageTargetEffect(4));§this.getSpellAbility().addTarget(new TargetPlayer());§Mode mode = new Mode();§mode.getEffects().add(new DamageAllEffect(2, new FilterCreaturePermanent()));§this.getSpellAbility().getModes().addMode(mode);§mode = new Mode();§mode.getEffects().add(new DestroyTargetEffect());§mode.getTargets().add(new TargetNonBasicLandPermanent());§this.getSpellAbility().getModes().addMode(mode);§mode = new Mode();§mode.getEffects().add(new IncendiaryCommandDrawEffect());§this.getSpellAbility().getModes().addMode(mode);§}§public IncendiaryCommand(final IncendiaryCommand card) {§super(card);§}§@Override§public IncendiaryCommand copy() {§return new IncendiaryCommand(this);§}§}§class IncendiaryCommandDrawEffect extends OneShotEffect {§public IncendiaryCommandDrawEffect() {§super(Outcome.Detriment);§this.staticText = "each player discards all the cards in his or her hand, then draws that many cards";§}§public IncendiaryCommandDrawEffect(final IncendiaryCommandDrawEffect effect) {§super(effect);§}§@Override§public IncendiaryCommandDrawEffect copy() {§return new IncendiaryCommandDrawEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Map<UUID, Integer> cardsToDraw = new HashMap<>();§for (UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {§Player player = game.getPlayer(playerId);§if (player != null) {§int cardsInHand = player.getHand().size();§player.discard(cardsInHand, false, source, game);§if (cardsInHand > 0) {§cardsToDraw.put(playerId, cardsInHand);§}§}§}§for (UUID playerId : cardsToDraw.keySet()) {§Player player = game.getPlayer(playerId);§if (player != null) {§player.drawCards(cardsToDraw.get(playerId), game);§}§}§return true;§}§return false;§}§}§
public class JelevaNephaliasScourge extends CardImpl {§public JelevaNephaliasScourge(UUID ownerId) {§super(ownerId, 194, "Jeleva, Nephalia's Scourge", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{1}{U}{B}{R}");§this.expansionSetCode = "C13";§this.supertype.add("Legendary");§this.subtype.add("Vampire");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new EntersBattlefieldTriggeredAbility(new JelevaNephaliasScourgeEffect(), false));§this.addAbility(new AttacksTriggeredAbility(new JelevaNephaliasCastEffect(), false), new JelevaNephaliasWatcher());§}§public JelevaNephaliasScourge(final JelevaNephaliasScourge card) {§super(card);§}§@Override§public JelevaNephaliasScourge copy() {§return new JelevaNephaliasScourge(this);§}§}§class JelevaNephaliasScourgeEffect extends OneShotEffect {§public JelevaNephaliasScourgeEffect() {§super(Outcome.Benefit);§this.staticText = "each player exiles the top X cards of his or her library, where X is the amount of mana spent to cast {this}";§}§public JelevaNephaliasScourgeEffect(final JelevaNephaliasScourgeEffect effect) {§super(effect);§}§@Override§public JelevaNephaliasScourgeEffect copy() {§return new JelevaNephaliasScourgeEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§Card sourceCard = game.getCard(source.getSourceId());§if (controller != null && sourceCard != null) {§JelevaNephaliasWatcher watcher = (JelevaNephaliasWatcher) game.getState().getWatchers().get("ManaPaidToCastJelevaNephalias", source.getSourceId());§if (watcher != null) {§int xValue = watcher.getManaSpentToCastLastTime(sourceCard.getZoneChangeCounter(game) - 1);§if (xValue > 0) {§for (UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {§Player player = game.getPlayer(playerId);§if (player != null) {§int cardsToExile = Math.min(player.getLibrary().size(), xValue);§for (int i = 0; i < cardsToExile; i++) {§Card card = player.getLibrary().removeFromTop(game);§if (card != null) {§card.moveToExile(CardUtil.getCardExileZoneId(game, source), sourceCard.getName(), source.getSourceId(), game);§}§}§}§}§}§return true;§}§}§return false;§}§}§class JelevaNephaliasCastEffect extends OneShotEffect {§public JelevaNephaliasCastEffect() {§super(Outcome.PlayForFree);§this.staticText = "you may cast an instant or sorcery card exiled with it without paying its mana cost";§}§public JelevaNephaliasCastEffect(final JelevaNephaliasCastEffect effect) {§super(effect);§}§@Override§public JelevaNephaliasCastEffect copy() {§return new JelevaNephaliasCastEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§if (controller.chooseUse(outcome, "Cast an instant or sorcery from exile?", source, game)) {§TargetCardInExile target = new TargetCardInExile(new FilterInstantOrSorceryCard(), CardUtil.getCardExileZoneId(game, source));§if (controller.choose(Outcome.PlayForFree, game.getExile().getExileZone(CardUtil.getCardExileZoneId(game, source)), target, game)) {§Card card = game.getCard(target.getFirstTarget());§if (card != null) {§game.getExile().removeCard(card, game);§return controller.cast(card.getSpellAbility(), game, true);§}§}§}§return true;§}§return false;§}§}§class JelevaNephaliasWatcher extends Watcher {§private final Map<Integer, Integer> manaSpendToCast = new HashMap<>(); §
public class KherKeep extends CardImpl {§public KherKeep(UUID ownerId) {§super(ownerId, 303, "Kher Keep", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "C13";§this.supertype.add("Legendary");§this.addAbility(new ColorlessManaAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new CreateTokenEffect(new KherKeepKoboldToken()), new ManaCostsImpl("{1}{R}"));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§}§public KherKeep(final KherKeep card) {§super(card);§}§@Override§public KherKeep copy() {§return new KherKeep(this);§}§}§class KherKeepKoboldToken extends Token {§public KherKeepKoboldToken() {§super("Kobolds of Kher Keep", "0/1 red Kobold creature token named Kobolds of Kher Keep");§cardType.add(CardType.CREATURE);§color.setRed(true);§subtype.add("Kobold");§power = new MageInt(0);§toughness = new MageInt(1);§}§}§
public class KirtarsWrath extends CardImpl {§public KirtarsWrath(UUID ownerId) {§super(ownerId, 15, "Kirtar's Wrath", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{4}{W}{W}");§this.expansionSetCode = "C13";§this.getSpellAbility().addEffect(new ConditionalOneShotEffect(§new KirtarsWrathEffect(),§new DestroyAllEffect(new FilterCreaturePermanent("all creatures"), true),§new CardsInControllerGraveCondition(7),§"Destroy all creatures. They can't be regenerated.<br/><br/><i>Threshold</i> - If seven or more cards are in your graveyard, instead destroy all creatures, then put two 1/1 white Spirit creature tokens with flying onto the battlefield. Creatures destroyed this way can't be regenerated"));§}§public KirtarsWrath(final KirtarsWrath card) {§super(card);§}§@Override§public KirtarsWrath copy() {§return new KirtarsWrath(this);§}§}§class KirtarsWrathEffect extends OneShotEffect {§public KirtarsWrathEffect() {§super(Outcome.DestroyPermanent);§this.staticText = "destroy all creatures, then put two 1/1 white Spirit creature tokens with flying onto the battlefield. Creatures destroyed this way can't be regenerated";§}§public KirtarsWrathEffect(final KirtarsWrathEffect effect) {§super(effect);§}§@Override§public KirtarsWrathEffect copy() {§return new KirtarsWrathEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§new DestroyAllEffect(new FilterCreaturePermanent("all creatures"), true).apply(game, source);§return new CreateTokenEffect(new SpiritWhiteToken(), 2).apply(game, source);§}§}§
public class KongmingSleepingDragon extends CardImpl {§public KongmingSleepingDragon(UUID ownerId) {§super(ownerId, 16, "Kongming, 'Sleeping Dragon'", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{W}{W}");§this.expansionSetCode = "C13";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Advisor");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostControlledEffect(1,1,Duration.WhileOnBattlefield, true)));§}§public KongmingSleepingDragon(final KongmingSleepingDragon card) {§super(card);§}§@Override§public KongmingSleepingDragon copy() {§return new KongmingSleepingDragon(this);§}§}§
public class LeafdrakeRoost extends CardImpl {§public LeafdrakeRoost(UUID ownerId) {§super(ownerId, 196, "Leafdrake Roost", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{3}{G}{U}");§this.expansionSetCode = "C13";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetLandPermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.PutCreatureInPlay));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§Ability abilityToGain = new SimpleActivatedAbility(Zone.BATTLEFIELD, new CreateTokenEffect(new LeafdrakeRoostDrakeToken()), new ManaCostsImpl("{G}{U}"));§abilityToGain.addCost(new TapSourceCost());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(abilityToGain, AttachmentType.AURA, Duration.WhileOnBattlefield,§"Enchanted land has \"{G}{U}, {t}: Put a 2/2 green and blue Drake creature token with flying onto the battlefield.\"")));§}§public LeafdrakeRoost(final LeafdrakeRoost card) {§super(card);§}§@Override§public LeafdrakeRoost copy() {§return new LeafdrakeRoost(this);§}§}§class LeafdrakeRoostDrakeToken extends Token {§public LeafdrakeRoostDrakeToken() {§super("Drake", "2/2 green and blue Drake creature token with flying");§cardType.add(CardType.CREATURE);§color.setGreen(true);§color.setBlue(true);§subtype.add("Drake");§power = new MageInt(2);§toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§}§}§
public class LeoninBladetrap extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("attacking creature without flying");§static {§filter.add(new AttackingPredicate());§filter.add(Predicates.not(new AbilityPredicate(FlyingAbility.class)));§}§public LeoninBladetrap(UUID ownerId) {§super(ownerId, 245, "Leonin Bladetrap", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "C13";§this.addAbility(FlashAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageAllEffect(2, filter), new GenericManaCost(2));§ability.addCost(new SacrificeSourceCost());§this.addAbility(ability);§}§public LeoninBladetrap(final LeoninBladetrap card) {§super(card);§}§@Override§public LeoninBladetrap copy() {§return new LeoninBladetrap(this);§}§}§
public class LimDulsVault extends CardImpl {§public LimDulsVault(UUID ownerId) {§super(ownerId, 197, "Lim-Dul's Vault", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{U}{B}");§this.expansionSetCode = "C13";§this.getSpellAbility().addEffect(new LimDulsVaultEffect());§}§public LimDulsVault(final LimDulsVault card) {§super(card);§}§@Override§public LimDulsVault copy() {§return new LimDulsVault(this);§}§}§class LimDulsVaultEffect extends OneShotEffect {§static final private String textTop = "card to put on your library (last chosen will be on top)";§static final private String textBottom = "card to put on bottom of your library (last chosen will be on bottom)";§public LimDulsVaultEffect() {§super(Outcome.Benefit);§this.staticText = "Look at the top five cards of your library. As many times as you choose, you may pay 1 life, put those cards on the bottom of your library in any order, then look at the top five cards of your library. Then shuffle your library and put the last cards you looked at this way on top of it in any order";§}§public LimDulsVaultEffect(final LimDulsVaultEffect effect) {§super(effect);§}§@Override§public LimDulsVaultEffect copy() {§return new LimDulsVaultEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player == null) {§return false;§}§boolean doAgain;§do {§Cards cards = new CardsImpl();§int count = Math.min(player.getLibrary().size(), 5);§for (int i = 0; i < count; i++) {§Card card = player.getLibrary().removeFromTop(game);§if (card != null) {§cards.add(card);§}§}§player.lookAtCards("Lim-Dul's Vault", cards, game);§doAgain = player.chooseUse(outcome, "Pay 1 life and look at the next 5 cards?", source, game);§if (doAgain) {§player.loseLife(1, game);§} else {§player.shuffleLibrary(game);§}§TargetCard target = new TargetCard(Zone.LIBRARY, new FilterCard(doAgain ? textBottom : textTop));§while (player.canRespond() && cards.size() > 1) {§player.choose(Outcome.Neutral, cards, target, game);§Card card = cards.get(target.getFirstTarget(), game);§if (card != null) {§cards.remove(card);§card.moveToZone(Zone.LIBRARY, source.getSourceId(), game, !doAgain);§}§target.clearChosen();§}§if (cards.size() == 1) {§Card card = cards.get(cards.iterator().next(), game);§card.moveToZone(Zone.LIBRARY, source.getSourceId(), game, !doAgain);§}§} while (doAgain);§return true;§}§}§
public class LuXunScholarGeneral extends CardImpl {§public LuXunScholarGeneral(UUID ownerId) {§super(ownerId, 49, "Lu Xun, Scholar General", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{U}{U}");§this.expansionSetCode = "C13";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(1);§this.toughness = new MageInt(3);§this.addAbility(HorsemanshipAbility.getInstance());§this.addAbility(new DealsDamageToOpponentTriggeredAbility(new DrawCardSourceControllerEffect(1), true));§}§public LuXunScholarGeneral(final LuXunScholarGeneral card) {§super(card);§}§@Override§public LuXunScholarGeneral copy() {§return new LuXunScholarGeneral(this);§}§}§
public class MagusOfTheArena extends CardImpl {§public MagusOfTheArena(UUID ownerId) {§super(ownerId, 115, "Magus of the Arena", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{R}{R}");§this.expansionSetCode = "C13";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new MagusOfTheArenaEffect(), new GenericManaCost(3));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetControlledCreaturePermanent());§ability.addTarget(new TargetOpponentsChoicePermanent(new FilterControlledCreaturePermanent()));§this.addAbility(ability);§}§public MagusOfTheArena(final MagusOfTheArena card) {§super(card);§}§@Override§public MagusOfTheArena copy() {§return new MagusOfTheArena(this);§}§}§class MagusOfTheArenaEffect extends OneShotEffect {§MagusOfTheArenaEffect() {§super(Outcome.Benefit);§this.staticText = "Tap target creature you control and target creature of an opponent's choice he or she controls. Those creatures fight each other";§}§MagusOfTheArenaEffect(final MagusOfTheArenaEffect effect) {§super(effect);§}§@Override§public MagusOfTheArenaEffect copy() {§return new MagusOfTheArenaEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent creature = game.getPermanent(source.getFirstTarget());§if (creature != null) {§creature.tap(game);§}§creature = game.getPermanent(source.getTargets().get(1).getFirstTarget());§if (creature != null) {§creature.tap(game);§}§return new FightTargetsEffect().apply(game, source);§}§}§
public class MarathWillOfTheWild extends CardImpl {§public MarathWillOfTheWild(UUID ownerId) {§super(ownerId, 198, "Marath, Will of the Wild", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{R}{G}{W}");§this.expansionSetCode = "C13";§this.supertype.add("Legendary");§this.subtype.add("Elemental");§this.subtype.add("Beast");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§Effect effect = new AddCountersSourceEffect(CounterType.P1P1.createInstance(0), new ManaSpentToCastCount(), true);§effect.setText("with a number of +1/+1 counters on it equal to the amount of mana spent to cast it");§this.addAbility(new EntersBattlefieldAbility(effect));§effect = new AddCountersTargetEffect(CounterType.P1P1.createInstance(0), new ManacostVariableValue());§effect.setText("Put X +1/+1 counters on target creature");§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new ManaCostsImpl("{X}"));§ability.addCost(new MarathWillOfTheWildRemoveCountersCost());§ability.addTarget(new TargetCreaturePermanent());§Mode mode = new Mode();§mode.getEffects().add(new DamageTargetEffect(new ManacostVariableValue()));§mode.getTargets().add(new TargetCreatureOrPlayer());§ability.addMode(mode);§mode = new Mode();§mode.getEffects().add(new MarathWillOfTheWildCreateTokenEffect());§ability.addMode(mode);§for (VariableCost cost: ability.getManaCosts().getVariableCosts()) {§if (cost instanceof VariableManaCost) {§((VariableManaCost) cost).setMinX(1);§break;§}§}§this.addAbility(ability);§}§@Override§public void adjustChoices(Ability ability, Game game) {§if (ability instanceof SimpleActivatedAbility && ability.getModes().size() == 3) {§Permanent sourcePermanent = game.getPermanent(ability.getSourceId());§if (sourcePermanent != null) {§int amount = sourcePermanent.getCounters().getCount(CounterType.P1P1);§if (amount > 0) {§for (VariableCost cost: ability.getManaCostsToPay().getVariableCosts()) {§if (cost instanceof VariableManaCost) {§((VariableManaCost) cost).setMaxX(amount);§break;§}§}§}§}§}§}§public MarathWillOfTheWild(final MarathWillOfTheWild card) {§super(card);§}§@Override§public MarathWillOfTheWild copy() {§return new MarathWillOfTheWild(this);§}§}§class MarathWillOfTheWildCreateTokenEffect extends OneShotEffect {§public MarathWillOfTheWildCreateTokenEffect() {§super(Outcome.PutCreatureInPlay);§staticText = "put an X/X green Elemental creature token onto the battlefield";§}§public MarathWillOfTheWildCreateTokenEffect(final MarathWillOfTheWildCreateTokenEffect effect) {§super(effect);§}§@Override§public MarathWillOfTheWildCreateTokenEffect copy() {§return new MarathWillOfTheWildCreateTokenEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§int amount = new ManacostVariableValue().calculate(game, source, this);§Token token = new MarathWillOfTheWildElementalToken();§token.getPower().initValue(amount);§token.getToughness().initValue(amount);§token.putOntoBattlefield(1, game, source.getSourceId(), source.getControllerId());§return true;§}§return false;§}§}§class MarathWillOfTheWildElementalToken extends Token {§public MarathWillOfTheWildElementalToken() {§super("Elemental", "X/X green Elemental creature token");§cardType.add(CardType.CREATURE);§subtype.add("Elemental");§color.setGreen(true);§power = new MageInt(0);§toughness = new MageInt(0);§}§}§class MarathWillOfTheWildRemoveCountersCost extends CostImpl {§public MarathWillOfTheWildRemoveCountersCost() {§this.text = "Remove X +1/+1 counters from Marath";§}§public MarathWillOfTheWildRemoveCountersCost(MarathWillOfTheWildRemoveCountersCost cost) {§super(cost);§}§@Override§public boolean canPay(Ability ability, UUID sourceId, UUID controllerId, Game game) {§Permanent permanent = game.getPermanent(sourceId);§if (permanent != null && permanent.getCounters().getCount(CounterType.P1P1) > 0) {§return true;§}§return false;§}§@Override§public boolean pay(Ability ability, Game game, UUID sourceId, UUID controllerId, boolean noMana, Cost costToPay) {§int amount = new ManacostVariableValue().calculate(game, ability, null);§Permanent permanent = game.getPermanent(sourceId);§if (permanent != null && permanent.getCounters().getCount(CounterType.P1P1) >= amount) {§permanent.removeCounters(CounterType.P1P1.getName(), amount, game);§this.paid = true;§}§return paid;§}§@Override§public MarathWillOfTheWildRemoveCountersCost copy() {§return new MarathWillOfTheWildRemoveCountersCost(this);§}§}§
public class Mirari extends CardImpl {§public Mirari(UUID ownerId) {§super(ownerId, 246, "Mirari", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{5}");§this.expansionSetCode = "C13";§this.supertype.add("Legendary");§this.addAbility(new MirariTriggeredAbility());§}§public Mirari(final Mirari card) {§super(card);§}§@Override§public Mirari copy() {§return new Mirari(this);§}§}§class MirariTriggeredAbility extends TriggeredAbilityImpl {§private static final FilterSpell filter = new FilterSpell();§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.INSTANT),§new CardTypePredicate(CardType.SORCERY)));§}§MirariTriggeredAbility() {§super(Zone.BATTLEFIELD, new DoIfCostPaid(new CopyTargetSpellEffect(), new GenericManaCost(3)), false);§this.addTarget(new TargetSpell(filter));§}§MirariTriggeredAbility(final MirariTriggeredAbility ability) {§super(ability);§}§@Override§public MirariTriggeredAbility copy() {§return new MirariTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.SPELL_CAST;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (event.getPlayerId().equals(this.getControllerId())) {§Spell spell = game.getStack().getSpell(event.getTargetId());§if (isControlledInstantOrSorcery(spell)) {§for (Effect effect : getEffects()) {§effect.setTargetPointer(new FixedTarget(spell.getId()));§}§return true;§}§}§return false;§}§private boolean isControlledInstantOrSorcery(Spell spell) {§return spell != null§&& (spell.getControllerId().equals(this.getControllerId()))§&& (spell.getCardType().contains(CardType.INSTANT) || spell.getCardType().contains(CardType.SORCERY));§}§@Override§public String getRule() {§return "Whenever you cast an instant or sorcery spell, you may pay {3}. If you do, copy that spell. You may choose new targets for the copy.";§}§}§
public class MoltenSlagheap extends CardImpl {§public MoltenSlagheap(UUID ownerId) {§super(ownerId, 306, "Molten Slagheap", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "C13";§this.addAbility(new ColorlessManaAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new AddCountersSourceEffect(CounterType.STORAGE.createInstance()),new GenericManaCost(1));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,§new AddManaInAnyCombinationEffect(new RemovedCountersForCostValue(), ColoredManaSymbol.B, ColoredManaSymbol.R),§new GenericManaCost(1));§ability.addCost(new RemoveVariableCountersSourceCost(CounterType.STORAGE.createInstance()));§this.addAbility(ability);§}§public MoltenSlagheap(final MoltenSlagheap card) {§super(card);§}§@Override§public MoltenSlagheap copy() {§return new MoltenSlagheap(this);§}§}§
public class MysticBarrier extends CardImpl {§public static final String ALLOW_ATTACKING_LEFT = "Allow attacking left";§public static final String ALLOW_ATTACKING_RIGHT = "Allow attacking right";§public MysticBarrier(UUID ownerId) {§super(ownerId, 18, "Mystic Barrier", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{4}{W}");§this.expansionSetCode = "C13";§this.addAbility(new MysticBarrierTriggeredAbility());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new MysticBarrierReplacementEffect()));§}§public MysticBarrier(final MysticBarrier card) {§super(card);§}§@Override§public MysticBarrier copy() {§return new MysticBarrier(this);§}§}§class MysticBarrierTriggeredAbility extends TriggeredAbilityImpl {§public MysticBarrierTriggeredAbility() {§super(Zone.BATTLEFIELD, new MysticBarrierChooseEffect(), false);§}§public MysticBarrierTriggeredAbility(final MysticBarrierTriggeredAbility ability) {§super(ability);§}§@Override§public MysticBarrierTriggeredAbility copy() {§return new MysticBarrierTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType().equals(EventType.ENTERS_THE_BATTLEFIELD) || event.getType().equals(EventType.UPKEEP_STEP_PRE);§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (event.getType().equals(EventType.ENTERS_THE_BATTLEFIELD)) {§return event.getTargetId().equals(this.getSourceId());§} else {§return event.getPlayerId().equals(this.getControllerId());§}§}§@Override§public String getRule() {§return "When {this} enters the battlefield or at the beginning of your upkeep, " + super.getRule();§}§}§class MysticBarrierChooseEffect extends OneShotEffect {§public static final String[] SET_VALUES = new String[] { MysticBarrier.ALLOW_ATTACKING_LEFT, MysticBarrier.ALLOW_ATTACKING_RIGHT };§public static final Set<String> CHOICES = new HashSet<>(Arrays.asList(SET_VALUES));§final static Choice DIRECTION_CHOICE = new ChoiceImpl(true);§static {§DIRECTION_CHOICE.setChoices(CHOICES);§DIRECTION_CHOICE.setMessage("Direction each player may only attack to");§DIRECTION_CHOICE.isRequired();§}§public MysticBarrierChooseEffect() {§super(Outcome.Benefit);§this.staticText = "choose left or right";§}§public MysticBarrierChooseEffect(final MysticBarrierChooseEffect effect) {§super(effect);§}§@Override§public MysticBarrierChooseEffect copy() {§return new MysticBarrierChooseEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§DIRECTION_CHOICE.clearChoice();§while (!DIRECTION_CHOICE.isChosen() && controller.canRespond()) {§controller.choose(outcome, DIRECTION_CHOICE, game);§}§if (!DIRECTION_CHOICE.getChoice().isEmpty()) {§game.getState().setValue(new StringBuilder("attack_direction_").append(source.getSourceId()).toString(), DIRECTION_CHOICE.getChoice());§return true;§}§}§return false;§}§}§class MysticBarrierReplacementEffect extends ReplacementEffectImpl {§MysticBarrierReplacementEffect ( ) {§super(Duration.WhileOnBattlefield, Outcome.Benefit);§staticText = "Each player may attack only the opponent seated nearest him or her in the last chosen direction and planeswalkers controlled by that player";§}§MysticBarrierReplacementEffect ( MysticBarrierReplacementEffect effect ) {§super(effect);§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§return true;§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.DECLARE_ATTACKER;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§if (game.getPlayers().size() > 2) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§if (game.getState().getPlayersInRange(controller.getId(), game).contains(event.getPlayerId())) {§String allowedDirection = (String) game.getState().getValue(new StringBuilder("attack_direction_").append(source.getSourceId()).toString());§if (allowedDirection != null) {§Player defender = game.getPlayer(event.getTargetId());§if (defender == null) {§Permanent planeswalker = game.getPermanent(event.getTargetId());§if (planeswalker != null) {§defender = game.getPlayer(planeswalker.getControllerId());§}§}§if (defender != null) {§PlayerList playerList = game.getState().getPlayerList(event.getPlayerId());§if (allowedDirection.equals(MysticBarrier.ALLOW_ATTACKING_LEFT)) {§if (!playerList.getNext().equals(defender.getId())) {§Player attacker = game.getPlayer(event.getPlayerId());§if (attacker != null) {§game.informPlayer(attacker, "You can only attack to the left!");§}§return true;§}§}§if (allowedDirection.equals(MysticBarrier.ALLOW_ATTACKING_RIGHT)) {§if (!playerList.getPrevious().equals(defender.getId())) {§Player attacker = game.getPlayer(event.getPlayerId());§if (attacker != null) {§game.informPlayer(attacker, "You can only attack to the right!");§}§return true;§}§}§}§}§}§}§}§return false;§}§@Override§public MysticBarrierReplacementEffect copy() {§return new MysticBarrierReplacementEffect(this);§}§}§
public class NayaSoulbeast extends CardImpl {§public NayaSoulbeast(UUID ownerId) {§super(ownerId, 157, "Naya Soulbeast", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{6}{G}{G}");§this.expansionSetCode = "C13";§this.subtype.add("Beast");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§this.addAbility(TrampleAbility.getInstance());§Ability ability = new CastSourceTriggeredAbility(new NayaSoulbeastCastEffect(), false);§ability.addEffect(new NayaSoulbeastReplacementEffect());§this.addAbility(ability);§}§public NayaSoulbeast(final NayaSoulbeast card) {§super(card);§}§@Override§public NayaSoulbeast copy() {§return new NayaSoulbeast(this);§}§}§class NayaSoulbeastCastEffect extends OneShotEffect {§public NayaSoulbeastCastEffect() {§super(Outcome.Benefit);§this.staticText = "each player reveals the top card of his or her library";§}§public NayaSoulbeastCastEffect(final NayaSoulbeastCastEffect effect) {§super(effect);§}§@Override§public NayaSoulbeastCastEffect copy() {§return new NayaSoulbeastCastEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§MageObject sourceObject = source.getSourceObject(game);§if (controller != null && sourceObject != null) {§int cmc = 0;§for (UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {§Player player = game.getPlayer(playerId);§if (player != null) {§if (player.getLibrary().size() > 0) {§Card card = player.getLibrary().getFromTop(game);§cmc += card.getManaCost().convertedManaCost();§player.revealCards(sourceObject.getName() + " " + player.getName() + ")", new CardsImpl(card), game);§}§}§}§for (Effect effect : source.getEffects()) {§if (effect instanceof NayaSoulbeastReplacementEffect) {§effect.setValue("NayaSoulbeastCounters", cmc);§}§}§return true;§}§return false;§}§}§class NayaSoulbeastReplacementEffect extends ReplacementEffectImpl {§public static final String SOURCE_CAST_SPELL_ABILITY = "sourceCastSpellAbility";§public NayaSoulbeastReplacementEffect() {§super(Duration.OneUse, Outcome.BoostCreature);§staticText = "{this} enters the battlefield with X +1/+1 counters on it, where X is the total converted mana cost of all cards revealed this way";§}§public NayaSoulbeastReplacementEffect(final NayaSoulbeastReplacementEffect effect) {§super(effect);§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == EventType.ENTERS_THE_BATTLEFIELD;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§return event.getTargetId().equals(source.getSourceId());§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§Object object = this.getValue("NayaSoulbeastCounters");§if (object instanceof Integer) {§int amount = ((Integer) object);§new AddCountersSourceEffect(CounterType.P1P1.createInstance(amount)).apply(game, source);§}§return false;§}§@Override§public NayaSoulbeastReplacementEffect copy() {§return new NayaSoulbeastReplacementEffect(this);§}§}§
public class NekusarTheMindrazer extends CardImpl {§public NekusarTheMindrazer(UUID ownerId) {§super(ownerId, 201, "Nekusar, the Mindrazer", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{2}{U}{B}{R}");§this.expansionSetCode = "C13";§this.supertype.add("Legendary");§this.subtype.add("Zombie");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(4);§Effect effect = new DrawCardTargetEffect(1);§effect.setText("that player draws an additional card");§this.addAbility(new BeginningOfDrawTriggeredAbility(effect , TargetController.ANY, false));§this.addAbility(new DrawCardOpponentTriggeredAbility(new DamageTargetEffect(1, true, "him or her"), false, true));§}§public NekusarTheMindrazer(final NekusarTheMindrazer card) {§super(card);§}§@Override§public NekusarTheMindrazer copy() {§return new NekusarTheMindrazer(this);§}§}§
public class OloroAgelessAscetic extends CardImpl {§public OloroAgelessAscetic(UUID ownerId) {§super(ownerId, 203, "Oloro, Ageless Ascetic", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{3}{W}{U}{B}");§this.expansionSetCode = "C13";§this.supertype.add("Legendary");§this.subtype.add("Giant");§this.subtype.add("Soldier");§this.power = new MageInt(4);§this.toughness = new MageInt(5);§this.addAbility(new BeginningOfUpkeepTriggeredAbility(new GainLifeEffect(2), TargetController.YOU, false));§DoIfCostPaid effect = new DoIfCostPaid(new DrawCardSourceControllerEffect(1), new GenericManaCost(1));§Effect effectToAdd = new LoseLifeOpponentsEffect(1);§effectToAdd.setText("and each opponent loses 1 life");§effect.addEffect(effectToAdd);§this.addAbility(new GainLifeControllerTriggeredAbility(effect, false));§this.addAbility(new BeginningOfUpkeepTriggeredAbility(Zone.COMMAND,§new GainLifeEffect(new StaticValue(2), "if {this} is in the command zone, you gain 2 life"), TargetController.YOU, false));§}§public OloroAgelessAscetic(final OloroAgelessAscetic card) {§super(card);§}§@Override§public OloroAgelessAscetic copy() {§return new OloroAgelessAscetic(this);§}§}§
public class OneDozenEyes extends CardImpl {§public OneDozenEyes(UUID ownerId) {§super(ownerId, 159, "One Dozen Eyes", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{5}{G}");§this.expansionSetCode = "C13";§this.getSpellAbility().getModes().setMinModes(1);§this.getSpellAbility().getModes().setMaxModes(1);§this.getSpellAbility().addEffect(new CreateTokenEffect(new OneDozenEyesBeastToken()));§Mode mode = new Mode();§mode.getEffects().add(new CreateTokenEffect(new InsectToken(),5));§this.getSpellAbility().addMode(mode);§this.addAbility(new EntwineAbility("{G}{G}{G}"));§}§public OneDozenEyes(final OneDozenEyes card) {§super(card);§}§@Override§public OneDozenEyes copy() {§return new OneDozenEyes(this);§}§}§class OneDozenEyesBeastToken extends Token {§public OneDozenEyesBeastToken() {§super("Beast", "5/5 green Beast creature token");§cardType.add(CardType.CREATURE);§color.setGreen(true);§subtype.add("Beast");§power = new MageInt(5);§toughness = new MageInt(5);§}§}§
public class OpalPalace extends CardImpl {§public OpalPalace(UUID ownerId) {§super(ownerId, 310, "Opal Palace", Rarity.COMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "C13";§this.addAbility(new ColorlessManaAbility());§Ability ability = new CommanderColorIdentityManaAbility(new GenericManaCost(1));§ability.addCost(new TapSourceCost());§this.addAbility(ability, new OpalPalaceWatcher(ability.getOriginalId().toString()));§ability = new SimpleStaticAbility(Zone.ALL, new OpalPalaceEntersBattlefieldEffect());§ability.setRuleVisible(false);§this.addAbility(ability);§}§public OpalPalace(final OpalPalace card) {§super(card);§}§@Override§public OpalPalace copy() {§return new OpalPalace(this);§}§}§class OpalPalaceWatcher extends Watcher {§public List<UUID> commanderId = new ArrayList<>();§private final String originalId;§public OpalPalaceWatcher(String originalId) {§super("ManaPaidFromOpalPalaceWatcher", WatcherScope.CARD);§this.originalId = originalId;§}§public OpalPalaceWatcher(final OpalPalaceWatcher watcher) {§super(watcher);§this.commanderId.addAll(watcher.commanderId);§this.originalId = watcher.originalId;§}§@Override§public OpalPalaceWatcher copy() {§return new OpalPalaceWatcher(this);§}§@Override§public void watch(GameEvent event, Game game) {§if (event.getType() == GameEvent.EventType.MANA_PAYED) {§if (event.getData() != null && event.getData().equals(originalId)) {§Spell spell = game.getStack().getSpell(event.getTargetId());§if (spell != null) {§Card card = spell.getCard();§if (card != null) {§for (UUID playerId : game.getPlayerList()) {§Player player = game.getPlayer(playerId);§if (player != null) {§if (player.getCommanderId() != null && player.getCommanderId().equals(card.getId())) {§commanderId.add(card.getId());§break;§}§}§}§}§}§}§}§}§@Override§public void reset() {§super.reset();§commanderId.clear();§}§}§class OpalPalaceEntersBattlefieldEffect extends ReplacementEffectImpl {§public OpalPalaceEntersBattlefieldEffect() {§super(Duration.EndOfGame, Outcome.BoostCreature, false);§staticText = "If you spend this mana to cast your commander, it enters the battlefield with a number of +1/+1 counters on it equal to the number of times it's been cast from the command zone this game";§}§public OpalPalaceEntersBattlefieldEffect(OpalPalaceEntersBattlefieldEffect effect) {§super(effect);§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == EventType.ENTERS_THE_BATTLEFIELD;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§OpalPalaceWatcher watcher = (OpalPalaceWatcher) game.getState().getWatchers().get("ManaPaidFromOpalPalaceWatcher", source.getSourceId());§return watcher != null§&& watcher.commanderId.contains(event.getTargetId());§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§Permanent permanent = ((EntersTheBattlefieldEvent) event).getTarget();§if (permanent != null) {§Integer castCount = (Integer) game.getState().getValue(permanent.getId() + "_castCount");§if (castCount != null && castCount > 0) {§permanent.addCounters(CounterType.P1P1.createInstance(castCount), game);§}§}§return false;§}§@Override§public OpalPalaceEntersBattlefieldEffect copy() {§return new OpalPalaceEntersBattlefieldEffect(this);§}§}§
public class Ophiomancer extends CardImpl {§public Ophiomancer(UUID ownerId) {§super(ownerId, 84, "Ophiomancer", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{B}");§this.expansionSetCode = "C13";§this.subtype.add("Human");§this.subtype.add("Shaman");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new ConditionalTriggeredAbility(§new BeginningOfUpkeepTriggeredAbility(Zone.BATTLEFIELD, new CreateTokenEffect(new OphiomancerSnakeToken()), TargetController.ANY, false),§new PermanentsOnTheBattlefieldCondition(new FilterCreaturePermanent("Snake", "no Snakes"), PermanentsOnTheBattlefieldCondition.CountType.EQUAL_TO, 0),§"At the beginning of each upkeep, if you control no Snakes, put a 1/1 black Snake creature token with deathtouch onto the battlefield."));§}§public Ophiomancer(final Ophiomancer card) {§super(card);§}§@Override§public Ophiomancer copy() {§return new Ophiomancer(this);§}§}§class OphiomancerSnakeToken extends Token {§public OphiomancerSnakeToken() {§super("Snake", "1/1 black Snake creature token with deathtouch");§cardType.add(CardType.CREATURE);§color.setBlack(true);§subtype.add("Snake");§power = new MageInt(1);§toughness = new MageInt(1);§this.addAbility(DeathtouchAbility.getInstance());§}§}§
public class OrderOfSuccession extends CardImpl {§public OrderOfSuccession(UUID ownerId) {§super(ownerId, 52, "Order of Succession", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{3}{U}");§this.expansionSetCode = "C13";§this.getSpellAbility().addChoice(new ChoiceLeftOrRight());§this.getSpellAbility().addEffect(new OrderOfSuccessionEffect());§}§public OrderOfSuccession(final OrderOfSuccession card) {§super(card);§}§@Override§public OrderOfSuccession copy() {§return new OrderOfSuccession(this);§}§}§class OrderOfSuccessionEffect extends OneShotEffect {§public OrderOfSuccessionEffect() {§super(Outcome.Benefit);§this.staticText = "Starting with you and proceeding in the chosen direction, each player chooses a creature controlled by the next player in that direction. Each player gains control of the creature he or she chose";§}§public OrderOfSuccessionEffect(final OrderOfSuccessionEffect effect) {§super(effect);§}§@Override§public OrderOfSuccessionEffect copy() {§return new OrderOfSuccessionEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Map<UUID, UUID> playerCreature = new HashMap<>();§boolean left = source.getChoices().get(0).getChoice().equals("Left");§PlayerList playerList = game.getState().getPlayerList().copy();§while (!playerList.get().equals(source.getControllerId()) && controller.canRespond()) {§playerList.getNext();§}§Player currentPlayer = game.getPlayer(playerList.get());§Player nextPlayer;§UUID firstNextPlayer = null;§while (!getNextPlayerInDirection(left, playerList, game).equals(firstNextPlayer) && controller.canRespond()){§nextPlayer = game.getPlayer(playerList.get());§if (nextPlayer == null) {§return false;§}§if (firstNextPlayer == null) {§firstNextPlayer = nextPlayer.getId();§}§if (!nextPlayer.canRespond()) {§continue;§}§if (currentPlayer != null && game.getState().getPlayersInRange(controller.getId(), game).contains(currentPlayer.getId())) {§FilterCreaturePermanent filter = new FilterCreaturePermanent(new StringBuilder("creature controlled by ").append(nextPlayer.getLogName()).toString());§filter.add(new ControllerIdPredicate(nextPlayer.getId()));§Target target = new TargetCreaturePermanent(filter);§target.setNotTarget(false);§if (target.canChoose(source.getSourceId(), currentPlayer.getId(), game)) {§if (currentPlayer.chooseTarget(outcome, target, source, game)) {§playerCreature.put(currentPlayer.getId(), target.getFirstTarget());§}§}§}§currentPlayer = nextPlayer;§}§for (Map.Entry<UUID, UUID> entry : playerCreature.entrySet()) {§Player player = game.getPlayer(entry.getKey());§if (player != null) {§Permanent creature = game.getPermanent(entry.getValue());§if (creature != null) {§ContinuousEffect effect = new GainControlTargetEffect(Duration.EndOfGame, player.getId());§effect.setTargetPointer(new FixedTarget(creature.getId()));§game.addEffect(effect, source);§game.informPlayers(new StringBuilder(player.getLogName()).append(" gains control of ").append(creature.getName()).toString());§}§}§}§return true;§}§return false;§}§private UUID getNextPlayerInDirection(boolean left, PlayerList playerList, Game game) {§UUID nextPlayerId;§if (left) {§nextPlayerId = playerList.getNext();§} else {§nextPlayerId = playerList.getPrevious();§}§return nextPlayerId;§}§}§
public class PhantomNantuko extends CardImpl {§public PhantomNantuko(UUID ownerId) {§super(ownerId, 160, "Phantom Nantuko", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{G}");§this.expansionSetCode = "C13";§this.subtype.add("Insect");§this.subtype.add("Spirit");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§this.addAbility(TrampleAbility.getInstance());§this.addAbility(new EntersBattlefieldAbility(new AddCountersSourceEffect(CounterType.P1P1.createInstance(2), true), "with two +1/+1 counters on it"));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new PhantomNantukoPreventionEffect()));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new AddCountersSourceEffect(CounterType.P1P1.createInstance()), new TapSourceCost()));§}§public PhantomNantuko(final PhantomNantuko card) {§super(card);§}§@Override§public PhantomNantuko copy() {§return new PhantomNantuko(this);§}§}§class PhantomNantukoPreventionEffect extends PreventionEffectImpl {§private int turn = 0;§private Step combatPhaseStep = null;§public PhantomNantukoPreventionEffect() {§super(Duration.WhileOnBattlefield);§staticText = "If damage would be dealt to {this}, prevent that damage. Remove a +1/+1 counter from {this}";§}§public PhantomNantukoPreventionEffect(final PhantomNantukoPreventionEffect effect) {§super(effect);§this.turn = effect.turn;§this.combatPhaseStep = effect.combatPhaseStep;§}§@Override§public PhantomNantukoPreventionEffect copy() {§return new PhantomNantukoPreventionEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§preventDamageAction(event, source, game);§Permanent permanent = game.getPermanent(source.getSourceId());§if (permanent != null) {§boolean removeCounter = true;§if (game.getTurn().getPhase().getStep().getType().equals(PhaseStep.COMBAT_DAMAGE)) {§if (game.getTurnNum() == turn§&& game.getTurn().getStep().equals(combatPhaseStep)) {§removeCounter = false;§} else {§turn = game.getTurnNum();§combatPhaseStep = game.getTurn().getStep();§}§}§if(removeCounter && permanent.getCounters().containsKey(CounterType.P1P1)) {§StringBuilder sb = new StringBuilder(permanent.getName()).append(": ");§permanent.removeCounters(CounterType.P1P1.createInstance(), game);§sb.append("Removed a +1/+1 counter ");§game.informPlayers(sb.toString());§}§}§return false;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§if (super.applies(event, source, game)) {§if (event.getTargetId().equals(source.getSourceId())) {§return true;§}§}§return false;§}§}§
public class PlagueBoiler extends CardImpl {§public PlagueBoiler(UUID ownerId) {§super(ownerId, 254, "Plague Boiler", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "C13";§this.addAbility(new BeginningOfUpkeepTriggeredAbility(Zone.BATTLEFIELD, new AddCountersSourceEffect(CounterType.PLAGUE.createInstance()), TargetController.YOU, false));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new PlagueBoilerEffect(), new ManaCostsImpl("{1}{B}{G}")));§this.addAbility(new PlagueBoilerTriggeredAbility());§}§public PlagueBoiler(final PlagueBoiler card) {§super(card);§}§@Override§public PlagueBoiler copy() {§return new PlagueBoiler(this);§}§}§class PlagueBoilerEffect extends OneShotEffect {§public PlagueBoilerEffect() {§super(Outcome.Detriment);§this.staticText = "Put a plague counter on {this} or remove a plague counter from it";§}§public PlagueBoilerEffect(final PlagueBoilerEffect effect) {§super(effect);§}§@Override§public PlagueBoilerEffect copy() {§return new PlagueBoilerEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§Permanent sourcePermanent = game.getPermanent(source.getSourceId());§if (controller != null && sourcePermanent != null) {§if (!sourcePermanent.getCounters().containsKey(CounterType.PLAGUE) || controller.chooseUse(outcome, "Put a plague counter on? (No removes one)", source, game)) {§return new AddCountersSourceEffect(CounterType.PLAGUE.createInstance(), true).apply(game, source);§} else {§return new RemoveCounterSourceEffect(CounterType.PLAGUE.createInstance()).apply(game, source);§}§}§return false;§}§}§class PlagueBoilerTriggeredAbility extends TriggeredAbilityImpl {§public PlagueBoilerTriggeredAbility() {§super(Zone.BATTLEFIELD, new PlagueBoilerSacrificeDestroyEffect(), false);§}§public PlagueBoilerTriggeredAbility(final PlagueBoilerTriggeredAbility ability) {§super(ability);§}§@Override§public PlagueBoilerTriggeredAbility copy() {§return new PlagueBoilerTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.COUNTER_ADDED;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (event.getTargetId().equals(this.getSourceId()) && event.getData().equals(CounterType.PLAGUE.getName())) {§Permanent sourcePermanent = game.getPermanent(this.getSourceId());§if (sourcePermanent != null && sourcePermanent.getCounters().getCount(CounterType.PLAGUE) >= 3) {§return true;§}§}§return false;§}§@Override§public String getRule() {§return "When {this} has three or more plague counters on it, " + super.getRule();§}§}§class PlagueBoilerSacrificeDestroyEffect extends OneShotEffect {§public PlagueBoilerSacrificeDestroyEffect() {§super(Outcome.DestroyPermanent);§this.staticText = "sacrifice it. If you do, destroy all nonland permanents";§}§public PlagueBoilerSacrificeDestroyEffect(final PlagueBoilerSacrificeDestroyEffect effect) {§super(effect);§}§@Override§public PlagueBoilerSacrificeDestroyEffect copy() {§return new PlagueBoilerSacrificeDestroyEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent sourcePermanent = game.getPermanent(source.getSourceId());§if (sourcePermanent != null) {§if (sourcePermanent.sacrifice(source.getSourceId(), game)) {§return new DestroyAllEffect(new FilterNonlandPermanent()).apply(game, source);§}§}§return false;§}§}§
public class PresenceOfGond extends CardImpl {§public PresenceOfGond(UUID ownerId) {§super(ownerId, 161, "Presence of Gond", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{G}");§this.expansionSetCode = "C13";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.PutCreatureInPlay));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§Ability abilityToGain = new SimpleActivatedAbility(Zone.BATTLEFIELD, new CreateTokenEffect(new ElfToken()), new TapSourceCost());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(abilityToGain, AttachmentType.AURA, Duration.WhileOnBattlefield,§"Enchanted creature has \"{t}: Put a 1/1 green Elf Warrior creature token onto the battlefield.\"")));§}§public PresenceOfGond(final PresenceOfGond card) {§super(card);§}§@Override§public PresenceOfGond copy() {§return new PresenceOfGond(this);§}§}§
public class PriceOfKnowledge extends CardImpl {§public PriceOfKnowledge(UUID ownerId) {§super(ownerId, 89, "Price of Knowledge", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{6}{B}");§this.expansionSetCode = "C13";§Effect effect = new MaximumHandSizeControllerEffect(Integer.MAX_VALUE, Duration.WhileOnBattlefield, HandSizeModification.SET, TargetController.ANY);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, effect));§this.addAbility(new BeginningOfUpkeepTriggeredAbility(Zone.BATTLEFIELD, new PriceOfKnowledgeEffect(), TargetController.OPPONENT, false));§}§public PriceOfKnowledge(final PriceOfKnowledge card) {§super(card);§}§@Override§public PriceOfKnowledge copy() {§return new PriceOfKnowledge(this);§}§}§class PriceOfKnowledgeEffect extends OneShotEffect {§public PriceOfKnowledgeEffect(final PriceOfKnowledgeEffect effect) {§super(effect);§}§public PriceOfKnowledgeEffect() {§super(Outcome.Neutral);§staticText = "{this} deals damage to that player equal to the number of cards in that player's hand";§}§@Override§public boolean apply(Game game, Ability source) {§Player targetPlayer = game.getPlayer(targetPointer.getFirst(game, source));§if (targetPlayer != null) {§int xValue = targetPlayer.getHand().size();§if (xValue > 0) {§targetPlayer.damage(xValue, source.getSourceId(), game, false, true);§}§return true;§}§return false;§}§@Override§public PriceOfKnowledgeEffect copy() {§return new PriceOfKnowledgeEffect(this);§}§}§
public class PrimalVigor extends CardImpl {§public PrimalVigor(UUID ownerId) {§super(ownerId, 162, "Primal Vigor", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{4}{G}");§this.expansionSetCode = "C13";§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new PrimalVigorTokenEffect()));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new PrimalVigorCounterEffect()));§}§public PrimalVigor(final PrimalVigor card) {§super(card);§}§@Override§public PrimalVigor copy() {§return new PrimalVigor(this);§}§}§class PrimalVigorTokenEffect extends ReplacementEffectImpl {§public PrimalVigorTokenEffect() {§super(Duration.WhileOnBattlefield, Outcome.Copy);§staticText = "If one or more tokens would be put onto the battlefield, twice that many of those tokens are put onto the battlefield instead";§}§public PrimalVigorTokenEffect(final PrimalVigorTokenEffect effect) {§super(effect);§}§@Override§public PrimalVigorTokenEffect copy() {§return new PrimalVigorTokenEffect(this);§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.CREATE_TOKEN;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§return true;§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§event.setAmount(event.getAmount() * 2);§return false;§}§}§class PrimalVigorCounterEffect extends ReplacementEffectImpl {§PrimalVigorCounterEffect() {§super(Duration.WhileOnBattlefield, Outcome.BoostCreature, false);§staticText = "If one or more +1/+1 counters would be placed on a creature, twice that many +1/+1 counters are placed on that creature instead";§}§PrimalVigorCounterEffect(final PrimalVigorCounterEffect effect) {§super(effect);§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§event.setAmount(event.getAmount() * 2);§return false;§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.ADD_COUNTERS;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§Permanent permanent = game.getPermanent(event.getTargetId());§if (permanent == null) {§permanent = game.getPermanentEntering(event.getTargetId());§}§if (permanent != null && permanent.getCardType().contains(CardType.CREATURE)§&& event.getData() != null && event.getData().equals("+1/+1")) {§return true;§}§return false;§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public PrimalVigorCounterEffect copy() {§return new PrimalVigorCounterEffect(this);§}§}§
public class Prosperity extends CardImpl {§public Prosperity(UUID ownerId) {§super(ownerId, 54, "Prosperity", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{X}{U}");§this.expansionSetCode = "C13";§this.getSpellAbility().addEffect(new DrawCardAllEffect(new ManacostVariableValue()));§}§public Prosperity(final Prosperity card) {§super(card);§}§@Override§public Prosperity copy() {§return new Prosperity(this);§}§}§
public class ProsshSkyraiderOfKher extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("another creature");§static {§filter.add(new AnotherPredicate());§}§public ProsshSkyraiderOfKher(UUID ownerId) {§super(ownerId, 204, "Prossh, Skyraider of Kher", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{3}{B}{R}{G}");§this.expansionSetCode = "C13";§this.supertype.add("Legendary");§this.subtype.add("Dragon");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new CastSourceTriggeredAbility(new CreateTokenEffect(new ProsshKoboldToken(), new ManaSpentToCastCount()), false));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(1,0, Duration.EndOfTurn), new SacrificeTargetCost(new TargetControlledCreaturePermanent(1,1,filter, true))));§}§public ProsshSkyraiderOfKher(final ProsshSkyraiderOfKher card) {§super(card);§}§@Override§public ProsshSkyraiderOfKher copy() {§return new ProsshSkyraiderOfKher(this);§}§}§class ProsshKoboldToken extends Token {§public ProsshKoboldToken() {§super("Kobolds of Kher Keep", "0/1 red Kobold creature tokens");§cardType.add(CardType.CREATURE);§color.setRed(true);§subtype.add("Kobold");§power = new MageInt(0);§toughness = new MageInt(1);§}§}§
public class Reincarnation extends CardImpl {§public Reincarnation(UUID ownerId) {§super(ownerId, 166, "Reincarnation", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{1}{G}{G}");§this.expansionSetCode = "C13";§this.getSpellAbility().addEffect(new ReincarnationEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public Reincarnation(final Reincarnation card) {§super(card);§}§@Override§public Reincarnation copy() {§return new Reincarnation(this);§}§}§class ReincarnationEffect extends OneShotEffect {§public ReincarnationEffect() {§super(Outcome.Benefit);§this.staticText = "Choose target creature. When that creature dies this turn, return a creature card from its owner's graveyard to the battlefield under the control of that creature's owner";§}§public ReincarnationEffect(final ReincarnationEffect effect) {§super(effect);§}§@Override§public ReincarnationEffect copy() {§return new ReincarnationEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§DelayedTriggeredAbility delayedAbility = new ReincarnationDelayedTriggeredAbility(targetPointer.getFirst(game, source));§game.addDelayedTriggeredAbility(delayedAbility, source);§return true;§}§}§class ReincarnationDelayedTriggeredAbility extends DelayedTriggeredAbility {§private UUID target;§public ReincarnationDelayedTriggeredAbility(UUID target) {§super(new ReincarnationDelayedEffect(target), Duration.EndOfTurn);§this.target = target;§}§public ReincarnationDelayedTriggeredAbility(ReincarnationDelayedTriggeredAbility ability) {§super(ability);§this.target = ability.target;§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.ZONE_CHANGE;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (event.getTargetId().equals(target)) {§ZoneChangeEvent zEvent = (ZoneChangeEvent) event;§if (zEvent.getFromZone() == Zone.BATTLEFIELD && zEvent.getToZone() == Zone.GRAVEYARD) {§return true;§}§}§return false;§}§@Override§public ReincarnationDelayedTriggeredAbility copy() {§return new ReincarnationDelayedTriggeredAbility(this);§}§@Override§public String getRule() {§return "When that creature dies this turn, return a creature card from its owner's graveyard to the battlefield under the control of that creature's owner.";§}§}§class ReincarnationDelayedEffect extends OneShotEffect {§private UUID target;§public ReincarnationDelayedEffect(UUID target) {§super(Outcome.Detriment);§this.target = target;§this.staticText = "return a creature card from its owner's graveyard to the battlefield under the control of that creature's owner";§}§public ReincarnationDelayedEffect(final ReincarnationDelayedEffect effect) {§super(effect);§this.target = effect.target;§}§@Override§public ReincarnationDelayedEffect copy() {§return new ReincarnationDelayedEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§Permanent permanent = (Permanent) game.getLastKnownInformation(target, Zone.BATTLEFIELD);§if (permanent != null && controller != null) {§Player player = game.getPlayer(permanent.getOwnerId());§if (player != null) {§FilterCreatureCard filter = new FilterCreatureCard(new StringBuilder("a creature card from ").append(player.getLogName()).append("'s graveyard").toString());§filter.add(new OwnerIdPredicate(player.getId()));§Target targetCreature = new TargetCardInGraveyard(filter);§if (targetCreature.canChoose(source.getSourceId(), controller.getId(), game)§&& controller.chooseTarget(outcome, targetCreature, source, game)) {§Card card = game.getCard(targetCreature.getFirstTarget());§if (card != null && game.getState().getZone(card.getId()).equals(Zone.GRAVEYARD)) {§return card.putOntoBattlefield(game, Zone.GRAVEYARD, source.getSourceId(), player.getId());§}§}§return true;§}§}§return false;§}§}§
public class Restore extends CardImpl {§private static final FilterLandCard filter = new FilterLandCard();§public Restore(UUID ownerId) {§super(ownerId, 167, "Restore", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{1}{G}");§this.expansionSetCode = "C13";§this.getSpellAbility().addEffect(new RestoreEffect());§Target target = new TargetCardInGraveyard(filter);§this.getSpellAbility().addTarget(target);§}§public Restore(final Restore card) {§super(card);§}§@Override§public Restore copy() {§return new Restore(this);§}§}§class RestoreEffect extends OneShotEffect {§public RestoreEffect() {§super(Outcome.PutLandInPlay);§this.staticText = "Put target land card from a graveyard onto the battlefield under your control";§}§public RestoreEffect(final RestoreEffect effect) {§super(effect);§}§@Override§public RestoreEffect copy() {§return new RestoreEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§Card land = game.getCard(this.getTargetPointer().getFirst(game, source));§if (controller != null && game.getState().getZone(land.getId()).equals(Zone.GRAVEYARD)) {§return land.putOntoBattlefield(game, Zone.GRAVEYARD, source.getSourceId(), controller.getId());§}§return false;§}§}§
public class RoonOfTheHiddenRealm extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("another target creature");§static {§filter.add(new AnotherPredicate());§}§public RoonOfTheHiddenRealm(UUID ownerId) {§super(ownerId, 206, "Roon of the Hidden Realm", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{2}{G}{W}{U}");§this.expansionSetCode = "C13";§this.supertype.add("Legendary");§this.subtype.add("Rhino");§this.subtype.add("Soldier");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(VigilanceAbility.getInstance());§this.addAbility(TrampleAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new RoonOfTheHiddenRealmEffect(), new GenericManaCost(2));§ability.addTarget(new TargetCreaturePermanent(filter));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§}§public RoonOfTheHiddenRealm(final RoonOfTheHiddenRealm card) {§super(card);§}§@Override§public RoonOfTheHiddenRealm copy() {§return new RoonOfTheHiddenRealm(this);§}§}§class RoonOfTheHiddenRealmEffect extends OneShotEffect {§public RoonOfTheHiddenRealmEffect() {§super(Outcome.Benefit);§this.staticText = "Exile another target creature. Return that card to the battlefield under its owner's control at the beginning of the next end step";§}§public RoonOfTheHiddenRealmEffect(final RoonOfTheHiddenRealmEffect effect) {§super(effect);§}§@Override§public RoonOfTheHiddenRealmEffect copy() {§return new RoonOfTheHiddenRealmEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§MageObject sourceObject = game.getObject(source.getSourceId());§if (controller != null && sourceObject != null) {§if (getTargetPointer().getFirst(game, source) != null) {§Permanent permanent = game.getPermanent(getTargetPointer().getFirst(game, source));§if (permanent != null) {§int zcc = permanent.getZoneChangeCounter(game);§if (controller.moveCards(permanent, Zone.EXILED, source, game)) {§Effect effect = new ReturnToBattlefieldUnderOwnerControlTargetEffect();§effect.setTargetPointer(new FixedTarget(permanent.getId(), zcc + 1));§AtTheBeginOfNextEndStepDelayedTriggeredAbility delayedAbility§= new AtTheBeginOfNextEndStepDelayedTriggeredAbility(effect);§game.addDelayedTriggeredAbility(delayedAbility, source);§}§}§}§return true;§}§return false;§}§}§
public class SavageTwister extends CardImpl {§public SavageTwister(UUID ownerId) {§super(ownerId, 208, "Savage Twister", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{X}{R}{G}");§this.expansionSetCode = "C13";§this.getSpellAbility().addEffect(new DamageAllEffect(new ManacostVariableValue(), new FilterCreaturePermanent()));§}§public SavageTwister(final SavageTwister card) {§super(card);§}§@Override§public SavageTwister copy() {§return new SavageTwister(this);§}§}§
public class SekKuarDeathkeeper extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("another nontoken creature you control");§static {§filter.add(new ControllerPredicate(TargetController.YOU));§filter.add(new AnotherPredicate());§filter.add(Predicates.not(new TokenPredicate()));§}§public SekKuarDeathkeeper(UUID ownerId) {§super(ownerId, 210, "Sek'Kuar, Deathkeeper", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{B}{R}{G}");§this.expansionSetCode = "C13";§this.supertype.add("Legendary");§this.subtype.add("Orc");§this.subtype.add("Shaman");§this.power = new MageInt(4);§this.toughness = new MageInt(3);§this.addAbility(new DiesCreatureTriggeredAbility(new CreateTokenEffect(new SekKuarDeathkeeperGravebornToken()),false, filter));§}§public SekKuarDeathkeeper(final SekKuarDeathkeeper card) {§super(card);§}§@Override§public SekKuarDeathkeeper copy() {§return new SekKuarDeathkeeper(this);§}§}§class SekKuarDeathkeeperGravebornToken extends Token {§public SekKuarDeathkeeperGravebornToken() {§super("Graveborn", "3/1 black and red Graveborn creature token with haste");§cardType.add(CardType.CREATURE);§color.setBlack(true);§color.setRed(true);§subtype.add("Graveborn");§power = new MageInt(3);§toughness = new MageInt(1);§this.addAbility(HasteAbility.getInstance());§}§}§
public class SereneMaster extends CardImpl {§public SereneMaster(UUID ownerId) {§super(ownerId, 20, "Serene Master", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "C13";§this.subtype.add("Human");§this.subtype.add("Monk");§this.power = new MageInt(0);§this.toughness = new MageInt(2);§this.addAbility(new BlocksTriggeredAbility(new SereneMasterEffect(), false));§}§public SereneMaster(final SereneMaster card) {§super(card);§}§@Override§public SereneMaster copy() {§return new SereneMaster(this);§}§}§class SereneMasterEffect extends OneShotEffect {§public SereneMasterEffect() {§super(Outcome.Benefit);§this.staticText = "exchange its power and the power of target creature it's blocking until end of combat";§}§public SereneMasterEffect(final SereneMasterEffect effect) {§super(effect);§}§@Override§public SereneMasterEffect copy() {§return new SereneMasterEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§Permanent sourceCreature = game.getPermanent(source.getSourceId());§if (controller != null && sourceCreature != null) {§FilterCreaturePermanent filter = new FilterCreaturePermanent("creature it's blocking");§filter.add(new BlockedByIdPredicate((source.getSourceId())));§Target target = new TargetCreaturePermanent(filter);§if (target.canChoose(source.getSourceId(), controller.getId(), game)) {§if (controller.chooseTarget(outcome, target, source, game)) {§Permanent attackingCreature = game.getPermanent(target.getFirstTarget());§if (attackingCreature != null) {§int newSourcePower = attackingCreature.getPower().getValue();§int newAttackerPower = sourceCreature.getPower().getValue();§ContinuousEffect effect = new SetPowerToughnessTargetEffect(newSourcePower, sourceCreature.getToughness().getValue(), Duration.EndOfCombat);§effect.setTargetPointer(new FixedTarget(source.getSourceId()));§game.addEffect(effect, source);§effect = new SetPowerToughnessTargetEffect(newAttackerPower, attackingCreature.getToughness().getValue(), Duration.EndOfCombat);§effect.setTargetPointer(new FixedTarget(attackingCreature.getId()));§game.addEffect(effect, source);§return true;§}§}§}§}§return false;§}§}§
public class ShattergangBrothers extends CardImpl {§public ShattergangBrothers(UUID ownerId) {§super(ownerId, 213, "Shattergang Brothers", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{1}{B}{R}{G}");§this.expansionSetCode = "C13";§this.supertype.add("Legendary");§this.subtype.add("Goblin");§this.subtype.add("Artificer");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§FilterControlledCreaturePermanent filterCreature = new FilterControlledCreaturePermanent("a creature");§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ShattergangBrothersEffect(filterCreature), new ManaCostsImpl("{2}{B}"));§ability.addCost(new SacrificeTargetCost(new TargetControlledCreaturePermanent(1,1, filterCreature, true)));§this.addAbility(ability);§FilterControlledPermanent filter = new FilterControlledArtifactPermanent("an artifact");§ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ShattergangBrothersEffect(filter), new ManaCostsImpl("{2}{R}"));§ability.addCost(new SacrificeTargetCost(new TargetControlledPermanent(1,1, filter, true)));§this.addAbility(ability);§filter = new FilterControlledPermanent("an enchantment");§filter.add(new CardTypePredicate(CardType.ENCHANTMENT));§ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ShattergangBrothersEffect(filter), new ManaCostsImpl("{2}{G}"));§ability.addCost(new SacrificeTargetCost(new TargetControlledPermanent(1,1, filter, true)));§this.addAbility(ability);§}§public ShattergangBrothers(final ShattergangBrothers card) {§super(card);§}§@Override§public ShattergangBrothers copy() {§return new ShattergangBrothers(this);§}§}§class ShattergangBrothersEffect extends OneShotEffect {§private FilterControlledPermanent filter;§public ShattergangBrothersEffect(FilterControlledPermanent filter) {§super(Outcome.Sacrifice);§this.filter = filter;§this.staticText = new StringBuilder("Each other player sacrifices ").append(filter.getMessage()).toString();§}§public ShattergangBrothersEffect(final ShattergangBrothersEffect effect) {§super(effect);§this.filter = effect.filter;§}§@Override§public ShattergangBrothersEffect copy() {§return new ShattergangBrothersEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§for(UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {§if (playerId != source.getControllerId()) {§Player player = game.getPlayer(playerId);§if (player != null) {§TargetControlledPermanent target = new TargetControlledPermanent(filter);§target.setNotTarget(true);§if (target.canChoose(source.getSourceId(), playerId, game) &&§player.chooseTarget(outcome, target, source, game)) {§Permanent permanent = game.getPermanent(target.getFirstTarget());§if (permanent != null) {§permanent.sacrifice(source.getSourceId(), game);§}§}§}§}§}§return true;§}§return false;§}§}§
public class Skyscribing extends CardImpl {§public Skyscribing(UUID ownerId) {§super(ownerId, 57, "Skyscribing", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{X}{U}{U}");§this.expansionSetCode = "C13";§this.getSpellAbility().addEffect(new DrawCardAllEffect(new ManacostVariableValue()));§this.addAbility(new ForecastAbility(new DrawCardAllEffect(1), new ManaCostsImpl("{2}{U}")));§}§public Skyscribing(final Skyscribing card) {§super(card);§}§@Override§public Skyscribing copy() {§return new Skyscribing(this);§}§}§
public class SpawningGrounds extends CardImpl {§public SpawningGrounds(UUID ownerId) {§super(ownerId, 171, "Spawning Grounds", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{6}{G}{G}");§this.expansionSetCode = "C13";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetLandPermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.PutCreatureInPlay));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§Ability abilityToGain = new SimpleActivatedAbility(Zone.BATTLEFIELD, new CreateTokenEffect(new SpawningGroundsBeastToken(), 1), new TapSourceCost());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(abilityToGain, AttachmentType.AURA, Duration.WhileOnBattlefield,§"Enchanted land has \"{t}: Put a 5/5 green Beast creature token with trample onto the battlefield.\"")));§}§public SpawningGrounds(final SpawningGrounds card) {§super(card);§}§@Override§public SpawningGrounds copy() {§return new SpawningGrounds(this);§}§}§class SpawningGroundsBeastToken extends Token {§public SpawningGroundsBeastToken() {§super("Beast", "5/5 green Beast creature token with trample");§cardType.add(CardType.CREATURE);§color.setGreen(true);§subtype.add("Beast");§power = new MageInt(5);§toughness = new MageInt(5);§this.addAbility(TrampleAbility.getInstance());§}§}§
public class SpoilsOfVictory extends CardImpl {§private static final FilterCard filter = new FilterCard("Plains, Island, Swamp, Mountain, or Forest card");§static {§filter.add(Predicates.or(§new SubtypePredicate("Plains"),§new SubtypePredicate("Island"),§new SubtypePredicate("Swamp"),§new SubtypePredicate("Mountain"),§new SubtypePredicate("Forest")));§}§public SpoilsOfVictory(UUID ownerId) {§super(ownerId, 172, "Spoils of Victory", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{2}{G}");§this.expansionSetCode = "C13";§this.getSpellAbility().addEffect(new SearchLibraryPutInPlayEffect(new TargetCardInLibrary(filter), false, Outcome.PutLandInPlay));§}§public SpoilsOfVictory(final SpoilsOfVictory card) {§super(card);§}§@Override§public SpoilsOfVictory copy() {§return new SpoilsOfVictory(this);§}§}§
public class SpringjackPasture extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("Goats");§static {§filter.add(new SubtypePredicate("Goat"));§}§public SpringjackPasture(UUID ownerId) {§super(ownerId, 326, "Springjack Pasture", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "C13";§this.addAbility(new ColorlessManaAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new CreateTokenEffect(new GoatToken()), new ManaCostsImpl("{4}"));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new SpringjackPastureEffect(), new TapSourceCost());§ability.addChoice(new ChoiceColor());§ability.addCost(new SacrificeXTargetCost(filter));§ability.addEffect(new GainLifeEffect(new GetXValue()));§this.addAbility(ability);§}§public SpringjackPasture(final SpringjackPasture card) {§super(card);§}§@Override§public SpringjackPasture copy() {§return new SpringjackPasture(this);§}§}§class SpringjackPastureEffect extends OneShotEffect {§public SpringjackPastureEffect() {§super(Outcome.Benefit);§staticText = "Add X mana of any one color to your mana pool";§}§public SpringjackPastureEffect(final SpringjackPastureEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player you = game.getPlayer(source.getControllerId());§ChoiceColor choice = (ChoiceColor) source.getChoices().get(0);§if (you != null && choice != null) {§int count = new GetXValue().calculate(game, source, this);§if (choice.getColor().isBlack()) {§you.getManaPool().addMana(new Mana(0, 0, 0, 0, count, 0, 0, 0), game, source);§} else if (choice.getColor().isBlue()) {§you.getManaPool().addMana(new Mana(0, 0, count, 0, 0, 0, 0, 0), game, source);§} else if (choice.getColor().isRed()) {§you.getManaPool().addMana(new Mana(count, 0, 0, 0, 0, 0, 0, 0), game, source);§} else if (choice.getColor().isGreen()) {§you.getManaPool().addMana(new Mana(0, count, 0, 0, 0, 0, 0, 0), game, source);§} else if (choice.getColor().isWhite()) {§you.getManaPool().addMana(new Mana(0, 0, 0, count, 0, 0, 0, 0), game, source);§}§return true;§}§return false;§}§@Override§public SpringjackPastureEffect copy() {§return new SpringjackPastureEffect(this);§}§}§
public class StalkingVengeance extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("another creature you control");§static {§filter.add(new ControllerPredicate(TargetController.YOU));§filter.add(new AnotherPredicate());§}§public StalkingVengeance(UUID ownerId) {§super(ownerId, 121, "Stalking Vengeance", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}{R}{R}");§this.expansionSetCode = "C13";§this.subtype.add("Avatar");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(HasteAbility.getInstance());§Ability ability = new DiesCreatureTriggeredAbility(new StalkingVengeanceDamageEffect(), false, filter, true);§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§}§public StalkingVengeance(final StalkingVengeance card) {§super(card);§}§@Override§public StalkingVengeance copy() {§return new StalkingVengeance(this);§}§}§class StalkingVengeanceDamageEffect extends OneShotEffect {§public StalkingVengeanceDamageEffect() {§super(Outcome.Damage);§this.staticText = "it deals damage equal to its power to target player";§}§public StalkingVengeanceDamageEffect(final StalkingVengeanceDamageEffect effect) {§super(effect);§}§@Override§public StalkingVengeanceDamageEffect copy() {§return new StalkingVengeanceDamageEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player targetPlayer = game.getPlayer(source.getTargets().getFirstTarget());§if (targetPlayer != null) {§Permanent creature = (Permanent) game.getLastKnownInformation(this.getTargetPointer().getFirst(game, source), Zone.BATTLEFIELD);§if (creature != null) {§targetPlayer.damage(creature.getPower().getValue(), creature.getId(), game, false, true);§return true;§}§}§return false;§}§}§
public class Stonecloaker extends CardImpl {§public Stonecloaker(UUID ownerId) {§super(ownerId, 22, "Stonecloaker", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "C13";§this.subtype.add("Gargoyle");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§this.addAbility(FlashAbility.getInstance());§this.addAbility(FlyingAbility.getInstance());§Ability ability = new EntersBattlefieldTriggeredAbility(new ReturnToHandChosenControlledPermanentEffect(new FilterControlledCreaturePermanent()), true);§this.addAbility(ability);§ability = new EntersBattlefieldTriggeredAbility(new ExileTargetEffect(), false);§ability.addTarget(new TargetCardInGraveyard());§this.addAbility(ability);§}§public Stonecloaker(final Stonecloaker card) {§super(card);§}§@Override§public Stonecloaker copy() {§return new Stonecloaker(this);§}§}§
public class StormscapeBattlemage extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("nonblack creature");§static {§filter.add(Predicates.not(new ColorPredicate(ObjectColor.BLACK)));§}§public StormscapeBattlemage(UUID ownerId) {§super(ownerId, 58, "Stormscape Battlemage", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{U}");§this.expansionSetCode = "C13";§this.subtype.add("Metathran");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§KickerAbility kickerAbility = new KickerAbility("{W}");§kickerAbility.addKickerCost("{2}{B}");§this.addAbility(kickerAbility);§this.addAbility(new ConditionalTriggeredAbility(§new EntersBattlefieldTriggeredAbility(new GainLifeEffect(3),false),§new KickedCostCondition("{W}"),§"When Stormscape Battlemage enters the battlefield, if it was kicked with its {W} kicker, you gain 3 life."));§TriggeredAbility ability = new EntersBattlefieldTriggeredAbility(new DestroyTargetEffect(true),false);§ability.addTarget(new TargetCreaturePermanent(filter));§this.addAbility(new ConditionalTriggeredAbility(§ability, new KickedCostCondition("{2}{B}"),§"When Stormscape Battlemage enters the battlefield, if it was kicked with its {2}{B} kicker, destroy target nonblack creature. That creature can't be regenerated."));§}§public StormscapeBattlemage(final StormscapeBattlemage card) {§super(card);§}§@Override§public StormscapeBattlemage copy() {§return new StormscapeBattlemage(this);§}§}§
public class StrategicPlanning extends CardImpl {§public StrategicPlanning(UUID ownerId) {§super(ownerId, 59, "Strategic Planning", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{1}{U}");§this.expansionSetCode = "C13";§this.getSpellAbility().addEffect(new StrategicPlanningEffect());§}§public StrategicPlanning(final StrategicPlanning card) {§super(card);§}§@Override§public StrategicPlanning copy() {§return new StrategicPlanning(this);§}§}§class StrategicPlanningEffect extends OneShotEffect {§public StrategicPlanningEffect() {§super(Outcome.DrawCard);§this.staticText = "Look at the top three cards of your library. Put one of them into your hand and the rest into your graveyard";§}§public StrategicPlanningEffect(final StrategicPlanningEffect effect) {§super(effect);§}§@Override§public StrategicPlanningEffect copy() {§return new StrategicPlanningEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Cards cards = new CardsImpl();§cards.addAll(controller.getLibrary().getTopCards(game, 3));§if (cards.size() > 0) {§controller.lookAtCards("Strategic Planning", cards, game);§TargetCard target = new TargetCard(Zone.LIBRARY, new FilterCard("card to put in your hand"));§if (controller.choose(Outcome.Benefit, cards, target, game)) {§Card card = cards.get(target.getFirstTarget(), game);§if (card != null) {§controller.moveCards(card, Zone.LIBRARY, Zone.HAND, source, game);§cards.remove(card);§}§}§controller.moveCards(cards, Zone.LIBRARY, Zone.GRAVEYARD, source, game);§}§return true;§}§return false;§}§}§
public class SuddenDemise extends CardImpl {§public SuddenDemise(UUID ownerId) {§super(ownerId, 124, "Sudden Demise", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{X}{R}");§this.expansionSetCode = "C13";§this.getSpellAbility().addEffect(new SuddenDemiseDamageEffect());§}§public SuddenDemise(final SuddenDemise card) {§super(card);§}§@Override§public SuddenDemise copy() {§return new SuddenDemise(this);§}§}§class SuddenDemiseDamageEffect extends OneShotEffect {§public SuddenDemiseDamageEffect() {§super(Outcome.Damage);§this.staticText = "Choose a color. Sudden Demise deals X damage to each creature of the chosen color";§}§public SuddenDemiseDamageEffect(final SuddenDemiseDamageEffect effect) {§super(effect);§}§@Override§public SuddenDemiseDamageEffect copy() {§return new SuddenDemiseDamageEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§ChoiceColor choice = new ChoiceColor();§controller.choose(outcome, choice, game);§if (choice.getColor() != null) {§final int damage = source.getManaCostsToPay().getX();§FilterPermanent filter = new FilterCreaturePermanent();§filter.add(new ColorPredicate(choice.getColor()));§for (Permanent permanent:game.getBattlefield().getActivePermanents(filter, source.getControllerId(), id, game)) {§permanent.damage(damage, source.getSourceId(), game, false, true);§}§return true;§}§}§return false;§}§}§
public class SunDroplet extends CardImpl {§public SunDroplet(UUID ownerId) {§super(ownerId, 261, "Sun Droplet", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{2}");§this.expansionSetCode = "C13";§this.addAbility(new SunDropletTriggeredAbility());§Effect effect = new DoIfCostPaid(new GainLifeEffect(1), new RemoveCountersSourceCost(CounterType.CHARGE.createInstance(1)));§this.addAbility(new ConditionalTriggeredAbility(new BeginningOfUpkeepTriggeredAbility(effect, TargetController.ANY, false),§new SourceHasCounterCondition(CounterType.CHARGE, 1),§"At the beginning of each upkeep, you may remove a charge counter from Sun Droplet. If you do, you gain 1 life"));§}§public SunDroplet(final SunDroplet card) {§super(card);§}§@Override§public SunDroplet copy() {§return new SunDroplet(this);§}§}§class SunDropletTriggeredAbility extends TriggeredAbilityImpl {§public SunDropletTriggeredAbility() {§super(Zone.BATTLEFIELD, new SunDropletEffect(), false);§}§public SunDropletTriggeredAbility(final SunDropletTriggeredAbility ability) {§super(ability);§}§@Override§public SunDropletTriggeredAbility copy() {§return new SunDropletTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.DAMAGED_PLAYER;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (event.getTargetId().equals(this.getControllerId())) {§this.getEffects().get(0).setValue("damageAmount", event.getAmount());§return true;§}§return false;§}§@Override§public String getRule() {§return "Whenever you're dealt damage, put that many charge counters on {this}.";§}§}§class SunDropletEffect extends OneShotEffect {§public SunDropletEffect() {§super(Outcome.Benefit);§}§public SunDropletEffect(final SunDropletEffect effect) {§super(effect);§}§@Override§public SunDropletEffect copy() {§return new SunDropletEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§return new AddCountersSourceEffect(CounterType.CHARGE.createInstance((Integer) this.getValue("damageAmount"))).apply(game, source);§}§}§
public class SurveyorsScope extends CardImpl {§public SurveyorsScope(UUID ownerId) {§super(ownerId, 262, "Surveyor's Scope", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{2}");§this.expansionSetCode = "C13";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new SurveyorsScopeEffect(), new TapSourceCost());§ability.addCost(new ExileSourceCost());§this.addAbility(ability);§}§public SurveyorsScope(final SurveyorsScope card) {§super(card);§}§@Override§public SurveyorsScope copy() {§return new SurveyorsScope(this);§}§}§class SurveyorsScopeEffect extends OneShotEffect {§public SurveyorsScopeEffect() {§super(Outcome.PutLandInPlay);§this.staticText = "Search your library for up to X basic land cards, where X is the number of players who control at least two more lands than you. Put those cards onto the battlefield, then shuffle your library";§}§public SurveyorsScopeEffect(final SurveyorsScopeEffect effect) {§super(effect);§}§@Override§public SurveyorsScopeEffect copy() {§return new SurveyorsScopeEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§int numberOfLands = 0;§int ownLands = game.getBattlefield().countAll(new FilterLandPermanent(), controller.getId(), game);§for (UUID playerId: game.getState().getPlayersInRange(controller.getId(), game)) {§if (!playerId.equals(controller.getId())) {§if (game.getBattlefield().countAll(new FilterLandPermanent(), playerId, game) > ownLands + 1) {§numberOfLands++;§}§}§}§game.informPlayers(new StringBuilder("Surveyor's Scope: X = ").append(numberOfLands).toString());§if (numberOfLands > 0) {§return new SearchLibraryPutInPlayEffect(new TargetCardInLibrary(0, numberOfLands, new FilterBasicLandCard())).apply(game, source);§}§return true;§}§return false;§}§}§
public class SwordOfTheParuns extends CardImpl {§private static final FilterCreaturePermanent filterTapped = new FilterCreaturePermanent();§private static final FilterCreaturePermanent filterUntapped = new FilterCreaturePermanent();§static {§filterTapped.add(new TappedPredicate());§filterUntapped.add(Predicates.not(new TappedPredicate()));§}§public SwordOfTheParuns(UUID ownerId) {§super(ownerId, 264, "Sword of the Paruns", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{4}");§this.expansionSetCode = "C13";§this.subtype.add("Equipment");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new ConditionalContinuousEffect(§new BoostControlledEffect(2,0, Duration.WhileOnBattlefield, filterTapped),§new CompoundCondition(EquipmentAttachedCondition.getInstance(), new AttachedToTappedCondition()),§"As long as equipped creature is tapped, tapped creatures you control get +2/+0"§)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new ConditionalContinuousEffect(§new BoostControlledEffect(0,2, Duration.WhileOnBattlefield, filterUntapped),§new CompoundCondition(EquipmentAttachedCondition.getInstance(), new InvertCondition(new AttachedToTappedCondition())),§"As long as equipped creature is untapped, untapped creatures you control get +0/+2"§)));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new MayTapOrUntapAttachedEffect(), new GenericManaCost(3)));§this.addAbility(new EquipAbility(Outcome.BoostCreature, new GenericManaCost(3)));§}§public SwordOfTheParuns(final SwordOfTheParuns card) {§super(card);§}§@Override§public SwordOfTheParuns copy() {§return new SwordOfTheParuns(this);§}§}§class MayTapOrUntapAttachedEffect extends OneShotEffect {§public MayTapOrUntapAttachedEffect() {§super(Outcome.Benefit);§this.staticText = "You may tap or untap equipped creature.";§}§public MayTapOrUntapAttachedEffect(final MayTapOrUntapAttachedEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent equipment = game.getPermanent(source.getSourceId());§if (equipment == null) {§equipment = (Permanent) game.getLastKnownInformation(source.getSourceId(), Zone.BATTLEFIELD);§}§if (equipment != null && equipment.getAttachedTo() != null) {§Permanent equipedCreature = game.getPermanent(equipment.getAttachedTo());§Player player = game.getPlayer(source.getControllerId());§if (equipedCreature != null && player != null) {§if (equipedCreature.isTapped()) {§if (player.chooseUse(Outcome.Untap, "Untap equipped creature?", source, game)) {§equipedCreature.untap(game);§}§} else {§if (player.chooseUse(Outcome.Tap, "Tap equipped creature?", source, game)) {§equipedCreature.tap(game);§}§}§return true;§}§}§return false;§}§@Override§public MayTapOrUntapAttachedEffect copy() {§return new MayTapOrUntapAttachedEffect(this);§}§}§
public class SydriGalvanicGenius extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("artifact creature");§private static final FilterArtifactPermanent filterNonCreature = new FilterArtifactPermanent("noncreature artifact");§static {§filter.add(new CardTypePredicate(CardType.ARTIFACT));§filter.add(new CardTypePredicate(CardType.CREATURE));§filterNonCreature.add(Predicates.not(new CardTypePredicate(CardType.CREATURE)));§}§public SydriGalvanicGenius(UUID ownerId) {§super(ownerId, 220, "Sydri, Galvanic Genius", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{W}{U}{B}");§this.expansionSetCode = "C13";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Artificer");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new SydriGalvanicGeniusEffect(), new ManaCostsImpl("{U"));§ability.addTarget(new TargetPermanent(filterNonCreature));§this.addAbility(ability);§Effect effect = new GainAbilityTargetEffect(DeathtouchAbility.getInstance(), Duration.EndOfTurn, "Target artifact creature gains deathtouch");§ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new ManaCostsImpl("{W}{B}"));§ability.addEffect(new GainAbilityTargetEffect(LifelinkAbility.getInstance(), Duration.EndOfTurn, "and lifelink until end of turn"));§ability.addTarget(new TargetPermanent(filter));§this.addAbility(ability);§}§public SydriGalvanicGenius(final SydriGalvanicGenius card) {§super(card);§}§@Override§public SydriGalvanicGenius copy() {§return new SydriGalvanicGenius(this);§}§}§class SydriGalvanicGeniusEffect extends ContinuousEffectImpl {§public SydriGalvanicGeniusEffect() {§super(Duration.EndOfTurn, Outcome.BecomeCreature);§staticText = "Target noncreature artifact becomes an artifact creature with power and toughness each equal to its converted mana cost until end of turn";§}§public SydriGalvanicGeniusEffect(final SydriGalvanicGeniusEffect effect) {§super(effect);§}§@Override§public SydriGalvanicGeniusEffect copy() {§return new SydriGalvanicGeniusEffect(this);§}§@Override§public boolean apply(Layer layer, SubLayer sublayer, Ability source, Game game) {§Permanent artifact = game.getPermanent(this.getTargetPointer().getFirst(game, source));§if (artifact == null) {§return false;§}§switch (layer) {§case TypeChangingEffects_4:§if (sublayer == SubLayer.NA) {§if (!artifact.getCardType().contains(CardType.CREATURE)) {§artifact.getCardType().add(CardType.CREATURE);§}§}§break;§case PTChangingEffects_7:§if (sublayer == SubLayer.SetPT_7b) {§int cmc = artifact.getManaCost().convertedManaCost();§artifact.getPower().setValue(cmc);§artifact.getToughness().setValue(cmc);§}§}§return true;§}§@Override§public boolean apply(Game game, Ability source) {§return false;§}§@Override§public boolean hasLayer(Layer layer) {§return layer == Layer.PTChangingEffects_7 || layer == Layer.TypeChangingEffects_4;§}§}§
public class TempleOfTheFalseGod extends CardImpl {§private static final FilterLandPermanent filter = new FilterLandPermanent("you control five or more lands");§public TempleOfTheFalseGod(UUID ownerId) {§super(ownerId, 327, "Temple of the False God", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "C13";§this.addAbility(new ActivateIfConditionManaAbility(§Zone.BATTLEFIELD,§new BasicManaEffect(Mana.ColorlessMana(2)),§new TapSourceCost(),§new PermanentsOnTheBattlefieldCondition(filter, PermanentsOnTheBattlefieldCondition.CountType.MORE_THAN, 4)));§}§public TempleOfTheFalseGod(final TempleOfTheFalseGod card) {§super(card);§}§@Override§public TempleOfTheFalseGod copy() {§return new TempleOfTheFalseGod(this);§}§}§
public class TemptWithImmortality extends CardImpl {§public TemptWithImmortality(UUID ownerId) {§super(ownerId, 95, "Tempt with Immortality", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{4}{B}");§this.expansionSetCode = "C13";§this.getSpellAbility().addEffect(new TemptWithImmortalityEffect());§}§public TemptWithImmortality(final TemptWithImmortality card) {§super(card);§}§@Override§public TemptWithImmortality copy() {§return new TemptWithImmortality(this);§}§}§class TemptWithImmortalityEffect extends OneShotEffect {§public TemptWithImmortalityEffect() {§super(Outcome.PutCreatureInPlay);§this.staticText = "<i>Tempting offer</i> - Return a creature card from your graveyard to the battlefield. Each opponent may return a creature card from his or her graveyard to the battlefield. For each player who does, return a creature card from your graveyard to the battlefield";§}§public TemptWithImmortalityEffect(final TemptWithImmortalityEffect effect) {§super(effect);§}§@Override§public TemptWithImmortalityEffect copy() {§return new TemptWithImmortalityEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§returnCreatureFromGraveToBattlefield(controller, source, game);§int opponentsReturnedCreatures = 0;§for (UUID playerId : game.getOpponents(controller.getId())) {§Player opponent = game.getPlayer(playerId);§if (opponent != null) {§FilterCard filter = new FilterCreatureCard("creature card from your graveyard");§filter.add(new OwnerIdPredicate(opponent.getId()));§Target targetOpponent = new TargetCardInGraveyard(filter);§if (targetOpponent.canChoose(source.getSourceId(), opponent.getId(), game)) {§if (opponent.chooseUse(outcome, new StringBuilder("Return a creature card from your graveyard to the battlefield?").toString(), source, game)) {§if (opponent.chooseTarget(outcome, targetOpponent, source, game)) {§Card card = game.getCard(targetOpponent.getFirstTarget());§if (card != null) {§opponentsReturnedCreatures++;§card.moveToZone(Zone.BATTLEFIELD, source.getSourceId(), game, false);§}§}§}§}§}§}§if (opponentsReturnedCreatures > 0) {§for (int i = 0; i < opponentsReturnedCreatures; i++) {§returnCreatureFromGraveToBattlefield(controller, source, game);§}§}§return true;§}§return false;§}§private boolean returnCreatureFromGraveToBattlefield(Player player, Ability source, Game game) {§Target target = new TargetCardInYourGraveyard(new FilterCreatureCard());§target.setNotTarget(false);§if (target.canChoose(source.getSourceId(), source.getControllerId(), game)) {§if (player.chooseTarget(outcome, target, source, game)) {§Card card = game.getCard(target.getFirstTarget());§if (card != null) {§return card.moveToZone(Zone.BATTLEFIELD, source.getSourceId(), game, false);§}§}§}§return false;§}§}§
public class TemptWithReflections extends CardImpl {§public TemptWithReflections(UUID ownerId) {§super(ownerId, 60, "Tempt with Reflections", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{3}{U}");§this.expansionSetCode = "C13";§this.getSpellAbility().addEffect(new TemptWithReflectionsEffect());§this.getSpellAbility().addTarget(new TargetControlledCreaturePermanent());§}§public TemptWithReflections(final TemptWithReflections card) {§super(card);§}§@Override§public TemptWithReflections copy() {§return new TemptWithReflections(this);§}§}§class TemptWithReflectionsEffect extends OneShotEffect {§public TemptWithReflectionsEffect() {§super(Outcome.PutCreatureInPlay);§this.staticText = "<i>Tempting offer</i> - Choose target creature you control. Put a token onto the battlefield that's a copy of that creature. Each opponent may put a token onto the battlefield that's a copy of that creature. For each opponent who does, put a token onto the battlefield that's a copy of that creature";§}§public TemptWithReflectionsEffect(final TemptWithReflectionsEffect effect) {§super(effect);§}§@Override§public TemptWithReflectionsEffect copy() {§return new TemptWithReflectionsEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getPermanentOrLKIBattlefield(this.getTargetPointer().getFirst(game, source));§if (permanent != null) {§Effect effect = new PutTokenOntoBattlefieldCopyTargetEffect();§effect.setTargetPointer(getTargetPointer());§effect.apply(game, source);§Set<UUID> playersSaidYes = new HashSet<>();§PlayerList playerList = game.getPlayerList().copy();§playerList.setCurrent(game.getActivePlayerId());§Player player = game.getPlayer(game.getActivePlayerId());§do {§if (game.getOpponents(source.getControllerId()).contains(player.getId())) {§String decision;§if (player.chooseUse(outcome, "Put a copy of target creature onto the battlefield for you?", source, game)) {§playersSaidYes.add(player.getId());§decision = " chooses to copy ";§} else {§decision = " won't copy ";§}§game.informPlayers((new StringBuilder(player.getLogName()).append(decision).append(permanent.getName()).toString()));§}§player = playerList.getNext(game);§} while (!player.getId().equals(game.getActivePlayerId()));§for (UUID playerId : playersSaidYes) {§effect = new PutTokenOntoBattlefieldCopyTargetEffect(playerId);§effect.setTargetPointer(getTargetPointer());§effect.apply(game, source);§}§if (playersSaidYes.size() > 0) {§effect = new PutTokenOntoBattlefieldCopyTargetEffect();§effect.setTargetPointer(getTargetPointer());§effect.apply(game, source);§}§return true;§}§return false;§}§}§
public class TemptWithVengeance extends CardImpl {§public TemptWithVengeance(UUID ownerId) {§super(ownerId, 125, "Tempt with Vengeance", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{X}{R}");§this.expansionSetCode = "C13";§this.getSpellAbility().addEffect(new TemptWithVengeanceEffect());§}§public TemptWithVengeance(final TemptWithVengeance card) {§super(card);§}§@Override§public TemptWithVengeance copy() {§return new TemptWithVengeance(this);§}§}§class TemptWithVengeanceEffect extends OneShotEffect {§public TemptWithVengeanceEffect() {§super(Outcome.PutLandInPlay);§this.staticText = "<i>Tempting offer</i> - Put X 1/1 red Elemental creature tokens with haste onto the battlefield. Each opponent may put X 1/1 red Elemental creature tokens with haste onto the battlefield. For each player who does, put X 1/1 red Elemental creature tokens with haste onto the battlefield";§}§public TemptWithVengeanceEffect(final TemptWithVengeanceEffect effect) {§super(effect);§}§@Override§public TemptWithVengeanceEffect copy() {§return new TemptWithVengeanceEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§int xValue = source.getManaCostsToPay().getX();§if (controller != null && xValue > 0) {§Token tokenCopy = new TemptWithVengeanceElementalToken();§tokenCopy.putOntoBattlefield(xValue, game, source.getSourceId(), source.getControllerId(), false, false);§int opponentsAddedTokens = 0;§for (UUID playerId : game.getOpponents(controller.getId())) {§Player opponent = game.getPlayer(playerId);§if (opponent != null) {§if (opponent.chooseUse(outcome, "Put " + xValue + " Elemental Tokens onto the battlefield?", source, game)) {§opponentsAddedTokens += xValue;§tokenCopy.putOntoBattlefield(xValue, game, source.getSourceId(), playerId, false, false);§}§}§}§if (opponentsAddedTokens > 0) {§tokenCopy.putOntoBattlefield(opponentsAddedTokens, game, source.getSourceId(), source.getControllerId(), false, false);§}§return true;§}§return false;§}§}§class TemptWithVengeanceElementalToken extends Token {§public TemptWithVengeanceElementalToken() {§super("Elemental", "1/1 red Elemental creature tokens with haste");§cardType.add(CardType.CREATURE);§subtype.add("Elemental");§color.setRed(true);§power = new MageInt(1);§toughness = new MageInt(1);§this.addAbility(HasteAbility.getInstance());§}§}§
public class TerraRavager extends CardImpl {§public TerraRavager(UUID ownerId) {§super(ownerId, 126, "Terra Ravager", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{R}{R}");§this.expansionSetCode = "C13";§this.subtype.add("Elemental");§this.subtype.add("Beast");§this.power = new MageInt(0);§this.toughness = new MageInt(4);§this.addAbility(new AttacksTriggeredAbility(new BoostSourceEffect(new TerraRavagerLandCount(), new StaticValue(0), Duration.EndOfTurn, true), false));§}§public TerraRavager(final TerraRavager card) {§super(card);§}§@Override§public TerraRavager copy() {§return new TerraRavager(this);§}§}§class TerraRavagerLandCount implements DynamicValue {§@Override§public int calculate(Game game, Ability sourceAbility, Effect effect) {§for (CombatGroup group :game.getCombat().getGroups()) {§if (group.getAttackers().contains(sourceAbility.getSourceId())) {§UUID defenderId = group.getDefenderId();§if (group.isDefenderIsPlaneswalker()) {§Permanent permanent = game.getPermanent(defenderId);§if (permanent != null) {§defenderId = permanent.getControllerId();§}§}§return game.getBattlefield().countAll(new FilterLandPermanent(), defenderId, game);§}§}§return 0;§}§@Override§public DynamicValue copy() {§return new TerraRavagerLandCount();§}§@Override§public String toString() {§return "X";§}§@Override§public String getMessage() {§return "the number of lands defending player controls";§}§}§
public class ThousandYearElixir extends CardImpl {§public ThousandYearElixir(UUID ownerId) {§super(ownerId, 266, "Thousand-Year Elixir", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "C13";§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new ThousandYearElixirEffect()));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new UntapTargetEffect(), new GenericManaCost(1));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public ThousandYearElixir(final ThousandYearElixir card) {§super(card);§}§@Override§public ThousandYearElixir copy() {§return new ThousandYearElixir(this);§}§}§class ThousandYearElixirEffect extends AsThoughEffectImpl {§public ThousandYearElixirEffect() {§super(AsThoughEffectType.ACTIVATE_HASTE, Duration.WhileOnBattlefield, Outcome.Benefit);§staticText = "You may activate abilities of creatures you control as though those creatures had haste";§}§public ThousandYearElixirEffect(final ThousandYearElixirEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public ThousandYearElixirEffect copy() {§return new ThousandYearElixirEffect(this);§}§@Override§public boolean applies(UUID sourceId, Ability source, UUID affectedControllerId, Game game) {§Permanent permanent = game.getPermanent(sourceId);§return permanent != null§&& permanent.getCardType().contains(CardType.CREATURE)§&& permanent.getControllerId().equals(source.getControllerId());§}§}§
public class Thunderstaff extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Attacking creatures");§static {§filter.add(new AttackingPredicate());§}§public Thunderstaff(UUID ownerId) {§super(ownerId, 267, "Thunderstaff", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "C13";§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new ThunderstaffPreventionEffect()));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostAllEffect(1,0,Duration.EndOfTurn, filter, false), new GenericManaCost(2));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§}§public Thunderstaff(final Thunderstaff card) {§super(card);§}§@Override§public Thunderstaff copy() {§return new Thunderstaff(this);§}§}§class ThunderstaffPreventionEffect extends PreventionEffectImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent();§public ThunderstaffPreventionEffect() {§super(Duration.WhileOnBattlefield, 1, true, false);§staticText = "As long as {this} is untapped, if a creature would deal combat damage to you, prevent 1 of that damage";§}§public ThunderstaffPreventionEffect(final ThunderstaffPreventionEffect effect) {§super(effect);§}§@Override§public ThunderstaffPreventionEffect copy() {§return new ThunderstaffPreventionEffect(this);§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§if (super.applies(event, source, game)) {§if (event.getTargetId().equals(source.getControllerId())){§Permanent sourcePermanent = game.getPermanent(source.getSourceId());§if (sourcePermanent != null && !sourcePermanent.isTapped()) {§Permanent damageSource = game.getPermanent(event.getSourceId());§if (damageSource != null && filter.match(damageSource, game)) {§return true;§}§}§}§}§return false;§}§}§
public class TidalForce extends CardImpl {§public TidalForce(UUID ownerId) {§super(ownerId, 62, "Tidal Force", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}{U}{U}{U}");§this.expansionSetCode = "C13";§this.subtype.add("Elemental");§this.power = new MageInt(7);§this.toughness = new MageInt(7);§Ability ability = new BeginningOfUpkeepTriggeredAbility(new MayTapOrUntapTargetEffect(), TargetController.ANY, false);§ability.addTarget(new TargetPermanent());§this.addAbility(ability);§}§public TidalForce(final TidalForce card) {§super(card);§}§@Override§public TidalForce copy() {§return new TidalForce(this);§}§}§
public class ToxicDeluge extends CardImpl {§public ToxicDeluge(UUID ownerId) {§super(ownerId, 96, "Toxic Deluge", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{2}{B}");§this.expansionSetCode = "C13";§this.getSpellAbility().addCost(new PayVariableLifeCost(true));§DynamicValue xValue = new SignInversionDynamicValue(new GetXValue());§this.getSpellAbility().addEffect(new BoostAllEffect(xValue, xValue, Duration.EndOfTurn, new FilterCreaturePermanent("All creatures"), false,§null, true));§}§public ToxicDeluge(final ToxicDeluge card) {§super(card);§}§@Override§public ToxicDeluge copy() {§return new ToxicDeluge(this);§}§}§
public class TrueNameNemesis extends CardImpl {§public TrueNameNemesis(UUID ownerId) {§super(ownerId, 63, "True-Name Nemesis", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{U}{U}");§this.expansionSetCode = "C13";§this.subtype.add("Merfolk");§this.subtype.add("Rogue");§this.power = new MageInt(3);§this.toughness = new MageInt(1);§this.addAbility(new AsEntersBattlefieldAbility(new ChoosePlayerEffect(Outcome.Protect)));§this.addAbility(new ProtectionFromPlayerAbility());§}§public TrueNameNemesis(final TrueNameNemesis card) {§super(card);§}§@Override§public TrueNameNemesis copy() {§return new TrueNameNemesis(this);§}§}§class ProtectionFromPlayerAbility extends ProtectionAbility {§public ProtectionFromPlayerAbility() {§super(new FilterCard());§}§public ProtectionFromPlayerAbility(final ProtectionFromPlayerAbility ability) {§super(ability);§}§@Override§public ProtectionFromPlayerAbility copy() {§return new ProtectionFromPlayerAbility(this);§}§@Override§public String getRule() {§return "{this} has protection from the chosen player.";§}§@Override§public boolean canTarget(MageObject source, Game game) {§UUID playerId = (UUID) game.getState().getValue(this.getSourceId() + "_player");§if (playerId != null && source != null) {§if (source instanceof Permanent) {§return !((Permanent) source).getControllerId().equals(playerId);§}§if (source instanceof Spell) {§return !((Spell) source).getControllerId().equals(playerId);§}§if (source instanceof StackObject) {§return !((StackObject) source).getControllerId().equals(playerId);§}§if (source instanceof Card) { §
public class UnexpectedlyAbsent extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("nonland permanent");§static {§filter.add(Predicates.not(new CardTypePredicate(CardType.LAND)));§}§public UnexpectedlyAbsent(UUID ownerId) {§super(ownerId, 25, "Unexpectedly Absent", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{X}{W}{W}");§this.expansionSetCode = "C13";§this.getSpellAbility().addEffect(new UnexpectedlyAbsentEffect());§this.getSpellAbility().addTarget(new TargetPermanent(filter));§}§public UnexpectedlyAbsent(final UnexpectedlyAbsent card) {§super(card);§}§@Override§public UnexpectedlyAbsent copy() {§return new UnexpectedlyAbsent(this);§}§}§class UnexpectedlyAbsentEffect extends OneShotEffect {§public UnexpectedlyAbsentEffect() {§super(Outcome.Benefit);§this.staticText = "Put target nonland permanent into its owner's library just beneath the top X cards of that library";§}§public UnexpectedlyAbsentEffect(final UnexpectedlyAbsentEffect effect) {§super(effect);§}§@Override§public UnexpectedlyAbsentEffect copy() {§return new UnexpectedlyAbsentEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Permanent permanent = game.getPermanent(this.getTargetPointer().getFirst(game, source));§if (permanent != null) {§Player owner = game.getPlayer(permanent.getOwnerId());§if (owner != null) {§int xValue = Math.min(source.getManaCostsToPay().getX(), owner.getLibrary().size());§Cards cards = new CardsImpl();§Deque<UUID> cardIds = new LinkedList<>();§for (int i = 0; i < xValue; i++) {§Card card = owner.getLibrary().removeFromTop(game);§cards.add(card);§cardIds.push(card.getId());§}§game.informPlayers(new StringBuilder(controller.getLogName())§.append(" puts ").append(permanent.getName())§.append(" beneath the top ").append(xValue)§.append(" cards of ").append(owner.getLogName()).append("'s library").toString());§permanent.moveToZone(Zone.LIBRARY, source.getSourceId(), game, true);§while(!cardIds.isEmpty()) {§UUID cardId = cardIds.poll();§Card card = cards.get(cardId, game);§if (card != null) {§card.moveToZone(Zone.LIBRARY, source.getSourceId(), game, true);§}§}§return true;§}§}§}§return false;§}§}§
public class VisionSkeins extends CardImpl {§public VisionSkeins(UUID ownerId) {§super(ownerId, 65, "Vision Skeins", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{U}");§this.expansionSetCode = "C13";§this.getSpellAbility().addEffect(new DrawCardAllEffect(2));§}§public VisionSkeins(final VisionSkeins card) {§super(card);§}§@Override§public VisionSkeins copy() {§return new VisionSkeins(this);§}§}§
public class WarCadence extends CardImpl {§public WarCadence(UUID ownerId) {§super(ownerId, 128, "War Cadence", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{R}");§this.expansionSetCode = "C13";§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new WarCadenceReplacementEffect(), new ManaCostsImpl("{X}{R}") ));§}§public WarCadence(final WarCadence card) {§super(card);§}§@Override§public WarCadence copy() {§return new WarCadence(this);§}§}§class WarCadenceReplacementEffect extends ReplacementEffectImpl {§DynamicValue xCosts = new ManacostVariableValue();§WarCadenceReplacementEffect ( ) {§super(Duration.EndOfTurn, Outcome.Neutral);§staticText = "This turn, creatures can't block unless their controller pays {X} for each blocking creature he or she controls";§}§WarCadenceReplacementEffect ( WarCadenceReplacementEffect effect ) {§super(effect);§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§Player player = game.getPlayer(event.getPlayerId());§if (player != null) {§int amount = xCosts.calculate(game, source, this);§if (amount > 0) {§String mana = new StringBuilder("{").append(amount).append("}").toString();§ManaCostsImpl cost = new ManaCostsImpl(mana);§if ( cost.canPay(source, source.getSourceId(), event.getPlayerId(), game) &&§player.chooseUse(Outcome.Benefit, new StringBuilder("Pay ").append(mana).append(" to declare blocker?").toString(), source, game) ) {§if (cost.payOrRollback(source, game, source.getSourceId(), event.getPlayerId())) {§return false;§}§}§return true;§}§}§return false;§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.DECLARE_BLOCKER;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§return true;§}§@Override§public WarCadenceReplacementEffect copy() {§return new WarCadenceReplacementEffect(this);§}§}§
public class WayfarersBauble extends CardImpl {§public WayfarersBauble(UUID ownerId) {§super(ownerId, 270, "Wayfarer's Bauble", Rarity.COMMON, new CardType[]{CardType.ARTIFACT}, "{1}");§this.expansionSetCode = "C13";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,§new SearchLibraryPutInPlayEffect(new TargetCardInLibrary(new FilterBasicLandCard()),true, true, Outcome.PutLandInPlay), new GenericManaCost(2));§ability.addCost(new SacrificeSourceCost());§this.addAbility(ability);§}§public WayfarersBauble(final WayfarersBauble card) {§super(card);§}§@Override§public WayfarersBauble copy() {§return new WayfarersBauble(this);§}§}§
public class WellOfLostDreams extends CardImpl {§public WellOfLostDreams(UUID ownerId) {§super(ownerId, 271, "Well of Lost Dreams", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{4}");§this.expansionSetCode = "C13";§this.addAbility(new GainLifeControllerTriggeredAbility(new WellOfLostDreamsEffect(), true, true));§}§public WellOfLostDreams(final WellOfLostDreams card) {§super(card);§}§@Override§public WellOfLostDreams copy() {§return new WellOfLostDreams(this);§}§}§class WellOfLostDreamsEffect extends OneShotEffect {§public WellOfLostDreamsEffect() {§super(Outcome.Benefit);§this.staticText = "you may pay {X}, where X is less than or equal to the amount of life you gained. If you do, draw X cards";§}§public WellOfLostDreamsEffect(final WellOfLostDreamsEffect effect) {§super(effect);§}§@Override§public WellOfLostDreamsEffect copy() {§return new WellOfLostDreamsEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§int amount = (Integer) getValue("gainedLife");§if (amount > 0) {§int xValue = controller.announceXMana(0, amount, "Announce X Value", game, source);§if (xValue > 0) {§if (new GenericManaCost(xValue).pay(source, game, source.getSourceId(), controller.getId(), false)) {§game.informPlayers(new StringBuilder(controller.getLogName()).append(" payed {").append(xValue).append("}").toString());§controller.drawCards(xValue, game);§} else {§return false;§}§}§}§return true;§}§return false;§}§}§
public class WidespreadPanic extends CardImpl {§public WidespreadPanic(UUID ownerId) {§super(ownerId, 131, "Widespread Panic", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{2}{R}");§this.expansionSetCode = "C13";§this.addAbility(new WidespreadPanicTriggeredAbility());§}§public WidespreadPanic(final WidespreadPanic card) {§super(card);§}§@Override§public WidespreadPanic copy() {§return new WidespreadPanic(this);§}§}§class WidespreadPanicTriggeredAbility extends TriggeredAbilityImpl {§public WidespreadPanicTriggeredAbility() {§super(Zone.BATTLEFIELD, new WidespreadPanicEffect(), false);§}§public WidespreadPanicTriggeredAbility(final WidespreadPanicTriggeredAbility ability) {§super(ability);§}§@Override§public WidespreadPanicTriggeredAbility copy() {§return new WidespreadPanicTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.LIBRARY_SHUFFLED;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§for (Effect effect :this.getEffects()) {§effect.setTargetPointer(new FixedTarget(event.getPlayerId()));§}§return true;§}§@Override§public String getRule() {§return new StringBuilder("Whenever a spell or ability causes its controller to shuffle his or her library, ").append(super.getRule()).toString();§}§}§class WidespreadPanicEffect extends OneShotEffect {§public WidespreadPanicEffect() {§super(Outcome.Detriment);§this.staticText = "that player puts a card from his or her hand on top of his or her library";§}§public WidespreadPanicEffect(final WidespreadPanicEffect effect) {§super(effect);§}§@Override§public WidespreadPanicEffect copy() {§return new WidespreadPanicEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player shuffler = game.getPlayer(this.getTargetPointer().getFirst(game, source));§if (shuffler != null) {§if (shuffler.getHand().size() > 0) {§TargetCardInHand target = new TargetCardInHand();§target.setNotTarget(true);§target.setTargetName("a card from your hand to put on top of your library");§shuffler.choose(Outcome.Detriment, target, source.getSourceId(), game);§Card card = shuffler.getHand().get(target.getFirstTarget(), game);§if (card != null) {§shuffler.moveCardToLibraryWithInfo(card, source.getSourceId(), game, Zone.HAND, true, false);§}§}§return true;§}§return false;§}§}§
public class WitchHunt extends CardImpl {§public WitchHunt(UUID ownerId) {§super(ownerId, 133, "Witch Hunt", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{4}{R}");§this.expansionSetCode = "C13";§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new CantGainLifeAllEffect()));§this.addAbility(new BeginningOfUpkeepTriggeredAbility(Zone.BATTLEFIELD, new DamageControllerEffect(4), TargetController.YOU, false));§Ability ability = new BeginningOfEndStepTriggeredAbility(Zone.BATTLEFIELD, new WitchHuntEffect(), TargetController.YOU, null, false);§Target target = new TargetOpponent();§target.setRandom(true);§ability.addTarget(target);§this.addAbility(ability);§}§public WitchHunt(final WitchHunt card) {§super(card);§}§@Override§public WitchHunt copy() {§return new WitchHunt(this);§}§}§class WitchHuntEffect extends ContinuousEffectImpl {§public WitchHuntEffect() {§super(Duration.Custom, Layer.ControlChangingEffects_2, SubLayer.NA, Outcome.GainControl);§staticText = "target opponent chosen at random gains control of {this}";§}§public WitchHuntEffect(final WitchHuntEffect effect) {§super(effect);§}§@Override§public WitchHuntEffect copy() {§return new WitchHuntEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getPermanent(source.getSourceId());§if (permanent != null) {§return permanent.changeControllerId(this.getTargetPointer().getFirst(game, source), game);§}§return false;§}§}§
public class AEtherGale extends CardImpl {§public AEtherGale(UUID ownerId) {§super(ownerId, 11, "AEther Gale", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{3}{U}{U}");§this.expansionSetCode = "C14";§this.getSpellAbility().addEffect(new ReturnToHandTargetEffect());§this.getSpellAbility().addTarget(new TargetNonlandPermanent(6,6, new FilterNonlandPermanent(), false));§}§public AEtherGale(final AEtherGale card) {§super(card);§}§@Override§public AEtherGale copy() {§return new AEtherGale(this);§}§}§
public class AEtherSnap extends CardImpl {§public AEtherSnap(UUID ownerId) {§super(ownerId, 133, "AEther Snap", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{3}{B}{B}");§this.expansionSetCode = "C14";§this.getSpellAbility().addEffect(new AEtherSnapEffect());§}§public AEtherSnap(final AEtherSnap card) {§super(card);§}§@Override§public AEtherSnap copy() {§return new AEtherSnap(this);§}§}§class AEtherSnapEffect extends OneShotEffect {§public AEtherSnapEffect() {§super(Outcome.Benefit);§this.staticText = "Remove all counters from all permanents and exile all tokens";§}§public AEtherSnapEffect(final AEtherSnapEffect effect) {§super(effect);§}§@Override§public AEtherSnapEffect copy() {§return new AEtherSnapEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§for (Permanent permanent :game.getBattlefield().getActivePermanents(new FilterPermanent(), controller.getId(), source.getSourceId(), game)) {§if (permanent instanceof PermanentToken) {§controller.moveCardToExileWithInfo(permanent, null, "", source.getSourceId(), game, Zone.BATTLEFIELD, true);§} else if (!permanent.getCounters().isEmpty()){§Counters counters = permanent.getCounters().copy();§for (Counter counter: counters.values()) {§permanent.getCounters().removeCounter(counter.getName(), counter.getCount());§}§}§}§return true;§}§return false;§}§}§
public class ArcaneLighthouse extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creatures your opponents control");§static {§filter.add(new ControllerPredicate(TargetController.OPPONENT));§}§public ArcaneLighthouse(UUID ownerId) {§super(ownerId, 59, "Arcane Lighthouse", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "C14";§this.addAbility(new ColorlessManaAbility());§Effect effect = new CreaturesCantGetOrHaveAbilityEffect(HexproofAbility.getInstance(), Duration.EndOfTurn, filter);§effect.setText("Until end of turn, creatures your opponents control lose hexproof");§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new GenericManaCost(1));§ability.addCost(new TapSourceCost());§effect = new CreaturesCantGetOrHaveAbilityEffect(ShroudAbility.getInstance(), Duration.EndOfTurn, filter);§effect.setText("and shroud and can't have hexproof or shroud");§ability.addEffect(effect);§this.addAbility(ability);§}§public ArcaneLighthouse(final ArcaneLighthouse card) {§super(card);§}§@Override§public ArcaneLighthouse copy() {§return new ArcaneLighthouse(this);§}§}§
public class Armistice extends CardImpl {§public Armistice(UUID ownerId) {§super(ownerId, 65, "Armistice", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{2}{W}");§this.expansionSetCode = "C14";§Effect effect = new DrawCardSourceControllerEffect(1);§effect.setText("You draw a card");§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new ManaCostsImpl("{3}{W}{W}"));§effect = new GainLifeTargetEffect(3);§effect.setText("and target opponent gains 3 life");§ability.addEffect(effect);§ability.addTarget(new TargetOpponent());§this.addAbility(ability);§}§public Armistice(final Armistice card) {§super(card);§}§@Override§public Armistice copy() {§return new Armistice(this);§}§}§
public class AssaultSuit extends CardImpl {§public AssaultSuit(UUID ownerId) {§super(ownerId, 53, "Assault Suit", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{4}");§this.expansionSetCode = "C14";§this.subtype.add("Equipment");§Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEquippedEffect(2, 2));§Effect effect = new GainAbilityAttachedEffect(HasteAbility.getInstance(), AttachmentType.EQUIPMENT);§effect.setText(", has haste");§ability.addEffect(effect);§effect = new CantAttackControllerAttachedEffect(AttachmentType.EQUIPMENT);§effect.setText(", can't attack you or a planeswalker you control");§ability.addEffect(effect);§effect = new AssaultSuitCantBeSacrificed();§effect.setText(", and can't be sacrificed");§ability.addEffect(effect);§this.addAbility(ability);§this.addAbility(new BeginningOfUpkeepTriggeredAbility(new AssaultSuitGainControlEffect(), TargetController.OPPONENT, false));§this.addAbility(new EquipAbility(Outcome.Detriment, new GenericManaCost(3)));§}§public AssaultSuit(final AssaultSuit card) {§super(card);§}§@Override§public AssaultSuit copy() {§return new AssaultSuit(this);§}§}§class AssaultSuitCantBeSacrificed extends ContinuousRuleModifyingEffectImpl {§public AssaultSuitCantBeSacrificed() {§super(Duration.WhileOnBattlefield, Outcome.Detriment, true, false);§staticText = "and can't be sacrificed";§}§public AssaultSuitCantBeSacrificed(final AssaultSuitCantBeSacrificed effect) {§super(effect);§}§@Override§public AssaultSuitCantBeSacrificed copy() {§return new AssaultSuitCantBeSacrificed(this);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public String getInfoMessage(Ability source, GameEvent event, Game game) {§return "This creature can't be sacrificed.";§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§if (event.getType() == GameEvent.EventType.SACRIFICE_PERMANENT) {§Permanent equipment = game.getPermanent(source.getSourceId());§if (equipment != null && equipment.getAttachedTo() != null) {§return equipment.getAttachedTo().equals(event.getTargetId());§}§}§return false;§}§}§class AssaultSuitGainControlEffect extends OneShotEffect {§public AssaultSuitGainControlEffect() {§super(Outcome.Benefit);§this.staticText = "you may have that player gain control of equipped creature until end of turn. If you do, untap it";§}§public AssaultSuitGainControlEffect(final AssaultSuitGainControlEffect effect) {§super(effect);§}§@Override§public AssaultSuitGainControlEffect copy() {§return new AssaultSuitGainControlEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§Player activePlayer = game.getPlayer(game.getActivePlayerId());§Permanent equipment = game.getPermanent(source.getSourceId());§if (controller != null && activePlayer != null && equipment != null) {§if (equipment.getAttachedTo() != null) {§Permanent equippedCreature = game.getPermanent(equipment.getAttachedTo());§if (equippedCreature != null && controller.chooseUse(outcome,§"Let have " + activePlayer.getLogName() + " gain control of " + equippedCreature.getLogName() + "?", source, game)) {§equippedCreature.untap(game);§ContinuousEffect effect = new GainControlTargetEffect(Duration.EndOfTurn, activePlayer.getId());§effect.setTargetPointer(new FixedTarget(equipment.getAttachedTo()));§game.addEffect(effect, source);§}§}§return true;§}§return false;§}§}§
public class BenevolentOffering extends CardImpl {§public BenevolentOffering(UUID ownerId) {§super(ownerId, 3, "Benevolent Offering", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{3}{W}");§this.expansionSetCode = "C14";§this.getSpellAbility().addEffect(new BenevolentOfferingEffect1());§this.getSpellAbility().addEffect(new BenevolentOfferingEffect2());§}§public BenevolentOffering(final BenevolentOffering card) {§super(card);§}§@Override§public BenevolentOffering copy() {§return new BenevolentOffering(this);§}§}§class BenevolentOfferingEffect1 extends OneShotEffect {§BenevolentOfferingEffect1() {§super(Outcome.Sacrifice);§this.staticText = "Choose an opponent. You and that player each put three 1/1 white Spirit creature tokens with flying onto the battlefield";§}§BenevolentOfferingEffect1(final BenevolentOfferingEffect1 effect) {§super(effect);§}§@Override§public BenevolentOfferingEffect1 copy() {§return new BenevolentOfferingEffect1(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Target target = new TargetOpponent(true);§target.choose(Outcome.Sacrifice, source.getControllerId(), source.getSourceId(), game);§Player opponent = game.getPlayer(target.getFirstTarget());§if (opponent != null) {§Effect effect = new CreateTokenTargetEffect(new SpiritWhiteToken("C14"), 3);§effect.setTargetPointer(new FixedTarget(opponent.getId()));§effect.apply(game, source);§new CreateTokenEffect(new SpiritWhiteToken("C14"), 3).apply(game, source);§return true;§}§}§return false;§}§}§class BenevolentOfferingEffect2 extends OneShotEffect {§BenevolentOfferingEffect2() {§super(Outcome.Sacrifice);§this.staticText = "Choose an opponent. You gain 2 life for each creature you control and that player gains 2 life for each creature he or she controls";§}§BenevolentOfferingEffect2(final BenevolentOfferingEffect2 effect) {§super(effect);§}§@Override§public BenevolentOfferingEffect2 copy() {§return new BenevolentOfferingEffect2(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Target target = new TargetOpponent(true);§target.choose(Outcome.Sacrifice, source.getControllerId(), source.getSourceId(), game);§Player opponent = game.getPlayer(target.getFirstTarget());§if (opponent != null) {§int count = game.getBattlefield().countAll(new FilterCreaturePermanent(), controller.getId(), game) * 2;§controller.gainLife(count, game);§count = game.getBattlefield().countAll(new FilterCreaturePermanent(), opponent.getId(), game) * 2;§opponent.gainLife(count, game);§return true;§}§}§return false;§}§}§
public class BitterFeud extends CardImpl {§public BitterFeud(UUID ownerId) {§super(ownerId, 32, "Bitter Feud", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{4}{R}");§this.expansionSetCode = "C14";§this.addAbility(new AsEntersBattlefieldAbility(new BitterFeudEntersBattlefieldEffect()));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BitterFeudEffect()));§}§public BitterFeud(final BitterFeud card) {§super(card);§}§@Override§public BitterFeud copy() {§return new BitterFeud(this);§}§}§class BitterFeudEntersBattlefieldEffect extends OneShotEffect {§public BitterFeudEntersBattlefieldEffect() {§super(Outcome.Damage);§staticText = "choose two players";§}§public BitterFeudEntersBattlefieldEffect(final BitterFeudEntersBattlefieldEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§Permanent permanent = game.getPermanentEntering(source.getSourceId());§if (controller != null && permanent != null) {§TargetPlayer target = new TargetPlayer(2, 2, true);§controller.chooseTarget(outcome, target, source, game);§Player player1 = game.getPlayer(target.getFirstTarget());§if (target.getTargets().size() > 1) {§Player player2 = game.getPlayer(target.getTargets().get(1));§if (player1 != null && player2 != null) {§game.getState().setValue(source.getSourceId() + "_player1", player1);§game.getState().setValue(source.getSourceId() + "_player2", player2);§game.informPlayers(permanent.getLogName() + ": " + controller.getLogName() + " has chosen " + player1.getLogName() + " and " + player2.getLogName());§permanent.addInfo("chosen players", "<font color = 'blue'>Chosen players: " + player1.getName() + ", " + player2.getName() + "</font>", game);§return true;§}§}§}§return false;§}§@Override§public BitterFeudEntersBattlefieldEffect copy() {§return new BitterFeudEntersBattlefieldEffect(this);§}§}§class BitterFeudEffect extends ReplacementEffectImpl {§Player player1;§Player player2;§public BitterFeudEffect() {§super(Duration.WhileOnBattlefield, Outcome.Damage);§staticText = "If a source controlled by one of the chosen players would deal damage to the other chosen player or a permanent that player controls, that source deals double that damage to that player or permanent instead";§}§public BitterFeudEffect(final BitterFeudEffect effect) {§super(effect);§}§@Override§public BitterFeudEffect copy() {§return new BitterFeudEffect(this);§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§switch (event.getType()) {§case DAMAGE_CREATURE:§case DAMAGE_PLAYER:§case DAMAGE_PLANESWALKER:§return true;§default:§return false;§}§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§player1 = (Player) game.getState().getValue(source.getSourceId() + "_player1");§player2 = (Player) game.getState().getValue(source.getSourceId() + "_player2");§if (player1 != null && player2 != null) {§UUID targetPlayerId = null;§switch (event.getType()) {§case DAMAGE_PLAYER:§targetPlayerId = event.getTargetId();§break;§case DAMAGE_CREATURE:§case DAMAGE_PLANESWALKER:§Permanent permanent = game.getPermanent(event.getTargetId());§if (permanent != null) {§targetPlayerId = permanent.getControllerId();§}§break;§default:§return false;§}§if (player1.getId().equals(targetPlayerId) || player2.getId().equals(targetPlayerId)) {§UUID sourcePlayerId = null;§MageObject damageSource = game.getObject(event.getSourceId());§if (damageSource instanceof StackObject) {§sourcePlayerId = ((StackObject) damageSource).getControllerId();§} else if (damageSource instanceof Permanent) {§sourcePlayerId = ((Permanent) damageSource).getControllerId();§} else if (damageSource instanceof Card) {§sourcePlayerId = ((Card) damageSource).getOwnerId();§}§if (sourcePlayerId != null§&& (player1.getId().equals(sourcePlayerId) || player2.getId().equals(sourcePlayerId))§&& !sourcePlayerId.equals(targetPlayerId)) {§return true;§}§}§}§return false;§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§event.setAmount(event.getAmount() * 2);§return false;§}§}§
public class BreachingLeviathan extends CardImpl {§public BreachingLeviathan(UUID ownerId) {§super(ownerId, 12, "Breaching Leviathan", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{7}{U}{U}");§this.expansionSetCode = "C14";§this.subtype.add("Leviathan");§this.power = new MageInt(9);§this.toughness = new MageInt(9);§Ability ability = new EntersBattlefieldTriggeredAbility(§new ConditionalOneShotEffect(new BreachingLeviathanEffect(), new CastFromHandCondition(),§"if you cast it from your hand, tap all nonblue creatures. Those creatures don't untap during their controllers' next untap steps"));§this.addAbility(ability, new CastFromHandWatcher());§}§public BreachingLeviathan(final BreachingLeviathan card) {§super(card);§}§@Override§public BreachingLeviathan copy() {§return new BreachingLeviathan(this);§}§}§class BreachingLeviathanEffect extends OneShotEffect {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("nonblue creatures");§static {§filter.add(Predicates.not(new ColorPredicate(ObjectColor.BLUE)));§}§public BreachingLeviathanEffect() {§super(Outcome.Tap);§this.staticText = "tap all nonblue creatures. Those creatures don't untap during their controllers' next untap steps";§}§public BreachingLeviathanEffect(final BreachingLeviathanEffect effect) {§super(effect);§}§@Override§public BreachingLeviathanEffect copy() {§return new BreachingLeviathanEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§for (Permanent creature: game.getBattlefield().getActivePermanents(filter, source.getControllerId(), source.getSourceId(), game)) {§creature.tap(game);§ContinuousEffect effect = new DontUntapInControllersNextUntapStepTargetEffect();§effect.setTargetPointer(new FixedTarget(creature.getId()));§game.addEffect(effect, source);§}§return true;§}§}§
public class BrineElemental extends CardImpl {§public BrineElemental(UUID ownerId) {§super(ownerId, 99, "Brine Elemental", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{U}{U}");§this.expansionSetCode = "C14";§this.subtype.add("Elemental");§this.power = new MageInt(5);§this.toughness = new MageInt(4);§this.addAbility(new MorphAbility(this, new ManaCostsImpl("{5}{U}{U}")));§this.addAbility(new TurnedFaceUpSourceTriggeredAbility(new BrineElementalEffect()));§}§public BrineElemental(final BrineElemental card) {§super(card);§}§@Override§public BrineElemental copy() {§return new BrineElemental(this);§}§}§class BrineElementalEffect extends OneShotEffect {§public BrineElementalEffect() {§super(Outcome.Benefit);§this.staticText = "each opponent skips his or her next untap step";§}§public BrineElementalEffect(final BrineElementalEffect effect) {§super(effect);§}§@Override§public BrineElementalEffect copy() {§return new BrineElementalEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§for (UUID playerId: game.getState().getPlayersInRange(controller.getId(), game)) {§if (controller.hasOpponent(playerId, game)) {§game.getState().getTurnMods().add(new TurnMod(playerId, PhaseStep.UNTAP));§}§}§return true;§}§return false;§}§}§
public class Comeuppance extends CardImpl {§public Comeuppance(UUID ownerId) {§super(ownerId, 4, "Comeuppance", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{3}{W}");§this.expansionSetCode = "C14";§this.getSpellAbility().addEffect(new ComeuppanceEffect());§}§public Comeuppance(final Comeuppance card) {§super(card);§}§@Override§public Comeuppance copy() {§return new Comeuppance(this);§}§}§class ComeuppanceEffect extends PreventionEffectImpl {§public ComeuppanceEffect() {§super(Duration.EndOfTurn, Integer.MAX_VALUE, false, false);§staticText = "Prevent all damage that would be dealt to you and planeswalkers you control this turn by sources you don't control. If damage from a creature source is prevented this way, {this} deals that much damage to that creature. If damage from a noncreature source is prevented this way, {this} deals that much damage to the source's controller";§}§public ComeuppanceEffect(final ComeuppanceEffect effect) {§super(effect);§}§@Override§public ComeuppanceEffect copy() {§return new ComeuppanceEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§PreventionEffectData preventionData = preventDamageAction(event, source, game);§if (preventionData.getPreventedDamage() > 0) {§MageObject damageDealingObject = game.getObject(event.getSourceId());§UUID objectControllerId = null;§if (damageDealingObject instanceof Permanent) {§if (((Permanent) damageDealingObject).getCardType().contains(CardType.CREATURE)) {§((Permanent) damageDealingObject).damage(preventionData.getPreventedDamage(), source.getSourceId(), game, false, true);§} else {§objectControllerId = ((Permanent) damageDealingObject).getControllerId();§}§} else if (damageDealingObject instanceof Ability) {§objectControllerId = ((Ability) damageDealingObject).getControllerId();§} else if (damageDealingObject instanceof Spell) {§objectControllerId = ((Spell) damageDealingObject).getControllerId();§}§if (objectControllerId != null) {§Player objectController = game.getPlayer(objectControllerId);§if (objectController != null) {§objectController.damage(preventionData.getPreventedDamage(), source.getSourceId(), game, false, true);§}§}§}§return true;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§if (!super.applies(event, source, game)) {§return false;§}§boolean catched = false;§if (event.getTargetId().equals(source.getControllerId())) {§catched = true;§} else {§Permanent targetPermanent = game.getPermanent(event.getTargetId());§if (targetPermanent != null &&§targetPermanent.getControllerId().equals(source.getControllerId()) &&§targetPermanent.getCardType().contains(CardType.PLANESWALKER)) {§catched = true;§}§}§if (catched) {§MageObject damageSource = game.getObject(event.getSourceId());§if (damageSource instanceof StackObject) {§return !((StackObject) damageSource).getControllerId().equals(source.getControllerId());§} else if (damageSource instanceof Permanent) {§return !((Permanent) damageSource).getControllerId().equals(source.getControllerId());§} else if (damageSource instanceof Card) {§return !((Card) damageSource).getOwnerId().equals(source.getControllerId());§}§Logger.getLogger(Comeuppance.class).error("Comeuppance: could not define source objects controller - " + (damageSource != null ? damageSource.getName(): "null"));§}§return false;§}§}§
public class CommandersSphere extends CardImpl {§public CommandersSphere(UUID ownerId) {§super(ownerId, 54, "Commander's Sphere", Rarity.COMMON, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "C14";§this.addAbility(new CommanderColorIdentityManaAbility());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new DrawCardSourceControllerEffect(1), new SacrificeSourceCost()));§}§public CommandersSphere(final CommandersSphere card) {§super(card);§}§@Override§public CommandersSphere copy() {§return new CommandersSphere(this);§}§}§
public class ContainmentPriest extends CardImpl {§public ContainmentPriest(UUID ownerId) {§super(ownerId, 5, "Containment Priest", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "C14";§this.subtype.add("Human");§this.subtype.add("Cleric");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlashAbility.getInstance());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new ContainmentPriestReplacementEffect()), new CreatureWasCastWatcher());§}§public ContainmentPriest(final ContainmentPriest card) {§super(card);§}§@Override§public ContainmentPriest copy() {§return new ContainmentPriest(this);§}§}§class ContainmentPriestReplacementEffect extends ReplacementEffectImpl {§public ContainmentPriestReplacementEffect() {§super(Duration.WhileOnBattlefield, Outcome.Exile);§staticText = "If a nontoken creature would enter the battlefield and it wasn't cast, exile it instead";§}§public ContainmentPriestReplacementEffect(final ContainmentPriestReplacementEffect effect) {§super(effect);§}§@Override§public ContainmentPriestReplacementEffect copy() {§return new ContainmentPriestReplacementEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§Player controller = game.getPlayer(source.getControllerId());§ZoneChangeEvent zEvent = (ZoneChangeEvent) event;§if (controller != null) {§Card card = game.getCard(event.getTargetId());§if (card != null) {§controller.moveCardToExileWithInfo(card, null, "", source.getSourceId(), game, zEvent.getFromZone(), true);§}§return true;§}§return false;§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.ZONE_CHANGE; §
public class CoralAtoll extends CardImpl {§private static final FilterControlledLandPermanent filter = new FilterControlledLandPermanent("an untapped Island");§static {§filter.add(new SubtypePredicate("Island"));§filter.add(Predicates.not(new TappedPredicate()));§}§public CoralAtoll(UUID ownerId) {§super(ownerId, 287, "Coral Atoll", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "C14";§this.addAbility(new EntersBattlefieldTappedAbility());§this.addAbility(new EntersBattlefieldTriggeredAbility(new SacrificeSourceUnlessPaysEffect(new ReturnToHandChosenControlledPermanentCost(new TargetControlledPermanent(filter)))));§this.addAbility(new SimpleManaAbility(Zone.BATTLEFIELD, new Mana(0, 0, 1, 0, 0, 0, 0, 1), new TapSourceCost()));§}§public CoralAtoll(final CoralAtoll card) {§super(card);§}§@Override§public CoralAtoll copy() {§return new CoralAtoll(this);§}§}§
public class Creeperhulk extends CardImpl {§public Creeperhulk(UUID ownerId) {§super(ownerId, 42, "Creeperhulk", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{G}{G}");§this.expansionSetCode = "C14";§this.subtype.add("Plant");§this.subtype.add("Elemental");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(TrampleAbility.getInstance());§Effect effect = new SetPowerToughnessTargetEffect(5,5, Duration.EndOfTurn);§effect.setText("Until end of turn, target creature you control has base power and toughness 5/5");§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new ManaCostsImpl("{1}{G}"));§ability.addTarget(new TargetControlledCreaturePermanent());§ability.addEffect(new GainAbilityTargetEffect(TrampleAbility.getInstance(), Duration.EndOfTurn, "and gains Trample"));§this.addAbility(ability);§}§public Creeperhulk(final Creeperhulk card) {§super(card);§}§@Override§public Creeperhulk copy() {§return new Creeperhulk(this);§}§}§
public class CrownOfDoom extends CardImpl {§private static final FilterPlayer filter = new FilterPlayer("player other than Crown of Doom's owner");§static {§filter.add(new PlayerPredicate(TargetController.NOT_YOU));§}§public CrownOfDoom(UUID ownerId) {§super(ownerId, 55, "Crown of Doom", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "C14";§Effect effect = new BoostTargetEffect(2,0,Duration.EndOfTurn);§effect.setText("it gets +2/+0 until end of turn");§this.addAbility(new AttacksAllTriggeredAbility(effect, false, new FilterCreaturePermanent(), SetTargetPointer.PERMANENT, true));§Ability ability = new ActivateIfConditionActivatedAbility(Zone.BATTLEFIELD, new CrownOfDoomEffect(), new ManaCostsImpl("{2}"), MyTurnCondition.getInstance());§ability.addTarget(new TargetPlayer(1, 1, false, filter));§this.addAbility(ability);§}§public CrownOfDoom(final CrownOfDoom card) {§super(card);§}§@Override§public CrownOfDoom copy() {§return new CrownOfDoom(this);§}§}§class CrownOfDoomEffect extends OneShotEffect {§public CrownOfDoomEffect() {§super(Outcome.Detriment);§this.staticText = "Target player other than {this}'s owner gains control of it";§}§public CrownOfDoomEffect(final CrownOfDoomEffect effect) {§super(effect);§}§@Override§public CrownOfDoomEffect copy() {§return new CrownOfDoomEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§Player newController = game.getPlayer(getTargetPointer().getFirst(game, source));§if (controller != null && newController != null) {§ContinuousEffect effect = new GainControlTargetEffect(Duration.EndOfGame, newController.getId());§effect.setTargetPointer(new FixedTarget(source.getSourceId()));§game.addEffect(effect, source);§return true;§}§return false;§}§}§
public class DarettiScrapSavant extends CardImpl {§public DarettiScrapSavant(UUID ownerId) {§super(ownerId, 33, "Daretti, Scrap Savant", Rarity.MYTHIC, new CardType[]{CardType.PLANESWALKER}, "{3}{R}");§this.expansionSetCode = "C14";§this.subtype.add("Daretti");§this.addAbility(new PlanswalkerEntersWithLoyalityCountersAbility(3));§this.addAbility(new LoyaltyAbility(new DarettiDiscardDrawEffect(), 2));§LoyaltyAbility loyaltyAbility = new LoyaltyAbility(new DarettiSacrificeEffect(), -2);§loyaltyAbility.addTarget(new TargetCardInYourGraveyard(new FilterArtifactCard("artifact card from your graveyard")));§this.addAbility(loyaltyAbility);§this.addAbility(new LoyaltyAbility(new GetEmblemEffect(new DarettiScrapSavantEmblem()), -10));§this.addAbility(CanBeYourCommanderAbility.getInstance());§}§public DarettiScrapSavant(final DarettiScrapSavant card) {§super(card);§}§@Override§public DarettiScrapSavant copy() {§return new DarettiScrapSavant(this);§}§}§class DarettiDiscardDrawEffect extends OneShotEffect {§public DarettiDiscardDrawEffect() {§super(Outcome.Detriment);§this.staticText = "Discard up to two cards, then draw that many cards";§}§public DarettiDiscardDrawEffect(final DarettiDiscardDrawEffect effect) {§super(effect);§}§@Override§public DarettiDiscardDrawEffect copy() {§return new DarettiDiscardDrawEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§TargetDiscard target = new TargetDiscard(0, 2, new FilterCard(), controller.getId());§target.choose(outcome, controller.getId(), source.getSourceId(), game);§int count = 0;§for (UUID cardId : target.getTargets()) {§Card card = game.getCard(cardId);§if (card != null) {§controller.discard(card, source, game);§count++;§}§}§controller.drawCards(count, game);§return true;§}§return false;§}§}§class DarettiSacrificeEffect extends OneShotEffect {§public DarettiSacrificeEffect() {§super(Outcome.PutCardInPlay);§this.staticText = "Sacrifice an artifact. If you do, return target artifact card from your graveyard to the battlefield";§}§public DarettiSacrificeEffect(final DarettiSacrificeEffect effect) {§super(effect);§}§@Override§public DarettiSacrificeEffect copy() {§return new DarettiSacrificeEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Target target = new TargetControlledPermanent(1, 1, new FilterControlledArtifactPermanent(), true);§if (target.canChoose(source.getSourceId(), controller.getId(), game)§&& controller.chooseTarget(outcome, target, source, game)) {§Permanent artifact = game.getPermanent(target.getFirstTarget());§if (artifact != null && artifact.sacrifice(source.getSourceId(), game)) {§Card card = game.getCard(getTargetPointer().getFirst(game, source));§if (card != null) {§return controller.moveCards(card, Zone.BATTLEFIELD, source, game);§}§}§}§return true;§}§return false;§}§}§class DarettiScrapSavantEmblem extends Emblem {§public DarettiScrapSavantEmblem() {§this.setName("Emblem - Daretti");§this.getAbilities().add(new DarettiScrapSavantTriggeredAbility());§}§}§class DarettiScrapSavantTriggeredAbility extends TriggeredAbilityImpl {§DarettiScrapSavantTriggeredAbility() {§super(Zone.COMMAND, new DarettiScrapSavantEffect(), false);§}§DarettiScrapSavantTriggeredAbility(final DarettiScrapSavantTriggeredAbility ability) {§super(ability);§}§@Override§public DarettiScrapSavantTriggeredAbility copy() {§return new DarettiScrapSavantTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.ZONE_CHANGE;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§ZoneChangeEvent zEvent = (ZoneChangeEvent) event;§if (zEvent.getToZone() == Zone.GRAVEYARD§&& zEvent.getFromZone() == Zone.BATTLEFIELD§&& zEvent.getTarget().getCardType().contains(CardType.ARTIFACT)§&& zEvent.getTarget().getOwnerId().equals(this.controllerId)) {§for (Effect effect : this.getEffects()) {§effect.setTargetPointer(new FixedTarget(zEvent.getTargetId()));§}§return true;§}§return false;§}§@Override§public String getRule() {§return "Whenever an artifact is put into your graveyard from the battlefield, " + super.getRule();§}§}§class DarettiScrapSavantEffect extends OneShotEffect {§DarettiScrapSavantEffect() {§super(Outcome.PutCardInPlay);§this.staticText = "return that card to the battlefield at the beginning of the next end step";§}§DarettiScrapSavantEffect(final DarettiScrapSavantEffect effect) {§super(effect);§}§@Override§public DarettiScrapSavantEffect copy() {§return new DarettiScrapSavantEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Card card = game.getCard(getTargetPointer().getFirst(game, source));§if (card != null && game.getState().getZone(card.getId()).equals(Zone.GRAVEYARD)) {§Effect effect = new ReturnFromGraveyardToBattlefieldTargetEffect();§effect.setTargetPointer(new FixedTarget(card.getId(), card.getZoneChangeCounter(game)));§effect.setText("return that card to the battlefield at the beginning of the next end step");§DelayedTriggeredAbility delayedAbility = new AtTheBeginOfNextEndStepDelayedTriggeredAbility(Zone.COMMAND, effect, TargetController.ANY);§delayedAbility.setSourceId(source.getSourceId());§delayedAbility.setControllerId(source.getControllerId());§delayedAbility.setSourceObject(source.getSourceObject(game), game);§game.addDelayedTriggeredAbility(delayedAbility);§return true;§}§return false;§}§}§
public class DemonOfWailingAgonies extends CardImpl {§public DemonOfWailingAgonies(UUID ownerId) {§super(ownerId, 21, "Demon of Wailing Agonies", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{B}{B}");§this.expansionSetCode = "C14";§this.subtype.add("Demon");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§Ability gainedAbility = new DealsCombatDamageToAPlayerTriggeredAbility(new SacrificeEffect(new FilterControlledCreaturePermanent("a creature"), 1, "that player"), false, true);§ContinuousEffect effect = new GainAbilitySourceEffect(gainedAbility);§effect.setText("and has \"Whenever {this} deals combat damage to a player, that player sacrifices a creature.\"");§this.addAbility(new LieutenantAbility(effect));§}§public DemonOfWailingAgonies(final DemonOfWailingAgonies card) {§super(card);§}§@Override§public DemonOfWailingAgonies copy() {§return new DemonOfWailingAgonies(this);§}§}§
public class DeployToTheFront extends CardImpl {§public DeployToTheFront(UUID ownerId) {§super(ownerId, 6, "Deploy to the Front", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{5}{W}{W}");§this.expansionSetCode = "C14";§Effect effect = new CreateTokenEffect(new SoldierToken(), new PermanentsOnBattlefieldCount(new FilterCreaturePermanent("the number of creatures on the battlefield")));§effect.setText("Put X 1/1 white Soldier creature tokens onto the battlefield, where X is the number of creatures on the battlefield");§this.getSpellAbility().addEffect(effect);§}§public DeployToTheFront(final DeployToTheFront card) {§super(card);§}§@Override§public DeployToTheFront copy() {§return new DeployToTheFront(this);§}§}§
public class DistortingWake extends CardImpl {§public DistortingWake(UUID ownerId) {§super(ownerId, 107, "Distorting Wake", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{X}{U}{U}{U}");§this.expansionSetCode = "C14";§Effect effect = new ReturnToHandTargetEffect();§effect.setText("Return X target nonland permanents to their owners' hands");§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addTarget(new TargetNonlandPermanent());§}§public DistortingWake(final DistortingWake card) {§super(card);§}§@Override§public DistortingWake copy() {§return new DistortingWake(this);§}§@Override§public void adjustTargets(Ability ability, Game game) {§if (ability instanceof SpellAbility) {§int xValue = ability.getManaCostsToPay().getX();§Target target = new TargetNonlandPermanent(xValue, xValue,§new FilterNonlandPermanent(xValue + " target nonland permanent(s)"), false);§ability.getTargets().clear();§ability.getTargets().add(target);§}§}§}§
public class DomineeringWill extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("nonattacking creatures");§static {§filter.add(Predicates.not(new AttackingPredicate()));§}§public DomineeringWill(UUID ownerId) {§super(ownerId, 13, "Domineering Will", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{3}{U}");§this.expansionSetCode = "C14";§this.getSpellAbility().addEffect(new DomineeringWillEffect());§this.getSpellAbility().addTarget(new TargetPlayer());§this.getSpellAbility().addTarget(new TargetCreaturePermanent(0, 3, filter, false));§}§public DomineeringWill(final DomineeringWill card) {§super(card);§}§@Override§public DomineeringWill copy() {§return new DomineeringWill(this);§}§}§class DomineeringWillEffect extends OneShotEffect {§public DomineeringWillEffect() {§super(Outcome.Benefit);§staticText = "Target player gains control of up to three target nonattacking creatures until end of turn. Untap those creatures. They block this turn if able";§}§public DomineeringWillEffect(final DomineeringWillEffect effect) {§super(effect);§}§@Override§public DomineeringWillEffect copy() {§return new DomineeringWillEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player targetPlayer = game.getPlayer(getTargetPointer().getFirst(game, source));§if (targetPlayer != null) {§ContinuousEffect effect = new GainControlTargetEffect(Duration.EndOfTurn, targetPlayer.getId());§effect.setTargetPointer(new SecondTargetPointer());§effect.setText("Target player gains control of up to three target nonattacking creatures until end of turn");§game.addEffect(effect, source);§Effect effect2 = new UntapTargetEffect();§effect2.setTargetPointer(new SecondTargetPointer());§effect2.setText("Untap those creatures");§effect2.apply(game, source);§RequirementEffect effect3 = new BlocksIfAbleTargetEffect(Duration.EndOfTurn);§effect3.setTargetPointer(new SecondTargetPointer());§effect3.setText("They block this turn if able");§game.addEffect(effect3, source);§return true;§}§return false;§}§}§
public class DualcasterMage extends CardImpl {§private static final FilterSpell filter = new FilterSpell("instant or sorcery spell");§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.INSTANT),§new CardTypePredicate(CardType.SORCERY)));§}§public DualcasterMage(UUID ownerId) {§super(ownerId, 34, "Dualcaster Mage", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{R}{R}");§this.expansionSetCode = "C14";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlashAbility.getInstance());§Ability ability = new EntersBattlefieldTriggeredAbility(new CopyTargetSpellEffect(), false);§ability.addTarget(new TargetSpell(filter));§this.addAbility(ability);§}§public DualcasterMage(final DualcasterMage card) {§super(card);§}§@Override§public DualcasterMage copy() {§return new DualcasterMage(this);§}§}§
public class DulcetSirens extends CardImpl {§public DulcetSirens(UUID ownerId) {§super(ownerId, 14, "Dulcet Sirens", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{U}");§this.expansionSetCode = "C14";§this.subtype.add("Siren");§this.power = new MageInt(1);§this.toughness = new MageInt(3);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DulcetSirensForceAttackEffect(Duration.EndOfTurn), new ManaCostsImpl("{U}"));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent());§ability.addTarget(new TargetOpponent());§this.addAbility(ability);§this.addAbility(new MorphAbility(this, new ManaCostsImpl("{U}")));§}§public DulcetSirens(final DulcetSirens card) {§super(card);§}§@Override§public DulcetSirens copy() {§return new DulcetSirens(this);§}§}§class DulcetSirensForceAttackEffect extends RequirementEffect {§public DulcetSirensForceAttackEffect(Duration duration) {§super(duration);§staticText = "Target creature attacks target opponent this turn if able";§}§public DulcetSirensForceAttackEffect(final DulcetSirensForceAttackEffect effect) {§super(effect);§}§@Override§public DulcetSirensForceAttackEffect copy() {§return new DulcetSirensForceAttackEffect(this);§}§@Override§public boolean applies(Permanent permanent, Ability source, Game game) {§if (this.getTargetPointer().getTargets(game, source).contains(permanent.getId())) {§return true;§}§return false;§}§@Override§public boolean mustAttack(Game game) {§return true;§}§@Override§public boolean mustBlock(Game game) {§return false;§}§@Override§public UUID mustAttackDefender(Ability source, Game game) {§Target target = source.getTargets().get(1);§if (target != null) {§return target.getFirstTarget();§}§return null;§}§}§
public class Everglades extends CardImpl {§private static final FilterControlledLandPermanent filter = new FilterControlledLandPermanent("an untapped Swamp");§static {§filter.add(new SubtypePredicate("Swamp"));§filter.add(Predicates.not(new TappedPredicate()));§}§public Everglades(UUID ownerId) {§super(ownerId, 294, "Everglades", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "C14";§this.addAbility(new EntersBattlefieldTappedAbility());§this.addAbility(new EntersBattlefieldTriggeredAbility(new SacrificeSourceUnlessPaysEffect(new ReturnToHandChosenControlledPermanentCost(new TargetControlledPermanent(1, 1, filter, true)))));§this.addAbility(new SimpleManaAbility(Zone.BATTLEFIELD, new Mana(0, 0, 0, 0, 0, 1, 0, 1), new TapSourceCost()));§}§public Everglades(final Everglades card) {§super(card);§}§@Override§public Everglades copy() {§return new Everglades(this);§}§}§
public class Exclude extends CardImpl {§public Exclude(UUID ownerId) {§super(ownerId, 108, "Exclude", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{U}");§this.expansionSetCode = "C14";§this.getSpellAbility().addEffect(new CounterTargetEffect());§this.getSpellAbility().addTarget(new TargetSpell(new FilterCreatureSpell()));§this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(1));§}§public Exclude(final Exclude card) {§super(card);§}§@Override§public Exclude copy() {§return new Exclude(this);§}§}§
public class FeldonOfTheThirdPath extends CardImpl {§public FeldonOfTheThirdPath(UUID ownerId) {§super(ownerId, 35, "Feldon of the Third Path", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{1}{R}{R}");§this.expansionSetCode = "C14";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Artificer");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new FeldonOfTheThirdPathEffect(), new ManaCostsImpl("{2}{R}"));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetCardInYourGraveyard(1, 1, new FilterCreatureCard("creature card in your graveyard")));§this.addAbility(ability);§}§public FeldonOfTheThirdPath(final FeldonOfTheThirdPath card) {§super(card);§}§@Override§public FeldonOfTheThirdPath copy() {§return new FeldonOfTheThirdPath(this);§}§}§class FeldonOfTheThirdPathEffect extends OneShotEffect {§public FeldonOfTheThirdPathEffect() {§super(Outcome.PutCreatureInPlay);§this.staticText = "Put a token onto the battlefield that's a copy of target creature card in your graveyard, except it's an artifact in addition to its other types. It gains haste. Sacrifice it at the beginning of the next end step";§}§public FeldonOfTheThirdPathEffect(final FeldonOfTheThirdPathEffect effect) {§super(effect);§}§@Override§public FeldonOfTheThirdPathEffect copy() {§return new FeldonOfTheThirdPathEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Card card = game.getCard(getTargetPointer().getFirst(game, source));§if (card != null) {§PutTokenOntoBattlefieldCopyTargetEffect effect = new PutTokenOntoBattlefieldCopyTargetEffect(source.getControllerId(), CardType.ARTIFACT, true);§effect.setTargetPointer(new FixedTarget(card.getId(), game.getState().getZoneChangeCounter(card.getId())));§effect.apply(game, source);§for (Permanent addedToken : effect.getAddedPermanent()) {§SacrificeTargetEffect sacrificeEffect = new SacrificeTargetEffect("Sacrifice the token at the beginning of the next end step", source.getControllerId());§sacrificeEffect.setTargetPointer(new FixedTarget(addedToken, game));§DelayedTriggeredAbility delayedAbility = new AtTheBeginOfNextEndStepDelayedTriggeredAbility(sacrificeEffect);§game.addDelayedTriggeredAbility(delayedAbility, source);§}§return true;§}§return false;§}§}§
public class FellTheMighty extends CardImpl {§public FellTheMighty(UUID ownerId) {§super(ownerId, 7, "Fell the Mighty", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{4}{W}");§this.expansionSetCode = "C14";§this.getSpellAbility().addEffect(new FellTheMightyEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public FellTheMighty(final FellTheMighty card) {§super(card);§}§@Override§public FellTheMighty copy() {§return new FellTheMighty(this);§}§}§class FellTheMightyEffect extends OneShotEffect {§public FellTheMightyEffect() {§super(Outcome.DestroyPermanent);§this.staticText = "Destroy all creatures with power greater than target creature's power";§}§public FellTheMightyEffect(final FellTheMightyEffect effect) {§super(effect);§}§@Override§public FellTheMightyEffect copy() {§return new FellTheMightyEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§Permanent targetCreature = game.getPermanentOrLKIBattlefield(source.getFirstTarget());§if (controller != null && targetCreature != null) {§for(Permanent permanent: game.getBattlefield().getActivePermanents(new FilterCreaturePermanent(), controller.getId(), source.getSourceId(), game)) {§if (permanent.getPower().getValue() > targetCreature.getPower().getValue()) {§permanent.destroy(source.getSourceId(), game, false);§}§}§return true;§}§return false;§}§}§
public class FlamekinVillage extends CardImpl {§private static final FilterCard filter = new FilterCard("an Elemental card from your hand");§static {§filter.add(new SubtypePredicate("Elemental"));§}§public FlamekinVillage(UUID ownerId) {§super(ownerId, 60, "Flamekin Village", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "C14";§this.addAbility(new AsEntersBattlefieldAbility(new TapSourceUnlessPaysEffect(new RevealTargetFromHandCost(new TargetCardInHand(filter))), "you may reveal a Elemental card from your hand. If you don't, {this} enters the battlefield tapped"));§this.addAbility(new RedManaAbility());§SimpleActivatedAbility ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,§new GainAbilityTargetEffect(HasteAbility.getInstance(), Duration.EndOfTurn),§new ManaCostsImpl("{R}"));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public FlamekinVillage(final FlamekinVillage card) {§super(card);§}§@Override§public FlamekinVillage copy() {§return new FlamekinVillage(this);§}§}§
public class FleshCarver extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("another creature");§static {§filter.add(new AnotherPredicate());§}§public FleshCarver(UUID ownerId) {§super(ownerId, 22, "Flesh Carver", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{B}");§this.expansionSetCode = "C14";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(IntimidateAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new AddCountersSourceEffect(CounterType.P1P1.createInstance(2)), new ManaCostsImpl("{1}{B}"));§ability.addCost(new SacrificeTargetCost(new TargetControlledPermanent(filter)));§this.addAbility(ability);§this.addAbility(new FleshCarverAbility());§}§public FleshCarver(final FleshCarver card) {§super(card);§}§@Override§public FleshCarver copy() {§return new FleshCarver(this);§}§}§class FleshCarverAbility extends DiesTriggeredAbility {§public FleshCarverAbility() {§super(new FleshCarverEffect(), false);§}§public FleshCarverAbility(final FleshCarverAbility ability) {§super(ability);§}§@Override§public FleshCarverAbility copy() {§return new FleshCarverAbility(this);§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (super.checkTrigger(event, game)) {§Permanent permanent = (Permanent) game.getLastKnownInformation(event.getTargetId(), Zone.BATTLEFIELD);§if (permanent !=null) {§for (Effect effect :this.getEffects()) {§effect.setValue("power", permanent.getPower().getValue());§}§return true;§}§}§return false;§}§@Override§public String getRule() {§return "When Flesh Carver dies, " + super.getRule();§}§}§class FleshCarverEffect extends OneShotEffect {§public FleshCarverEffect() {§super(Outcome.DestroyPermanent);§staticText = "put an X/X black Horror creature token onto the battlefield, where X is {this}'s power";§}§public FleshCarverEffect(FleshCarverEffect ability) {§super(ability);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§int xValue = (Integer) getValue("power");§return new CreateTokenEffect(new FleshCarverHorrorToken(xValue)).apply(game, source);§}§return false;§}§@Override§public FleshCarverEffect copy() {§return new FleshCarverEffect(this);§}§}§class FleshCarverHorrorToken extends Token {§public FleshCarverHorrorToken(int xValue) {§super("Horror", "X/X black Horror creature token");§setOriginalExpansionSetCode("C14");§cardType.add(CardType.CREATURE);§color.setBlack(true);§subtype.add("Horror");§power = new MageInt(xValue);§toughness = new MageInt(xValue);§}§}§
public class FoolsDemise extends CardImpl {§public FoolsDemise(UUID ownerId) {§super(ownerId, 111, "Fool's Demise", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{4}{U}");§this.expansionSetCode = "C14";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.Detriment));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new DiesAttachedTriggeredAbility(new ReturnToBattlefieldUnderYourControlAttachedEffect(), "enchanted creature"));§this.addAbility(new PutIntoGraveFromBattlefieldSourceTriggeredAbility(new ReturnToHandSourceEffect()));§}§public FoolsDemise(final FoolsDemise card) {§super(card);§}§@Override§public FoolsDemise copy() {§return new FoolsDemise(this);§}§}§
public class FreyaliseLlanowarsFury extends CardImpl {§private static final FilterControlledCreaturePermanent filterGreen = new FilterControlledCreaturePermanent("green creature you control");§static {§filterGreen.add(new ColorPredicate(ObjectColor.GREEN));§}§public FreyaliseLlanowarsFury(UUID ownerId) {§super(ownerId, 43, "Freyalise, Llanowar's Fury", Rarity.MYTHIC, new CardType[]{CardType.PLANESWALKER}, "{3}{G}{G}");§this.expansionSetCode = "C14";§this.subtype.add("Freyalise");§this.addAbility(new PlanswalkerEntersWithLoyalityCountersAbility(3));§this.addAbility(new LoyaltyAbility(new CreateTokenEffect(new FreyaliseLlanowarsFuryToken()), 2));§LoyaltyAbility loyaltyAbility = new LoyaltyAbility(new DestroyTargetEffect(), -2);§loyaltyAbility.addTarget(new TargetPermanent(new FilterArtifactOrEnchantmentPermanent()));§this.addAbility(loyaltyAbility);§this.addAbility(new LoyaltyAbility(new DrawCardSourceControllerEffect(new PermanentsOnBattlefieldCount(filterGreen)), -6));§this.addAbility(CanBeYourCommanderAbility.getInstance());§}§public FreyaliseLlanowarsFury(final FreyaliseLlanowarsFury card) {§super(card);§}§@Override§public FreyaliseLlanowarsFury copy() {§return new FreyaliseLlanowarsFury(this);§}§}§class FreyaliseLlanowarsFuryToken extends Token {§FreyaliseLlanowarsFuryToken() {§super("Elf Druid", "1/1 green Elf Druid creature token with \"{t}: Add {G} to your mana pool.\"");§this.setOriginalExpansionSetCode("C14");§this.cardType.add(CardType.CREATURE);§this.color = ObjectColor.GREEN;§this.subtype.add("Elf");§this.subtype.add("Druid");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new GreenManaAbility());§}§}§
public class GhoulcallerGisa extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("another creature");§static {§filter.add(new AnotherPredicate());§}§public GhoulcallerGisa(UUID ownerId) {§super(ownerId, 23, "Ghoulcaller Gisa", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{3}{B}{B}");§this.expansionSetCode = "C14";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(3);§this.toughness = new MageInt(4);§DynamicValue xValue = new SacrificeCostCreaturesPower();§Token zombie = new ZombieToken();§zombie.setTokenType(2);§Effect effect = new CreateTokenEffect(zombie, xValue);§effect.setText("Put X 2/2 black Zombie creature tokens onto the battlefield, where X is the sacrificed creature's power");§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new ManaCostsImpl("{B}"));§ability.addCost(new TapSourceCost());§ability.addCost(new SacrificeTargetCost(new TargetControlledCreaturePermanent(filter)));§this.addAbility(ability);§}§public GhoulcallerGisa(final GhoulcallerGisa card) {§super(card);§}§@Override§public GhoulcallerGisa copy() {§return new GhoulcallerGisa(this);§}§}§
public class GiftOfEstates extends CardImpl {§private static final FilterCard filter = new FilterCard("Plains cards");§static {§filter.add(new SubtypePredicate("Plains"));§}§public GiftOfEstates(UUID ownerId) {§super(ownerId, 73, "Gift of Estates", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{1}{W}");§this.expansionSetCode = "C14";§this.getSpellAbility().addEffect(new ConditionalOneShotEffect(§new SearchLibraryPutInHandEffect(new TargetCardInLibrary(0, 3, filter), true),§new OpponentControlsMoreCondition(new FilterLandPermanent("lands"))));§}§public GiftOfEstates(final GiftOfEstates card) {§super(card);§}§@Override§public GiftOfEstates copy() {§return new GiftOfEstates(this);§}§}§
public class GraveSifter extends CardImpl {§public GraveSifter(UUID ownerId) {§super(ownerId, 44, "Grave Sifter", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}{G}");§this.expansionSetCode = "C14";§this.subtype.add("Elemental");§this.subtype.add("Beast");§this.power = new MageInt(5);§this.toughness = new MageInt(7);§this.addAbility(new EntersBattlefieldTriggeredAbility(new GraveSifterEffect(), false));§}§public GraveSifter(final GraveSifter card) {§super(card);§}§@Override§public GraveSifter copy() {§return new GraveSifter(this);§}§}§class GraveSifterEffect extends OneShotEffect {§public GraveSifterEffect() {§super(Outcome.ReturnToHand);§this.staticText = "each player chooses a creature type and returns any number of cards of that type from his or her graveyard to his or her hand";§}§public GraveSifterEffect(final GraveSifterEffect effect) {§super(effect);§}§@Override§public GraveSifterEffect copy() {§return new GraveSifterEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Choice typeChoice = new ChoiceImpl(true);§typeChoice.setMessage("Choose creature type to return cards from your graveyard");§typeChoice.setChoices(CardRepository.instance.getCreatureTypes());§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§for (UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {§Player player = game.getPlayer(playerId);§if (player != null) {§typeChoice.clearChoice();§if (player.choose(outcome, typeChoice, game)) {§game.informPlayers(player.getLogName() + " has chosen: " + typeChoice.getChoice());§FilterCard filter = new FilterCreatureCard("creature cards with creature type " + typeChoice.getChoice() + " from your graveyard");§filter.add(new SubtypePredicate(typeChoice.getChoice()));§Target target = new TargetCardInYourGraveyard(0, Integer.MAX_VALUE, filter);§player.chooseTarget(outcome, target, source, game);§player.moveCards(new CardsImpl(target.getTargets()), null, Zone.HAND, source, game);§}§}§}§return true;§}§return false;§}§}§
public class HallowedSpiritkeeper extends CardImpl {§public HallowedSpiritkeeper(UUID ownerId) {§super(ownerId, 8, "Hallowed Spiritkeeper", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{W}{W}");§this.expansionSetCode = "C14";§this.subtype.add("Avatar");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§this.addAbility(VigilanceAbility.getInstance());§Effect effect = new CreateTokenEffect(new SpiritWhiteToken(), new CardsInControllerGraveyardCount(new FilterCreatureCard("creature cards")));§effect.setText("put X 1/1 white Spirit creature tokens with flying onto the battlefield, where X is the number of creature cards in your graveyard");§this.addAbility(new DiesTriggeredAbility(effect, false));§}§public HallowedSpiritkeeper(final HallowedSpiritkeeper card) {§super(card);§}§@Override§public HallowedSpiritkeeper copy() {§return new HallowedSpiritkeeper(this);§}§}§
public class ImpactResonance extends CardImpl {§public ImpactResonance(UUID ownerId) {§super(ownerId, 36, "Impact Resonance", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{1}{R}");§this.expansionSetCode = "C14";§DynamicValue xValue = new GreatestAmountOfDamageDealtValue();§Effect effect = new DamageMultiEffect(xValue);§effect.setText("{this} deals X damage divided as you choose among any number of target creatures, where X is the greatest amount of damage dealt by a source to a permanent or player this turn");§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addTarget(new TargetCreaturePermanentAmount(xValue));§this.getSpellAbility().addWatcher(new GreatestAmountOfDamageWatcher());§}§public ImpactResonance(final ImpactResonance card) {§super(card);§}§@Override§public ImpactResonance copy() {§return new ImpactResonance(this);§}§}§class GreatestAmountOfDamageDealtValue implements DynamicValue, MageSingleton {§private static final GreatestAmountOfDamageDealtValue fINSTANCE = new GreatestAmountOfDamageDealtValue();§private Object readResolve() throws ObjectStreamException {§return fINSTANCE;§}§public static GreatestAmountOfDamageDealtValue getInstance() {§return fINSTANCE;§}§@Override§public int calculate(Game game, Ability sourceAbility, Effect effect) {§return this.calculate(game, sourceAbility.getControllerId());§}§public int calculate(Game game, UUID controllerId) {§GreatestAmountOfDamageWatcher watcher = (GreatestAmountOfDamageWatcher) game.getState().getWatchers().get("GreatestAmountOfDamage");§if (watcher != null) {§return watcher.getGreatestAmountOfDamage();§}§return 0;§}§@Override§public DynamicValue copy() {§return new GreatestAmountOfDamageDealtValue();§}§@Override§public String toString() {§return "X";§}§@Override§public String getMessage() {§return "the greatest amount of damage dealt by a source to a permanent or player this turn";§}§}§class GreatestAmountOfDamageWatcher extends Watcher {§private int damageAmount;§public GreatestAmountOfDamageWatcher() {§super("GreatestAmountOfDamage", WatcherScope.GAME);§}§public GreatestAmountOfDamageWatcher(final GreatestAmountOfDamageWatcher watcher) {§super(watcher);§this.damageAmount = watcher.damageAmount;§}§@Override§public GreatestAmountOfDamageWatcher copy() {§return new GreatestAmountOfDamageWatcher(this);§}§@Override§public void watch(GameEvent event, Game game) {§switch(event.getType()) {§case DAMAGED_CREATURE:§case DAMAGED_PLANESWALKER:§case DAMAGED_PLAYER:§if (event.getAmount() > damageAmount) {§damageAmount = event.getAmount();§}§}§}§/**§*§* @return Returns the greatest amount of damage dealt to a player or permanent during the current turn.§*/§public int getGreatestAmountOfDamage() {§return damageAmount;§}§@Override§public void reset() {§super.reset();§damageAmount = 0;§}§}§
public class InciteRebellion extends CardImpl {§public InciteRebellion(UUID ownerId) {§super(ownerId, 37, "Incite Rebellion", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{4}{R}{R}");§this.expansionSetCode = "C14";§this.getSpellAbility().addEffect(new InciteRebellionEffect());§}§public InciteRebellion(final InciteRebellion card) {§super(card);§}§@Override§public InciteRebellion copy() {§return new InciteRebellion(this);§}§}§class InciteRebellionEffect extends OneShotEffect {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent();§public InciteRebellionEffect() {§super(Outcome.Detriment);§this.staticText = "For each player, {this} deals damage to that player and each creature that player controls equal to the number of creatures he or she controls";§}§public InciteRebellionEffect(final InciteRebellionEffect effect) {§super(effect);§}§@Override§public InciteRebellionEffect copy() {§return new InciteRebellionEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§for (UUID playerId: game.getState().getPlayersInRange(controller.getId(), game)) {§Player player = game.getPlayer(playerId);§if (player != null) {§int count = game.getBattlefield().countAll(filter, playerId, game);§if (count > 0) {§player.damage(count, source.getSourceId(), game, false, true);§for (Permanent permanent: game.getBattlefield().getAllActivePermanents(filter, playerId, game)) {§permanent.damage(count, source.getSourceId(), game, false, true);§}§}§}§}§return true;§}§return false;§}§}§
public class InfernalOffering extends CardImpl {§public InfernalOffering(UUID ownerId) {§super(ownerId, 24, "Infernal Offering", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{4}{B}");§this.expansionSetCode = "C14";§this.getSpellAbility().addEffect(new InfernalOfferingSacrificeEffect());§this.getSpellAbility().addEffect(new InfernalOfferingReturnEffect());§}§public InfernalOffering(final InfernalOffering card) {§super(card);§}§@Override§public InfernalOffering copy() {§return new InfernalOffering(this);§}§}§class InfernalOfferingSacrificeEffect extends OneShotEffect {§InfernalOfferingSacrificeEffect() {§super(Outcome.Sacrifice);§this.staticText = "Choose an opponent. You and that player each sacrifice a creature. Each player who sacrificed a creature this way draws two cards";§}§InfernalOfferingSacrificeEffect(final InfernalOfferingSacrificeEffect effect) {§super(effect);§}§@Override§public InfernalOfferingSacrificeEffect copy() {§return new InfernalOfferingSacrificeEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§Target target = new TargetOpponent(true);§target.choose(Outcome.Sacrifice, source.getControllerId(), source.getSourceId(), game);§Player opponent = game.getPlayer(target.getFirstTarget());§if (opponent != null) {§Map<UUID, UUID> toSacrifice = new HashMap<>(2);§for (UUID playerId : game.getState().getPlayersInRange(player.getId(), game)) {§if (playerId.equals(player.getId()) || playerId.equals(opponent.getId())) {§target = new TargetControlledCreaturePermanent(1, 1, new FilterControlledCreaturePermanent(), true);§if (target.choose(Outcome.Sacrifice, playerId, source.getControllerId(), game)) {§toSacrifice.put(playerId, target.getFirstTarget());§}§}§}§List<UUID> toDraw = new ArrayList<>(2);§for (Entry<UUID, UUID> entry : toSacrifice.entrySet()) {§Permanent permanent = game.getPermanent(entry.getValue());§if (permanent != null) {§if (permanent.sacrifice(source.getSourceId(), game)) {§toDraw.add(entry.getKey());§}§}§}§for (UUID playerId : toDraw) {§Player playerToDraw = game.getPlayer(playerId);§if (playerToDraw != null) {§playerToDraw.drawCards(2, game);§}§}§return true;§}§}§return false;§}§}§class InfernalOfferingReturnEffect extends OneShotEffect {§InfernalOfferingReturnEffect() {§super(Outcome.PutCreatureInPlay);§this.staticText = "Choose an opponent. Return a creature card from your graveyard to the battlefield, then that player returns a creature card from his or her graveyard to the battlefield";§}§InfernalOfferingReturnEffect(final InfernalOfferingReturnEffect effect) {§super(effect);§}§@Override§public InfernalOfferingReturnEffect copy() {§return new InfernalOfferingReturnEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Target target = new TargetOpponent(true);§target.choose(Outcome.PutCreatureInPlay, source.getControllerId(), source.getSourceId(), game);§Player opponent = game.getPlayer(target.getFirstTarget());§target = new TargetCardInYourGraveyard(new FilterCreatureCard("creature card in your graveyard"));§if (target.choose(Outcome.PutCreatureInPlay, controller.getId(), source.getSourceId(), game)) {§Card card = controller.getGraveyard().get(target.getFirstTarget(), game);§if (card != null) {§controller.moveCards(card, Zone.BATTLEFIELD, source, game);§}§}§if (opponent != null) {§target = new TargetCardInYourGraveyard(new FilterCreatureCard("creature card in your graveyard"));§if (target.choose(Outcome.PutCreatureInPlay, opponent.getId(), source.getSourceId(), game)) {§Card card = opponent.getGraveyard().get(target.getFirstTarget(), game);§if (card != null) {§opponent.moveCards(card, Zone.BATTLEFIELD, source, game);§}§}§}§return true;§}§return false;§}§}§
public class IntellectualOffering extends CardImpl {§public IntellectualOffering(UUID ownerId) {§super(ownerId, 15, "Intellectual Offering", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{4}{U}");§this.expansionSetCode = "C14";§this.getSpellAbility().addEffect(new IntellectualOfferingDrawEffect());§this.getSpellAbility().addEffect(new IntellectualOfferingUntapEffect());§}§public IntellectualOffering(final IntellectualOffering card) {§super(card);§}§@Override§public IntellectualOffering copy() {§return new IntellectualOffering(this);§}§}§class IntellectualOfferingDrawEffect extends OneShotEffect {§IntellectualOfferingDrawEffect() {§super(Outcome.DrawCard);§this.staticText = "Choose an opponent. You and that player each draw three cards";§}§IntellectualOfferingDrawEffect(final IntellectualOfferingDrawEffect effect) {§super(effect);§}§@Override§public IntellectualOfferingDrawEffect copy() {§return new IntellectualOfferingDrawEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§Target target = new TargetOpponent(true);§target.choose(Outcome.DrawCard, source.getControllerId(), source.getSourceId(), game);§player.drawCards(3, game);§Player opponent = game.getPlayer(target.getFirstTarget());§if (opponent != null) {§opponent.drawCards(3, game);§return true;§}§}§return false;§}§}§class IntellectualOfferingUntapEffect extends OneShotEffect {§IntellectualOfferingUntapEffect() {§super(Outcome.Untap);§this.staticText = "<br><br>Choose an opponent. Untap all nonland permanents you control and all nonland permanents that player controls";§}§IntellectualOfferingUntapEffect(final IntellectualOfferingUntapEffect effect) {§super(effect);§}§@Override§public IntellectualOfferingUntapEffect copy() {§return new IntellectualOfferingUntapEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§Target target = new TargetOpponent(true);§target.choose(Outcome.Untap, source.getControllerId(), source.getSourceId(), game);§for (Permanent permanent : game.getBattlefield().getAllActivePermanents(new FilterNonlandPermanent(), player.getId(), game)) {§permanent.untap(game);§}§Player opponent = game.getPlayer(target.getFirstTarget());§if (opponent != null) {§for (Permanent permanent : game.getBattlefield().getAllActivePermanents(new FilterNonlandPermanent(), opponent.getId(), game)) {§permanent.untap(game);§}§return true;§}§}§return false;§}§}§
public class JungleBasin extends CardImpl {§private static final FilterControlledLandPermanent filter = new FilterControlledLandPermanent("an untapped Forest");§static {§filter.add(new SubtypePredicate("Forest"));§filter.add(Predicates.not(new TappedPredicate()));§}§public JungleBasin(UUID ownerId) {§super(ownerId, 302, "Jungle Basin", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "C14";§this.addAbility(new EntersBattlefieldTappedAbility());§this.addAbility(new EntersBattlefieldTriggeredAbility(new SacrificeSourceUnlessPaysEffect(new ReturnToHandChosenControlledPermanentCost(new TargetControlledPermanent(filter)))));§this.addAbility(new SimpleManaAbility(Zone.BATTLEFIELD, new Mana(0, 1, 0, 0, 0, 0, 0, 1), new TapSourceCost()));§}§public JungleBasin(final JungleBasin card) {§super(card);§}§@Override§public JungleBasin copy() {§return new JungleBasin(this);§}§}§
public class JunkDiver extends CardImpl {§private static final FilterArtifactCard filter = new FilterArtifactCard("another target artifact card from your graveyard");§static {§filter.add(new AnotherCardPredicate());§}§public JunkDiver(UUID ownerId) {§super(ownerId, 244, "Junk Diver", Rarity.RARE, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{3}");§this.expansionSetCode = "C14";§this.subtype.add("Bird");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§Effect effect = new ReturnFromGraveyardToHandTargetEffect();§effect.setText("return another target artifact card from your graveyard to your hand");§Ability ability = new DiesTriggeredAbility(effect);§ability.addTarget(new TargetCardInYourGraveyard(filter));§this.addAbility(ability);§}§public JunkDiver(final JunkDiver card) {§super(card);§}§@Override§public JunkDiver copy() {§return new JunkDiver(this);§}§}§
public class Karoo extends CardImpl {§private static final FilterControlledLandPermanent filter = new FilterControlledLandPermanent("an untapped Plains");§static {§filter.add(new SubtypePredicate("Plains"));§filter.add(Predicates.not(new TappedPredicate()));§}§public Karoo(UUID ownerId) {§super(ownerId, 303, "Karoo", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "C14";§this.addAbility(new EntersBattlefieldTappedAbility());§this.addAbility(new EntersBattlefieldTriggeredAbility(new SacrificeSourceUnlessPaysEffect(new ReturnToHandChosenControlledPermanentCost(new TargetControlledPermanent(filter)))));§this.addAbility(new SimpleManaAbility(Zone.BATTLEFIELD, new Mana(0, 0, 0, 1, 0, 0, 0, 1), new TapSourceCost()));§}§public Karoo(final Karoo card) {§super(card);§}§@Override§public Karoo copy() {§return new Karoo(this);§}§}§
public class LifebloodHydra extends CardImpl {§public LifebloodHydra(UUID ownerId) {§super(ownerId, 45, "Lifeblood Hydra", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{X}{G}{G}{G}");§this.expansionSetCode = "C14";§this.subtype.add("Hydra");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§this.addAbility(TrampleAbility.getInstance());§this.addAbility(new EntersBattlefieldAbility(new EntersBattlefieldWithXCountersEffect(CounterType.P1P1.createInstance())));§this.addAbility(new DiesTriggeredAbility(new LifebloodHydraEffect(), false));§}§public LifebloodHydra(final LifebloodHydra card) {§super(card);§}§@Override§public LifebloodHydra copy() {§return new LifebloodHydra(this);§}§}§class LifebloodHydraEffect extends OneShotEffect {§public LifebloodHydraEffect() {§super(Outcome.Benefit);§this.staticText = "you gain life and draw cards equal to its power";§}§public LifebloodHydraEffect(final LifebloodHydraEffect effect) {§super(effect);§}§@Override§public LifebloodHydraEffect copy() {§return new LifebloodHydraEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Permanent diedPermanent = (Permanent) getValue("permanentLeftBattlefield");§if (diedPermanent != null) {§controller.gainLife(diedPermanent.getPower().getValue(), game);§controller.drawCards(diedPermanent.getPower().getValue(), game);§}§return true;§}§return false;§}§}§
public class LoreseekersStone extends CardImpl {§public LoreseekersStone(UUID ownerId) {§super(ownerId, 56, "Loreseeker's Stone", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{6}");§this.expansionSetCode = "C14";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DrawCardSourceControllerEffect(3), new GenericManaCost(3));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.ALL, new LoreseekersStoneCostIncreasingEffect(ability.getOriginalId())));§}§public LoreseekersStone(final LoreseekersStone card) {§super(card);§}§@Override§public LoreseekersStone copy() {§return new LoreseekersStone(this);§}§}§class LoreseekersStoneCostIncreasingEffect extends CostModificationEffectImpl {§private final UUID originalId;§LoreseekersStoneCostIncreasingEffect (UUID originalId ) {§super(Duration.EndOfGame, Outcome.Benefit, CostModificationType.INCREASE_COST);§staticText = "This ability costs {1} more to activate for each card in your hand";§this.originalId = originalId;§}§LoreseekersStoneCostIncreasingEffect(final LoreseekersStoneCostIncreasingEffect effect) {§super(effect);§this.originalId = effect.originalId;§}§@Override§public boolean apply(Game game, Ability source, Ability abilityToModify) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§CardUtil.increaseCost(abilityToModify, controller.getHand().size());§}§return true;§}§@Override§public boolean applies(Ability abilityToModify, Ability source, Game game) {§return abilityToModify.getOriginalId().equals(originalId);§}§@Override§public LoreseekersStoneCostIncreasingEffect copy() {§return new LoreseekersStoneCostIncreasingEffect(this);§}§}§
public class MagusOfTheCoffers extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("Swamp you control");§static {§filter.add(new SubtypePredicate("Swamp"));§}§public MagusOfTheCoffers(UUID ownerId) {§super(ownerId, 148, "Magus of the Coffers", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{B}");§this.expansionSetCode = "C14";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§Ability ability = new DynamicManaAbility(Mana.BlackMana(1), new PermanentsOnBattlefieldCount(filter), new GenericManaCost(2));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§}§public MagusOfTheCoffers(final MagusOfTheCoffers card) {§super(card);§}§@Override§public MagusOfTheCoffers copy() {§return new MagusOfTheCoffers(this);§}§}§
public class MaliciousAffliction extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("nonblack creatures");§static {§filter.add(Predicates.not(new ColorPredicate(ObjectColor.BLACK)));§}§public MaliciousAffliction(UUID ownerId) {§super(ownerId, 25, "Malicious Affliction", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{B}{B}");§this.expansionSetCode = "C14";§Ability ability = new ConditionalTriggeredAbility(§new CastSourceTriggeredAbility(new CopySourceSpellEffect(), true),§new LockedInCondition(MorbidCondition.getInstance()),§"<i>Morbid</i> - When you cast {this}, if a creature died this turn, you may copy {this} and may choose a new target for the copy");§ability.setRuleAtTheTop(true);§this.addAbility(ability);§this.getSpellAbility().addEffect(new DestroyTargetEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent(filter));§}§public MaliciousAffliction(final MaliciousAffliction card) {§super(card);§}§@Override§public MaliciousAffliction copy() {§return new MaliciousAffliction(this);§}§}§class CopySourceSpellEffect extends OneShotEffect {§final String rule = "copy {this} and may choose a new target for the copy";§public CopySourceSpellEffect() {§super(Outcome.Benefit);§staticText = rule;§}§public CopySourceSpellEffect(final CopySourceSpellEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Spell spell = game.getStack().getSpell(source.getSourceId());§if (spell != null) {§Spell spellCopy = spell.copySpell();§spellCopy.setCopiedSpell(true);§spellCopy.setControllerId(source.getControllerId());§game.getStack().push(spellCopy);§spellCopy.chooseNewTargets(game, controller.getId());§String activateMessage = spellCopy.getActivatedMessage(game);§if (activateMessage.startsWith(" casts ")) {§activateMessage = activateMessage.substring(6);§}§game.informPlayers(controller.getLogName() + " copies " + activateMessage);§return true;§}§}§return false;§}§@Override§public CopySourceSpellEffect copy() {§return new CopySourceSpellEffect(this);§}§}§
public class MasterworkOfIngenuity extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("artifact");§static {§filter.add(new CardTypePredicate(CardType.ARTIFACT));§filter.add(new SubtypePredicate("Equipment"));§}§public MasterworkOfIngenuity(UUID ownerId) {§super(ownerId, 57, "Masterwork of Ingenuity", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{1}");§this.expansionSetCode = "C14";§this.subtype.add("Equipment");§this.addAbility(new EntersBattlefieldAbility(new CopyPermanentEffect(filter), true));§}§public MasterworkOfIngenuity(final MasterworkOfIngenuity card) {§super(card);§}§@Override§public MasterworkOfIngenuity copy() {§return new MasterworkOfIngenuity(this);§}§}§
public class MyriadLandscape extends CardImpl {§private static final FilterBasicLandCard filter = new FilterBasicLandCard();§public MyriadLandscape(UUID ownerId) {§super(ownerId, 61, "Myriad Landscape", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "C14";§this.addAbility(new EntersBattlefieldTappedAbility());§this.addAbility(new ColorlessManaAbility());§Effect effect = new SearchLibraryPutInPlayEffect(new TargetCardInLibrarySharingLandType(0, 2, filter), true);§effect.setText("Search your library for up to two basic land cards that share a land type, put them onto the battlefield tapped, then shuffle your library");§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new GenericManaCost(2));§ability.addCost(new TapSourceCost());§ability.addCost(new SacrificeSourceCost());§this.addAbility(ability);§}§public MyriadLandscape(final MyriadLandscape card) {§super(card);§}§@Override§public MyriadLandscape copy() {§return new MyriadLandscape(this);§}§}§class TargetCardInLibrarySharingLandType extends TargetCardInLibrary {§public TargetCardInLibrarySharingLandType(int minNumTargets, int maxNumTargets, FilterCard filter) {§super(minNumTargets, maxNumTargets, filter);§}§public TargetCardInLibrarySharingLandType(final TargetCardInLibrarySharingLandType target) {§super(target);§}§@Override§public boolean canTarget(UUID id, Cards cards, Game game) {§if (super.canTarget(id, cards, game)) {§if (!getTargets().isEmpty()) {§HashSet<String> landTypes = null;§for (UUID landId: getTargets()) {§Card landCard = game.getCard(landId);§if (landCard != null) {§if (landTypes == null) {§landTypes = new HashSet<>();§landTypes.addAll(landCard.getSubtype());§} else {§for (Iterator<String> iterator = landTypes.iterator(); iterator.hasNext();) {§String next = iterator.next();§if (!landCard.getSubtype().contains(next)) {§iterator.remove();§}§}§}§}§}§Card card = game.getCard(id);§if (card != null && landTypes != null) {§for (Iterator<String> iterator = landTypes.iterator(); iterator.hasNext();) {§String next = iterator.next();§if (card.getSubtype().contains(next)) {§return true;§}§}§}§} else {§return true;§}§}§return false;§}§@Override§public TargetCardInLibrarySharingLandType copy() {§return new TargetCardInLibrarySharingLandType(this);§}§}§
public class NahiriTheLithomancer extends CardImpl {§public NahiriTheLithomancer(UUID ownerId) {§super(ownerId, 10, "Nahiri, the Lithomancer", Rarity.MYTHIC, new CardType[]{CardType.PLANESWALKER}, "{3}{W}{W}");§this.expansionSetCode = "C14";§this.subtype.add("Nahiri");§this.addAbility(new PlanswalkerEntersWithLoyalityCountersAbility(3));§this.addAbility(new LoyaltyAbility(new NahiriTheLithomancerFirstAbilityEffect(), 2));§this.addAbility(new LoyaltyAbility(new NahiriTheLithomancerSecondAbilityEffect(), -2));§Effect effect = new CreateTokenEffect(new NahiriTheLithomancerEquipmentToken());§effect.setText("Put a colorless Equipment artifact token named Stoneforged Blade onto the battlefield. It has indestructible, \"Equipped creature gets +5/+5 and has double strike,\" and equip {0}");§this.addAbility(new LoyaltyAbility(effect, -10));§this.addAbility(CanBeYourCommanderAbility.getInstance());§}§public NahiriTheLithomancer(final NahiriTheLithomancer card) {§super(card);§}§@Override§public NahiriTheLithomancer copy() {§return new NahiriTheLithomancer(this);§}§}§class NahiriTheLithomancerFirstAbilityEffect extends OneShotEffect {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("an Equipment you control");§static {§filter.add(new SubtypePredicate("Equipment"));§}§NahiriTheLithomancerFirstAbilityEffect() {§super(Outcome.PutCreatureInPlay);§this.staticText = "Put a 1/1 white Kor Soldier creature token onto the battlefield. You may attach an Equipment you control to it";§}§NahiriTheLithomancerFirstAbilityEffect(final NahiriTheLithomancerFirstAbilityEffect effect) {§super(effect);§}§@Override§public NahiriTheLithomancerFirstAbilityEffect copy() {§return new NahiriTheLithomancerFirstAbilityEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Token token = new KorSoldierToken();§if (token.putOntoBattlefield(1, game, source.getSourceId(), source.getControllerId())) {§for (UUID tokenId : token.getLastAddedTokenIds()) {§Permanent tokenPermanent = game.getPermanent(tokenId);§if (tokenPermanent != null) {§Target target = new TargetControlledPermanent(0, 1, filter, true);§if (target.canChoose(source.getSourceId(), controller.getId(), game)§&& controller.chooseUse(outcome, "Attach an Equipment you control to the created " + tokenPermanent.getIdName() + "?", source, game)) {§if (target.choose(Outcome.Neutral, source.getControllerId(), source.getSourceId(), game)) {§Permanent equipmentPermanent = game.getPermanent(target.getFirstTarget());§if (equipmentPermanent != null) {§Permanent attachedTo = game.getPermanent(equipmentPermanent.getAttachedTo());§if (attachedTo != null) {§attachedTo.removeAttachment(equipmentPermanent.getId(), game);§}§tokenPermanent.addAttachment(equipmentPermanent.getId(), game);§}§}§}§}§}§}§return true;§}§return false;§}§}§class NahiriTheLithomancerSecondAbilityEffect extends OneShotEffect {§private static final FilterCard filter = new FilterCard("an Equipment");§static {§filter.add(new SubtypePredicate("Equipment"));§}§NahiriTheLithomancerSecondAbilityEffect() {§super(Outcome.PutCardInPlay);§this.staticText = "You may put an Equipment card from your hand or graveyard onto the battlefield";§}§NahiriTheLithomancerSecondAbilityEffect(final NahiriTheLithomancerSecondAbilityEffect effect) {§super(effect);§}§@Override§public NahiriTheLithomancerSecondAbilityEffect copy() {§return new NahiriTheLithomancerSecondAbilityEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§if (controller.chooseUse(Outcome.PutCardInPlay, "Put an Equipment from hand? (No = from graveyard)", source, game)) {§Target target = new TargetCardInHand(0, 1, filter);§controller.choose(outcome, target, source.getSourceId(), game);§Card card = controller.getHand().get(target.getFirstTarget(), game);§if (card != null) {§controller.moveCards(card, Zone.BATTLEFIELD, source, game);§}§} else {§Target target = new TargetCardInYourGraveyard(0, 1, filter);§target.choose(Outcome.PutCardInPlay, source.getControllerId(), source.getSourceId(), game);§Card card = controller.getGraveyard().get(target.getFirstTarget(), game);§if (card != null) {§controller.moveCards(card, Zone.BATTLEFIELD, source, game);§}§}§return true;§}§return false;§}§}§class NahiriTheLithomancerEquipmentToken extends Token {§NahiriTheLithomancerEquipmentToken() {§super("Stoneforged Blade", "colorless Equipment artifact token named Stoneforged Blade with indestructible, \"Equipped creature gets +5/+5 and has double strike,\" and equip {0}");§cardType.add(CardType.ARTIFACT);§subtype.add("Equipment");§this.addAbility(IndestructibleAbility.getInstance());§Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEquippedEffect(5, 5));§ability.addEffect(new GainAbilityAttachedEffect(DoubleStrikeAbility.getInstance(), AttachmentType.EQUIPMENT, Duration.WhileOnBattlefield, "and has double strike"));§this.addAbility(ability);§this.addAbility(new EquipAbility(Outcome.BoostCreature, new GenericManaCost(0)));§}§}§
public class NecromanticSelection extends CardImpl {§public NecromanticSelection(UUID ownerId) {§super(ownerId, 26, "Necromantic Selection", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{4}{B}{B}{B}");§this.expansionSetCode = "C14";§this.getSpellAbility().addEffect(new NecromanticSelectionEffect());§this.getSpellAbility().addEffect(ExileSpellEffect.getInstance());§}§public NecromanticSelection(final NecromanticSelection card) {§super(card);§}§@Override§public NecromanticSelection copy() {§return new NecromanticSelection(this);§}§}§class NecromanticSelectionEffect extends OneShotEffect {§public NecromanticSelectionEffect() {§super(Outcome.DestroyPermanent);§this.staticText = "Destroy all creatures, then return a creature card put into a graveyard this way to the battlefield under your control. It's a black Zombie in addition to its other colors and types";§}§public NecromanticSelectionEffect(final NecromanticSelectionEffect effect) {§super(effect);§}§@Override§public NecromanticSelectionEffect copy() {§return new NecromanticSelectionEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§MageObject sourceObject = game.getObject(source.getSourceId());§if (sourceObject != null && controller != null) {§Cards cards = new CardsImpl();§for (Permanent permanent : game.getBattlefield().getActivePermanents(new FilterCreaturePermanent(), controller.getId(), source.getSourceId(), game)) {§permanent.destroy(source.getSourceId(), game, false);§if (game.getState().getZone(permanent.getId()).equals(Zone.GRAVEYARD)) {§cards.add(permanent);§}§}§FilterCard filter = new FilterCreatureCard("creature card put into a graveyard with " + sourceObject.getLogName());§ArrayList<Predicate<MageObject>> cardIdPredicates = new ArrayList<>();§for (UUID cardId : cards) {§cardIdPredicates.add(new CardIdPredicate(cardId));§}§filter.add(Predicates.or(cardIdPredicates));§Target target = new TargetCardInGraveyard(filter);§if (controller.chooseTarget(outcome, target, source, game)) {§Card card = game.getCard(target.getFirstTarget());§if (card != null) {§controller.moveCards(card, Zone.BATTLEFIELD, source, game);§ContinuousEffect effect = new NecromanticSelectionContinuousEffect();§effect.setTargetPointer(new FixedTarget(card.getId()));§game.addEffect(effect, source);§}§}§return true;§}§return false;§}§}§class NecromanticSelectionContinuousEffect extends ContinuousEffectImpl {§public NecromanticSelectionContinuousEffect() {§super(Duration.Custom, Outcome.Neutral);§staticText = "It's a black Zombie in addition to its other colors and types";§}§public NecromanticSelectionContinuousEffect(final NecromanticSelectionContinuousEffect effect) {§super(effect);§}§@Override§public NecromanticSelectionContinuousEffect copy() {§return new NecromanticSelectionContinuousEffect(this);§}§@Override§public boolean apply(Layer layer, SubLayer sublayer, Ability source, Game game) {§Permanent creature = game.getPermanent(targetPointer.getFirst(game, source));§if (creature != null) {§switch (layer) {§case TypeChangingEffects_4:§if (sublayer == SubLayer.NA) {§if (!creature.getSubtype().contains("Zombie")) {§creature.getSubtype().add("Zombie");§}§}§break;§case ColorChangingEffects_5:§if (sublayer == SubLayer.NA) {§creature.getColor(game).setBlack(true);§}§break;§}§return true;§} else {§this.used = true;§}§return false;§}§@Override§public boolean apply(Game game, Ability source) {§return false;§}§@Override§public boolean hasLayer(Layer layer) {§return layer == Layer.ColorChangingEffects_5 || layer == Layer.TypeChangingEffects_4;§}§}§
public class ObNixilisOfTheBlackOath extends CardImpl {§public ObNixilisOfTheBlackOath(UUID ownerId) {§super(ownerId, 27, "Ob Nixilis of the Black Oath", Rarity.MYTHIC, new CardType[]{CardType.PLANESWALKER}, "{3}{B}{B}");§this.expansionSetCode = "C14";§this.subtype.add("Nixilis");§this.addAbility(new PlanswalkerEntersWithLoyalityCountersAbility(3));§this.addAbility(new LoyaltyAbility(new ObNixilisOfTheBlackOathEffect1(), 2));§LoyaltyAbility loyaltyAbility = new LoyaltyAbility(new CreateTokenEffect(new DemonToken()), -2);§loyaltyAbility.addEffect(new LoseLifeSourceControllerEffect(2));§this.addAbility(loyaltyAbility);§this.addAbility(new LoyaltyAbility(new GetEmblemEffect(new ObNixilisOfTheBlackOathEmblem()), -8));§this.addAbility(CanBeYourCommanderAbility.getInstance());§}§public ObNixilisOfTheBlackOath(final ObNixilisOfTheBlackOath card) {§super(card);§}§@Override§public ObNixilisOfTheBlackOath copy() {§return new ObNixilisOfTheBlackOath(this);§}§}§class ObNixilisOfTheBlackOathEffect1 extends OneShotEffect {§public ObNixilisOfTheBlackOathEffect1() {§super(Outcome.Damage);§staticText = "Each opponent loses 1 life. You gain life equal to the life lost this way";§}§public ObNixilisOfTheBlackOathEffect1(final ObNixilisOfTheBlackOathEffect1 effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§int loseLife = 0;§for (UUID opponentId : game.getOpponents(source.getControllerId())) {§Player opponent = game.getPlayer(opponentId);§if (opponent != null) {§loseLife += opponent.loseLife(1, game);§}§}§controller.gainLife(loseLife, game);§return true;§}§return false;§}§@Override§public ObNixilisOfTheBlackOathEffect1 copy() {§return new ObNixilisOfTheBlackOathEffect1(this);§}§}§class ObNixilisOfTheBlackOathEmblem extends Emblem {§public ObNixilisOfTheBlackOathEmblem() {§this.setName("EMBLEM: Ob Nixilis of the Black Oath");§DynamicValue xValue = new SacrificeCostCreaturesPower();§Effect effect = new GainLifeEffect(xValue);§effect.setText("You gain X life");§Ability ability = new SimpleActivatedAbility(Zone.COMMAND, effect, new ManaCostsImpl("{1}{B}"));§ability.addCost(new SacrificeTargetCost(new TargetControlledCreaturePermanent()));§effect = new DrawCardSourceControllerEffect(xValue);§effect.setText("and draw X cards, where X is the sacrificed creature's power");§ability.addEffect(effect);§this.getAbilities().add(ability);§}§}§
public class OverseerOfTheDamned extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("nontoken creature an opponent controls");§static {§filter.add(new ControllerPredicate(TargetController.OPPONENT));§filter.add(Predicates.not(new TokenPredicate()));§}§public OverseerOfTheDamned(UUID ownerId) {§super(ownerId, 28, "Overseer of the Damned", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}{B}{B}");§this.expansionSetCode = "C14";§this.subtype.add("Demon");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new EntersBattlefieldTriggeredAbility(new DestroyTargetEffect(), true);§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§Token zombie = new ZombieToken();§zombie.setTokenType(2);§this.addAbility(new DiesCreatureTriggeredAbility(new CreateTokenEffect(zombie, 1, true, false), false, filter));§}§public OverseerOfTheDamned(final OverseerOfTheDamned card) {§super(card);§}§@Override§public OverseerOfTheDamned copy() {§return new OverseerOfTheDamned(this);§}§}§
public class PredatorFlagship extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature with flying");§static {§filter.add(new AbilityPredicate(FlyingAbility.class));§}§public PredatorFlagship(UUID ownerId) {§super(ownerId, 263, "Predator, Flagship", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{5}");§this.expansionSetCode = "C14";§this.supertype.add("Legendary");§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilityTargetEffect(FlyingAbility.getInstance(), Duration.EndOfTurn), new ManaCostsImpl("{2}"));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DestroyTargetEffect(), new ManaCostsImpl("{5}"));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent(filter));§this.addAbility(ability);§}§public PredatorFlagship(final PredatorFlagship card) {§super(card);§}§@Override§public PredatorFlagship copy() {§return new PredatorFlagship(this);§}§}§
public class ProfaneCommand extends CardImpl {§public ProfaneCommand(UUID ownerId) {§super(ownerId, 156, "Profane Command", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{X}{B}{B}");§this.expansionSetCode = "C14";§DynamicValue xValue = new ManacostVariableValue();§this.getSpellAbility().getModes().setMinModes(2);§this.getSpellAbility().getModes().setMaxModes(2);§this.getSpellAbility().addEffect(new LoseLifeTargetEffect(xValue));§this.getSpellAbility().addTarget(new TargetPlayer());§Mode mode = new Mode();§mode.getEffects().add(new ReturnFromGraveyardToBattlefieldTargetEffect());§mode.getTargets().add(new TargetCardInYourGraveyard(new FilterCreatureCard("creature card with converted mana cost X or less from your graveyard")));§this.getSpellAbility().addMode(mode);§DynamicValue minusValue = new SignInversionDynamicValue(xValue);§mode = new Mode();§mode.getEffects().add(new BoostTargetEffect(minusValue, minusValue, Duration.EndOfTurn));§mode.getTargets().add(new TargetCreaturePermanent());§this.getSpellAbility().addMode(mode);§mode = new Mode();§Effect effect = new GainAbilityTargetEffect(FearAbility.getInstance(), Duration.EndOfTurn);§effect.setText("Up to X target creatures gain fear until end of turn");§mode.getEffects().add(effect);§mode.getTargets().add(new TargetCreaturePermanent(0,1));§this.getSpellAbility().addMode(mode);§}§@Override§public void adjustTargets(Ability ability, Game game) {§Mode mode = ability.getModes().getMode();§for (Effect effect :mode.getEffects()) {§if (effect instanceof ReturnFromGraveyardToBattlefieldTargetEffect) {§mode.getTargets().clear();§int xValue = ability.getManaCostsToPay().getX();§FilterCard filter = new FilterCreatureCard("creature card with converted mana cost " + xValue + " or less from your graveyard");§filter.add(new ConvertedManaCostPredicate(Filter.ComparisonType.LessThan, xValue + 1));§mode.getTargets().add(new TargetCardInYourGraveyard(filter));§}§if (effect instanceof GainAbilityTargetEffect) {§mode.getTargets().clear();§int xValue = ability.getManaCostsToPay().getX();§FilterCreaturePermanent filter = new FilterCreaturePermanent("creatures gain fear until end of turn");§mode.getTargets().add(new TargetCreaturePermanent(0, xValue, filter, false));§}§}§}§public ProfaneCommand(final ProfaneCommand card) {§super(card);§}§@Override§public ProfaneCommand copy() {§return new ProfaneCommand(this);§}§}§
public class PromiseOfPower extends CardImpl {§public PromiseOfPower(UUID ownerId) {§super(ownerId, 157, "Promise of Power", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{2}{B}{B}{B}");§this.expansionSetCode = "C14";§this.getSpellAbility().getModes().setMinModes(1);§this.getSpellAbility().getModes().setMaxModes(1);§Effect effect = new DrawCardSourceControllerEffect(5);§effect.setText("You draw five cards");§this.getSpellAbility().addEffect(effect);§effect = new LoseLifeSourceControllerEffect(5);§effect.setText("and you lose 5 life");§this.getSpellAbility().addEffect(effect);§Mode mode = new Mode();§mode.getEffects().add(new PromiseOfPowerEffect());§this.getSpellAbility().getModes().addMode(mode);§this.addAbility(new EntwineAbility("{4}"));§}§public PromiseOfPower(final PromiseOfPower card) {§super(card);§}§@Override§public PromiseOfPower copy() {§return new PromiseOfPower(this);§}§}§class PromiseOfPowerEffect extends OneShotEffect {§public PromiseOfPowerEffect() {§super(Outcome.DestroyPermanent);§staticText = "Put an X/X black Demon creature token with flying onto the battlefield, where X is the number of cards in your hand";§}§public PromiseOfPowerEffect(PromiseOfPowerEffect ability) {§super(ability);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§return new CreateTokenEffect(new PromiseOfPowerDemonToken(controller.getHand().size())).apply(game, source);§}§return false;§}§@Override§public PromiseOfPowerEffect copy() {§return new PromiseOfPowerEffect(this);§}§}§class PromiseOfPowerDemonToken extends Token {§public PromiseOfPowerDemonToken(int xValue) {§super("Demon", "X/X black Demon creature token with flying");§setOriginalExpansionSetCode("C14");§setTokenType(2);§cardType.add(CardType.CREATURE);§color.setBlack(true);§subtype.add("Demon");§power = new MageInt(xValue);§toughness = new MageInt(xValue);§addAbility(FlyingAbility.getInstance());§}§}§
public class RavingDead extends CardImpl {§public RavingDead(UUID ownerId) {§super(ownerId, 29, "Raving Dead", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{B}");§this.expansionSetCode = "C14";§this.subtype.add("Zombie");§this.power = new MageInt(2);§this.toughness = new MageInt(6);§this.addAbility(DeathtouchAbility.getInstance());§this.addAbility(new BeginningOfCombatTriggeredAbility(new RavingDeadEffect(), TargetController.YOU, false));§this.addAbility(new DealsCombatDamageToAPlayerTriggeredAbility(new RavingDeadDamageEffect(), false, true));§}§public RavingDead(final RavingDead card) {§super(card);§}§@Override§public RavingDead copy() {§return new RavingDead(this);§}§}§class RavingDeadEffect extends OneShotEffect {§public RavingDeadEffect() {§super(Outcome.Benefit);§this.staticText = "choose an opponent at random. {this} attacks that player this combat if able";§}§public RavingDeadEffect(final RavingDeadEffect effect) {§super(effect);§}§@Override§public RavingDeadEffect copy() {§return new RavingDeadEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Random random = new Random();§List<UUID> opponents = new ArrayList<>();§opponents.addAll(game.getOpponents(controller.getId()));§Player opponent = game.getPlayer(opponents.get(random.nextInt(opponents.size())));§if (opponent != null) {§ContinuousEffect effect = new AttacksIfAbleTargetPlayerSourceEffect();§effect.setTargetPointer(new FixedTarget(opponent.getId()));§game.addEffect(effect, source);§return true;§}§}§return false;§}§}§class RavingDeadDamageEffect extends OneShotEffect {§public RavingDeadDamageEffect() {§super(Outcome.Damage);§this.staticText = "that player loses half his or her life, rounded up";§}§public RavingDeadDamageEffect(final RavingDeadDamageEffect effect) {§super(effect);§}§@Override§public RavingDeadDamageEffect copy() {§return new RavingDeadDamageEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(getTargetPointer().getFirst(game, source));§if (player != null) {§Integer amount = (int) Math.ceil(player.getLife() / 2f);§if (amount > 0) {§player.loseLife(amount, game);§}§return true;§}§return false;§}§}§class AttacksIfAbleTargetPlayerSourceEffect extends RequirementEffect {§public AttacksIfAbleTargetPlayerSourceEffect() {§super(Duration.EndOfTurn);§staticText = "{this} attacks that player this combat if able";§}§public AttacksIfAbleTargetPlayerSourceEffect(final AttacksIfAbleTargetPlayerSourceEffect effect) {§super(effect);§}§@Override§public AttacksIfAbleTargetPlayerSourceEffect copy() {§return new AttacksIfAbleTargetPlayerSourceEffect(this);§}§@Override§public boolean applies(Permanent permanent, Ability source, Game game) {§if (permanent.getId().equals(source.getSourceId())) {§return true;§}§return false;§}§@Override§public boolean mustAttack(Game game) {§return true;§}§@Override§public boolean mustBlock(Game game) {§return false;§}§@Override§public UUID mustAttackDefender(Ability source, Game game) {§return getTargetPointer().getFirst(game, source);§}§}§
public class ReefWorm extends CardImpl {§public ReefWorm(UUID ownerId) {§super(ownerId, 16, "Reef Worm", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{U}");§this.expansionSetCode = "C14";§this.subtype.add("Worm");§this.power = new MageInt(0);§this.toughness = new MageInt(1);§addAbility(new DiesTriggeredAbility(new CreateTokenEffect(new ReefWormFishToken())));§}§public ReefWorm(final ReefWorm card) {§super(card);§}§@Override§public ReefWorm copy() {§return new ReefWorm(this);§}§}§class ReefWormFishToken extends Token {§ReefWormFishToken() {§super("Fish", "a 3/3 blue Fish creature token onto the battlefield with \"When this creature dies, put a 6/6 blue Whale creature token onto the battlefield with \"When this creature dies, put a 9/9 blue Kraken creature token onto the battlefield.\"\"");§setOriginalExpansionSetCode("C14");§cardType.add(CardType.CREATURE);§color.setBlue(true);§subtype.add("Fish");§power = new MageInt(3);§toughness = new MageInt(3);§addAbility(new DiesTriggeredAbility(new CreateTokenEffect(new ReefWormWhaleToken())));§}§}§class ReefWormWhaleToken extends Token {§ReefWormWhaleToken() {§super("Whale", "a 6/6 blue Whale creature token with \"When this creature dies, put a 9/9 blue Kraken creature token onto the battlefield.\"");§setOriginalExpansionSetCode("C14");§cardType.add(CardType.CREATURE);§color.setBlue(true);§subtype.add("Whale");§power = new MageInt(6);§toughness = new MageInt(6);§addAbility(new DiesTriggeredAbility(new CreateTokenEffect(new ReefWormKrakenToken())));§}§}§class ReefWormKrakenToken extends Token {§ReefWormKrakenToken() {§super("Kraken", "a 9/9 blue Kraken creature token");§setOriginalExpansionSetCode("C14");§cardType.add(CardType.CREATURE);§color.setBlue(true);§subtype.add("Kraken");§power = new MageInt(9);§toughness = new MageInt(9);§}§}§
public class ScrapMastery extends CardImpl {§public ScrapMastery(UUID ownerId) {§super(ownerId, 38, "Scrap Mastery", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{3}{R}{R}");§this.expansionSetCode = "C14";§this.getSpellAbility().addEffect(new ScrapMasteryEffect());§}§public ScrapMastery(final ScrapMastery card) {§super(card);§}§@Override§public ScrapMastery copy() {§return new ScrapMastery(this);§}§}§class ScrapMasteryEffect extends OneShotEffect {§public ScrapMasteryEffect() {§super(Outcome.PutCardInPlay);§this.staticText = "Each player exiles all artifact cards from his or her graveyard, then sacrifices all artifacts he or she controls, then puts all cards he or she exiled this way onto the battlefield";§}§public ScrapMasteryEffect(final ScrapMasteryEffect effect) {§super(effect);§}§@Override§public ScrapMasteryEffect copy() {§return new ScrapMasteryEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Map<UUID, Set<Card>> exiledCards = new HashMap<>();§for (UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {§Player player = game.getPlayer(playerId);§if (player != null) {§Set<Card> cards = player.getGraveyard().getCards(new FilterArtifactCard(), game);§controller.moveCards(cards, Zone.EXILED, source, game);§exiledCards.put(player.getId(), cards);§}§}§for (UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {§Player player = game.getPlayer(playerId);§if (player != null) {§for (Permanent permanent : game.getBattlefield().getAllActivePermanents(new FilterArtifactPermanent(), playerId, game)) {§permanent.sacrifice(source.getSourceId(), game);§}§}§}§for (UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {§Player player = game.getPlayer(playerId);§if (player != null) {§player.moveCards(exiledCards.get(playerId), Zone.BATTLEFIELD, source, game);§}§}§return true;§}§return false;§}§}§
public class ShaperParasite extends CardImpl {§public ShaperParasite(UUID ownerId) {§super(ownerId, 125, "Shaper Parasite", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{U}{U}");§this.expansionSetCode = "C14";§this.subtype.add("Illusion");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(new MorphAbility(this, new ManaCostsImpl("{2}{U}")));§Ability ability = new TurnedFaceUpSourceTriggeredAbility(new ShaperParasiteEffect());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public ShaperParasite(final ShaperParasite card) {§super(card);§}§@Override§public ShaperParasite copy() {§return new ShaperParasite(this);§}§}§class ShaperParasiteEffect extends ContinuousEffectImpl {§private int power;§private int toughness;§public ShaperParasiteEffect() {§super(Duration.EndOfTurn, Layer.PTChangingEffects_7, SubLayer.ModifyPT_7c, Outcome.BoostCreature);§this.power = 2;§this.toughness = -2;§this.staticText = "target creature gets +2/-2 or -2/+2 until end of turn";§}§public ShaperParasiteEffect(final ShaperParasiteEffect effect) {§super(effect);§this.power = effect.power;§this.toughness = effect.toughness;§}§@Override§public ShaperParasiteEffect copy() {§return new ShaperParasiteEffect(this);§}§@Override§public void init(Ability source, Game game) {§super.init(source, game);§Player player = game.getPlayer(source.getControllerId());§String message = "Should the target creature get -2/+2 instead of +2/-2?";§if (player != null && player.chooseUse(Outcome.Neutral, message, source, game)) {§this.power *= -1;§this.toughness *= -1;§}§}§@Override§public boolean apply(Game game, Ability source) {§Permanent target = game.getPermanent(source.getFirstTarget());§if (target != null) {§target.addPower(power);§target.addToughness(toughness);§return true;§}§return false;§}§}§
public class SiegeBehemoth extends CardImpl {§public SiegeBehemoth(UUID ownerId) {§super(ownerId, 46, "Siege Behemoth", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}{G}{G}");§this.expansionSetCode = "C14";§this.subtype.add("Beast");§this.power = new MageInt(7);§this.toughness = new MageInt(4);§this.addAbility(HexproofAbility.getInstance());§this.addAbility(new SimpleStaticAbility(§Zone.BATTLEFIELD,§new ConditionalContinuousEffect(§new GainAbilityControlledEffect(DamageAsThoughNotBlockedAbility.getInstance(), Duration.WhileOnBattlefield),§SourceAttackingCondition.getInstance(),§"As long as {this} is attacking, for each creature you control, you may have that creature assign its combat damage as though it weren't blocked"§)));§}§public SiegeBehemoth(final SiegeBehemoth card) {§super(card);§}§@Override§public SiegeBehemoth copy() {§return new SiegeBehemoth(this);§}§}§
public class SongOfTheDryads extends CardImpl {§public SongOfTheDryads(UUID ownerId) {§super(ownerId, 47, "Song of the Dryads", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{2}{G}");§this.expansionSetCode = "C14";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetPermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.Benefit));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BecomesColorlessForestLandEffect()));§}§public SongOfTheDryads(final SongOfTheDryads card) {§super(card);§}§@Override§public SongOfTheDryads copy() {§return new SongOfTheDryads(this);§}§}§class BecomesColorlessForestLandEffect extends ContinuousEffectImpl {§public BecomesColorlessForestLandEffect() {§super(Duration.WhileOnBattlefield, Outcome.Detriment);§this.staticText = "Enchanted permanent is a colorless Forest land";§}§public BecomesColorlessForestLandEffect(final BecomesColorlessForestLandEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§return false;§}§@Override§public BecomesColorlessForestLandEffect copy() {§return new BecomesColorlessForestLandEffect(this);§}§@Override§public boolean apply(Layer layer, SubLayer sublayer, Ability source, Game game) {§Permanent enchantment = game.getPermanent(source.getSourceId());§if (enchantment != null && enchantment.getAttachedTo() != null) {§Permanent permanent = game.getPermanent(enchantment.getAttachedTo());§if (permanent != null) {§switch (layer) {§case ColorChangingEffects_5:§permanent.getColor(game).setWhite(false);§permanent.getColor(game).setGreen(false);§permanent.getColor(game).setBlack(false);§permanent.getColor(game).setBlue(false);§permanent.getColor(game).setRed(false);§break;§case AbilityAddingRemovingEffects_6:§permanent.removeAllAbilities(source.getSourceId(), game);§permanent.addAbility(new GreenManaAbility(), source.getSourceId(), game);§break;§case TypeChangingEffects_4:§permanent.getCardType().clear();§permanent.getCardType().add(CardType.LAND);§permanent.getSubtype().clear();§permanent.getSubtype().add("Forest");§break;§}§return true;§}§}§return false;§}§@Override§public boolean hasLayer(Layer layer) {§return layer == Layer.AbilityAddingRemovingEffects_6 || layer == Layer.ColorChangingEffects_5 || layer == Layer.TypeChangingEffects_4;§}§}§
public class SpoilsOfBlood extends CardImpl {§public SpoilsOfBlood(UUID ownerId) {§super(ownerId, 30, "Spoils of Blood", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{B}");§this.expansionSetCode = "C14";§this.getSpellAbility().addEffect(new SpoilsOfBloodEffect());§this.getSpellAbility().addWatcher(new CreaturesDiedThisTurnWatcher());§}§public SpoilsOfBlood(final SpoilsOfBlood card) {§super(card);§}§@Override§public SpoilsOfBlood copy() {§return new SpoilsOfBlood(this);§}§}§class SpoilsOfBloodEffect extends OneShotEffect {§public SpoilsOfBloodEffect() {§super(Outcome.DestroyPermanent);§staticText = "Put an X/X black Horror creature token onto the battlefield, where X is the number of creatures that died this turn";§}§public SpoilsOfBloodEffect(SpoilsOfBloodEffect ability) {§super(ability);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§CreaturesDiedThisTurnWatcher watcher = (CreaturesDiedThisTurnWatcher) game.getState().getWatchers().get("CreaturesDied");§if (watcher != null) {§new CreateTokenEffect(new SpoilsOfBloodHorrorToken(watcher.creaturesDiedThisTurn)).apply(game, source);§}§return true;§}§return false;§}§@Override§public SpoilsOfBloodEffect copy() {§return new SpoilsOfBloodEffect(this);§}§}§class CreaturesDiedThisTurnWatcher extends Watcher {§public int creaturesDiedThisTurn = 0;§public CreaturesDiedThisTurnWatcher() {§super("CreaturesDied", WatcherScope.GAME);§}§public CreaturesDiedThisTurnWatcher(final CreaturesDiedThisTurnWatcher watcher) {§super(watcher);§}§@Override§public CreaturesDiedThisTurnWatcher copy() {§return new CreaturesDiedThisTurnWatcher(this);§}§@Override§public void watch(GameEvent event, Game game) {§if (event.getType() == EventType.ZONE_CHANGE && ((ZoneChangeEvent)event).isDiesEvent()) {§MageObject mageObject = game.getLastKnownInformation(event.getTargetId(), Zone.BATTLEFIELD);§if (mageObject != null && mageObject.getCardType().contains(CardType.CREATURE)) {§creaturesDiedThisTurn++;§}§}§}§@Override§public void reset() {§super.reset();§creaturesDiedThisTurn = 0;§}§}§class SpoilsOfBloodHorrorToken extends Token {§public SpoilsOfBloodHorrorToken(int xValue) {§super("Horror", "X/X black Horror creature token");§setOriginalExpansionSetCode("C14");§cardType.add(CardType.CREATURE);§color.setBlack(true);§subtype.add("Horror");§power = new MageInt(xValue);§toughness = new MageInt(xValue);§}§}§
public class StitcherGeralf extends CardImpl {§public StitcherGeralf(UUID ownerId) {§super(ownerId, 17, "Stitcher Geralf", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{3}{U}{U}");§this.expansionSetCode = "C14";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(3);§this.toughness = new MageInt(4);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new StitcherGeralfEffect(), new ManaCostsImpl("{2}{U}"));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§}§public StitcherGeralf(final StitcherGeralf card) {§super(card);§}§@Override§public StitcherGeralf copy() {§return new StitcherGeralf(this);§}§}§class StitcherGeralfEffect extends OneShotEffect {§public StitcherGeralfEffect() {§super(Outcome.PutCreatureInPlay);§this.staticText = "Each player puts the top three cards of his or her library into his or her graveyard. Exile up to two creature cards put into graveyards this way. Put an X/X blue Zombie creature token onto the battlefield, where X is the total power of the cards exiled this way";§}§public StitcherGeralfEffect(final StitcherGeralfEffect effect) {§super(effect);§}§@Override§public StitcherGeralfEffect copy() {§return new StitcherGeralfEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Cards cards = new CardsImpl();§for (UUID playerId: game.getState().getPlayersInRange(controller.getId(), game)) {§Player player = game.getPlayer(playerId);§if (player != null) {§cards.addAll(player.getLibrary().getTopCards(game, 3));§}§}§controller.moveCards(cards, Zone.LIBRARY, Zone.GRAVEYARD, source, game);§TargetCard target = new TargetCard(0,2,Zone.GRAVEYARD, new FilterCreatureCard("creature cards to exile"));§controller.chooseTarget(outcome, cards, target, source, game);§int power = 0;§for (UUID cardId: target.getTargets()) {§Card card = game.getCard(cardId);§if (card != null) {§power += card.getPower().getValue();§controller.moveCardToExileWithInfo(card, null, "", source.getSourceId(), game, Zone.GRAVEYARD, true);§}§}§return new CreateTokenEffect(new StitcherGeralfZombieToken(power)).apply(game, source);§}§return false;§}§}§class StitcherGeralfZombieToken extends Token {§StitcherGeralfZombieToken(int xValue) {§super("Zombie", "an X/X blue Zombie creature token");§setOriginalExpansionSetCode("C14");§setTokenType(1);§cardType.add(CardType.CREATURE);§color.setBlue(true);§subtype.add("Zombie");§power = new MageInt(xValue);§toughness = new MageInt(xValue);§}§}§
public class StormsurgeKraken extends CardImpl {§public StormsurgeKraken(UUID ownerId) {§super(ownerId, 18, "Stormsurge Kraken", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{U}{U}");§this.expansionSetCode = "C14";§this.subtype.add("Kraken");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(HexproofAbility.getInstance());§ContinuousEffect effect = new GainAbilitySourceEffect(new BecomesBlockedTriggeredAbility(new DrawCardSourceControllerEffect(2), true), Duration.WhileOnBattlefield);§effect.setText("and has \"Whenever Stormsurge Kraken becomes blocked, you may draw two cards.\"");§this.addAbility(new LieutenantAbility(effect));§}§public StormsurgeKraken(final StormsurgeKraken card) {§super(card);§}§@Override§public StormsurgeKraken copy() {§return new StormsurgeKraken(this);§}§}§
public class SylvanOffering extends CardImpl {§public SylvanOffering(UUID ownerId) {§super(ownerId, 48, "Sylvan Offering", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{X}{G}");§this.expansionSetCode = "C14";§this.getSpellAbility().addEffect(new SylvanOfferingEffect1());§this.getSpellAbility().addEffect(new SylvanOfferingEffect2());§}§public SylvanOffering(final SylvanOffering card) {§super(card);§}§@Override§public SylvanOffering copy() {§return new SylvanOffering(this);§}§}§class SylvanOfferingEffect1 extends OneShotEffect {§SylvanOfferingEffect1() {§super(Outcome.Sacrifice);§this.staticText = "Choose an opponent. You and that player each put an X/X green Treefolk creature token onto the battlefield";§}§SylvanOfferingEffect1(final SylvanOfferingEffect1 effect) {§super(effect);§}§@Override§public SylvanOfferingEffect1 copy() {§return new SylvanOfferingEffect1(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Target target = new TargetOpponent(true);§target.choose(Outcome.Sacrifice, source.getControllerId(), source.getSourceId(), game);§Player opponent = game.getPlayer(target.getFirstTarget());§if (opponent != null) {§int xValue = source.getManaCostsToPay().getX();§Effect effect = new CreateTokenTargetEffect(new SylvanOfferingTreefolkToken(xValue));§effect.setTargetPointer(new FixedTarget(opponent.getId()));§effect.apply(game, source);§new CreateTokenTargetEffect(new SylvanOfferingTreefolkToken(xValue)).apply(game, source);§return true;§}§}§return false;§}§}§class SylvanOfferingTreefolkToken extends Token {§public SylvanOfferingTreefolkToken(int xValue) {§super("Treefolk", "X/X green Treefolk creature token");§setOriginalExpansionSetCode("C14");§cardType.add(CardType.CREATURE);§subtype.add("Treefolk");§color.setGreen(true);§power = new MageInt(xValue);§toughness = new MageInt(xValue);§}§}§class SylvanOfferingEffect2 extends OneShotEffect {§SylvanOfferingEffect2() {§super(Outcome.Sacrifice);§this.staticText = "<br>Choose an opponent. You and that player each put X 1/1 green Elf Warrior creature tokens onto the battlefield";§}§SylvanOfferingEffect2(final SylvanOfferingEffect2 effect) {§super(effect);§}§@Override§public SylvanOfferingEffect2 copy() {§return new SylvanOfferingEffect2(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Target target = new TargetOpponent(true);§target.choose(Outcome.Sacrifice, source.getControllerId(), source.getSourceId(), game);§Player opponent = game.getPlayer(target.getFirstTarget());§if (opponent != null) {§int xValue = source.getManaCostsToPay().getX();§Effect effect = new CreateTokenTargetEffect(new ElfToken(), xValue);§effect.setTargetPointer(new FixedTarget(opponent.getId()));§effect.apply(game, source);§new CreateTokenEffect(new ElfToken(), xValue).apply(game, source);§return true;§}§}§return false;§}§}§
public class TeferiTemporalArchmage extends CardImpl {§public TeferiTemporalArchmage(UUID ownerId) {§super(ownerId, 19, "Teferi, Temporal Archmage", Rarity.MYTHIC, new CardType[]{CardType.PLANESWALKER}, "{4}{U}{U}");§this.expansionSetCode = "C14";§this.subtype.add("Teferi");§this.addAbility(new PlanswalkerEntersWithLoyalityCountersAbility(5));§this.addAbility(new LoyaltyAbility(new LookLibraryAndPickControllerEffect(§new StaticValue(2), false, new StaticValue(1), new FilterCard(), Zone.LIBRARY, false, false), 1));§LoyaltyAbility loyaltyAbility = new LoyaltyAbility(new UntapTargetEffect(), -1);§loyaltyAbility.addTarget(new TargetPermanent(0, 4, new FilterPermanent(), false));§this.addAbility(loyaltyAbility);§this.addAbility(new LoyaltyAbility(new GetEmblemEffect(new TeferiTemporalArchmageEmblem()), -10));§this.addAbility(CanBeYourCommanderAbility.getInstance());§}§public TeferiTemporalArchmage(final TeferiTemporalArchmage card) {§super(card);§}§@Override§public TeferiTemporalArchmage copy() {§return new TeferiTemporalArchmage(this);§}§}§class TeferiTemporalArchmageEmblem extends Emblem {§public TeferiTemporalArchmageEmblem() {§this.setName("EMBLEM: Teferi, Temporal Archmage");§this.getAbilities().add(new SimpleStaticAbility(Zone.COMMAND, new TeferiTemporalArchmageAsThoughEffect()));§}§}§class TeferiTemporalArchmageAsThoughEffect extends AsThoughEffectImpl {§public TeferiTemporalArchmageAsThoughEffect() {§super(AsThoughEffectType.ACTIVATE_AS_INSTANT, Duration.EndOfGame, Outcome.Benefit);§staticText = "You may activate loyalty abilities of planeswalkers you control on any player's turn any time you could cast an instant";§}§public TeferiTemporalArchmageAsThoughEffect(final TeferiTemporalArchmageAsThoughEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public TeferiTemporalArchmageAsThoughEffect copy() {§return new TeferiTemporalArchmageAsThoughEffect(this);§}§@Override§public boolean applies(UUID objectId, Ability affectedAbility, Ability source, Game game) {§if (affectedAbility.getControllerId().equals(source.getControllerId()) && affectedAbility instanceof LoyaltyAbility) {§return true;§}§return false;§}§@Override§public boolean applies(UUID objectId, Ability source, UUID affectedControllerId, Game game) {§return false; §
public class ThunderfootBaloth extends CardImpl {§public ThunderfootBaloth(UUID ownerId) {§super(ownerId, 49, "Thunderfoot Baloth", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{G}{G}");§this.expansionSetCode = "C14";§this.subtype.add("Beast");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(TrampleAbility.getInstance());§Effects effects = new Effects();§Effect effect = new BoostControlledEffect(2, 2, Duration.WhileOnBattlefield, true);§effect.setText("and other creatures you control get +2/+2");§effects.add(effect);§effect = new GainAbilityControlledEffect(TrampleAbility.getInstance(), Duration.WhileOnBattlefield, new FilterControlledCreaturePermanent(), true);§effect.setText("and have trample");§effects.add(effect);§this.addAbility(new LieutenantAbility(effects));§}§public ThunderfootBaloth(final ThunderfootBaloth card) {§super(card);§}§@Override§public ThunderfootBaloth copy() {§return new ThunderfootBaloth(this);§}§}§
public class TitaniaProtectorOfArgoth extends CardImpl {§private static final FilterLandPermanent filter = new FilterLandPermanent("a land you control");§static {§filter.add(new ControllerPredicate(TargetController.YOU));§}§public TitaniaProtectorOfArgoth(UUID ownerId) {§super(ownerId, 50, "Titania, Protector of Argoth", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{3}{G}{G}");§this.expansionSetCode = "C14";§this.supertype.add("Legendary");§this.subtype.add("Elemental");§this.power = new MageInt(5);§this.toughness = new MageInt(3);§Ability ability = new EntersBattlefieldTriggeredAbility(new ReturnFromGraveyardToBattlefieldTargetEffect(), true);§ability.addTarget(new TargetCardInYourGraveyard(new FilterLandCard("land card from your graveyard")));§this.addAbility(ability);§ability = new PutIntoGraveFromBattlefieldAllTriggeredAbility(new CreateTokenEffect(new TitaniaProtectorOfArgothElementalToken()), false, filter, false);§this.addAbility(ability);§}§public TitaniaProtectorOfArgoth(final TitaniaProtectorOfArgoth card) {§super(card);§}§@Override§public TitaniaProtectorOfArgoth copy() {§return new TitaniaProtectorOfArgoth(this);§}§}§class TitaniaProtectorOfArgothElementalToken extends Token {§TitaniaProtectorOfArgothElementalToken() {§super("Elemental", "a 5/3 green Elemental creature token");§this.setOriginalExpansionSetCode("C14");§this.cardType.add(CardType.CREATURE);§this.color = ObjectColor.GREEN;§this.subtype.add("Elemental");§this.power = new MageInt(5);§this.toughness = new MageInt(3);§}§}§
public class TyrantsFamiliar extends CardImpl {§private final UUID originalId;§public TyrantsFamiliar(UUID ownerId) {§super(ownerId, 39, "Tyrant's Familiar", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}{R}{R}");§this.expansionSetCode = "C14";§this.subtype.add("Dragon");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(HasteAbility.getInstance());§Ability gainedAbility = new AttacksTriggeredAbility(new DamageTargetEffect(7), false);§gainedAbility.addTarget(new TargetCreaturePermanent());§ContinuousEffect effect = new GainAbilitySourceEffect(gainedAbility);§effect.setText("and has \"Whenever {this} attacks, it deals 7 damage to target creature defending player controls\"");§originalId = gainedAbility.getOriginalId();§this.addAbility(new LieutenantAbility(effect));§}§public TyrantsFamiliar(final TyrantsFamiliar card) {§super(card);§this.originalId = card.originalId;§}§@Override§public TyrantsFamiliar copy() {§return new TyrantsFamiliar(this);§}§@Override§public void adjustTargets(Ability ability, Game game) {§if (ability.getOriginalId().equals(originalId)) {§ability.getTargets().clear();§FilterCreaturePermanent filter = new FilterCreaturePermanent("creature defending player controls");§UUID defenderId = game.getCombat().getDefenderId(ability.getSourceId());§filter.add(new ControllerIdPredicate(defenderId));§TargetCreaturePermanent target = new TargetCreaturePermanent(filter);§ability.addTarget(target);§}§}§}§
public class UnstableObelisk extends CardImpl {§public UnstableObelisk(UUID ownerId) {§super(ownerId, 58, "Unstable Obelisk", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "C14";§this.addAbility(new ColorlessManaAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DestroyTargetEffect(), new GenericManaCost(7));§ability.addCost(new TapSourceCost());§ability.addCost(new SacrificeSourceCost());§ability.addTarget(new TargetPermanent());§this.addAbility(ability);§}§public UnstableObelisk(final UnstableObelisk card) {§super(card);§}§@Override§public UnstableObelisk copy() {§return new UnstableObelisk(this);§}§}§
public class VolcanicOffering extends CardImpl {§private static final FilterLandPermanent filterLand = new FilterLandPermanent("nonbasic land you don't control");§private static final FilterCreaturePermanent filterCreature = new FilterCreaturePermanent("creature you don't control");§static {§filterLand.add(new ControllerPredicate(TargetController.NOT_YOU));§filterLand.add(Predicates.not(new SupertypePredicate("Basic")));§filterCreature.add(new ControllerPredicate(TargetController.NOT_YOU));§}§public VolcanicOffering(UUID ownerId) {§super(ownerId, 40, "Volcanic Offering", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{4}{R}");§this.expansionSetCode = "C14";§this.getSpellAbility().addEffect(new VolcanicOfferingEffect());§this.getSpellAbility().addTarget(new TargetPermanent(filterLand));§this.getSpellAbility().addTarget(new TargetPermanent(filterCreature));§}§public VolcanicOffering(final VolcanicOffering card) {§super(card);§}§@Override§public void adjustTargets(Ability ability, Game game) {§Player controller = game.getPlayer(ability.getControllerId());§if (controller != null && (ability instanceof SpellAbility)) {§ability.getTargets().clear();§ability.addTarget(new TargetPermanent(filterLand));§FilterLandPermanent filterLandForOpponent = new FilterLandPermanent("nonbasic land not controlled by " + controller.getLogName());§filterLandForOpponent.add(Predicates.not(new SupertypePredicate("Basic")));§filterLandForOpponent.add(Predicates.not(new ControllerIdPredicate(controller.getId())));§ability.addTarget(new TargetOpponentsChoicePermanent(filterLandForOpponent));§ability.addTarget(new TargetPermanent(filterCreature));§FilterCreaturePermanent filterCreatureForOpponent = new FilterCreaturePermanent("creature not controlled by " + controller.getLogName());§filterCreatureForOpponent.add(Predicates.not(new ControllerIdPredicate(controller.getId())));§ability.addTarget(new TargetOpponentsChoicePermanent(filterCreatureForOpponent));§}§}§@Override§public VolcanicOffering copy() {§return new VolcanicOffering(this);§}§}§class VolcanicOfferingEffect extends OneShotEffect {§public VolcanicOfferingEffect() {§super(Outcome.Benefit);§this.staticText = "Destroy target nonbasic land you don't control and target nonbasic land of an opponent's choice you don't control.<br>" +§"{this} deals 7 damage to target creature you don't control and 7 damage to target creature of an opponent's choice you don't control";§}§public VolcanicOfferingEffect(final VolcanicOfferingEffect effect) {§super(effect);§}§@Override§public VolcanicOfferingEffect copy() {§return new VolcanicOfferingEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Permanent permanent = game.getPermanent(source.getFirstTarget());§if (permanent != null) {§permanent.destroy(source.getSourceId(), game, false);§}§permanent = game.getPermanent(source.getTargets().get(1).getFirstTarget());§if (permanent != null) {§permanent.destroy(source.getSourceId(), game, false);§}§permanent = game.getPermanent(source.getTargets().get(2).getFirstTarget());§if (permanent != null) {§permanent.damage(7, source.getSourceId(), game, false, true);§}§permanent = game.getPermanent(source.getTargets().get(3).getFirstTarget());§if (permanent != null) {§permanent.damage(7, source.getSourceId(), game, false, true);§}§return true;§}§return false;§}§}§
public class WakeTheDead extends CardImpl {§public WakeTheDead(UUID ownerId) {§super(ownerId, 31, "Wake the Dead", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{X}{B}{B}");§this.expansionSetCode = "C14";§this.addAbility(new CastOnlyDuringPhaseStepSourceAbility(TurnPhase.COMBAT, OnOpponentsTurnCondition.getInstance()));§this.getSpellAbility().addEffect(new WakeTheDeadReturnFromGraveyardToBattlefieldTargetEffect());§this.getSpellAbility().addTarget(new TargetCardInYourGraveyard(0, Integer.MAX_VALUE, new FilterCreatureCard("creature cards from your graveyard")));§}§@Override§public void adjustTargets(Ability ability, Game game) {§if (ability instanceof SpellAbility) {§int xValue = ability.getManaCostsToPay().getX();§ability.getTargets().clear();§ability.addTarget(new TargetCardInYourGraveyard(xValue, xValue, new FilterCreatureCard("creature cards from your graveyard")));§}§}§public WakeTheDead(final WakeTheDead card) {§super(card);§}§@Override§public WakeTheDead copy() {§return new WakeTheDead(this);§}§}§class WakeTheDeadReturnFromGraveyardToBattlefieldTargetEffect extends OneShotEffect {§public WakeTheDeadReturnFromGraveyardToBattlefieldTargetEffect() {§super(Outcome.PutCreatureInPlay);§this.staticText = "Return X target creature cards from your graveyard to the battlefield. Sacrifice those creatures at the beginning of the next end step";§}§public WakeTheDeadReturnFromGraveyardToBattlefieldTargetEffect(final WakeTheDeadReturnFromGraveyardToBattlefieldTargetEffect effect) {§super(effect);§}§@Override§public WakeTheDeadReturnFromGraveyardToBattlefieldTargetEffect copy() {§return new WakeTheDeadReturnFromGraveyardToBattlefieldTargetEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Cards cards = new CardsImpl(getTargetPointer().getTargets(game, source));§controller.moveCards(cards, Zone.BATTLEFIELD, source, game);§ArrayList<Permanent> toSacrifice = new ArrayList<>(cards.size());§for (UUID targetId : cards) {§Permanent creature = game.getPermanent(targetId);§if (creature != null) {§toSacrifice.add(creature);§}§}§Effect effect = new SacrificeTargetEffect("Sacrifice those creatures at the beginning of the next end step", source.getControllerId());§effect.setTargetPointer(new FixedTargets(toSacrifice, game));§DelayedTriggeredAbility delayedAbility = new AtTheBeginOfNextEndStepDelayedTriggeredAbility(effect);§game.addDelayedTriggeredAbility(delayedAbility, source);§return true;§}§return false;§}§}§
public class WarmongerHellkite extends CardImpl {§public WarmongerHellkite(UUID ownerId) {§super(ownerId, 41, "Warmonger Hellkite", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{R}{R}");§this.expansionSetCode = "C14";§this.subtype.add("Dragon");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(FlyingAbility.getInstance());§Effect effect = new AttacksIfAbleAllEffect(new FilterCreaturePermanent("creatures"), Duration.WhileOnBattlefield, true);§effect.setText("All creatures attack each combat if able");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, effect));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostAllEffect(1, 0, Duration.EndOfTurn, new FilterAttackingCreature("Attacking creatures"), false), new ManaCostsImpl("{1}{R}")));§}§public WarmongerHellkite(final WarmongerHellkite card) {§super(card);§}§@Override§public WarmongerHellkite copy() {§return new WarmongerHellkite(this);§}§}§
public class WaveOfVitriol extends CardImpl {§public WaveOfVitriol(UUID ownerId) {§super(ownerId, 51, "Wave of Vitriol", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{5}{G}{G}");§this.expansionSetCode = "C14";§this.getSpellAbility().addEffect(new WaveOfVitriolEffect());§}§public WaveOfVitriol(final WaveOfVitriol card) {§super(card);§}§@Override§public WaveOfVitriol copy() {§return new WaveOfVitriol(this);§}§}§class WaveOfVitriolEffect extends OneShotEffect {§private static final FilterPermanent filter = new FilterPermanent();§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.ARTIFACT),§new CardTypePredicate(CardType.ENCHANTMENT),§Predicates.and(§new CardTypePredicate(CardType.LAND),§Predicates.not(new SupertypePredicate("Basic"))§)§));§}§public WaveOfVitriolEffect() {§super(Outcome.Benefit);§this.staticText = "Each player sacrifices all artifacts, enchantments, and nonbasic lands he or she controls. For each land sacrificed this way, its controller may search his or her library for a basic land card and put it onto the battlefield tapped. Then each player who searched his or her library this way shuffles it";§}§public WaveOfVitriolEffect(final WaveOfVitriolEffect effect) {§super(effect);§}§@Override§public WaveOfVitriolEffect copy() {§return new WaveOfVitriolEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Map<Player, Integer> sacrificedLands = new HashMap<>();§for (UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {§Player player = game.getPlayer(playerId);§if (player != null) {§int count = 0;§for (Permanent permanent : game.getBattlefield().getAllActivePermanents(filter, playerId, game)) {§if (permanent.sacrifice(source.getSourceId(), game) && permanent.getCardType().contains(CardType.LAND)) {§count++;§}§}§if (count > 0) {§sacrificedLands.put(player, count);§}§}§}§game.getState().handleSimultaneousEvent(game);§Cards toBattlefield = new CardsImpl();§Set<Player> playersToShuffle = new LinkedHashSet<>();§for (Map.Entry<Player, Integer> entry : sacrificedLands.entrySet()) {§if (entry.getKey().chooseUse(Outcome.PutLandInPlay, "Search your library for up to " + entry.getValue() + " basic lands?", source, game)) {§Target target = new TargetCardInLibrary(0, entry.getValue(), new FilterBasicLandCard());§entry.getKey().chooseTarget(outcome, target, source, game);§toBattlefield.addAll(target.getTargets());§playersToShuffle.add(entry.getKey());§}§}§controller.moveCards(toBattlefield.getCards(game), Zone.BATTLEFIELD, source, game, true, false, true, null);§for (Player player : playersToShuffle) {§player.shuffleLibrary(game);§}§return true;§}§return false;§}§}§
public class WellOfIdeas extends CardImpl {§public WellOfIdeas(UUID ownerId) {§super(ownerId, 20, "Well of Ideas", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{5}{U}");§this.expansionSetCode = "C14";§this.addAbility(new EntersBattlefieldTriggeredAbility(new DrawCardSourceControllerEffect(2), false));§Effect effect = new DrawCardTargetEffect(1);§effect.setText("that player draws an additional card");§this.addAbility(new BeginningOfDrawTriggeredAbility(effect, TargetController.NOT_YOU, false));§effect = new DrawCardTargetEffect(2);§effect.setText("draw two additional cards");§this.addAbility(new BeginningOfDrawTriggeredAbility(effect , TargetController.YOU, false));§}§public WellOfIdeas(final WellOfIdeas card) {§super(card);§}§@Override§public WellOfIdeas copy() {§return new WellOfIdeas(this);§}§}§
public class Willbender extends CardImpl {§private static final FilterSpell filter = new FilterSpell("spell with a single target");§static {§filter.add(new NumberOfTargetsPredicate(1));§}§public Willbender(UUID ownerId) {§super(ownerId, 131, "Willbender", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{U}");§this.expansionSetCode = "C14";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§this.addAbility(new MorphAbility(this, new ManaCostsImpl("{1}{U}")));§Ability ability = new TurnedFaceUpSourceTriggeredAbility(new ChooseNewTargetsTargetEffect(true, true));§ability.addTarget(new TargetStackObject(filter));§this.addAbility(ability);§}§public Willbender(final Willbender card) {§super(card);§}§@Override§public Willbender copy() {§return new Willbender(this);§}§}§
public class WolfcallersHowl extends CardImpl {§public WolfcallersHowl(UUID ownerId) {§super(ownerId, 52, "Wolfcaller's Howl", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{3}{G}");§this.expansionSetCode = "C14";§this.addAbility(new BeginningOfUpkeepTriggeredAbility(Zone.BATTLEFIELD, new WolfcallersHowlEffect(), TargetController.YOU, false));§}§public WolfcallersHowl(final WolfcallersHowl card) {§super(card);§}§@Override§public WolfcallersHowl copy() {§return new WolfcallersHowl(this);§}§}§class WolfcallersHowlEffect extends OneShotEffect {§public WolfcallersHowlEffect() {§super(Outcome.PutCreatureInPlay);§this.staticText = "put X 2/2 green Wolf creature tokens onto the battlefield, where X is the number of your opponents with four or more cards in hand";§}§public WolfcallersHowlEffect(final WolfcallersHowlEffect effect) {§super(effect);§}§@Override§public WolfcallersHowlEffect copy() {§return new WolfcallersHowlEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§int count = 0;§for(UUID playerId :game.getState().getPlayersInRange(controller.getId(), game)) {§if (controller.hasOpponent(playerId, game)) {§Player opponent = game.getPlayer(playerId);§if (opponent != null) {§if (opponent.getHand().size() >= 4) {§count++;§}§}§}§}§if (count > 0) {§return new CreateTokenEffect(new WolfToken("C14"), count).apply(game, source);§}§return true;§}§return false;§}§}§
public class WordOfSeizing extends CardImpl {§public WordOfSeizing(UUID ownerId) {§super(ownerId, 185, "Word of Seizing", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{3}{R}{R}");§this.expansionSetCode = "C14";§this.addAbility(new SplitSecondAbility());§this.getSpellAbility().addEffect(new UntapTargetEffect());§Effect effect = new GainControlTargetEffect(Duration.EndOfTurn);§effect.setText("and gain control of it until end of turn");§this.getSpellAbility().addEffect(effect);§effect = new GainAbilityTargetEffect(HasteAbility.getInstance(), Duration.EndOfTurn);§effect.setText("It gains haste until end of turn");§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addTarget(new TargetPermanent());§}§public WordOfSeizing(final WordOfSeizing card) {§super(card);§}§@Override§public WordOfSeizing copy() {§return new WordOfSeizing(this);§}§}§
public class ZoeticCavern extends CardImpl {§public ZoeticCavern(UUID ownerId) {§super(ownerId, 317, "Zoetic Cavern", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "C14";§this.addAbility(new ColorlessManaAbility());§this.addAbility(new MorphAbility(this, new ManaCostsImpl("{2}")));§}§public ZoeticCavern(final ZoeticCavern card) {§super(card);§}§@Override§public ZoeticCavern copy() {§return new ZoeticCavern(this);§}§}§
public class AEthersnatch extends CardImpl {§public AEthersnatch(UUID ownerId) {§super(ownerId, 9, "AEthersnatch", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{4}{U}{U}");§this.expansionSetCode = "C15";§this.getSpellAbility().addEffect(new AEthersnatchEffect());§this.getSpellAbility().addTarget(new TargetSpell());§}§public AEthersnatch(final AEthersnatch card) {§super(card);§}§@Override§public AEthersnatch copy() {§return new AEthersnatch(this);§}§}§class AEthersnatchEffect extends OneShotEffect {§AEthersnatchEffect() {§super(Outcome.GainControl);§this.staticText = "Gain control of target spell. You may choose new targets for it";§}§AEthersnatchEffect(final AEthersnatchEffect effect) {§super(effect);§}§@Override§public AEthersnatchEffect copy() {§return new AEthersnatchEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§Spell spell = game.getStack().getSpell(this.getTargetPointer().getFirst(game, source));§if (controller != null && spell != null) {§spell.setControllerId(controller.getId());§spell.chooseNewTargets(game, controller.getId(), false, false, null);§return true;§}§return false;§}§}§
public class AnyaMercilessAngel extends CardImpl {§public AnyaMercilessAngel(UUID ownerId) {§super(ownerId, 41, "Anya, Merciless Angel", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{3}{R}{W}");§this.expansionSetCode = "C15";§this.supertype.add("Legendary");§this.subtype.add("Angel");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§DynamicValue dValue = new MultipliedValue(new AnyaMercilessAngelDynamicValue(), 3);§Effect effect = new BoostSourceEffect(dValue, dValue, Duration.WhileOnBattlefield);§effect.setText("{this{ gets +3/+3 for each opponent whose life total is less than half his or her starting life total");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostSourceEffect(dValue, dValue, Duration.WhileOnBattlefield)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD,§new ConditionalContinuousEffect(new GainAbilitySourceEffect(IndestructibleAbility.getInstance(), Duration.WhileOnBattlefield),§AnyaMercilessAngelCondition.getInstance(),§"As long as an opponent's life total is less than half his or her starting life total, {this} has indestructible")));§}§public AnyaMercilessAngel(final AnyaMercilessAngel card) {§super(card);§}§@Override§public AnyaMercilessAngel copy() {§return new AnyaMercilessAngel(this);§}§}§class AnyaMercilessAngelDynamicValue implements DynamicValue {§@Override§public int calculate(Game game, Ability sourceAbility, Effect effect) {§int opponentCount = 0;§Player controller = game.getPlayer(sourceAbility.getControllerId());§if (controller != null) {§int startingLifeTotal = game.getLife();§for (UUID opponentId : game.getOpponents(controller.getId())) {§Player opponent = game.getPlayer(opponentId);§if (opponent != null && opponent.getLife() < startingLifeTotal / 2) {§opponentCount++;§}§}§}§return opponentCount;§}§@Override§public AnyaMercilessAngelDynamicValue copy() {§return new AnyaMercilessAngelDynamicValue();§}§@Override§public String getMessage() {§return "number of opponents whose life total is less than half his or her starting life total";§}§@Override§public String toString() {§return "X";§}§}§class AnyaMercilessAngelCondition implements Condition {§private static final AnyaMercilessAngelCondition fInstance = new AnyaMercilessAngelCondition();§public static AnyaMercilessAngelCondition getInstance() {§return fInstance;§};§private AnyaMercilessAngelCondition() {}§@Override§public boolean apply(Game game, Ability source) {§return new AnyaMercilessAngelDynamicValue().calculate(game, source, null) > 0;§}§@Override§public String toString() {§return "an opponent's life total is less than half his or her starting life total";§}§}§
public class Arachnogenesis extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("non-Spider creatures");§static {§filter.add(Predicates.not(new SubtypePredicate("Spider")));§}§public Arachnogenesis(UUID ownerId) {§super(ownerId, 32, "Arachnogenesis", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{2}{G}");§this.expansionSetCode = "C15";§Effect effect = new CreateTokenEffect(new SpiderToken(), new ArachnogenesisCount());§effect.setText("Put X 1/2 green Spider creature tokens with reach onto the battlefield, where X is the number of creatures attacking you");§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addEffect(new PreventAllDamageByAllEffect(filter, Duration.EndOfTurn, true));§}§public Arachnogenesis(final Arachnogenesis card) {§super(card);§}§@Override§public Arachnogenesis copy() {§return new Arachnogenesis(this);§}§}§class ArachnogenesisCount implements DynamicValue {§@Override§public int calculate(Game game, Ability sourceAbility, Effect effect) {§int count = 0;§for (CombatGroup combatGroup : game.getCombat().getGroups()) {§if (combatGroup.getDefenderId().equals(sourceAbility.getControllerId())) {§count += combatGroup.getAttackers().size();§}§}§return count;§}§@Override§public DynamicValue copy() {§return this;§}§@Override§public String getMessage() {§return "creatures attacking you";§}§}§
public class ArjunTheShiftingFlame extends CardImpl {§public ArjunTheShiftingFlame(UUID ownerId) {§super(ownerId, 42, "Arjun, the Shifting Flame", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{4}{U}{R}");§this.expansionSetCode = "C15";§this.supertype.add("Legendary");§this.subtype.add("Sphinx");§this.subtype.add("Wizard");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new SpellCastControllerTriggeredAbility(new ArjunTheShiftingFlameEffect(), false));§}§public ArjunTheShiftingFlame(final ArjunTheShiftingFlame card) {§super(card);§}§@Override§public ArjunTheShiftingFlame copy() {§return new ArjunTheShiftingFlame(this);§}§}§class ArjunTheShiftingFlameEffect extends OneShotEffect {§public ArjunTheShiftingFlameEffect() {§super(Outcome.Neutral);§staticText = "put the cards in your hand on the bottom of your library in any order, then draw that many cards";§}§public ArjunTheShiftingFlameEffect(final ArjunTheShiftingFlameEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player you = game.getPlayer(source.getControllerId());§if (you != null) {§int count = you.getHand().size();§you.putCardsOnBottomOfLibrary(you.getHand(), game, source, true);§you.drawCards(count, game);§}§return true;§}§@Override§public ArjunTheShiftingFlameEffect copy() {§return new ArjunTheShiftingFlameEffect(this);§}§}§
public class AwakenTheSkyTyrant extends CardImpl {§public AwakenTheSkyTyrant(UUID ownerId) {§super(ownerId, 24, "Awaken the Sky Tyrant", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{3}{R}");§this.expansionSetCode = "C15";§this.addAbility(new AwakenTheSkyTyrantTriggeredAbility());§}§public AwakenTheSkyTyrant(final AwakenTheSkyTyrant card) {§super(card);§}§@Override§public AwakenTheSkyTyrant copy() {§return new AwakenTheSkyTyrant(this);§}§}§class AwakenTheSkyTyrantTriggeredAbility extends TriggeredAbilityImpl {§public AwakenTheSkyTyrantTriggeredAbility() {§super(Zone.BATTLEFIELD, new DoIfCostPaid(new CreateTokenEffect(new DragonToken2(), 1), new SacrificeSourceCost(), null, false), false);§}§public AwakenTheSkyTyrantTriggeredAbility(final AwakenTheSkyTyrantTriggeredAbility ability) {§super(ability);§}§@java.lang.Override§public AwakenTheSkyTyrantTriggeredAbility copy() {§return new AwakenTheSkyTyrantTriggeredAbility(this);§}§@java.lang.Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType().equals(GameEvent.EventType.DAMAGED_PLAYER);§}§@java.lang.Override§public boolean checkTrigger(GameEvent event, Game game) {§if (event.getTargetId().equals(controllerId)) {§UUID sourceControllerId = game.getControllerId(event.getSourceId());§if (sourceControllerId != null && game.getOpponents(getControllerId()).contains(sourceControllerId)) {§return true;§}§}§return false;§}§@java.lang.Override§public String getRule() {§return "When a source an opponent controls deals damage to you, " + super.getRule();§}§}§
public class BansheeOfTheDreadChoir extends CardImpl {§public BansheeOfTheDreadChoir(UUID ownerId) {§super(ownerId, 16, "Banshee of the Dread Choir", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{B}{B}");§this.expansionSetCode = "C15";§this.subtype.add("Spirit");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(new MyriadAbility());§this.addAbility(new DealsCombatDamageToAPlayerTriggeredAbility(new DiscardTargetEffect(1), false, true));§}§public BansheeOfTheDreadChoir(final BansheeOfTheDreadChoir card) {§super(card);§}§@Override§public BansheeOfTheDreadChoir copy() {§return new BansheeOfTheDreadChoir(this);§}§}§
public class BastionProtector extends CardImpl {§private final static FilterCreaturePermanent filter = new FilterCreaturePermanent("Commander creatures you control");§static {§filter.add(new CommanderPredicate());§}§public BastionProtector(UUID ownerId) {§super(ownerId, 1, "Bastion Protector", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "C15";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostControlledEffect(2, 2, Duration.WhileOnBattlefield, filter));§Effect effect = new GainAbilityControlledEffect(IndestructibleAbility.getInstance(), Duration.WhileOnBattlefield, filter);§effect.setText("and have indestructible");§ability.addEffect(effect);§this.addAbility(ability);§}§public BastionProtector(final BastionProtector card) {§super(card);§}§@Override§public BastionProtector copy() {§return new BastionProtector(this);§}§}§
public class BladeOfSelves extends CardImpl {§public BladeOfSelves(UUID ownerId) {§super(ownerId, 51, "Blade of Selves", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{2}");§this.expansionSetCode = "C15";§this.subtype.add("Equipment");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(new MyriadAbility(), AttachmentType.EQUIPMENT)));§this.addAbility(new EquipAbility(Outcome.BoostCreature, new GenericManaCost(4)));§}§public BladeOfSelves(final BladeOfSelves card) {§super(card);§}§@Override§public BladeOfSelves copy() {§return new BladeOfSelves(this);§}§}§
public class BloodsporeThrinax extends CardImpl {§public BloodsporeThrinax(UUID ownerId) {§super(ownerId, 33, "Bloodspore Thrinax", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{G}{G}");§this.expansionSetCode = "C15";§this.subtype.add("Lizard");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new DevourAbility(DevourEffect.DevourFactor.Devour1));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BloodsporeThrinaxEntersBattlefieldEffect()));§}§public BloodsporeThrinax(final BloodsporeThrinax card) {§super(card);§}§@Override§public BloodsporeThrinax copy() {§return new BloodsporeThrinax(this);§}§}§class BloodsporeThrinaxEntersBattlefieldEffect extends ReplacementEffectImpl {§public BloodsporeThrinaxEntersBattlefieldEffect() {§super(Duration.WhileOnBattlefield, Outcome.BoostCreature);§staticText = "Each other creature you control enters the battlefield with an additional X +1/+1 counters on it, where X is the number of +1/+1 counters on {this}";§}§public BloodsporeThrinaxEntersBattlefieldEffect(BloodsporeThrinaxEntersBattlefieldEffect effect) {§super(effect);§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == EventType.ENTERS_THE_BATTLEFIELD;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§Permanent creature = ((EntersTheBattlefieldEvent) event).getTarget();§return creature != null && creature.getControllerId().equals(source.getControllerId())§&& creature.getCardType().contains(CardType.CREATURE)§&& !event.getTargetId().equals(source.getSourceId());§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§Permanent sourceCreature = game.getPermanent(source.getSourceId());§Permanent creature = ((EntersTheBattlefieldEvent) event).getTarget();§if (sourceCreature != null && creature != null) {§int amount = sourceCreature.getCounters().getCount(CounterType.P1P1);§if (amount > 0) {§creature.addCounters(CounterType.P1P1.createInstance(amount), game);§}§}§return false;§}§@Override§public BloodsporeThrinaxEntersBattlefieldEffect copy() {§return new BloodsporeThrinaxEntersBattlefieldEffect(this);§}§}§
public class BorderlandBehemoth extends CardImpl {§public BorderlandBehemoth(UUID ownerId) {§super(ownerId, 142, "Borderland Behemoth", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}{R}{R}");§this.expansionSetCode = "C15";§this.subtype.add("Giant");§this.subtype.add("Warrior");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(TrampleAbility.getInstance());§FilterCreaturePermanent filter = new FilterCreaturePermanent("other Giant you control");§filter.add(new SubtypePredicate("Giant"));§filter.add(Predicates.not(new PermanentIdPredicate(this.getId())));§filter.add(new ControllerPredicate(TargetController.YOU));§DynamicValue xValue = new PermanentsOnBattlefieldCount(filter, 4);§Effect effect = new BoostSourceEffect(xValue, xValue, Duration.WhileOnBattlefield, false);§effect.setText("{this} gets +4/+4 for each other Giant you control");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, effect));§}§public BorderlandBehemoth(final BorderlandBehemoth card) {§super(card);§}§@Override§public BorderlandBehemoth copy() {§return new BorderlandBehemoth(this);§}§}§
public class BroodbirthViper extends CardImpl {§public BroodbirthViper(UUID ownerId) {§super(ownerId, 10, "Broodbirth Viper", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{U}");§this.expansionSetCode = "C15";§this.subtype.add("Snake");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new MyriadAbility());§this.addAbility(new DealsCombatDamageToAPlayerTriggeredAbility(new DrawCardSourceControllerEffect(1), true, false));§}§public BroodbirthViper(final BroodbirthViper card) {§super(card);§}§@Override§public BroodbirthViper copy() {§return new BroodbirthViper(this);§}§}§
public class CallerOfThePack extends CardImpl {§public CallerOfThePack(UUID ownerId) {§super(ownerId, 34, "Caller of the Pack", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{5}{G}{G}");§this.expansionSetCode = "C15";§this.subtype.add("Beast");§this.power = new MageInt(8);§this.toughness = new MageInt(6);§this.addAbility(TrampleAbility.getInstance());§this.addAbility(new MyriadAbility());§}§public CallerOfThePack(final CallerOfThePack card) {§super(card);§}§@Override§public CallerOfThePack copy() {§return new CallerOfThePack(this);§}§}§
public class CentaurVinecrasher extends CardImpl {§public CentaurVinecrasher(UUID ownerId) {§super(ownerId, 35, "Centaur Vinecrasher", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{G}");§this.expansionSetCode = "C15";§this.subtype.add("Plant");§this.subtype.add("Centaur");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(TrampleAbility.getInstance());§Effect effect = new AddCountersSourceEffect(CounterType.P1P1.createInstance(0), new CardsInAllGraveyardsCount(new FilterLandCard()), true);§effect.setText("with a number of +1/+1 counters on it equal to the number of land cards in all graveyards");§this.addAbility(new EntersBattlefieldAbility(effect));§this.addAbility(new PutCardIntoGraveFromAnywhereAllTriggeredAbility(Zone.GRAVEYARD,§new DoIfCostPaid(new ReturnSourceFromGraveyardToHandEffect(), new ManaCostsImpl<>("{G}{G}")),§false, new FilterLandCard("a land card"), TargetController.ANY, SetTargetPointer.NONE§));§}§public CentaurVinecrasher(final CentaurVinecrasher card) {§super(card);§}§@Override§public CentaurVinecrasher copy() {§return new CentaurVinecrasher(this);§}§}§
public class CommandBeacon extends CardImpl {§public CommandBeacon(UUID ownerId) {§super(ownerId, 56, "Command Beacon", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "C15";§this.addAbility(new ColorlessManaAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new CommandBeaconEffect(), new TapSourceCost());§ability.addCost(new SacrificeSourceCost());§this.addAbility(ability);§}§public CommandBeacon(final CommandBeacon card) {§super(card);§}§@Override§public CommandBeacon copy() {§return new CommandBeacon(this);§}§}§class CommandBeaconEffect extends OneShotEffect {§CommandBeaconEffect() {§super(Outcome.ReturnToHand);§this.staticText = "Put your commander into your hand from the command zone";§}§CommandBeaconEffect(final CommandBeaconEffect effect) {§super(effect);§}§@Override§public CommandBeaconEffect copy() {§return new CommandBeaconEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Card commander = game.getCard(controller.getCommanderId());§if (commander != null && game.getState().getZone(commander.getId()) == Zone.COMMAND) {§controller.moveCards(commander, Zone.HAND, source, game);§}§return true;§}§return false;§}§}§
public class DawnbreakReclaimer extends CardImpl {§public DawnbreakReclaimer(UUID ownerId) {§super(ownerId, 2, "Dawnbreak Reclaimer", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{W}{W}");§this.expansionSetCode = "C15";§this.subtype.add("Angel");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new BeginningOfEndStepTriggeredAbility(new DawnbreakReclaimerEffect(), TargetController.YOU, false));§}§public DawnbreakReclaimer(final DawnbreakReclaimer card) {§super(card);§}§@Override§public DawnbreakReclaimer copy() {§return new DawnbreakReclaimer(this);§}§}§class DawnbreakReclaimerEffect extends OneShotEffect {§public DawnbreakReclaimerEffect() {§super(Outcome.Detriment);§this.staticText = "choose a creature card in an opponent's graveyard, then that player chooses a creature card in your graveyard. You may return those cards to the battlefield under their owners' control";§}§public DawnbreakReclaimerEffect(final DawnbreakReclaimerEffect effect) {§super(effect);§}§@Override§public DawnbreakReclaimerEffect copy() {§return new DawnbreakReclaimerEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§MageObject sourceObject = source.getSourceObject(game);§if (controller != null && sourceObject != null) {§TargetCardInOpponentsGraveyard targetCreature = new TargetCardInOpponentsGraveyard(new FilterCreatureCard("a creature card in an opponent's graveyard"));§if (controller.choose(Outcome.Detriment, targetCreature, source.getSourceId(), game)) {§Card creatureCard = game.getCard(targetCreature.getFirstTarget());§Player opponent = game.getPlayer(creatureCard.getOwnerId());§if (opponent != null) {§game.informPlayers(sourceObject.getLogName() + ": " + controller.getLogName() + " has chosen " + creatureCard.getIdName() + " of " + opponent.getLogName());§FilterCreatureCard filter = new FilterCreatureCard("a creature card in " + controller.getName() + "'s the graveyard");§filter.add(new OwnerIdPredicate(controller.getId()));§TargetCardInGraveyard targetCard = new TargetCardInGraveyard(filter);§targetCard.setNotTarget(true);§if (opponent.choose(outcome, targetCard, source.getSourceId(), game)) {§Card controllerCreatureCard = game.getCard(targetCard.getFirstTarget());§if (controllerCreatureCard != null) {§MessageToClient message = new MessageToClient("Return those cards to the battlefield under their owners' control?",§"Opponent's creature card: " + creatureCard.getLogName() + " - Your creature: " + controllerCreatureCard.getLogName());§if (controller.chooseUse(outcome, message, source, game)) {§Set<Card> cards = new HashSet<>();§cards.add(creatureCard);§cards.add(controllerCreatureCard);§opponent.moveCards(cards, Zone.BATTLEFIELD, source, game, false, false, true, null);§}§}§}§}§}§return true;§}§return false;§}§}§
public class DaxossTorment extends CardImpl {§public DaxossTorment(UUID ownerId) {§super(ownerId, 18, "Daxos's Torment", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{3}{B}");§this.expansionSetCode = "C15";§this.addAbility(new ConstellationAbility(new BecomesCreatureSourceEffect(new DaxossTormentToken(), "", Duration.EndOfTurn)));§}§public DaxossTorment(final DaxossTorment card) {§super(card);§}§@Override§public DaxossTorment copy() {§return new DaxossTorment(this);§}§}§class DaxossTormentToken extends Token {§public DaxossTormentToken() {§super("", "a 5/5 Demon creature with flying and haste");§cardType.add(CardType.CREATURE);§subtype.add("Demon");§power = new MageInt(5);§toughness = new MageInt(5);§addAbility(FlyingAbility.getInstance());§addAbility(HasteAbility.getInstance());§}§}§
public class DaxosTheReturned extends CardImpl {§private static final FilterSpell filter = new FilterSpell("an enchantment spell");§static {§filter.add(new CardTypePredicate(CardType.ENCHANTMENT));§}§public DaxosTheReturned(UUID ownerId) {§super(ownerId, 43, "Daxos the Returned", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{1}{W}{B}");§this.expansionSetCode = "C15";§this.supertype.add("Legendary");§this.subtype.add("Zombie");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Effect effect = new AddCountersControllerEffect(CounterType.EXPERIENCE.createInstance(1), false);§effect.setText("you get an experience counter");§Ability ability = new SpellCastControllerTriggeredAbility(effect, filter, false);§this.addAbility(ability);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new CreateTokenEffect(new DaxosSpiritToken(), 1), new ManaCostsImpl("{1}{W}{B}")));§}§public DaxosTheReturned(final DaxosTheReturned card) {§super(card);§}§@Override§public DaxosTheReturned copy() {§return new DaxosTheReturned(this);§}§}§class DaxosSpiritToken extends Token {§DaxosSpiritToken() {§super("Spirit", "white and black Spirit enchantment creature token with \"This creature's power and toughness are each equal to the number of experience counters you have.\"");§this.setOriginalExpansionSetCode("C15");§cardType.add(CardType.ENCHANTMENT);§cardType.add(CardType.CREATURE);§color.setWhite(true);§color.setBlack(true);§subtype.add("Spirit");§power = new MageInt(0);§toughness = new MageInt(0);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new DaxosSpiritSetPTEffect()));§}§}§class DaxosSpiritSetPTEffect extends ContinuousEffectImpl {§public DaxosSpiritSetPTEffect() {§super(Duration.WhileOnBattlefield, Layer.PTChangingEffects_7, SubLayer.SetPT_7b, Outcome.BoostCreature);§staticText = "This creature's power and toughness are each equal to the number of experience counters you have";§}§public DaxosSpiritSetPTEffect(final DaxosSpiritSetPTEffect effect) {§super(effect);§}§@Override§public DaxosSpiritSetPTEffect copy() {§return new DaxosSpiritSetPTEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Permanent permanent = game.getPermanent(source.getSourceId());§if (permanent != null && new MageObjectReference(source.getSourceObject(game), game).refersTo(permanent, game)) {§int amount = controller.getCounters().getCount(CounterType.EXPERIENCE);§permanent.getPower().setValue(amount);§permanent.getToughness().setValue(amount);§return true;§} else {§discard();§}§}§return false;§}§}§
public class DeadlyTempest extends CardImpl {§public DeadlyTempest(UUID ownerId) {§super(ownerId, 19, "Deadly Tempest", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{4}{B}{B}");§this.expansionSetCode = "C15";§getSpellAbility().addEffect(new DeadlyTempestEffect());§}§public DeadlyTempest(final DeadlyTempest card) {§super(card);§}§@Override§public DeadlyTempest copy() {§return new DeadlyTempest(this);§}§}§class DeadlyTempestEffect extends OneShotEffect {§public DeadlyTempestEffect() {§super(Outcome.DestroyPermanent);§this.staticText = "Destroy all creatures. Each player loses life equal to the number of creatures he or she controlled that were destroyed this way";§}§public DeadlyTempestEffect(final DeadlyTempestEffect effect) {§super(effect);§}§@Override§public DeadlyTempestEffect copy() {§return new DeadlyTempestEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§HashMap<UUID, Integer> destroyedCreatures = new HashMap<>();§for (Permanent permanent : game.getBattlefield().getActivePermanents(new FilterCreaturePermanent(), source.getControllerId(), source.getSourceId(), game)) {§if (permanent.destroy(source.getSourceId(), game, false)) {§int count = destroyedCreatures.containsKey(permanent.getControllerId()) ? destroyedCreatures.get(permanent.getControllerId()) : 0;§destroyedCreatures.put(permanent.getControllerId(), count + 1);§}§}§for (UUID playerId : game.getState().getPlayerList(source.getControllerId())) {§int count = destroyedCreatures.containsKey(playerId) ? destroyedCreatures.get(playerId) : 0;§if (count > 0) {§Player player = game.getPlayer(playerId);§if (player != null) {§player.damage(count, playerId, game, false, true);§}§}§}§return true;§}§return false;§}§}§
public class DreadSummons extends CardImpl {§public DreadSummons(UUID ownerId) {§super(ownerId, 20, "Dread Summons", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{X}{B}{B}");§this.expansionSetCode = "C15";§getSpellAbility().addEffect(new DreadSummonsEffect());§}§public DreadSummons(final DreadSummons card) {§super(card);§}§@Override§public DreadSummons copy() {§return new DreadSummons(this);§}§}§class DreadSummonsEffect extends OneShotEffect {§public DreadSummonsEffect() {§super(Outcome.PutCreatureInPlay);§this.staticText = "Each player puts the top X cards of his or her library into his or her graveyard. For each creature card put into a graveyard this way, you put a 2/2 black Zombie creature token onto the battlefield tapped";§}§public DreadSummonsEffect(final DreadSummonsEffect effect) {§super(effect);§}§@Override§public DreadSummonsEffect copy() {§return new DreadSummonsEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§int numberOfCards = source.getManaCostsToPay().getX();§if (numberOfCards > 0) {§int numberOfCreatureCards = 0;§for (UUID playerId : game.getState().getPlayersInRange(source.getControllerId(), game)) {§Player player = game.getPlayer(playerId);§if (player != null) {§Set<Card> movedCards = player.moveCardsToGraveyardWithInfo(player.getLibrary().getTopCards(game, numberOfCards), source, game, Zone.LIBRARY);§for (Card card : movedCards) {§if (card.getCardType().contains(CardType.CREATURE)) {§numberOfCreatureCards++;§}§}§}§}§if (numberOfCreatureCards > 0) {§return new CreateTokenEffect(new ZombieToken(), numberOfCreatureCards, true, false).apply(game, source);§}§}§return true;§}§return false;§}§}§
public class DreamPillager extends CardImpl {§public DreamPillager(UUID ownerId) {§super(ownerId, 25, "Dream Pillager", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}{R}{R}");§this.expansionSetCode = "C15";§this.subtype.add("Dragon");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new DreamPillagerTriggeredAbility());§}§public DreamPillager(final DreamPillager card) {§super(card);§}§@Override§public DreamPillager copy() {§return new DreamPillager(this);§}§}§class DreamPillagerTriggeredAbility extends TriggeredAbilityImpl {§public DreamPillagerTriggeredAbility() {§super(Zone.BATTLEFIELD, new DreamPillagerEffect(), false);§}§public DreamPillagerTriggeredAbility(final DreamPillagerTriggeredAbility ability) {§super(ability);§}§@Override§public DreamPillagerTriggeredAbility copy() {§return new DreamPillagerTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.DAMAGED_PLAYER;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (event.getSourceId().equals(this.sourceId) && ((DamagedPlayerEvent) event).isCombatDamage()) {§for (Effect effect : getEffects()) {§effect.setValue("damage", event.getAmount());§}§return true;§}§return false;§}§@Override§public String getRule() {§return "Whenever {this} deals combat damage to a player, exile that many cards from the top of your library. Until end of turn, you may cast nonland cards exiled this way.";§}§}§class DreamPillagerEffect extends OneShotEffect {§public DreamPillagerEffect() {§super(Outcome.Benefit);§this.staticText = "exile that many cards from the top of your library. Until end of turn, you may cast nonland cards exiled this way";§}§public DreamPillagerEffect(final DreamPillagerEffect effect) {§super(effect);§}§@Override§public DreamPillagerEffect copy() {§return new DreamPillagerEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§MageObject sourceObject = source.getSourceObject(game);§if (controller != null && sourceObject != null) {§int amount = (Integer) getValue("damage");§if (amount > 0) {§Set<Card> cards = controller.getLibrary().getTopCards(game, amount);§if (!cards.isEmpty()) {§controller.moveCards(cards, Zone.EXILED, source, game);§for (Card card : cards) {§if (!card.getCardType().contains(CardType.LAND)) {§ContinuousEffect effect = new DreamPillagerCastFromExileEffect();§effect.setTargetPointer(new FixedTarget(card.getId(), card.getZoneChangeCounter(game)));§game.addEffect(effect, source);§}§}§}§return true;§}§return true;§}§return false;§}§}§class DreamPillagerCastFromExileEffect extends AsThoughEffectImpl {§public DreamPillagerCastFromExileEffect() {§super(AsThoughEffectType.PLAY_FROM_NOT_OWN_HAND_ZONE, Duration.EndOfTurn, Outcome.Benefit);§staticText = "You may play the card from exile";§}§public DreamPillagerCastFromExileEffect(final DreamPillagerCastFromExileEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public DreamPillagerCastFromExileEffect copy() {§return new DreamPillagerCastFromExileEffect(this);§}§@Override§public boolean applies(UUID objectId, Ability source, UUID affectedControllerId, Game game) {§return source.getControllerId().equals(affectedControllerId)§&& objectId.equals(getTargetPointer().getFirst(game, source));§}§}§
public class EzuriClawOfProgress extends CardImpl {§final private static FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent();§final private static FilterControlledCreaturePermanent filter2 = new FilterControlledCreaturePermanent();§static {§filter.add(new PowerPredicate(Filter.ComparisonType.LessThan, 3));§filter2.add(new AnotherPredicate());§}§String rule = "Whenever a creature with power 2 or less enters the battlefield under your control, you get an experience counter.";§public EzuriClawOfProgress(UUID ownerId) {§super(ownerId, 44, "Ezuri, Claw of Progress", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{2}{G}{U}");§this.expansionSetCode = "C15";§this.supertype.add("Legendary");§this.subtype.add("Elf");§this.subtype.add("Warrior");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new EntersBattlefieldAllTriggeredAbility(Zone.BATTLEFIELD, new AddCountersControllerEffect(§CounterType.EXPERIENCE.createInstance(1), false), filter, false, rule, true));§Ability ability = new BeginningOfCombatTriggeredAbility(new EzuriClawOfProgressEffect(), TargetController.YOU, false);§ability.addTarget(new TargetControlledCreaturePermanent(filter2));§this.addAbility(ability);§}§public EzuriClawOfProgress(final EzuriClawOfProgress card) {§super(card);§}§@Override§public EzuriClawOfProgress copy() {§return new EzuriClawOfProgress(this);§}§}§class EzuriClawOfProgressEffect extends OneShotEffect {§public EzuriClawOfProgressEffect() {§super(Outcome.Benefit);§this.staticText = "put X +1/+1 counters on another target creature you control, where X is the number of experience counters you have";§}§public EzuriClawOfProgressEffect(final EzuriClawOfProgressEffect effect) {§super(effect);§}§@Override§public EzuriClawOfProgressEffect copy() {§return new EzuriClawOfProgressEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent target = game.getPermanent(source.getFirstTarget());§if (target == null) {§return false;§}§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§int amount = controller.getCounters().getCount(CounterType.EXPERIENCE);§target.addCounters(CounterType.P1P1.createInstance(amount), game);§}§return false;§}§}§
public class EzurisPredation extends CardImpl {§public EzurisPredation(UUID ownerId) {§super(ownerId, 36, "Ezuri's Predation", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{5}{G}{G}{G}");§this.expansionSetCode = "C15";§this.getSpellAbility().addEffect(new EzurisPredationEffect());§}§public EzurisPredation(final EzurisPredation card) {§super(card);§}§@Override§public EzurisPredation copy() {§return new EzurisPredation(this);§}§}§class EzurisPredationEffect extends OneShotEffect {§public EzurisPredationEffect() {§super(Outcome.PutCreatureInPlay);§this.staticText = "For each creature your opponents control, put a 4/4 green Beast creature token onto the battlefield. Each of those Beasts fights a different one of those creatures";§}§public EzurisPredationEffect(final EzurisPredationEffect effect) {§super(effect);§}§@Override§public EzurisPredationEffect copy() {§return new EzurisPredationEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§/*§* Players can't cast spells or activate any abilities in between the§* Beasts entering the battlefield and fighting the other creatures.§* Ifthe Beasts entering the battlefield cause any abilities to trigger,§* those abilities will be put onto the stack after Ezuri's Predation is§* finished resolving.§* You choose which Beast is fighting which creature§* an opponent controls. Each of the "fights" happens at the same time.§* If Ezuri's Predation creates more than one token for any given§* creature (due to an effect such as the one Doubling Season creates),§* the extra tokens won't fight any creature.§*/§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§FilterCreaturePermanent filterCreature = new FilterCreaturePermanent();§filterCreature.add(new ControllerPredicate(TargetController.OPPONENT));§List<Permanent> creaturesOfOpponents = game.getBattlefield().getActivePermanents(filterCreature, source.getControllerId(), source.getSourceId(), game);§if (!creaturesOfOpponents.isEmpty()) {§CreateTokenEffect effect = new CreateTokenEffect(new BeastToken2(), creaturesOfOpponents.size());§effect.apply(game, source);§for (UUID tokenId : effect.getLastAddedTokenIds()) {§Permanent token = game.getPermanent(tokenId);§if (token != null) {§if (creaturesOfOpponents.isEmpty()) {§break;§}§Permanent opponentCreature = creaturesOfOpponents.iterator().next();§creaturesOfOpponents.remove(opponentCreature);§token.fight(opponentCreature, source, game);§game.informPlayers(token.getLogName() + " fights " + opponentCreature.getLogName());§}§}§}§return true;§}§return false;§}§}§
public class FieryConfluence extends CardImpl {§public FieryConfluence(UUID ownerId) {§super(ownerId, 26, "Fiery Confluence", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{2}{R}{R}");§this.expansionSetCode = "C15";§this.getSpellAbility().getModes().setMinModes(3);§this.getSpellAbility().getModes().setMaxModes(3);§this.getSpellAbility().getModes().setEachModeMoreThanOnce(true);§this.getSpellAbility().addEffect(new DamageAllEffect(1, new FilterCreaturePermanent()));§Mode mode = new Mode();§mode.getEffects().add(new DamagePlayersEffect(2, TargetController.OPPONENT));§this.getSpellAbility().getModes().addMode(mode);§mode = new Mode();§mode.getEffects().add(new DestroyTargetEffect());§mode.getTargets().add(new TargetArtifactPermanent());§this.getSpellAbility().getModes().addMode(mode);§}§public FieryConfluence(final FieryConfluence card) {§super(card);§}§@Override§public FieryConfluence copy() {§return new FieryConfluence(this);§}§}§
public class Gigantoplasm extends CardImpl {§public Gigantoplasm(UUID ownerId) {§super(ownerId, 11, "Gigantoplasm", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{U}");§this.expansionSetCode = "C15";§this.subtype.add("Shapeshifter");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§Effect effect = new CopyPermanentEffect(new FilterCreaturePermanent(), new GigantoplasmApplyToPermanent());§effect.setText("a copy of any creature on the battlefield except it gains \"{X}: This creature has base power and toughness X/X.\"");§this.addAbility(new EntersBattlefieldAbility(effect, true));§}§public Gigantoplasm(final Gigantoplasm card) {§super(card);§}§@Override§public Gigantoplasm copy() {§return new Gigantoplasm(this);§}§}§class GigantoplasmApplyToPermanent extends ApplyToPermanent {§@Override§public Boolean apply(Game game, Permanent permanent) {§DynamicValue variableMana = new ManacostVariableValue();§Effect effect = new SetPowerToughnessSourceEffect(variableMana, Duration.WhileOnBattlefield, SubLayer.SetPT_7b);§effect.setText("This creature has base power and toughness X/X");§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new ManaCostsImpl("{X}"));§permanent.getAbilities().add(ability);§return true;§}§@Override§public Boolean apply(Game game, MageObject mageObject) {§DynamicValue variableMana = new ManacostVariableValue();§Effect effect = new SetPowerToughnessSourceEffect(variableMana, Duration.WhileOnBattlefield, SubLayer.SetPT_7b);§effect.setText("This creature has base power and toughness X/X");§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new ManaCostsImpl("{X}"));§mageObject.getAbilities().add(ability);§return true;§}§}§
public class GraspOfFate extends CardImpl {§public GraspOfFate(UUID ownerId) {§super(ownerId, 3, "Grasp of Fate", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{1}{W}{W}");§this.expansionSetCode = "C15";§Ability ability = new EntersBattlefieldTriggeredAbility(new GraspOfFateExileEffect());§ability.addTarget(new TargetPermanent(filter));§ability.addEffect(new CreateDelayedTriggeredAbilityEffect(new OnLeaveReturnExiledToBattlefieldAbility()));§this.addAbility(ability);§}§public GraspOfFate(final GraspOfFate card) {§super(card);§}§@Override§public void adjustTargets(Ability ability, Game game) {§if (ability instanceof EntersBattlefieldTriggeredAbility) {§ability.getTargets().clear();§for (UUID opponentId : game.getOpponents(ability.getControllerId())) {§Player opponent = game.getPlayer(opponentId);§if (opponent != null) {§FilterPermanent filter = new FilterPermanent("nonland permanent from opponent " + opponent.getLogName());§filter.add(new ControllerIdPredicate(opponentId));§filter.add(Predicates.not(new CardTypePredicate(CardType.LAND)));§TargetPermanent target = new TargetPermanent(0, 1, filter, false);§ability.addTarget(target);§}§}§}§}§@Override§public GraspOfFate copy() {§return new GraspOfFate(this);§}§}§class GraspOfFateExileEffect extends OneShotEffect {§public GraspOfFateExileEffect() {§super(Outcome.Benefit);§this.staticText = "exile up to one target nonland permanent that player controls until {this} leaves the battlefield";§}§public GraspOfFateExileEffect(final GraspOfFateExileEffect effect) {§super(effect);§}§@Override§public GraspOfFateExileEffect copy() {§return new GraspOfFateExileEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getPermanent(source.getSourceId());§if (permanent != null) {§return new ExileTargetEffect(CardUtil.getCardExileZoneId(game, source), permanent.getIdName(), Zone.BATTLEFIELD, true).apply(game, source);§}§return false;§}§}§
public class GreatOakGuardian extends CardImpl {§public GreatOakGuardian(UUID ownerId) {§super(ownerId, 37, "Great Oak Guardian", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{5}{G}");§this.expansionSetCode = "C15";§this.subtype.add("Treefolk");§this.power = new MageInt(4);§this.toughness = new MageInt(5);§this.addAbility(FlashAbility.getInstance());§this.addAbility(ReachAbility.getInstance());§Ability ability = new EntersBattlefieldTriggeredAbility(new GreatOakGuardianEffect(), false);§ability.addEffect(new GreatOakGuardianUntapEffect());§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§}§public GreatOakGuardian(final GreatOakGuardian card) {§super(card);§}§@Override§public GreatOakGuardian copy() {§return new GreatOakGuardian(this);§}§}§class GreatOakGuardianEffect extends ContinuousEffectImpl {§public GreatOakGuardianEffect() {§super(Duration.EndOfTurn, Layer.PTChangingEffects_7, SubLayer.ModifyPT_7c, Outcome.BoostCreature);§staticText = "creatures target player controls get +2/+2 until end of turn. Untap them";§}§public GreatOakGuardianEffect(final GreatOakGuardianEffect effect) {§super(effect);§}§@Override§public GreatOakGuardianEffect copy() {§return new GreatOakGuardianEffect(this);§}§@Override§public void init(Ability source, Game game) {§super.init(source, game);§if (this.affectedObjectsSet) {§List<Permanent> creatures = game.getBattlefield().getAllActivePermanents(new FilterCreaturePermanent(), source.getFirstTarget(), game);§for (Permanent creature : creatures) {§affectedObjectList.add(new MageObjectReference(creature, game));§}§}§}§@Override§public boolean apply(Game game, Ability source) {§for (Iterator<MageObjectReference> it = affectedObjectList.iterator(); it.hasNext();) {§Permanent permanent = it.next().getPermanent(game);§if (permanent != null) {§permanent.addPower(2);§permanent.addToughness(2);§} else {§it.remove();§}§}§return true;§}§}§class GreatOakGuardianUntapEffect extends OneShotEffect {§public GreatOakGuardianUntapEffect() {§super(Outcome.Benefit);§this.staticText = "untap them";§}§public GreatOakGuardianUntapEffect(final GreatOakGuardianUntapEffect effect) {§super(effect);§}§@Override§public GreatOakGuardianUntapEffect copy() {§return new GreatOakGuardianUntapEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player targetPlayer = game.getPlayer(source.getControllerId());§if (targetPlayer != null) {§for (Permanent permanent : game.getBattlefield().getAllActivePermanents(new FilterCreaturePermanent(), targetPlayer.getId(), game)) {§permanent.untap(game);§}§return true;§}§return false;§}§}§
public class HeraldOfTheHost extends CardImpl {§public HeraldOfTheHost(UUID ownerId) {§super(ownerId, 4, "Herald of the Host", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{W}{W}");§this.expansionSetCode = "C15";§this.subtype.add("Angel");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(VigilanceAbility.getInstance());§this.addAbility(new MyriadAbility());§}§public HeraldOfTheHost(final HeraldOfTheHost card) {§super(card);§}§@Override§public HeraldOfTheHost copy() {§return new HeraldOfTheHost(this);§}§}§
public class IllusoryAmbusher extends CardImpl {§public IllusoryAmbusher(UUID ownerId) {§super(ownerId, 12, "Illusory Ambusher", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{U}");§this.expansionSetCode = "C15";§this.subtype.add("Cat");§this.subtype.add("Illusion");§this.power = new MageInt(4);§this.toughness = new MageInt(1);§this.addAbility(FlashAbility.getInstance());§this.addAbility(new DealtDamageToSourceTriggeredAbility(Zone.BATTLEFIELD, new IllusoryAmbusherDealtDamageEffect(), false));§}§public IllusoryAmbusher(final IllusoryAmbusher card) {§super(card);§}§@Override§public IllusoryAmbusher copy() {§return new IllusoryAmbusher(this);§}§}§class IllusoryAmbusherDealtDamageEffect extends OneShotEffect {§public IllusoryAmbusherDealtDamageEffect() {§super(Outcome.Damage);§this.staticText = "draw that many cards";§}§public IllusoryAmbusherDealtDamageEffect(final IllusoryAmbusherDealtDamageEffect effect) {§super(effect);§}§@Override§public IllusoryAmbusherDealtDamageEffect copy() {§return new IllusoryAmbusherDealtDamageEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§int amount = (Integer) getValue("damage");§if (amount > 0) {§player.drawCards(amount, game);§}§return true;§}§return false;§}§}§
public class KalemneDiscipleOfIroas extends CardImpl {§private static final FilterSpell filterSpell = new FilterSpell("a creature spell with converted mana cost 5 or greater");§static {§filterSpell.add(new CardTypePredicate(CardType.CREATURE));§filterSpell.add(new ConvertedManaCostPredicate(Filter.ComparisonType.GreaterThan, 4));§}§public KalemneDiscipleOfIroas(UUID ownerId) {§super(ownerId, 45, "Kalemne, Disciple of Iroas", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{2}{R}{W}");§this.expansionSetCode = "C15";§this.supertype.add("Legendary");§this.subtype.add("Giant");§this.subtype.add("Soldier");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(DoubleStrikeAbility.getInstance());§this.addAbility(VigilanceAbility.getInstance());§Effect effect = new AddCountersControllerEffect(CounterType.EXPERIENCE.createInstance(1), false);§effect.setText("you get an experience counter");§Ability ability = new SpellCastControllerTriggeredAbility(effect, filterSpell, false);§this.addAbility(ability);§DynamicValue value = new SourceControllerExperienceCountersCount();§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostSourceEffect(value, value, Duration.WhileOnBattlefield)));§}§public KalemneDiscipleOfIroas(final KalemneDiscipleOfIroas card) {§super(card);§}§@Override§public KalemneDiscipleOfIroas copy() {§return new KalemneDiscipleOfIroas(this);§}§}§class SourceControllerExperienceCountersCount implements DynamicValue {§@Override§public int calculate(Game game, Ability sourceAbility, Effect effect) {§int amount = 0;§Player player = game.getPlayer(sourceAbility.getControllerId());§if (player != null) {§amount = player.getCounters().getCount(CounterType.EXPERIENCE);§}§return amount;§}§@Override§public SourceControllerExperienceCountersCount copy() {§return new SourceControllerExperienceCountersCount();§}§@Override§public String toString() {§return "1";§}§@Override§public String getMessage() {§return "experience counter you have";§}§}§
public class KalemnesCaptain extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("artifacts and enchantments");§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.ARTIFACT),§new CardTypePredicate(CardType.ENCHANTMENT)));§}§public KalemnesCaptain(UUID ownerId) {§super(ownerId, 5, "Kalemne's Captain", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{W}{W}");§this.expansionSetCode = "C15";§this.subtype.add("Giant");§this.subtype.add("Soldier");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(VigilanceAbility.getInstance());§this.addAbility(new MonstrosityAbility("{5}{W}{W}", 3));§this.addAbility(new BecomesMonstrousSourceTriggeredAbility(new ExileAllEffect(filter)));§}§public KalemnesCaptain(final KalemnesCaptain card) {§super(card);§}§@Override§public KalemnesCaptain copy() {§return new KalemnesCaptain(this);§}§}§
public class KarlovOfTheGhostCouncil extends CardImpl {§public KarlovOfTheGhostCouncil(UUID ownerId) {§super(ownerId, 46, "Karlov of the Ghost Council", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{W}{B}");§this.expansionSetCode = "C15";§this.supertype.add("Legendary");§this.subtype.add("Spirit");§this.subtype.add("Advisor");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new GainLifeControllerTriggeredAbility(new AddCountersSourceEffect(CounterType.P1P1.createInstance(2)), false));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ExileTargetEffect(), new ManaCostsImpl("{W}{B}"));§ability.addCost(new RemoveCountersSourceCost(CounterType.P1P1.createInstance(6)));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public KarlovOfTheGhostCouncil(final KarlovOfTheGhostCouncil card) {§super(card);§}§@Override§public KarlovOfTheGhostCouncil copy() {§return new KarlovOfTheGhostCouncil(this);§}§}§
public class KasetoOrochiArchmage extends CardImpl {§public KasetoOrochiArchmage(UUID ownerId) {§super(ownerId, 47, "Kaseto, Orochi Archmage", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{1}{G}{U}");§this.expansionSetCode = "C15";§this.supertype.add("Legendary");§this.subtype.add("Snake");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new KasetoEffect(), new ManaCostsImpl<>("{G}{U}"));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public KasetoOrochiArchmage(final KasetoOrochiArchmage card) {§super(card);§}§@Override§public KasetoOrochiArchmage copy() {§return new KasetoOrochiArchmage(this);§}§}§class KasetoEffect extends OneShotEffect {§public KasetoEffect() {§super(Outcome.BoostCreature);§staticText = "Target creature can't be blocked this turn. If that creature is a Snake, it gets +2/+2 until end of turn";§}§public KasetoEffect(final KasetoEffect effect) {§super(effect);§}§@Override§public KasetoEffect copy() {§return new KasetoEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getPermanent(getTargetPointer().getFirst(game, source));§if (permanent != null) {§game.addEffect(new CantBeBlockedTargetEffect(Duration.EndOfTurn), source);§if (permanent.getSubtype().contains("Snake")) {§game.addEffect(new BoostTargetEffect(2,2,Duration.EndOfTurn), source);§}§return true;§}§return false;§}§}§
public class MerenOfClanNelToth extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("another creature you control");§static {§filter.add(new AnotherPredicate());§filter.add(new ControllerPredicate(TargetController.YOU));§}§public MerenOfClanNelToth(UUID ownerId) {§super(ownerId, 49, "Meren of Clan Nel Toth", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{2}{B}{G}");§this.expansionSetCode = "C15";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Shaman");§this.power = new MageInt(3);§this.toughness = new MageInt(4);§Effect effect = new AddCountersControllerEffect(CounterType.EXPERIENCE.createInstance(1), false);§effect.setText("you get an experience counter");§this.addAbility(new DiesCreatureTriggeredAbility(effect, false, filter));§Target target = new TargetCardInYourGraveyard(new FilterCreatureCard("creature card in your graveyard"));§Ability ability = new BeginningOfYourEndStepTriggeredAbility(new MerenOfClanNelTothEffect(), false);§ability.addTarget(target);§this.addAbility(ability);§}§public MerenOfClanNelToth(final MerenOfClanNelToth card) {§super(card);§}§@Override§public MerenOfClanNelToth copy() {§return new MerenOfClanNelToth(this);§}§}§class MerenOfClanNelTothEffect extends OneShotEffect {§public MerenOfClanNelTothEffect() {§super(Outcome.PutCreatureInPlay);§this.staticText = "choose target creature card in your graveyard. If that card's converted mana cost is less than or equal to the number of experience counters you have, return it to the battlefield. Otherwise, put it into your hand";§}§public MerenOfClanNelTothEffect(final MerenOfClanNelTothEffect effect) {§super(effect);§}§@Override§public MerenOfClanNelTothEffect copy() {§return new MerenOfClanNelTothEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§int amount = player.getCounters().getCount(CounterType.EXPERIENCE);§Card card = game.getCard(targetPointer.getFirst(game, source));§if (card != null) {§Zone targetZone = Zone.HAND;§String text = " put into hand of ";§if (card.getManaCost().convertedManaCost() <= amount) {§targetZone = Zone.BATTLEFIELD;§text = " put onto battlefield for ";§}§card.moveToZone(targetZone, source.getSourceId(), game, false);§game.informPlayers(new StringBuilder("Meren of Clan Nel Toth: ").append(card.getName()).append(text).append(player.getLogName()).toString());§return true;§}§}§return false;§}§}§
public class MeteorBlast extends CardImpl {§public MeteorBlast(UUID ownerId) {§super(ownerId, 28, "Meteor Blast", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{X}{R}{R}{R}");§this.expansionSetCode = "C15";§this.getSpellAbility().addEffect(new MeteorBlastEffect());§}§public MeteorBlast(final MeteorBlast card) {§super(card);§}§@Override§public void adjustTargets(Ability ability, Game game) {§int xValue = ability.getManaCostsToPay().getX();§if (xValue > 0) {§Target target = new TargetCreatureOrPlayer(xValue);§ability.addTarget(target);§}§}§@Override§public MeteorBlast copy() {§return new MeteorBlast(this);§}§}§class MeteorBlastEffect extends OneShotEffect {§public MeteorBlastEffect() {§super(Outcome.Damage);§staticText = "{this} deals 4 damage to each of X target creatures and/or players";§}§public MeteorBlastEffect(final MeteorBlastEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§if (source.getTargets().size() > 0) {§for (UUID targetId : this.getTargetPointer().getTargets(game, source)) {§Permanent creature = game.getPermanent(targetId);§if (creature != null) {§creature.damage(4, source.getSourceId(), game, false, true);§} else {§Player player = game.getPlayer(targetId);§if (player != null) {§player.damage(4, source.getSourceId(), game, false, true);§}§}§}§}§return true;§}§return false;§}§@Override§public MeteorBlastEffect copy() {§return new MeteorBlastEffect(this);§}§}§
public class MirrorMatch extends CardImpl {§public MirrorMatch(UUID ownerId) {§super(ownerId, 13, "Mirror Match", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{4}{U}{U}");§this.expansionSetCode = "C15";§this.addAbility(new CastOnlyDuringPhaseStepSourceAbility(PhaseStep.DECLARE_BLOCKERS));§this.getSpellAbility().addEffect(new MirrorMatchEffect());§}§public MirrorMatch(final MirrorMatch card) {§super(card);§}§@Override§public MirrorMatch copy() {§return new MirrorMatch(this);§}§}§class MirrorMatchEffect extends OneShotEffect {§public MirrorMatchEffect() {§super(Outcome.Benefit);§this.staticText = "For each creature attacking you or a planeswalker you control, put a token that's a copy of that creature onto the battlefield blocking that creature. Exile those tokens at end of combat";§}§public MirrorMatchEffect(final MirrorMatchEffect effect) {§super(effect);§}§@Override§public MirrorMatchEffect copy() {§return new MirrorMatchEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§for (UUID attackerId : game.getCombat().getAttackers()) {§Permanent attacker = game.getPermanent(attackerId);§if (attacker != null§&& source.getControllerId().equals(game.getCombat().getDefendingPlayerId(attackerId, game))) {§PutTokenOntoBattlefieldCopyTargetEffect effect = new PutTokenOntoBattlefieldCopyTargetEffect(source.getControllerId(), null, false);§effect.setTargetPointer(new FixedTarget(attacker, game));§effect.apply(game, source);§CombatGroup group = game.getCombat().findGroup(attacker.getId());§boolean isCreature = false;§if (group != null) {§for (Permanent addedToken : effect.getAddedPermanent()) {§if (addedToken.getCardType().contains(CardType.CREATURE)) {§group.addBlockerToGroup(addedToken.getId(), attackerId, game);§isCreature = true;§}§}§ExileTargetEffect exileEffect = new ExileTargetEffect("Exile those tokens at end of combat");§exileEffect.setTargetPointer(new FixedTargets(effect.getAddedPermanent(), game));§game.addDelayedTriggeredAbility(new AtTheEndOfCombatDelayedTriggeredAbility(exileEffect), source);§if (isCreature) {§group.pickBlockerOrder(attacker.getControllerId(), game);§}§}§}§}§return true;§}§return false;§}§}§
public class MizzixOfTheIzmagnus extends CardImpl {§private static final FilterInstantOrSorcerySpell filter = new FilterInstantOrSorcerySpell("an instant or sorcery spell with converted mana cost greater than the number of experience counters you have");§static {§filter.add(new MizzixOfTheIzmagnusPredicate());§}§public MizzixOfTheIzmagnus(UUID ownerId) {§super(ownerId, 50, "Mizzix of the Izmagnus", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{2}{U}{R}");§this.expansionSetCode = "C15";§this.supertype.add("Legendary");§this.subtype.add("Goblin");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new SpellCastControllerTriggeredAbility(§new AddCountersControllerEffect(CounterType.EXPERIENCE.createInstance(1), false), filter, false));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new MizzixOfTheIzmagnusCostReductionEffect()));§}§public MizzixOfTheIzmagnus(final MizzixOfTheIzmagnus card) {§super(card);§}§@Override§public MizzixOfTheIzmagnus copy() {§return new MizzixOfTheIzmagnus(this);§}§}§class MizzixOfTheIzmagnusPredicate implements Predicate<MageObject> {§@Override§public boolean apply(MageObject input, Game game) {§Spell spell = game.getStack().getSpell(input.getId());§if (spell != null) {§Player controller = game.getPlayer(spell.getControllerId());§if (controller != null) {§if (spell.getConvertedManaCost() > controller.getCounters().getCount(CounterType.EXPERIENCE)) {§return true;§}§}§}§return false;§}§@Override§public String toString() {§return "VariableManaCost";§}§}§class MizzixOfTheIzmagnusCostReductionEffect extends CostModificationEffectImpl {§MizzixOfTheIzmagnusCostReductionEffect() {§super(Duration.WhileOnBattlefield, Outcome.Benefit, CostModificationType.REDUCE_COST);§staticText = "Instant and sorcery spells you cast cost {1} less to cast for each experience counter you have";§}§MizzixOfTheIzmagnusCostReductionEffect(MizzixOfTheIzmagnusCostReductionEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source, Ability abilityToModify) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§SpellAbility spellAbility = (SpellAbility) abilityToModify;§CardUtil.adjustCost(spellAbility, controller.getCounters().getCount(CounterType.EXPERIENCE));§return true;§}§return false;§}§@Override§public boolean applies(Ability abilityToModify, Ability source, Game game) {§if (abilityToModify instanceof SpellAbility && abilityToModify.getControllerId().equals(source.getControllerId())) {§Spell spell = (Spell) game.getStack().getStackObject(abilityToModify.getId());§if (spell != null) {§return new FilterInstantOrSorceryCard().match(spell, source.getSourceId(), source.getControllerId(), game);§} else {§Card sourceCard = game.getCard(abilityToModify.getSourceId());§return sourceCard != null && new FilterInstantOrSorceryCard().match(sourceCard, source.getSourceId(), source.getControllerId(), game);§}§}§return false;§}§@Override§public MizzixOfTheIzmagnusCostReductionEffect copy() {§return new MizzixOfTheIzmagnusCostReductionEffect(this);§}§}§
public class MizzixsMastery extends CardImpl {§public MizzixsMastery(UUID ownerId) {§super(ownerId, 29, "Mizzix's Mastery", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{3}{R}");§this.expansionSetCode = "C15";§this.getSpellAbility().addEffect(new MizzixsMasteryEffect());§this.getSpellAbility().addTarget(new TargetCardInYourGraveyard(new FilterInstantOrSorceryCard("card that's an instant or sorcery from your graveyard")));§this.getSpellAbility().addEffect(ExileSpellEffect.getInstance());§Ability ability = new OverloadAbility(this, new MizzixsMasteryOverloadEffect(), new ManaCostsImpl("{5}{R}{R}{R}"), TimingRule.SORCERY);§ability.addEffect(ExileSpellEffect.getInstance());§this.addAbility(ability);§}§public MizzixsMastery(final MizzixsMastery card) {§super(card);§}§@Override§public MizzixsMastery copy() {§return new MizzixsMastery(this);§}§}§class MizzixsMasteryEffect extends OneShotEffect {§public MizzixsMasteryEffect() {§super(Outcome.PlayForFree);§this.staticText = "Exile target card that's an instant or sorcery from your graveyard. For each card exiled this way, copy it, and you may cast the copy without paying its mana cost";§}§public MizzixsMasteryEffect(final MizzixsMasteryEffect effect) {§super(effect);§}§@Override§public MizzixsMasteryEffect copy() {§return new MizzixsMasteryEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Card card = game.getCard(getTargetPointer().getFirst(game, source));§if (card != null) {§if (controller.moveCards(card, Zone.EXILED, source, game)) {§Card cardCopy = game.copyCard(card, source, source.getControllerId());§if (cardCopy.getSpellAbility().canChooseTarget(game)§&& controller.chooseUse(outcome, "Cast copy of " + card.getName() + " without paying its mana cost?", source, game)) {§controller.cast(cardCopy.getSpellAbility(), game, true);§}§}§}§return true;§}§return false;§}§}§class MizzixsMasteryOverloadEffect extends OneShotEffect {§public MizzixsMasteryOverloadEffect() {§super(Outcome.PlayForFree);§this.staticText = "Exile each card that's an instant or sorcery from your graveyard. For each card exiled this way, copy it, and you may cast the copy without paying its mana cost. Exile {this}";§}§public MizzixsMasteryOverloadEffect(final MizzixsMasteryOverloadEffect effect) {§super(effect);§}§@Override§public MizzixsMasteryOverloadEffect copy() {§return new MizzixsMasteryOverloadEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Set<Card> cardsToExile = controller.getGraveyard().getCards(new FilterInstantOrSorceryCard(), source.getId(), source.getControllerId(), game);§if (!cardsToExile.isEmpty()) {§if (controller.moveCards(cardsToExile, Zone.EXILED, source, game)) {§Cards copiedCards = new CardsImpl();§for (Card card : cardsToExile) {§copiedCards.add(game.copyCard(card, source, source.getControllerId()));§}§boolean continueCasting = true;§while (continueCasting) {§TargetCard targetCard = new TargetCard(0, 1, Zone.EXILED, new FilterCard("copied card to cast without paying its mana cost?"));§targetCard.setNotTarget(true);§if (controller.choose(outcome, copiedCards, targetCard, game)) {§Card selectedCard = game.getCard(targetCard.getFirstTarget());§if (selectedCard != null && selectedCard.getSpellAbility().canChooseTarget(game)) {§if (controller.cast(selectedCard.getSpellAbility(), game, true)) {§copiedCards.remove(selectedCard);§}§}§}§continueCasting = copiedCards.size() > 0§&& controller.chooseUse(outcome, "Cast one of the copied cards without paying its mana cost?", source, game);§}§}§}§return true;§}§return false;§}§}§
public class MysticConfluence extends CardImpl {§public MysticConfluence(UUID ownerId) {§super(ownerId, 14, "Mystic Confluence", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{3}{U}{U}");§this.expansionSetCode = "C15";§this.getSpellAbility().getModes().setMinModes(3);§this.getSpellAbility().getModes().setMaxModes(3);§this.getSpellAbility().getModes().setEachModeMoreThanOnce(true);§this.getSpellAbility().addEffect(new CounterUnlessPaysEffect(new GenericManaCost(3)));§this.getSpellAbility().addTarget(new TargetSpell());§Mode mode = new Mode();§mode.getEffects().add(new ReturnToHandTargetEffect());§mode.getTargets().add(new TargetCreaturePermanent());§this.getSpellAbility().getModes().addMode(mode);§mode = new Mode();§mode.getEffects().add(new DrawCardSourceControllerEffect(1));§this.getSpellAbility().getModes().addMode(mode);§}§public MysticConfluence(final MysticConfluence card) {§super(card);§}§@Override§public MysticConfluence copy() {§return new MysticConfluence(this);§}§}§
public class OreskosExplorer extends CardImpl {§public OreskosExplorer(UUID ownerId) {§super(ownerId, 6, "Oreskos Explorer", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "C15";§this.subtype.add("Cat");§this.subtype.add("Scout");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new EntersBattlefieldTriggeredAbility(new OreskosExplorerEffect()));§}§public OreskosExplorer(final OreskosExplorer card) {§super(card);§}§@Override§public OreskosExplorer copy() {§return new OreskosExplorer(this);§}§}§class OreskosExplorerEffect extends OneShotEffect {§public OreskosExplorerEffect() {§super(Outcome.PutLandInPlay);§this.staticText = "search your library for up to X Plains cards, where X is the number of players who control more lands than you. Reveal those cards, put them into your hand, then shuffle your library";§}§public OreskosExplorerEffect(final OreskosExplorerEffect effect) {§super(effect);§}§@Override§public OreskosExplorerEffect copy() {§return new OreskosExplorerEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§MageObject sourceObject = source.getSourceObject(game);§if (controller == null || sourceObject == null) {§return false;§}§int controllerLands = game.getBattlefield().countAll(new FilterLandPermanent(), controller.getId(), game);§int landsToSearch = 0;§for (UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {§if (!playerId.equals(controller.getId())) {§if (controllerLands < game.getBattlefield().countAll(new FilterLandPermanent(), playerId, game)) {§landsToSearch++;§}§}§}§if (landsToSearch > 0) {§FilterBasicLandCard filterPlains = new FilterBasicLandCard("up to " + landsToSearch + " Plains cards");§filterPlains.add(new ControllerPredicate(TargetController.YOU));§filterPlains.add(new SubtypePredicate("Plains"));§TargetCardInLibrary target = new TargetCardInLibrary(0, landsToSearch, filterPlains);§if (controller.searchLibrary(target, game)) {§Cards cards = new CardsImpl(target.getTargets());§controller.revealCards(sourceObject.getIdName(), cards, game);§controller.moveCards(cards.getCards(game), Zone.HAND, source, game);§}§}§controller.shuffleLibrary(game);§return true;§}§}§
public class PathbreakerIbex extends CardImpl {§public PathbreakerIbex(UUID ownerId) {§super(ownerId, 38, "Pathbreaker Ibex", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{G}{G}");§this.expansionSetCode = "C15";§this.subtype.add("Goat");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new AttacksTriggeredAbility(new PathbreakerIbexEffect(), false));§}§public PathbreakerIbex(final PathbreakerIbex card) {§super(card);§}§@Override§public PathbreakerIbex copy() {§return new PathbreakerIbex(this);§}§}§class PathbreakerIbexEffect extends OneShotEffect {§public PathbreakerIbexEffect() {§super(Outcome.BoostCreature);§this.staticText = "creatures you control gain trample and get +X/+X until end of turn, where X is the greatest power among creatures you control";§}§public PathbreakerIbexEffect(final PathbreakerIbexEffect effect) {§super(effect);§}§@Override§public PathbreakerIbexEffect copy() {§return new PathbreakerIbexEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§int maxPower = 0;§for (Permanent perm: game.getBattlefield().getAllActivePermanents(new FilterCreaturePermanent(), source.getControllerId(), game)) {§if (perm.getPower().getValue() > maxPower) {§maxPower = perm.getPower().getValue();§}§}§ContinuousEffect effect = new GainAbilityControlledEffect(TrampleAbility.getInstance(), Duration.EndOfStep, new FilterCreaturePermanent());§game.addEffect(effect, source);§if (maxPower != 0) {§effect = new BoostControlledEffect(maxPower, maxPower, Duration.EndOfTurn);§game.addEffect(effect, source);§}§return true;§}§}§
public class RighteousConfluence extends CardImpl {§public RighteousConfluence(UUID ownerId) {§super(ownerId, 7, "Righteous Confluence", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{3}{W}{W}");§this.expansionSetCode = "C15";§this.getSpellAbility().getModes().setMinModes(3);§this.getSpellAbility().getModes().setMaxModes(3);§this.getSpellAbility().getModes().setEachModeMoreThanOnce(true);§this.getSpellAbility().addEffect(new CreateTokenEffect(new KnightToken()));§Mode mode = new Mode();§mode.getEffects().add(new ExileTargetEffect());§mode.getTargets().add(new TargetEnchantmentPermanent());§this.getSpellAbility().getModes().addMode(mode);§mode = new Mode();§mode.getEffects().add(new GainLifeEffect(5));§this.getSpellAbility().getModes().addMode(mode);§}§public RighteousConfluence(final RighteousConfluence card) {§super(card);§}§@Override§public RighteousConfluence copy() {§return new RighteousConfluence(this);§}§}§
public class RiteOfTheRagingStorm extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Creatures named Lightning Rager");§static {§filter.add(new NamePredicate("Lightning Rager"));§}§public RiteOfTheRagingStorm(UUID ownerId) {§super(ownerId, 30, "Rite of the Raging Storm", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{3}{R}{R}");§this.expansionSetCode = "C15";§Effect effect = new CantAttackYouOrPlaneswalkerAllEffect(Duration.WhileOnBattlefield, filter);§effect.setText("Creatures named Lightning Rager can't attack you or planeswalkers you control");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, effect));§this.addAbility(new BeginningOfUpkeepTriggeredAbility(Zone.BATTLEFIELD, new RiteOfTheRagingStormEffect(), TargetController.ANY, false));§}§public RiteOfTheRagingStorm(final RiteOfTheRagingStorm card) {§super(card);§}§@Override§public RiteOfTheRagingStorm copy() {§return new RiteOfTheRagingStorm(this);§}§}§class RiteOfTheRagingStormEffect extends OneShotEffect {§private static final String effectText = "that player puts a 5/1 red Elemental creature token named Lightning Rager onto the battlefield. "§+ "It has trample, haste, and \"At the beginning of the end step, sacrifice this creature.\"";§RiteOfTheRagingStormEffect() {§super(Outcome.Sacrifice);§staticText = effectText;§}§RiteOfTheRagingStormEffect(RiteOfTheRagingStormEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(targetPointer.getFirst(game, source));§if (player != null) {§Token lightningRagerToken = new LightningRagerToken();§lightningRagerToken.putOntoBattlefield(1, game, this.getId(), player.getId());§}§return false;§}§@Override§public RiteOfTheRagingStormEffect copy() {§return new RiteOfTheRagingStormEffect(this);§}§}§class LightningRagerToken extends Token {§LightningRagerToken() {§super("Lightning Rager", "5/1 red Elemental creature token named Lightning Rager onto the battlefield."§+ "It has trample, haste, and \"At the beginning of the end step, sacrifice this creature.\"");§this.setOriginalExpansionSetCode("C15");§cardType.add(CardType.CREATURE);§color.setRed(true);§subtype.add("Elemental");§power = new MageInt(5);§toughness = new MageInt(1);§addAbility(TrampleAbility.getInstance());§addAbility(HasteAbility.getInstance());§this.addAbility(new BeginningOfEndStepTriggeredAbility(new SacrificeSourceEffect(), TargetController.NEXT, false));§}§}§
public class SandstoneOracle extends CardImpl {§public SandstoneOracle(UUID ownerId) {§super(ownerId, 52, "Sandstone Oracle", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{7}");§this.expansionSetCode = "C15";§this.subtype.add("Sphinx");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new EntersBattlefieldTriggeredAbility(new SandstoneOracleEffect()));§}§public SandstoneOracle(final SandstoneOracle card) {§super(card);§}§@Override§public SandstoneOracle copy() {§return new SandstoneOracle(this);§}§}§class SandstoneOracleEffect extends OneShotEffect {§SandstoneOracleEffect() {§super(Outcome.DrawCard);§this.staticText = "choose an opponent. If that player has more cards in hand than you, draw cards equal to the difference";§}§SandstoneOracleEffect(final SandstoneOracleEffect effect) {§super(effect);§}§@Override§public SandstoneOracleEffect copy() {§return new SandstoneOracleEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§MageObject sourceObject = source.getSourceObject(game);§if (controller != null && sourceObject != null) {§TargetOpponent target = new TargetOpponent(true);§if (controller.choose(Outcome.DrawCard, target, source.getSourceId(), game)) {§Player opponent = game.getPlayer(target.getFirstTarget());§if (opponent != null) {§game.informPlayers(sourceObject.getLogName() + ": " + controller.getLogName() + " has chosen " + opponent.getLogName());§int cardsDiff = opponent.getHand().size() - controller.getHand().size();§if (cardsDiff > 0) {§controller.drawCards(cardsDiff, game);§}§}§}§return true;§}§return false;§}§}§
public class ScourgeOfNelToth extends CardImpl {§public ScourgeOfNelToth(UUID ownerId) {§super(ownerId, 21, "Scourge of Nel Toth", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}{B}{B}");§this.expansionSetCode = "C15";§this.subtype.add("Zombie");§this.subtype.add("Dragon");§this.power = new MageInt(6);§this.toughness = new MageInt(6);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new SimpleStaticAbility(Zone.ALL, new ScourgeOfNelTothPlayEffect()));§}§public ScourgeOfNelToth(final ScourgeOfNelToth card) {§super(card);§}§@Override§public ScourgeOfNelToth copy() {§return new ScourgeOfNelToth(this);§}§}§class ScourgeOfNelTothPlayEffect extends AsThoughEffectImpl {§public ScourgeOfNelTothPlayEffect() {§super(AsThoughEffectType.PLAY_FROM_NOT_OWN_HAND_ZONE, Duration.EndOfGame, Outcome.Benefit);§staticText = "You may cast {this} from your graveyard by paying {B}{B} and sacrificing two creatures rather than paying its mana cost";§}§public ScourgeOfNelTothPlayEffect(final ScourgeOfNelTothPlayEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public ScourgeOfNelTothPlayEffect copy() {§return new ScourgeOfNelTothPlayEffect(this);§}§@Override§public boolean applies(UUID sourceId, Ability source, UUID affectedControllerId, Game game) {§if (sourceId.equals(source.getSourceId()) && source.getControllerId().equals(affectedControllerId)) {§if (game.getState().getZone(source.getSourceId()) == Zone.GRAVEYARD) {§Player player = game.getPlayer(affectedControllerId);§if (player != null) {§Costs<Cost> costs = new CostsImpl<>();§costs.add(new SacrificeTargetCost(new TargetControlledCreaturePermanent(2)));§player.setCastSourceIdWithAlternateMana(sourceId, new ManaCostsImpl<>("{B}{B}"), costs);§return true;§}§}§}§return false;§}§}§
public class Scytheclaw extends CardImpl {§public Scytheclaw(UUID ownerId) {§super(ownerId, 53, "Scytheclaw", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{5}");§this.expansionSetCode = "C15";§this.subtype.add("Equipment");§this.addAbility(new LivingWeaponAbility());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEquippedEffect(1, 1)));§this.addAbility(new ScytheclawTriggeredAbility());§this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(3)));§}§public Scytheclaw(final Scytheclaw card) {§super(card);§}§@Override§public Scytheclaw copy() {§return new Scytheclaw(this);§}§}§class ScytheclawTriggeredAbility extends TriggeredAbilityImpl {§public ScytheclawTriggeredAbility() {§super(Zone.BATTLEFIELD, new ScytheclawEffect());§}§public ScytheclawTriggeredAbility(final ScytheclawTriggeredAbility ability) {§super(ability);§}§@Override§public ScytheclawTriggeredAbility copy() {§return new ScytheclawTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.DAMAGED_PLAYER;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§DamagedPlayerEvent damageEvent = (DamagedPlayerEvent) event;§Permanent p = game.getPermanent(event.getSourceId());§if (damageEvent.isCombatDamage() && p != null && p.getAttachments().contains(this.getSourceId())) {§for (Effect effect : this.getEffects()) {§effect.setTargetPointer(new FixedTarget(event.getPlayerId()));§}§return true;§}§return false;§}§@Override§public String getRule() {§return "Whenever equipped creature deals combat damage to a player, " + super.getRule();§}§}§class ScytheclawEffect extends OneShotEffect {§public ScytheclawEffect() {§super(Outcome.Damage);§this.staticText = "that player loses half his or her life, rounded up";§}§public ScytheclawEffect(final ScytheclawEffect effect) {§super(effect);§}§@Override§public ScytheclawEffect copy() {§return new ScytheclawEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(getTargetPointer().getFirst(game, source));§if (player != null) {§Integer amount = (int) Math.ceil(player.getLife() / 2f);§if (amount > 0) {§player.loseLife(amount, game);§}§return true;§}§return false;§}§}§
public class SealOfTheGuildpact extends CardImpl {§public SealOfTheGuildpact(UUID ownerId) {§super(ownerId, 54, "Seal of the Guildpact", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{5}");§this.expansionSetCode = "C15";§this.addAbility(new EntersBattlefieldAbility(new SealOfTheGuildpactChooseColorEffect()));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new SealOfTheGuildpactCostReductionEffect()));§}§public SealOfTheGuildpact(final SealOfTheGuildpact card) {§super(card);§}§@Override§public SealOfTheGuildpact copy() {§return new SealOfTheGuildpact(this);§}§}§class SealOfTheGuildpactChooseColorEffect extends OneShotEffect {§SealOfTheGuildpactChooseColorEffect() {§super(Outcome.Benefit);§this.staticText = "choose two colors";§}§SealOfTheGuildpactChooseColorEffect(final SealOfTheGuildpactChooseColorEffect effect) {§super(effect);§}§@Override§public SealOfTheGuildpactChooseColorEffect copy() {§return new SealOfTheGuildpactChooseColorEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§MageObject mageObject = game.getPermanentEntering(source.getSourceId());§if (controller != null && mageObject != null) {§ChoiceColor choice1 = new ChoiceColor();§while (!choice1.isChosen()) {§controller.choose(Outcome.Benefit, choice1, game);§if (!controller.canRespond()) {§return false;§}§}§String color1 = choice1.getChoice();§Set<String> choices2 = new HashSet<>();§if (!color1.equals("White")) {§choices2.add("White");§}§if (!color1.equals("Blue")) {§choices2.add("Blue");§}§if (!color1.equals("Black")) {§choices2.add("Black");§}§if (!color1.equals("Red")) {§choices2.add("Red");§}§if (!color1.equals("Green")) {§choices2.add("Green");§}§ChoiceColor choice2 = new ChoiceColor();§choice2.setChoices(choices2);§while (!choice2.isChosen()) {§controller.choose(Outcome.Benefit, choice2, game);§if (!controller.canRespond()) {§return false;§}§}§String color2 = choice2.getChoice();§if (!game.isSimulation()) {§game.informPlayers(mageObject.getLogName() + ": " + controller.getLogName() + " has chosen " + color1 + " and " + color2 + ".");§}§game.getState().setValue(mageObject.getId() + "_color1", choice1.getColor());§game.getState().setValue(mageObject.getId() + "_color2", choice2.getColor());§((Card) mageObject).addInfo("chosen colors", CardUtil.addToolTipMarkTags("Chosen colors: " + color1 + " and " + color2), game);§return true;§}§return false;§}§}§class SealOfTheGuildpactCostReductionEffect extends CostModificationEffectImpl {§SealOfTheGuildpactCostReductionEffect() {§super(Duration.WhileOnBattlefield, Outcome.Benefit, CostModificationType.REDUCE_COST);§staticText = "Each spell you cast costs {1} less to cast for each of the chosen colors it is";§}§SealOfTheGuildpactCostReductionEffect(SealOfTheGuildpactCostReductionEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source, Ability abilityToModify) {§MageObject sourceObject = game.getObject(abilityToModify.getSourceId());§if (sourceObject != null) {§ObjectColor color1 = (ObjectColor) game.getState().getValue(source.getSourceId() + "_color1");§ObjectColor color2 = (ObjectColor) game.getState().getValue(source.getSourceId() + "_color2");§int amount = 0;§if (color1 != null && sourceObject.getColor(game).contains(color1)) {§amount++;§}§if (color2 != null && sourceObject.getColor(game).contains(color2)) {§amount++;§}§if (amount > 0) {§SpellAbility spellAbility = (SpellAbility) abilityToModify;§CardUtil.adjustCost(spellAbility, amount);§}§return true;§}§return false;§}§@Override§public boolean applies(Ability abilityToModify, Ability source, Game game) {§return abilityToModify.getControllerId().equals(source.getControllerId()) &&§abilityToModify instanceof SpellAbility;§}§@Override§public SealOfTheGuildpactCostReductionEffect copy() {§return new SealOfTheGuildpactCostReductionEffect(this);§}§}§
public class ShieldedByFaith extends CardImpl {§public ShieldedByFaith(UUID ownerId) {§super(ownerId, 8, "Shielded by Faith", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{1}{W}{W}");§this.expansionSetCode = "C15";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.Benefit));§this.addAbility(new EnchantAbility(auraTarget.getTargetName()));§Effect effect = new GainAbilityAttachedEffect(IndestructibleAbility.getInstance(), AttachmentType.AURA, Duration.WhileOnBattlefield);§effect.setText("Enchanted creature has indestructible");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, effect));§this.addAbility(new EntersBattlefieldAllTriggeredAbility(§Zone.BATTLEFIELD, new AttachEffect(Outcome.Neutral, "attach {source} to that creature"),§new FilterCreaturePermanent("a creature"), true, SetTargetPointer.PERMANENT, null, false));§}§public ShieldedByFaith(final ShieldedByFaith card) {§super(card);§}§@Override§public ShieldedByFaith copy() {§return new ShieldedByFaith(this);§}§}§
public class Skullwinder extends CardImpl {§public Skullwinder(UUID ownerId) {§super(ownerId, 39, "Skullwinder", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{G}");§this.expansionSetCode = "C15";§this.subtype.add("Snake");§this.power = new MageInt(1);§this.toughness = new MageInt(3);§this.addAbility(DeathtouchAbility.getInstance());§Ability ability = new EntersBattlefieldTriggeredAbility(new ReturnFromGraveyardToHandTargetEffect());§ability.addTarget(new TargetCardInYourGraveyard());§ability.addEffect(new SkullwinderEffect());§this.addAbility(ability);§}§public Skullwinder(final Skullwinder card) {§super(card);§}§@Override§public Skullwinder copy() {§return new Skullwinder(this);§}§}§class SkullwinderEffect extends OneShotEffect {§public SkullwinderEffect() {§super(Outcome.Benefit);§this.staticText = ", then choose an opponent. That player returns a card from his or her graveyard to his or her hand";§}§public SkullwinderEffect(final SkullwinderEffect effect) {§super(effect);§}§@Override§public SkullwinderEffect copy() {§return new SkullwinderEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§MageObject sourceObject = source.getSourceObject(game);§if (controller != null && sourceObject != null) {§TargetOpponent targetOpponent = new TargetOpponent(true);§if (controller.choose(Outcome.Detriment, targetOpponent, source.getSourceId(), game)) {§Player opponent = game.getPlayer(targetOpponent.getFirstTarget());§if (opponent != null) {§game.informPlayers(sourceObject.getLogName() + ": " + controller.getLogName() + " has chosen " + opponent.getLogName());§TargetCardInYourGraveyard targetCard = new TargetCardInYourGraveyard(new FilterCard("a card from your graveyard to return to your hand"));§targetCard.setNotTarget(true);§if (opponent.choose(outcome, targetCard, source.getSourceId(), game)) {§Card card = game.getCard(targetCard.getFirstTarget());§if (card != null) {§opponent.moveCards(card, Zone.HAND, source, game);§}§}§}§}§return true;§}§return false;§}§}§
public class SyntheticDestiny extends CardImpl {§public SyntheticDestiny(UUID ownerId) {§super(ownerId, 15, "Synthetic Destiny", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{4}{U}{U}");§this.expansionSetCode = "C15";§getSpellAbility().addEffect(new SyntheticDestinyEffect());§}§public SyntheticDestiny(final SyntheticDestiny card) {§super(card);§}§@Override§public SyntheticDestiny copy() {§return new SyntheticDestiny(this);§}§}§class SyntheticDestinyEffect extends OneShotEffect {§public SyntheticDestinyEffect() {§super(Outcome.Detriment);§this.staticText = "Exile all creatures you control. At the beginning of the next end step, reveal cards from the top of your library until you reveal that many creature cards, put all creature cards revealed this way onto the battlefield, then shuffle the rest of the revealed cards into your library";§}§public SyntheticDestinyEffect(final SyntheticDestinyEffect effect) {§super(effect);§}§@Override§public SyntheticDestinyEffect copy() {§return new SyntheticDestinyEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Set<Card> cardsToExile = new HashSet<>();§cardsToExile.addAll(game.getBattlefield().getAllActivePermanents(new FilterCreaturePermanent(), controller.getId(), game));§controller.moveCards(cardsToExile, Zone.EXILED, source, game);§Effect effect = new SyntheticDestinyDelayedEffect(cardsToExile.size());§DelayedTriggeredAbility delayedAbility = new AtTheBeginOfNextEndStepDelayedTriggeredAbility(effect);§delayedAbility.setSourceId(source.getSourceId());§delayedAbility.setControllerId(source.getControllerId());§delayedAbility.setSourceObject(source.getSourceObject(game), game);§game.addDelayedTriggeredAbility(delayedAbility);§return true;§}§return false;§}§}§class SyntheticDestinyDelayedEffect extends OneShotEffect {§protected int numberOfCards;§public SyntheticDestinyDelayedEffect(int numberOfCards) {§super(Outcome.PutCreatureInPlay);§this.numberOfCards = numberOfCards;§this.staticText = "reveal cards from the top of your library until you reveal that many creature cards, put all creature cards revealed this way onto the battlefield, then shuffle the rest of the revealed cards into your library";§}§public SyntheticDestinyDelayedEffect(final SyntheticDestinyDelayedEffect effect) {§super(effect);§this.numberOfCards = effect.numberOfCards;§}§@Override§public SyntheticDestinyDelayedEffect copy() {§return new SyntheticDestinyDelayedEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§MageObject sourceObject = source.getSourceObject(game);§if (controller != null && sourceObject != null) {§Cards revealed = new CardsImpl();§Set<Card> creatureCards = new LinkedHashSet<>();§Cards nonCreatureCards = new CardsImpl();§while (creatureCards.size() < numberOfCards && controller.getLibrary().size() > 0) {§Card card = controller.getLibrary().removeFromTop(game);§revealed.add(card);§if (card.getCardType().contains(CardType.CREATURE)) {§creatureCards.add(card);§} else {§nonCreatureCards.add(card);§}§}§controller.revealCards(sourceObject.getIdName(), revealed, game);§controller.moveCards(creatureCards, Zone.BATTLEFIELD, source, game, false, false, true, null);§controller.putCardsOnTopOfLibrary(nonCreatureCards, game, source, false);§controller.shuffleLibrary(game);§return true;§}§return false;§}§}§
public class ThiefOfBlood extends CardImpl {§public ThiefOfBlood(UUID ownerId) {§super(ownerId, 22, "Thief of Blood", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{B}{B}");§this.expansionSetCode = "C15";§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.subtype.add("Vampire");§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new EntersBattlefieldAbility(new ThiefOfBloodEffect(), null, "As {this} enters the battlefield, remove all counters from all permanents. {this} enters the battlefield with a +1/+1 counter on it for each counter removed this way", null));§}§public ThiefOfBlood(final ThiefOfBlood card) {§super(card);§}§@Override§public ThiefOfBlood copy() {§return new ThiefOfBlood(this);§}§}§class ThiefOfBloodEffect extends OneShotEffect {§private static final FilterPermanent filter = new FilterPermanent("permanent with a counter");§static {§filter.add(new CounterPredicate(null));§}§ThiefOfBloodEffect() {§super(Outcome.BoostCreature);§this.staticText = "remove all counters from all permanents. {this} enters the battlefield with a +1/+1 counter on it for each counter removed this way";§}§ThiefOfBloodEffect(final ThiefOfBloodEffect effect) {§super(effect);§}§@Override§public ThiefOfBloodEffect copy() {§return new ThiefOfBloodEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§int countersRemoved = 0;§for (Permanent permanent : game.getBattlefield().getActivePermanents(filter, source.getControllerId(), game)) {§Counters counters = permanent.getCounters().copy();§for (Counter counter : counters.values()) {§permanent.getCounters().removeCounter(counter.getName(), counter.getCount());§countersRemoved += counter.getCount();§}§}§if (countersRemoved > 0) {§Permanent sourcePermanent = game.getPermanentEntering(source.getSourceId());§if (sourcePermanent != null) {§sourcePermanent.addCounters(CounterType.P1P1.createInstance(countersRemoved), game);§}§}§return true;§}§}§
public class WarchiefGiant extends CardImpl {§public WarchiefGiant(UUID ownerId) {§super(ownerId, 31, "Warchief Giant", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{R}{R}");§this.expansionSetCode = "C15";§this.subtype.add("Giant");§this.subtype.add("Warrior");§this.power = new MageInt(5);§this.toughness = new MageInt(3);§this.addAbility(HasteAbility.getInstance());§this.addAbility(new MyriadAbility());§}§public WarchiefGiant(final WarchiefGiant card) {§super(card);§}§@Override§public WarchiefGiant copy() {§return new WarchiefGiant(this);§}§}§
public class WretchedConfluence extends CardImpl {§public WretchedConfluence(UUID ownerId) {§super(ownerId, 23, "Wretched Confluence", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{3}{B}{B}");§this.expansionSetCode = "C15";§this.getSpellAbility().getModes().setMinModes(3);§this.getSpellAbility().getModes().setMaxModes(3);§this.getSpellAbility().getModes().setEachModeMoreThanOnce(true);§Effect effect = new LoseLifeTargetEffect(1);§effect.setText("and loses 1 life");§this.getSpellAbility().addEffect(new DrawCardTargetEffect(1));§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addTarget(new TargetPlayer());§Mode mode = new Mode();§mode.getEffects().add(new BoostTargetEffect(-2, -2, Duration.EndOfTurn));§mode.getTargets().add(new TargetCreaturePermanent());§this.getSpellAbility().getModes().addMode(mode);§mode = new Mode();§mode.getEffects().add(new ReturnFromGraveyardToHandTargetEffect());§mode.getTargets().add(new TargetCardInYourGraveyard(new FilterCreatureCard("creature card from your graveyard")));§this.getSpellAbility().getModes().addMode(mode);§}§public WretchedConfluence(final WretchedConfluence card) {§super(card);§}§@Override§public WretchedConfluence copy() {§return new WretchedConfluence(this);§}§}§
public class AbsorbVis extends CardImpl {§public AbsorbVis (UUID ownerId) {§super(ownerId, 40, "Absorb Vis", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{6}{B}");§this.expansionSetCode = "CON";§this.getSpellAbility().addEffect(new LoseLifeTargetEffect(4));§this.getSpellAbility().addEffect(new GainLifeEffect(4));§this.getSpellAbility().addTarget(new TargetPlayer());§this.addAbility(new BasicLandcyclingAbility(new ManaCostsImpl("{1}{B}")));§}§public AbsorbVis (final AbsorbVis card) {§super(card);§}§@Override§public AbsorbVis copy() {§return new AbsorbVis(this);§}§}§
public class AerieMystics extends CardImpl {§private static FilterCreaturePermanent filter = new FilterCreaturePermanent("creatures");§public AerieMystics(UUID ownerId) {§super(ownerId, 1, "Aerie Mystics", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{W}");§this.expansionSetCode = "CON";§this.subtype.add("Bird");§this.subtype.add("Wizard");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilityControlledEffect(ShroudAbility.getInstance(), Duration.EndOfTurn, filter), new ManaCostsImpl("{1}{G}{U}")));§}§public AerieMystics(final AerieMystics card) {§super(card);§}§@Override§public AerieMystics copy() {§return new AerieMystics(this);§}§}§
public class AncientZiggurat extends CardImpl {§public AncientZiggurat(UUID ownerId) {§super(ownerId, 141, "Ancient Ziggurat", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "CON";§this.addAbility(new ConditionalAnyColorManaAbility(1, new AncientZigguratManaBuilder()));§}§public AncientZiggurat(final AncientZiggurat card) {§super(card);§}§@Override§public AncientZiggurat copy() {§return new AncientZiggurat(this);§}§}§class AncientZigguratManaBuilder extends ConditionalManaBuilder {§@Override§public ConditionalMana build(Object. options) {§return new CreatureCastConditionalMana(this.mana);§}§@Override§public String getRule() {§return "Spend this mana only to cast a creature spell";§}§}§
public class ApocalypseHydra extends CardImpl {§public ApocalypseHydra(UUID ownerId) {§super(ownerId, 98, "Apocalypse Hydra", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{X}{R}{G}");§this.expansionSetCode = "CON";§this.subtype.add("Hydra");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§this.addAbility(new EntersBattlefieldAbility(new ApocalypseHydraEffect()));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(1), new ManaCostsImpl("{1}{R}"));§ability.addCost(new RemoveCountersSourceCost(CounterType.P1P1.createInstance()));§ability.addTarget(new TargetCreatureOrPlayer());§this.addAbility(ability);§}§public ApocalypseHydra(final ApocalypseHydra card) {§super(card);§}§@Override§public ApocalypseHydra copy() {§return new ApocalypseHydra(this);§}§}§class ApocalypseHydraEffect extends OneShotEffect {§ApocalypseHydraEffect() {§super(Outcome.BoostCreature);§staticText = "with X +1/+1 counters on it. If X is 5 or more, it enters the battlefield with an additional X +1/+1 counters on it";§}§ApocalypseHydraEffect(final ApocalypseHydraEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getPermanentEntering(source.getSourceId());§if (permanent != null) {§SpellAbility spellAbility = (SpellAbility) getValue(EntersBattlefieldEffect.SOURCE_CAST_SPELL_ABILITY);§if (spellAbility != null§&& spellAbility.getSourceId().equals(source.getSourceId())§&& permanent.getZoneChangeCounter(game) == spellAbility.getSourceObjectZoneChangeCounter()) {§int amount = spellAbility.getManaCostsToPay().getX();§if (amount > 0) {§if (amount < 5) {§permanent.addCounters(CounterType.P1P1.createInstance(amount), game);§} else {§permanent.addCounters(CounterType.P1P1.createInstance(amount * 2), game);§}§}§}§return true;§}§return true;§}§@Override§public ApocalypseHydraEffect copy() {§return new ApocalypseHydraEffect(this);§}§}§
public class ArmillarySphere extends CardImpl {§public ArmillarySphere(UUID ownerId) {§super(ownerId, 134, "Armillary Sphere", Rarity.COMMON, new CardType[]{CardType.ARTIFACT}, "{2}");§this.expansionSetCode = "CON";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,§new SearchLibraryPutInHandEffect(new TargetCardInLibrary(0, 2, new FilterBasicLandCard()), true),§new GenericManaCost(2));§ability.addCost(new TapSourceCost());§ability.addCost(new SacrificeSourceCost());§this.addAbility(ability);§}§public ArmillarySphere(final ArmillarySphere card) {§super(card);§}§@Override§public ArmillarySphere copy() {§return new ArmillarySphere(this);§}§}§
public class AshasFavor extends CardImpl {§public AshasFavor (UUID ownerId) {§super(ownerId, 2, "Asha's Favor", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{W}");§this.expansionSetCode = "CON";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(FlyingAbility.getInstance(), AttachmentType.AURA)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(FirstStrikeAbility.getInstance(), AttachmentType.AURA)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(VigilanceAbility.getInstance(), AttachmentType.AURA)));§}§public AshasFavor (final AshasFavor card) {§super(card);§}§@Override§public AshasFavor copy() {§return new AshasFavor(this);§}§}§
public class AvenSquire extends CardImpl {§public AvenSquire(UUID ownerId) {§super(ownerId, 3, "Aven Squire", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "CON";§this.subtype.add("Bird");§this.subtype.add("Soldier");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new ExaltedAbility());§}§public AvenSquire(final AvenSquire card) {§super(card);§}§@Override§public AvenSquire copy() {§return new AvenSquire(this);§}§}§
public class AvenTrailblazer extends CardImpl {§public AvenTrailblazer(UUID ownerId) {§super(ownerId, 4, "Aven Trailblazer", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "CON";§this.subtype.add("Bird");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(0);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new SimpleStaticAbility(Zone.ALL, new SetToughnessSourceEffect(new DomainValue(), Duration.EndOfGame)));§}§public AvenTrailblazer(final AvenTrailblazer card) {§super(card);§}§@Override§public AvenTrailblazer copy() {§return new AvenTrailblazer(this);§}§}§
public class Banefire extends CardImpl {§public Banefire(UUID ownerId) {§super(ownerId, 58, "Banefire", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{X}{R}");§this.expansionSetCode = "CON";§this.getSpellAbility().addEffect(new BaneFireEffect());§this.getSpellAbility().addTarget(new TargetCreatureOrPlayer());§this.addAbility(new SimpleStaticAbility(Zone.STACK, new BanefireCantCounterEffect()));§}§public Banefire(final Banefire card) {§super(card);§}§@Override§public Banefire copy() {§return new Banefire(this);§}§}§class testCondition implements Condition {§private DynamicValue xValue;§private int limit;§public testCondition(DynamicValue xValue, int limit) {§this.xValue = xValue;§this.limit = limit;§}§@Override§public boolean apply(Game game, Ability source) {§Spell spell = (Spell) game.getStack().getStackObject(source.getSourceId());§if (spell != null) {§return (xValue.calculate(game, spell.getSpellAbility(), null) >= limit);§}§return false;§}§}§class BaneFireEffect extends OneShotEffect {§public BaneFireEffect() {§super(Outcome.Damage);§staticText = "{this} deals X damage to target creature or player";§}§public BaneFireEffect(final BaneFireEffect effect) {§super(effect);§}§@Override§public BaneFireEffect copy() {§return new BaneFireEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player targetPlayer = game.getPlayer(source.getFirstTarget());§Permanent targetCreature = game.getPermanent(source.getFirstTarget());§int damage = source.getManaCostsToPay().getX();§boolean preventable = damage < 5;§if (targetPlayer != null) {§targetPlayer.damage(damage, source.getSourceId(), game, false, preventable);§return true;§}§if (targetCreature != null) {§targetCreature.damage(damage, source.getSourceId(), game, false, preventable);§return true;§}§return false;§}§}§class BanefireCantCounterEffect extends ContinuousRuleModifyingEffectImpl {§Condition condition = new testCondition(new ManacostVariableValue(), 5);§public BanefireCantCounterEffect() {§super(Duration.WhileOnStack, Outcome.Benefit);§staticText = "If X is 5 or more, {this} can't be countered by spells or abilities and the damage can't be prevented";§}§public BanefireCantCounterEffect(final BanefireCantCounterEffect effect) {§super(effect);§this.condition = effect.condition;§}§@Override§public BanefireCantCounterEffect copy() {§return new BanefireCantCounterEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§if (event.getType() == EventType.COUNTER) {§Card card = game.getCard(source.getSourceId());§if (card != null) {§UUID spellId = card.getSpellAbility().getId();§if (event.getTargetId().equals(spellId)) {§if (condition.apply(game, source)) {§return true;§}§}§}§}§return false;§}§}§
public class BeaconBehemoth extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature with power 5 or greater");§static {§filter.add(new PowerPredicate(ComparisonType.GreaterThan, 4));§}§public BeaconBehemoth (UUID ownerId) {§super(ownerId, 78, "Beacon Behemoth", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{G}{G}");§this.expansionSetCode = "CON";§this.subtype.add("Beast");§this.power = new MageInt(5);§this.toughness = new MageInt(3);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilityTargetEffect(VigilanceAbility.getInstance(), Duration.EndOfTurn), new ManaCostsImpl("{1}"));§ability.addTarget(new TargetCreaturePermanent(filter));§this.addAbility(ability);§}§public BeaconBehemoth (final BeaconBehemoth card) {§super(card);§}§@Override§public BeaconBehemoth copy() {§return new BeaconBehemoth(this);§}§}§
public class BloodhallOoze extends CardImpl {§public BloodhallOoze(UUID ownerId) {§super(ownerId, 59, "Bloodhall Ooze", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{R}");§this.expansionSetCode = "CON";§this.subtype.add("Ooze");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new BloodhallOozeTriggeredAbility1());§this.addAbility(new BloodhallOozeTriggeredAbility2());§}§public BloodhallOoze(final BloodhallOoze card) {§super(card);§}§@Override§public BloodhallOoze copy() {§return new BloodhallOoze(this);§}§}§class BloodhallOozeTriggeredAbility1 extends TriggeredAbilityImpl {§private static final FilterPermanent filter = new FilterPermanent();§static {§filter.add(new ColorPredicate(ObjectColor.BLACK));§}§public BloodhallOozeTriggeredAbility1() {§super(Zone.BATTLEFIELD, new AddCountersSourceEffect(CounterType.P1P1.createInstance()), true);§}§public BloodhallOozeTriggeredAbility1(final BloodhallOozeTriggeredAbility1 ability) {§super(ability);§}§@Override§public BloodhallOozeTriggeredAbility1 copy() {§return new BloodhallOozeTriggeredAbility1(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.UPKEEP_STEP_PRE;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (event.getPlayerId().equals(this.controllerId)) {§return true;§}§return false;§}§@Override§public boolean checkInterveningIfClause(Game game) {§return game.getBattlefield().countAll(filter, this.controllerId, game) >= 1;§}§@Override§public String getRule() {§return "At the beginning of your upkeep, if you control a black permanent, you may put a +1/+1 counter on {this}.";§}§}§class BloodhallOozeTriggeredAbility2 extends TriggeredAbilityImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent();§static {§filter.add(new ColorPredicate(ObjectColor.GREEN));§}§public BloodhallOozeTriggeredAbility2() {§super(Zone.BATTLEFIELD, new AddCountersSourceEffect(CounterType.P1P1.createInstance()), true);§}§public BloodhallOozeTriggeredAbility2(final BloodhallOozeTriggeredAbility2 ability) {§super(ability);§}§@Override§public BloodhallOozeTriggeredAbility2 copy() {§return new BloodhallOozeTriggeredAbility2(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.UPKEEP_STEP_PRE;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (event.getPlayerId().equals(this.controllerId)) {§return true;§}§return false;§}§@Override§public boolean checkInterveningIfClause(Game game) {§return game.getBattlefield().countAll(filter, this.controllerId, game) >= 1;§}§@Override§public String getRule() {§return "At the beginning of your upkeep, if you control a green permanent, you may put a +1/+1 counter on {this}.";§}§}§
public class BloodTyrant extends CardImpl {§public BloodTyrant(UUID ownerId) {§super(ownerId, 99, "Blood Tyrant", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{U}{B}{R}");§this.expansionSetCode = "CON";§this.subtype.add("Vampire");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(TrampleAbility.getInstance());§this.addAbility(new BeginningOfUpkeepTriggeredAbility(Zone.BATTLEFIELD, new BloodTyrantEffect(), TargetController.YOU, false));§this.addAbility(new PlayerLosesTheGameTriggeredAbility());§}§public BloodTyrant(final BloodTyrant card) {§super(card);§}§@Override§public BloodTyrant copy() {§return new BloodTyrant(this);§}§}§class PlayerLosesTheGameTriggeredAbility extends TriggeredAbilityImpl {§public PlayerLosesTheGameTriggeredAbility() {§super(Zone.BATTLEFIELD, new AddCountersSourceEffect(CounterType.P1P1.createInstance(5)), false);§}§public PlayerLosesTheGameTriggeredAbility(final PlayerLosesTheGameTriggeredAbility ability) {§super(ability);§}§@Override§public PlayerLosesTheGameTriggeredAbility copy() {§return new PlayerLosesTheGameTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.LOSES;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§return true;§}§@Override§public String getRule() {§return "Whenever a player loses the game, put five +1/+1 counters on {this}.";§}§}§class BloodTyrantEffect extends OneShotEffect {§public BloodTyrantEffect() {§super(Outcome.Benefit);§staticText = "each player loses 1 life. Put a +1/+1 counter on {this} for each 1 life lost this way";§}§public BloodTyrantEffect(final BloodTyrantEffect effect) {§super(effect);§}§@Override§public BloodTyrantEffect copy() {§return new BloodTyrantEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§int counters = 0;§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§for (UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {§Player player = game.getPlayer(playerId);§if (player != null) {§if (player.loseLife(1, game) > 0) {§counters++;§}§}§}§Permanent bloodTyrant = game.getPermanent(source.getSourceId());§if (bloodTyrant != null && counters > 0) {§bloodTyrant.addCounters(CounterType.P1P1.createInstance(counters), game);§}§return true;§}§return false;§}§}§
public class BoneSaw extends CardImpl {§public BoneSaw(UUID ownerId) {§super(ownerId, 135, "Bone Saw", Rarity.COMMON, new CardType[]{CardType.ARTIFACT}, "{0}");§this.expansionSetCode = "CON";§this.subtype.add("Equipment");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEquippedEffect(1, 0)));§this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(1)));§}§public BoneSaw(final BoneSaw card) {§super(card);§}§@Override§public BoneSaw copy() {§return new BoneSaw(this);§}§}§
public class BrackwaterElemental extends CardImpl {§public BrackwaterElemental(UUID ownerId) {§super(ownerId, 21, "Brackwater Elemental", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{U}");§this.expansionSetCode = "CON";§this.subtype.add("Elemental");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(new AttacksOrBlocksTriggeredAbility(new BrackwaterElementalSacrificeEffect(), false));§this.addAbility(new UnearthAbility(new ManaCostsImpl("{2}{U}")));§}§public BrackwaterElemental(final BrackwaterElemental card) {§super(card);§}§@Override§public BrackwaterElemental copy() {§return new BrackwaterElemental(this);§}§}§class BrackwaterElementalSacrificeEffect extends OneShotEffect {§public BrackwaterElementalSacrificeEffect() {§super(Outcome.Sacrifice);§this.staticText = "sacrifice it at the beginning of the next end step";§}§public BrackwaterElementalSacrificeEffect(final BrackwaterElementalSacrificeEffect effect) {§super(effect);§}§@Override§public BrackwaterElementalSacrificeEffect copy() {§return new BrackwaterElementalSacrificeEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent sourcePermanent = game.getPermanent(source.getSourceId());§if (sourcePermanent != null) {§SacrificeTargetEffect sacrificeEffect = new SacrificeTargetEffect("sacrifice {this}");§sacrificeEffect.setTargetPointer(new FixedTarget(sourcePermanent.getId()));§DelayedTriggeredAbility delayedAbility = new AtTheBeginOfNextEndStepDelayedTriggeredAbility(sacrificeEffect);§delayedAbility.setSourceId(source.getSourceId());§delayedAbility.setControllerId(source.getControllerId());§delayedAbility.setSourceObject(source.getSourceObject(game), game);§game.addDelayedTriggeredAbility(delayedAbility);§}§return false;§}§}§
public class CanyonMinotaur extends CardImpl {§public CanyonMinotaur(UUID ownerId) {§super(ownerId, 60, "Canyon Minotaur", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{R}");§this.expansionSetCode = "CON";§this.subtype.add("Minotaur");§this.subtype.add("Warrior");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§}§public CanyonMinotaur(final CanyonMinotaur card) {§super(card);§}§@Override§public CanyonMinotaur copy() {§return new CanyonMinotaur(this);§}§}§
public class CelestialPurge extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("black or red permanent");§static {§filter.add(Predicates.or(§new ColorPredicate(ObjectColor.BLACK),§new ColorPredicate(ObjectColor.RED)));§}§public CelestialPurge(UUID ownerId) {§super(ownerId, 5, "Celestial Purge", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{1}{W}");§this.expansionSetCode = "CON";§this.getSpellAbility().addTarget(new TargetPermanent(filter));§this.getSpellAbility().addEffect(new ExileTargetEffect());§}§public CelestialPurge(final CelestialPurge card) {§super(card);§}§@Override§public CelestialPurge copy() {§return new CelestialPurge(this);§}§}§
public class CliffrunnerBehemoth extends CardImpl {§private static final FilterPermanent redPermanentFilter = new FilterPermanent("red");§private static final FilterPermanent whitePermanentFilter = new FilterPermanent("white");§static {§redPermanentFilter.add(new ColorPredicate(ObjectColor.RED));§whitePermanentFilter.add(new ColorPredicate(ObjectColor.WHITE));§}§public CliffrunnerBehemoth(UUID ownerId) {§super(ownerId, 79, "Cliffrunner Behemoth", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{G}");§this.expansionSetCode = "CON";§this.subtype.add("Rhino");§this.subtype.add("Beast");§this.power = new MageInt(5);§this.toughness = new MageInt(3);§this.addAbility(new SimpleStaticAbility(§Zone.BATTLEFIELD,§new ConditionalContinuousEffect(§new GainAbilitySourceEffect(HasteAbility.getInstance(), Duration.WhileOnBattlefield),§new PermanentsOnTheBattlefieldCondition(redPermanentFilter), "{this} has haste as long as you control a red permanent")));§this.addAbility(new SimpleStaticAbility(§Zone.BATTLEFIELD,§new ConditionalContinuousEffect(§new GainAbilitySourceEffect(LifelinkAbility.getInstance(), Duration.WhileOnBattlefield),§new PermanentsOnTheBattlefieldCondition(whitePermanentFilter), "{this} has lifelink as long as you control a white permanent")));§}§public CliffrunnerBehemoth(final CliffrunnerBehemoth card) {§super(card);§}§@Override§public CliffrunnerBehemoth copy() {§return new CliffrunnerBehemoth(this);§}§}§
public class Conflux extends CardImpl {§public Conflux(UUID ownerId) {§super(ownerId, 102, "Conflux", Rarity.MYTHIC, new CardType[]{CardType.SORCERY}, "{3}{W}{U}{B}{R}{G}");§this.expansionSetCode = "CON";§this.getSpellAbility().addEffect(new ConfluxEffect());§}§public Conflux(final Conflux card) {§super(card);§}§@Override§public Conflux copy() {§return new Conflux(this);§}§}§class ConfluxEffect extends OneShotEffect {§public ConfluxEffect() {§super(Outcome.DrawCard);§this.staticText = "Search your library for a white card, a blue card, a black card, a red card, and a green card. Reveal those cards and put them into your hand. Then shuffle your library";§}§public ConfluxEffect(final ConfluxEffect effect) {§super(effect);§}§@Override§public ConfluxEffect copy() {§return new ConfluxEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player you = game.getPlayer(source.getControllerId());§Cards cards = new CardsImpl();§FilterCard filterWhite = new FilterCard("white card");§filterWhite.add(new ColorPredicate(ObjectColor.WHITE));§FilterCard filterBlue = new FilterCard("blue card");§filterBlue.add(new ColorPredicate(ObjectColor.BLUE));§FilterCard filterBlack = new FilterCard("black card");§filterBlack.add(new ColorPredicate(ObjectColor.BLACK));§FilterCard filterRed = new FilterCard("red card");§filterRed.add(new ColorPredicate(ObjectColor.RED));§FilterCard filterGreen = new FilterCard("green card");§filterGreen.add(new ColorPredicate(ObjectColor.GREEN));§TargetCardInLibrary targetWhite = new TargetCardInLibrary(filterWhite);§TargetCardInLibrary targetBlue = new TargetCardInLibrary(filterBlue);§TargetCardInLibrary targetBlack = new TargetCardInLibrary(filterBlack);§TargetCardInLibrary targetRed = new TargetCardInLibrary(filterRed);§TargetCardInLibrary targetGreen = new TargetCardInLibrary(filterGreen);§if (you != null && you.getLibrary().size() > 0) {§if (you.searchLibrary(targetWhite, game)) {§if (targetWhite.getTargets().size() > 0) {§for (UUID cardId : (List<UUID>) targetWhite.getTargets()) {§Card card = you.getLibrary().remove(cardId, game);§if (card != null) {§cards.add(card);§}§}§}§}§}§if (you != null && you.getLibrary().size() > 0) {§if (you.searchLibrary(targetBlue, game)) {§if (targetBlue.getTargets().size() > 0) {§for (UUID cardId : (List<UUID>) targetBlue.getTargets()) {§Card card = you.getLibrary().remove(cardId, game);§if (card != null) {§cards.add(card);§}§}§}§}§}§if (you != null && you.getLibrary().size() > 0) {§if (you.searchLibrary(targetBlack, game)) {§if (targetBlack.getTargets().size() > 0) {§for (UUID cardId : (List<UUID>) targetBlack.getTargets()) {§Card card = you.getLibrary().remove(cardId, game);§if (card != null) {§cards.add(card);§}§}§}§}§}§if (you != null && you.getLibrary().size() > 0) {§if (you.searchLibrary(targetRed, game)) {§if (targetRed.getTargets().size() > 0) {§for (UUID cardId : (List<UUID>) targetRed.getTargets()) {§Card card = you.getLibrary().remove(cardId, game);§if (card != null) {§cards.add(card);§}§}§}§}§}§if (you != null && you.getLibrary().size() > 0) {§if (you.searchLibrary(targetGreen, game)) {§if (targetGreen.getTargets().size() > 0) {§for (UUID cardId : (List<UUID>) targetGreen.getTargets()) {§Card card = you.getLibrary().remove(cardId, game);§if (card != null) {§cards.add(card);§}§}§}§}§}§if (you != null) {§you.revealCards("Conflux", cards, game);§for (Card card : cards.getCards(game)) {§card.moveToZone(Zone.HAND, source.getSourceId(), game, true);§}§you.shuffleLibrary(game);§}§return true;§}§}§
public class ConstrictingTendrils extends CardImpl {§public ConstrictingTendrils(UUID ownerId) {§super(ownerId, 22, "Constricting Tendrils", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{U}");§this.expansionSetCode = "CON";§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.getSpellAbility().addEffect(new BoostTargetEffect(-3, 0, Duration.EndOfTurn));§this.addAbility(new CyclingAbility(new ManaCostsImpl("{2}")));§}§public ConstrictingTendrils(final ConstrictingTendrils card) {§super(card);§}§@Override§public ConstrictingTendrils copy() {§return new ConstrictingTendrils(this);§}§}§
public class ControlledInstincts extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("red or green creature");§static {§filter.add(Predicates.or(§new ColorPredicate(ObjectColor.RED),§new ColorPredicate(ObjectColor.GREEN)));§}§public ControlledInstincts(UUID ownerId) {§super(ownerId, 23, "Controlled Instincts", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{U}");§this.expansionSetCode = "CON";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent(filter);§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.Detriment));§this.addAbility(new EnchantAbility(auraTarget.getTargetName()));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new DontUntapInControllersUntapStepEnchantedEffect()));§}§public ControlledInstincts(final ControlledInstincts card) {§super(card);§}§@Override§public ControlledInstincts copy() {§return new ControlledInstincts(this);§}§}§
public class CorruptedRoots extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("Forest or Plains");§static {§filter.add(Predicates.or(§new SubtypePredicate("Forest"),§new SubtypePredicate("Plains")));§}§public CorruptedRoots(UUID ownerId) {§super(ownerId, 41, "Corrupted Roots", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{B}");§this.expansionSetCode = "CON";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetPermanent(filter);§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.Detriment));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new BecomesTappedAttachedTriggeredAbility(new LoseLifeControllerAttachedEffect(2), "enchanted land"));§}§public CorruptedRoots(final CorruptedRoots card) {§super(card);§}§@Override§public CorruptedRoots copy() {§return new CorruptedRoots(this);§}§}§
public class Countersquall extends CardImpl {§private static final FilterSpell filter = new FilterSpell("noncreature spell");§static {§filter.add(Predicates.not(new CardTypePredicate(CardType.CREATURE)));§}§public Countersquall(UUID ownerId) {§super(ownerId, 103, "Countersquall", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{U}{B}");§this.expansionSetCode = "CON";§this.getSpellAbility().addTarget(new TargetSpell(filter));§this.getSpellAbility().addEffect(new CounterTargetEffect());§this.getSpellAbility().addEffect(new LoseLifeTargetControllerEffect(2));§}§public Countersquall(final Countersquall card) {§super(card);§}§@Override§public Countersquall copy() {§return new Countersquall(this);§}§}§
public class CourtHomunculus extends CardImpl {§public CourtHomunculus(UUID ownerId) {§super(ownerId, 6, "Court Homunculus", Rarity.COMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{W}");§this.expansionSetCode = "CON";§this.subtype.add("Homunculus");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD,§new ConditionalContinuousEffect(new BoostSourceEffect(1, 1, Duration.WhileOnBattlefield),§new ControlsAnotherArtifactCondition(), "{this} gets +1/+1 as long as you control another artifact")));§}§public CourtHomunculus(final CourtHomunculus card) {§super(card);§}§@Override§public CourtHomunculus copy() {§return new CourtHomunculus(this);§}§}§class ControlsAnotherArtifactCondition implements Condition {§@Override§public boolean apply(Game game, Ability source) {§List<Permanent> controlledArtifacts = game.getBattlefield().getAllActivePermanents(new FilterArtifactPermanent(), source.getControllerId(), game);§for (Permanent permanent : controlledArtifacts) {§if (!permanent.getId().equals(game.getObject(source.getSourceId()).getId())) {§return true;§}§}§return false;§}§}§
public class CumberStone extends CardImpl {§public CumberStone(UUID ownerId) {§super(ownerId, 24, "Cumber Stone", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{3}{U}");§this.expansionSetCode = "CON";§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostOpponentsEffect(-1, 0, Duration.WhileOnBattlefield)));§}§public CumberStone(final CumberStone card) {§super(card);§}§@Override§public CumberStone copy() {§return new CumberStone(this);§}§}§
public class CylianSunsinger extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Cylian Sunsinger and each other creature with the same name");§static {§filter.add(new NamePredicate("Cylian Sunsinger"));§}§public CylianSunsinger(UUID ownerId) {§super(ownerId, 80, "Cylian Sunsinger", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "CON";§this.subtype.add("Elf");§this.subtype.add("Shaman");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostAllEffect(3, 3, Duration.EndOfTurn, filter, false), new ManaCostsImpl("{R}{G}{W}")));§}§public CylianSunsinger(final CylianSunsinger card) {§super(card);§}§@Override§public CylianSunsinger copy() {§return new CylianSunsinger(this);§}§}§
public class DarklitGargoyle extends CardImpl {§public DarklitGargoyle(UUID ownerId) {§super(ownerId, 7, "Darklit Gargoyle", Rarity.COMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "CON";§this.subtype.add("Gargoyle");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(2, -1, Duration.EndOfTurn), new ManaCostsImpl(("{B}"))));§}§public DarklitGargoyle(final DarklitGargoyle card) {§super(card);§}§@Override§public DarklitGargoyle copy() {§return new DarklitGargoyle(this);§}§}§
public class DarkTemper extends CardImpl {§public DarkTemper(UUID ownerId) {§super(ownerId, 61, "Dark Temper", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{R}");§this.expansionSetCode = "CON";§this.getSpellAbility().addEffect(new DarkTemperEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public DarkTemper(final DarkTemper card) {§super(card);§}§@Override§public DarkTemper copy() {§return new DarkTemper(this);§}§}§class DarkTemperEffect extends OneShotEffect {§public DarkTemperEffect() {§super(Outcome.Damage);§this.staticText = "{this} deals 2 damage to target creature. If you control a black permanent, destroy the creature instead";§}§public DarkTemperEffect(final DarkTemperEffect effect) {§super(effect);§}§@Override§public DarkTemperEffect copy() {§return new DarkTemperEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getPermanent(targetPointer.getFirst(game, source));§if (permanent == null) {§return false;§}§FilterPermanent filter = new FilterPermanent("black permanent");§filter.add(new ColorPredicate(ObjectColor.BLACK));§if (game.getBattlefield().countAll(filter, source.getControllerId(), game) == 0) {§permanent.damage(2, source.getSourceId(), game, false, true);§} else {§permanent.destroy(source.getSourceId(), game, false);§}§return true;§}§}§
public class DragDown extends CardImpl {§public DragDown(UUID ownerId) {§super(ownerId, 42, "Drag Down", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{B}");§this.expansionSetCode = "CON";§this.getSpellAbility().addEffect(new BoostTargetEffect(new DomainValue(-1), new DomainValue(-1), Duration.EndOfTurn, true));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public DragDown(final DragDown card) {§super(card);§}§@Override§public DragDown copy() {§return new DragDown(this);§}§}§
public class DragonsoulKnight extends CardImpl {§public DragonsoulKnight(UUID ownerId) {§super(ownerId, 62, "Dragonsoul Knight", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "CON";§this.subtype.add("Human");§this.subtype.add("Knight");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FirstStrikeAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DragonsoulKnightEffect(), new ManaCostsImpl("{W}{U}{B}{R}{G}"));§Effect effect = new BoostSourceEffect(5, 3, Duration.EndOfTurn);§effect.setText("gets +5/+3");§ability.addEffect(effect);§effect = new GainAbilitySourceEffect(FlyingAbility.getInstance(), Duration.EndOfTurn);§effect.setText("and gains flying");§ability.addEffect(effect);§effect = new GainAbilitySourceEffect(TrampleAbility.getInstance(), Duration.EndOfTurn);§effect.setText("and trample");§ability.addEffect(effect);§this.addAbility(ability);§}§public DragonsoulKnight(final DragonsoulKnight card) {§super(card);§}§@Override§public DragonsoulKnight copy() {§return new DragonsoulKnight(this);§}§private class DragonsoulKnightEffect extends ContinuousEffectImpl {§public DragonsoulKnightEffect() {§super(Duration.EndOfTurn, Outcome.BecomeCreature);§setText();§}§public DragonsoulKnightEffect(final DragonsoulKnightEffect effect) {§super(effect);§}§@Override§public DragonsoulKnightEffect copy() {§return new DragonsoulKnightEffect(this);§}§@Override§public boolean apply(Layer layer, SubLayer sublayer, Ability source, Game game) {§Permanent permanent = game.getPermanent(source.getSourceId());§if (permanent == null) {§return false;§}§switch (layer) {§case TypeChangingEffects_4:§if (sublayer == SubLayer.NA) {§permanent.getSubtype().clear();§permanent.getSubtype().add("Dragon");§}§break;§}§return true;§}§@Override§public boolean apply(Game game, Ability source) {§return false;§}§private void setText() {§staticText = "Until end of turn, {this} becomes a Dragon, ";§}§@Override§public boolean hasLayer(Layer layer) {§return layer == Layer.TypeChangingEffects_4;§}§}§}§
public class Dreadwing extends CardImpl {§public Dreadwing(UUID ownerId) {§super(ownerId, 43, "Dreadwing", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{B}");§this.expansionSetCode = "CON";§this.subtype.add("Zombie");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Effect effect = new BoostSourceEffect(3, 0, Duration.EndOfTurn);§effect.setText("{this} gets +3/+0");§SimpleActivatedAbility ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new ManaCostsImpl(("{1}{U}{R}")));§effect = new GainAbilitySourceEffect(FlyingAbility.getInstance(), Duration.EndOfTurn);§effect.setText("and gains flying until end of turn");§ability.getEffects().add(effect);§this.addAbility(ability);§}§public Dreadwing(final Dreadwing card) {§super(card);§}§@Override§public Dreadwing copy() {§return new Dreadwing(this);§}§}§
public class ElderMastery extends CardImpl {§public ElderMastery(UUID ownerId) {§super(ownerId, 104, "Elder Mastery", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{3}{U}{B}{R}");§this.expansionSetCode = "CON";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(3, 3, Duration.WhileOnBattlefield)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(FlyingAbility.getInstance(), AttachmentType.AURA, Duration.WhileOnBattlefield)));§this.addAbility(new DealsDamageToAPlayerAttachedTriggeredAbility(new DiscardTargetEffect(2), "enchanted", false, true));§}§public ElderMastery(final ElderMastery card) {§super(card);§}§@Override§public ElderMastery copy() {§return new ElderMastery(this);§}§}§
public class EmberWeaver extends CardImpl {§private static final FilterPermanent redPermanentFilter = new FilterPermanent("red");§static {§redPermanentFilter.add(new ColorPredicate(ObjectColor.RED));§}§public EmberWeaver(UUID ownerId) {§super(ownerId, 81, "Ember Weaver", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{G}");§this.expansionSetCode = "CON";§this.subtype.add("Spider");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(ReachAbility.getInstance());§this.addAbility(new SimpleStaticAbility(§Zone.BATTLEFIELD,§new ConditionalContinuousEffect(§new BoostSourceEffect(1, 0, Duration.WhileOnBattlefield),§new PermanentsOnTheBattlefieldCondition(redPermanentFilter), "{this} gets +1/+0 as long as you control a red permanent")));§this.addAbility(new SimpleStaticAbility(§Zone.BATTLEFIELD,§new ConditionalContinuousEffect(§new GainAbilitySourceEffect(FirstStrikeAbility.getInstance(), Duration.WhileOnBattlefield),§new PermanentsOnTheBattlefieldCondition(redPermanentFilter), "{this} has first strike as long as you control a red permanent")));§}§public EmberWeaver(final EmberWeaver card) {§super(card);§}§@Override§public EmberWeaver copy() {§return new EmberWeaver(this);§}§}§
public class EsperCormorants extends CardImpl {§public EsperCormorants(UUID ownerId) {§super(ownerId, 105, "Esper Cormorants", Rarity.COMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{2}{W}{U}");§this.expansionSetCode = "CON";§this.subtype.add("Bird");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§}§public EsperCormorants(final EsperCormorants card) {§super(card);§}§@Override§public EsperCormorants copy() {§return new EsperCormorants(this);§}§}§
public class Esperzoa extends CardImpl {§public Esperzoa (UUID ownerId) {§super(ownerId, 25, "Esperzoa", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{2}{U}");§this.expansionSetCode = "CON";§this.subtype.add("Jellyfish");§this.power = new MageInt(4);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new BeginningOfUpkeepTriggeredAbility(new ReturnToHandChosenControlledPermanentEffect(new FilterControlledArtifactPermanent()), TargetController.YOU, false));§}§public Esperzoa (final Esperzoa card) {§super(card);§}§@Override§public Esperzoa copy() {§return new Esperzoa(this);§}§}§
public class ExplodingBorders extends CardImpl {§public ExplodingBorders(UUID ownerId) {§super(ownerId, 106, "Exploding Borders", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{2}{R}{G}");§this.expansionSetCode = "CON";§this.getSpellAbility().addEffect(new SearchLibraryPutInPlayEffect(new TargetCardInLibrary(new FilterBasicLandCard()), true));§this.getSpellAbility().addEffect(new DamageTargetEffect(new DomainValue()));§this.getSpellAbility().addTarget(new TargetPlayer());§}§public ExplodingBorders(final ExplodingBorders card) {§super(card);§}§@Override§public ExplodingBorders copy() {§return new ExplodingBorders(this);§}§}§
public class ExtractorDemon extends CardImpl {§public ExtractorDemon(UUID ownerId) {§super(ownerId, 44, "Extractor Demon", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{B}{B}");§this.expansionSetCode = "CON";§this.subtype.add("Demon");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new DiesCreatureTriggeredAbility(new PutLibraryIntoGraveTargetEffect(2), true, true, false);§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§this.addAbility(new UnearthAbility(new ManaCostsImpl("{2}{B}")));§}§public ExtractorDemon(final ExtractorDemon card) {§super(card);§}§@Override§public ExtractorDemon copy() {§return new ExtractorDemon(this);§}§}§
public class FaerieMechanist extends CardImpl {§private static final FilterCard filter = new FilterCard("an artifact card");§static {§filter.add(new CardTypePredicate(CardType.ARTIFACT));§}§public FaerieMechanist(UUID ownerId) {§super(ownerId, 27, "Faerie Mechanist", Rarity.COMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{3}{U}");§this.expansionSetCode = "CON";§this.subtype.add("Faerie");§this.subtype.add("Artificer");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new EntersBattlefieldTriggeredAbility(new LookLibraryAndPickControllerEffect(new StaticValue(3), false, new StaticValue(1), filter, false)));§}§public FaerieMechanist(final FaerieMechanist card) {§super(card);§}§@Override§public FaerieMechanist copy() {§return new FaerieMechanist(this);§}§}§
public class FieryFall extends CardImpl {§public FieryFall (UUID ownerId) {§super(ownerId, 63, "Fiery Fall", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{5}{R}");§this.expansionSetCode = "CON";§this.getSpellAbility().addEffect(new DamageTargetEffect(5));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.addAbility(new BasicLandcyclingAbility(new ManaCostsImpl("{1}{R}")));§}§public FieryFall (final FieryFall card) {§super(card);§}§@Override§public FieryFall copy() {§return new FieryFall(this);§}§}§
public class FiligreeFracture extends CardImpl {§public FiligreeFracture(UUID ownerId) {§super(ownerId, 82, "Filigree Fracture", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{2}{G}");§this.expansionSetCode = "CON";§this.getSpellAbility().addTarget(new TargetPermanent(new FilterArtifactOrEnchantmentPermanent()));§this.getSpellAbility().addEffect(new DestroyTargetEffect());§this.getSpellAbility().addEffect(new FiligreeFractureEffect());§}§public FiligreeFracture(final FiligreeFracture card) {§super(card);§}§@Override§public FiligreeFracture copy() {§return new FiligreeFracture(this);§}§}§class FiligreeFractureEffect extends OneShotEffect {§public FiligreeFractureEffect() {§super(Outcome.DrawCard);§this.staticText = "If that permanent was blue or black, draw a card";§}§public FiligreeFractureEffect(final FiligreeFractureEffect effect) {§super(effect);§}§@Override§public FiligreeFractureEffect copy() {§return new FiligreeFractureEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§Permanent permanent = (Permanent) game.getLastKnownInformation(source.getFirstTarget(), Zone.BATTLEFIELD);§if (player != null && permanent != null§&& (permanent.getColor(game).isBlack() || permanent.getColor(game).isBlue())) {§player.drawCards(1, game);§return true;§}§return false;§}§}§
public class Fleshformer extends CardImpl {§public Fleshformer(UUID ownerId) {§super(ownerId, 45, "Fleshformer", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{B}");§this.expansionSetCode = "CON";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Effect effect = new BoostSourceEffect(2, 2, Duration.EndOfTurn);§effect.setText("{this} gets +2/+2");§Ability ability = new ActivateIfConditionActivatedAbility(Zone.BATTLEFIELD, effect, new ManaCostsImpl("{W}{U}{B}{R}{G}"), MyTurnCondition.getInstance());§effect = new GainAbilitySourceEffect(FearAbility.getInstance(), Duration.EndOfTurn);§effect.setText("and gains fear until end of turn");§ability.addEffect(effect);§ability.addEffect(new BoostTargetEffect(-2, -2, Duration.EndOfTurn));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public Fleshformer(final Fleshformer card) {§super(card);§}§@Override§public Fleshformer copy() {§return new Fleshformer(this);§}§}§
public class FontOfMythos extends CardImpl {§public FontOfMythos(UUID ownerId) {§super(ownerId, 136, "Font of Mythos", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{4}");§this.expansionSetCode = "CON";§this.addAbility(new FontOfMythosAbility());§}§public FontOfMythos(final FontOfMythos card) {§super(card);§}§@Override§public FontOfMythos copy() {§return new FontOfMythos(this);§}§}§class FontOfMythosAbility extends TriggeredAbilityImpl {§public FontOfMythosAbility() {§super(Zone.BATTLEFIELD, new DrawCardTargetEffect(2));§}§public FontOfMythosAbility(final FontOfMythosAbility ability) {§super(ability);§}§@Override§public FontOfMythosAbility copy() {§return new FontOfMythosAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.DRAW_STEP_PRE;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§this.getTargets().clear();§this.addTarget(new TargetPlayer());§getTargets().get(0).add(event.getPlayerId(),game);§return true;§}§@Override§public String getRule() {§return "At the beginning of each player's draw step, that player draws two additional cards.";§}§}§
public class FrontlineSage extends CardImpl {§public FrontlineSage (UUID ownerId) {§super(ownerId, 28, "Frontline Sage", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{U}");§this.expansionSetCode = "CON";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(0);§this.toughness = new MageInt(1);§this.addAbility(new ExaltedAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DrawDiscardControllerEffect(), new ManaCostsImpl("{U}"));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§}§public FrontlineSage (final FrontlineSage card) {§super(card);§}§@Override§public FrontlineSage copy() {§return new FrontlineSage(this);§}§}§
public class FusionElemental extends CardImpl {§public FusionElemental(UUID ownerId) {§super(ownerId, 107, "Fusion Elemental", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{W}{U}{B}{R}{G}");§this.expansionSetCode = "CON";§this.subtype.add("Elemental");§this.power = new MageInt(8);§this.toughness = new MageInt(8);§}§public FusionElemental(final FusionElemental card) {§super(card);§}§@Override§public FusionElemental copy() {§return new FusionElemental(this);§}§}§
public class GiltspireAvenger extends CardImpl {§public GiltspireAvenger(UUID ownerId) {§super(ownerId, 108, "Giltspire Avenger", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{G}{W}{U}");§this.expansionSetCode = "CON";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new ExaltedAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DestroyTargetEffect(), new TapSourceCost());§ability.addTarget(new GiltspireAvengerTarget());§this.addAbility(ability);§}§public GiltspireAvenger(final GiltspireAvenger card) {§super(card);§}§@Override§public GiltspireAvenger copy() {§return new GiltspireAvenger(this);§}§}§class GiltspireAvengerTarget extends TargetPermanent {§public GiltspireAvengerTarget() {§super(1, 1, new FilterCreaturePermanent(), false);§targetName = "creature that dealt damage to you this turn";§}§public GiltspireAvengerTarget(final GiltspireAvengerTarget target) {§super(target);§}§@Override§public boolean canTarget(UUID id, Ability source, Game game) {§PlayerDamagedBySourceWatcher watcher = (PlayerDamagedBySourceWatcher) game.getState().getWatchers().get("PlayerDamagedBySource",source.getControllerId());§if (watcher != null && watcher.hasSourceDoneDamage(id, game)) {§return super.canTarget(id, source, game);§}§return false;§}§@Override§public Set<UUID> possibleTargets(UUID sourceId, UUID sourceControllerId, Game game) {§Set<UUID> availablePossibleTargets = super.possibleTargets(sourceId, sourceControllerId, game);§Set<UUID> possibleTargets = new HashSet<UUID>();§PlayerDamagedBySourceWatcher watcher = (PlayerDamagedBySourceWatcher) game.getState().getWatchers().get("PlayerDamagedBySource", sourceControllerId);§for (UUID targetId : availablePossibleTargets) {§Permanent permanent = game.getPermanent(targetId);§if(permanent != null && watcher != null && watcher.hasSourceDoneDamage(targetId, game)){§possibleTargets.add(targetId);§}§}§return possibleTargets;§}§@Override§public boolean canChoose(UUID sourceId, UUID sourceControllerId, Game game) {§int remainingTargets = this.minNumberOfTargets - targets.size();§if (remainingTargets == 0) {§return true;§}§int count = 0;§MageObject targetSource = game.getObject(sourceId);§PlayerDamagedBySourceWatcher watcher = (PlayerDamagedBySourceWatcher) game.getState().getWatchers().get("PlayerDamagedBySource", sourceControllerId);§for (Permanent permanent: game.getBattlefield().getActivePermanents(filter, sourceControllerId, sourceId, game)) {§if (!targets.containsKey(permanent.getId()) && permanent.canBeTargetedBy(targetSource, sourceControllerId, game)§&& watcher != null && watcher.hasSourceDoneDamage(permanent.getId(), game)) {§count++;§if (count >= remainingTargets) {§return true;§}§}§}§return false;§}§@Override§public GiltspireAvengerTarget copy() {§return new GiltspireAvengerTarget(this);§}§}§
public class GleamOfResistance extends CardImpl {§public GleamOfResistance(UUID ownerId) {§super(ownerId, 8, "Gleam of Resistance", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{4}{W}");§this.expansionSetCode = "CON";§this.getSpellAbility().addEffect(new BoostControlledEffect(1, 2, Duration.EndOfTurn));§this.getSpellAbility().addEffect(new UntapAllControllerEffect(new FilterCreaturePermanent(),"Untap those creatures"));§this.addAbility(new BasicLandcyclingAbility(new ManaCostsImpl("{1}{W}")));§}§public GleamOfResistance(final GleamOfResistance card) {§super(card);§}§@Override§public GleamOfResistance copy() {§return new GleamOfResistance(this);§}§}§
public class GluttonousSlime extends CardImpl {§public GluttonousSlime(UUID ownerId) {§super(ownerId, 83, "Gluttonous Slime", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{G}");§this.expansionSetCode = "CON";§this.subtype.add("Ooze");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlashAbility.getInstance());§this.addAbility(new DevourAbility(DevourFactor.Devour1));§}§public GluttonousSlime(final GluttonousSlime card) {§super(card);§}§@Override§public GluttonousSlime copy() {§return new GluttonousSlime(this);§}§}§
public class GoblinOutlander extends CardImpl {§private static final FilterCard filter = new FilterCard("white");§static {§filter.add(new ColorPredicate(ObjectColor.WHITE));§}§public GoblinOutlander(UUID ownerId) {§super(ownerId, 109, "Goblin Outlander", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{B}{R}");§this.expansionSetCode = "CON";§this.subtype.add("Goblin");§this.subtype.add("Scout");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new ProtectionAbility(filter));§}§public GoblinOutlander(final GoblinOutlander card) {§super(card);§}§@Override§public GoblinOutlander copy() {§return new GoblinOutlander(this);§}§}§
public class GoblinRazerunners extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledLandPermanent("a land");§public GoblinRazerunners (UUID ownerId) {§super(ownerId, 64, "Goblin Razerunners", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{R}{R}");§this.expansionSetCode = "CON";§this.subtype.add("Goblin");§this.subtype.add("Warrior");§this.power = new MageInt(3);§this.toughness = new MageInt(4);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new AddCountersSourceEffect(CounterType.P1P1.createInstance()), new ManaCostsImpl("{1}{R}"));§ability.addCost(new SacrificeTargetCost(new TargetControlledPermanent(filter)));§this.addAbility(ability);§ability = new BeginningOfYourEndStepTriggeredAbility(new DamageTargetEffect(new CountersCount(CounterType.P1P1)), true);§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§}§public GoblinRazerunners (final GoblinRazerunners card) {§super(card);§}§@Override§public GoblinRazerunners copy() {§return new GoblinRazerunners(this);§}§}§
public class GrixisIllusionist extends CardImpl {§private static final FilterLandPermanent filter = new FilterLandPermanent("land you control");§static {§filter.add(new ControllerPredicate(TargetController.YOU));§}§public GrixisIllusionist(UUID ownerId) {§super(ownerId, 29, "Grixis Illusionist", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{U}");§this.expansionSetCode = "CON";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BecomesBasicLandTargetEffect(Duration.EndOfTurn), new TapSourceCost());§Target target = new TargetLandPermanent(filter);§ability.addTarget(target);§this.addAbility(ability);§}§public GrixisIllusionist(final GrixisIllusionist card) {§super(card);§}§@Override§public GrixisIllusionist copy() {§return new GrixisIllusionist(this);§}§}§
public class GrixisSlavedriver extends CardImpl {§public GrixisSlavedriver(UUID ownerId) {§super(ownerId, 46, "Grixis Slavedriver", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{5}{B}");§this.expansionSetCode = "CON";§this.subtype.add("Zombie");§this.subtype.add("Giant");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(new LeavesBattlefieldTriggeredAbility(new CreateTokenEffect(new ZombieToken()), false));§this.addAbility(new UnearthAbility(new ManaCostsImpl("{3}{B}")));§}§public GrixisSlavedriver(final GrixisSlavedriver card) {§super(card);§}§@Override§public GrixisSlavedriver copy() {§return new GrixisSlavedriver(this);§}§}§
public class GwafaHazidProfiteer extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature you don't control");§static {§filter.add(new ControllerPredicate(TargetController.NOT_YOU));§}§public GwafaHazidProfiteer(UUID ownerId) {§super(ownerId, 110, "Gwafa Hazid, Profiteer", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{W}{U}");§this.expansionSetCode = "CON";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Rogue");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new GwafaHazidProfiteerEffect1(), new ManaCostsImpl("{W}{U}"));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent(filter));§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GwafaHazidProfiteerEffect2()));§}§public GwafaHazidProfiteer(final GwafaHazidProfiteer card) {§super(card);§}§@Override§public GwafaHazidProfiteer copy() {§return new GwafaHazidProfiteer(this);§}§}§class GwafaHazidProfiteerEffect1 extends OneShotEffect {§GwafaHazidProfiteerEffect1() {§super(Outcome.Detriment);§staticText = "Put a bribery counter on target creature you don't control. Its controller draws a card";§}§public GwafaHazidProfiteerEffect1(final GwafaHazidProfiteerEffect1 effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent targetCreature = game.getPermanent(source.getFirstTarget());§if (targetCreature != null) {§Player controller = game.getPlayer(targetCreature.getControllerId());§targetCreature.addCounters(CounterType.BRIBERY.createInstance(), game);§if (controller != null) {§controller.drawCards(1, game);§}§return true;§}§return false;§}§@Override§public GwafaHazidProfiteerEffect1 copy() {§return new GwafaHazidProfiteerEffect1(this);§}§}§class GwafaHazidProfiteerEffect2 extends RestrictionEffect {§public GwafaHazidProfiteerEffect2() {§super(Duration.WhileOnBattlefield);§staticText = "Creatures with bribery counters on them can't attack or block";§}§public GwafaHazidProfiteerEffect2(final GwafaHazidProfiteerEffect2 effect) {§super(effect);§}§@Override§public boolean applies(Permanent permanent, Ability source, Game game) {§return permanent.getCounters().containsKey(CounterType.BRIBERY);§}§@Override§public boolean canAttack(Game game) {§return false;§}§@Override§public boolean canBlock(Permanent attacker, Permanent blocker, Ability source, Game game) {§return false;§}§@Override§public GwafaHazidProfiteerEffect2 copy() {§return new GwafaHazidProfiteerEffect2(this);§}§}§
public class HellkiteHatchling extends CardImpl {§public HellkiteHatchling(UUID ownerId) {§super(ownerId, 111, "Hellkite Hatchling", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{R}{G}");§this.expansionSetCode = "CON";§this.subtype.add("Dragon");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new DevourAbility(DevourFactor.Devour1));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new ConditionalContinuousEffect(§new GainAbilitySourceEffect(FlyingAbility.getInstance()),§new DevouredCreaturesCondition(Condition.ComparisonType.GreaterThan, 0),§"{this} has flying if it devoured a creature")));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new ConditionalContinuousEffect(§new GainAbilitySourceEffect(TrampleAbility.getInstance()),§new DevouredCreaturesCondition(Condition.ComparisonType.GreaterThan, 0),§"{this} has trample if it devoured a creature")));§}§public HellkiteHatchling(final HellkiteHatchling card) {§super(card);§}§@Override§public HellkiteHatchling copy() {§return new HellkiteHatchling(this);§}§}§
public class InkwellLeviathan extends CardImpl {§public InkwellLeviathan(UUID ownerId) {§super(ownerId, 30, "Inkwell Leviathan", Rarity.RARE, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{7}{U}{U}" );§this.expansionSetCode = "CON";§this.subtype.add("Leviathan");§this.power = new MageInt(7);§this.toughness = new MageInt(11);§this.addAbility(new IslandwalkAbility());§this.addAbility(TrampleAbility.getInstance());§this.addAbility(ShroudAbility.getInstance());§}§public InkwellLeviathan(final InkwellLeviathan card) {§super(card);§}§@Override§public InkwellLeviathan copy() {§return new InkwellLeviathan(this);§}§}§
public class JhessianBalmgiver extends CardImpl {§public JhessianBalmgiver(UUID ownerId) {§super(ownerId, 112, "Jhessian Balmgiver", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{W}{U}");§this.expansionSetCode = "CON";§this.subtype.add("Human");§this.subtype.add("Cleric");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new PreventDamageToTargetEffect(Duration.EndOfTurn, 1), new TapSourceCost());§ability.addTarget(new TargetCreatureOrPlayer());§this.addAbility(ability);§ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new CantBeBlockedTargetEffect(), new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public JhessianBalmgiver(final JhessianBalmgiver card) {§super(card);§}§@Override§public JhessianBalmgiver copy() {§return new JhessianBalmgiver(this);§}§}§
public class Kaleidostone extends CardImpl {§public Kaleidostone(UUID ownerId) {§super(ownerId, 137, "Kaleidostone", Rarity.COMMON, new CardType[]{CardType.ARTIFACT}, "{2}");§this.expansionSetCode = "CON";§this.addAbility(new EntersBattlefieldTriggeredAbility(new DrawCardSourceControllerEffect(1)));§Ability ability = new SimpleManaAbility(Zone.BATTLEFIELD, new Mana(1, 1, 1, 1, 1, 0, 0, 0), new GenericManaCost(5));§ability.addCost(new TapSourceCost());§ability.addCost(new SacrificeSourceCost());§this.addAbility(ability);§}§public Kaleidostone(final Kaleidostone card) {§super(card);§}§@Override§public Kaleidostone copy() {§return new Kaleidostone(this);§}§}§
public class KederektParasite extends CardImpl {§public KederektParasite(UUID ownerId) {§super(ownerId, 48, "Kederekt Parasite", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{B}");§this.expansionSetCode = "CON";§this.subtype.add("Horror");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new KederektParasiteTriggeredAbility());§}§public KederektParasite(final KederektParasite card) {§super(card);§}§@Override§public KederektParasite copy() {§return new KederektParasite(this);§}§}§class KederektParasiteTriggeredAbility extends TriggeredAbilityImpl {§KederektParasiteTriggeredAbility() {§super(Zone.BATTLEFIELD, new DamageTargetEffect(1, false, "opponent"), true);§}§KederektParasiteTriggeredAbility(final KederektParasiteTriggeredAbility ability) {§super(ability);§}§@Override§public KederektParasiteTriggeredAbility copy() {§return new KederektParasiteTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.DREW_CARD;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (game.getOpponents(this.getControllerId()).contains(event.getPlayerId())) {§boolean youControlRedPermanent = false;§for (Permanent permanent : game.getBattlefield().getAllActivePermanents(this.getControllerId())) {§if (permanent.getColor(game).isRed()) {§youControlRedPermanent = true;§break;§}§}§if (youControlRedPermanent) {§getEffects().get(0).setTargetPointer(new FixedTarget(event.getPlayerId()));§return true;§}§}§return false;§}§@Override§public String getRule() {§return "Whenever an opponent draws a card, if you control a red permanent, you may have {this} deal 1 damage to that player.";§}§}§
public class KnightOfTheReliquary extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledLandPermanent("Forest or Plains");§static {§filter.add(Predicates.or(new SubtypePredicate("Forest"), new SubtypePredicate("Plains")));§}§public KnightOfTheReliquary(UUID ownerId) {§super(ownerId, 113, "Knight of the Reliquary", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{G}{W}");§this.expansionSetCode = "CON";§this.subtype.add("Human");§this.subtype.add("Knight");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§CardsInControllerGraveyardCount value = new CardsInControllerGraveyardCount(new FilterLandCard());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostSourceEffect(value, value, Duration.WhileOnBattlefield)));§TargetCardInLibrary target = new TargetCardInLibrary(new FilterLandCard());§Costs<Cost> costs = new CostsImpl<>();§costs.add(new TapSourceCost());§costs.add(new SacrificeTargetCost(new TargetControlledPermanent(1, 1, filter, false)));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new SearchLibraryPutInPlayEffect(target, false, Outcome.PutLandInPlay), costs));§}§public KnightOfTheReliquary(final KnightOfTheReliquary card) {§super(card);§}§@Override§public KnightOfTheReliquary copy() {§return new KnightOfTheReliquary(this);§}§}§
public class KnotvineMystic extends CardImpl{§public KnotvineMystic(UUID ownerId) {§super(ownerId, 114, "Knotvine Mystic", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{R}{G}{W}");§this.expansionSetCode = "CON";§this.subtype.add("Elf");§this.subtype.add("Druid");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new KnotvineMysticManaAbility();§ability.addManaCost(new GenericManaCost(1));§this.addAbility(ability);§}§public KnotvineMystic(final KnotvineMystic card) {§super(card);§}§@Override§public KnotvineMystic copy() {§return new KnotvineMystic(this);§}§}§class KnotvineMysticManaAbility extends BasicManaAbility {§public KnotvineMysticManaAbility() {§super(new BasicManaEffect(new Mana(1, 1, 0, 1, 0, 0, 0, 0)));§this.netMana.add(new Mana(1, 1, 0, 1, 0, 0, 0, 0));§}§public KnotvineMysticManaAbility(final KnotvineMysticManaAbility ability) {§super(ability);§}§@Override§public KnotvineMysticManaAbility copy() {§return new KnotvineMysticManaAbility(this);§}§}§
public class Kranioceros extends CardImpl {§public Kranioceros(UUID ownerId) {§super(ownerId, 67, "Kranioceros", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{R}");§this.expansionSetCode = "CON";§this.subtype.add("Beast");§this.power = new MageInt(5);§this.toughness = new MageInt(2);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(0, 3, Duration.EndOfTurn), new ManaCostsImpl("{1}{W}")));§}§public Kranioceros (final Kranioceros card) {§super(card);§}§@Override§public Kranioceros copy() {§return new Kranioceros(this);§}§}§
public class LapseOfCertainty extends CardImpl {§public LapseOfCertainty(UUID ownerId) {§super(ownerId, 9, "Lapse of Certainty", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{W}");§this.expansionSetCode = "CON";§this.getSpellAbility().addEffect(new CounterTargetWithReplacementEffect(Zone.LIBRARY, ZoneDetail.TOP));§this.getSpellAbility().addTarget(new TargetSpell());§}§public LapseOfCertainty(final LapseOfCertainty card) {§super(card);§}§@Override§public LapseOfCertainty copy() {§return new LapseOfCertainty(this);§}§}§
public class MaelstromArchangel extends CardImpl {§public MaelstromArchangel(UUID ownerId) {§super(ownerId, 115, "Maelstrom Archangel", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{W}{U}{B}{R}{G}");§this.expansionSetCode = "CON";§this.subtype.add("Angel");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new DealsCombatDamageToAPlayerTriggeredAbility(new MaelstromArchangelCastEffect(), false));§}§public MaelstromArchangel(final MaelstromArchangel card) {§super(card);§}§@Override§public MaelstromArchangel copy() {§return new MaelstromArchangel(this);§}§}§class MaelstromArchangelCastEffect extends OneShotEffect {§private static final FilterCard filter = new FilterNonlandCard("nonland card from your hand");§public MaelstromArchangelCastEffect() {§super(Outcome.PlayForFree);§this.staticText = "you may cast a nonland card from your hand without paying its mana cost";§}§public MaelstromArchangelCastEffect(final MaelstromArchangelCastEffect effect) {§super(effect);§}§@Override§public MaelstromArchangelCastEffect copy() {§return new MaelstromArchangelCastEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Target target = new TargetCardInHand(filter);§if (target.canChoose(source.getSourceId(), controller.getId(), game) &&§controller.chooseUse(outcome, "Cast a nonland card from your hand without paying its mana cost?", source, game)) {§Card cardToCast = null;§boolean cancel = false;§while (controller.canRespond() && !cancel) {§if (controller.chooseTarget(outcome, target, source, game)) {§cardToCast = game.getCard(target.getFirstTarget());§if (cardToCast != null && cardToCast.getSpellAbility().canChooseTarget(game)) {§cancel = true;§}§} else {§cancel = true;§}§}§if (cardToCast != null) {§controller.cast(cardToCast.getSpellAbility(), game, true);§}§}§return true;§}§return false;§}§}§
public class MagisterSphinx extends CardImpl {§public MagisterSphinx(UUID ownerId) {§super(ownerId, 116, "Magister Sphinx", Rarity.RARE, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{4}{W}{U}{B}");§this.expansionSetCode = "CON";§this.subtype.add("Sphinx");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new EntersBattlefieldTriggeredAbility(new MagisterSphinxEffect(), false);§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§}§public MagisterSphinx(final MagisterSphinx card) {§super(card);§}§@Override§public MagisterSphinx copy() {§return new MagisterSphinx(this);§}§}§class MagisterSphinxEffect extends OneShotEffect {§MagisterSphinxEffect() {§super(Outcome.Detriment);§staticText = "target player's life total becomes 10";§}§MagisterSphinxEffect(final MagisterSphinxEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player targetPlayer = game.getPlayer(source.getFirstTarget());§if (targetPlayer != null) {§targetPlayer.setLife(10, game);§return true;§}§return false;§}§@Override§public MagisterSphinxEffect copy() {§return new MagisterSphinxEffect(this);§}§}§
public class Malfegor extends CardImpl {§public Malfegor(UUID ownerId) {§super(ownerId, 117, "Malfegor", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{2}{B}{B}{R}{R}");§this.expansionSetCode = "CON";§this.supertype.add("Legendary");§this.subtype.add("Demon");§this.subtype.add("Dragon");§this.power = new MageInt(6);§this.toughness = new MageInt(6);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new EntersBattlefieldTriggeredAbility(new MalfegorEffect(), false));§}§public Malfegor(final Malfegor card) {§super(card);§}§@Override§public Malfegor copy() {§return new Malfegor(this);§}§}§class MalfegorEffect extends OneShotEffect {§public MalfegorEffect() {§super(Outcome.Neutral);§staticText = "discard your hand. Each opponent sacrifices a creature for each card discarded this way";§}§public MalfegorEffect(final MalfegorEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§int sacrificeNumber = controller.getHand().size();§if (sacrificeNumber > 0) {§controller.discard(sacrificeNumber, source, game);§for (UUID opponentId : game.getOpponents(controller.getId())) {§Player opponent = game.getPlayer(opponentId);§if (opponent != null) {§for (int i = 0; i < sacrificeNumber; i++) {§Target target = new TargetControlledPermanent(new FilterControlledCreaturePermanent());§if (target.canChoose(opponentId, game)) {§if (opponent.choose(Outcome.Sacrifice, target, source.getSourceId(), game)) {§Permanent permanent = game.getPermanent(target.getFirstTarget());§if (permanent != null) {§permanent.sacrifice(source.getSourceId(), game);§}§}§}§}§}§}§}§return true;§}§return false;§}§@Override§public MalfegorEffect copy() {§return new MalfegorEffect(this);§}§}§
public class ManaCylix extends CardImpl {§public ManaCylix(UUID ownerId) {§super(ownerId, 138, "Mana Cylix", Rarity.COMMON, new CardType[]{CardType.ARTIFACT}, "{1}");§this.expansionSetCode = "CON";§Ability ability = new AnyColorManaAbility(new GenericManaCost(1));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§}§public ManaCylix(final ManaCylix card) {§super(card);§}§@Override§public ManaCylix copy() {§return new ManaCylix(this);§}§}§
public class ManaforceMace extends CardImpl {§public ManaforceMace(UUID ownerId) {§super(ownerId, 139, "Manaforce Mace", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{4}");§this.expansionSetCode = "CON";§this.subtype.add("Equipment");§DomainValue value = new DomainValue();§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEquippedEffect(value, value)));§this.addAbility(new EquipAbility(Outcome.BoostCreature, new GenericManaCost(3)));§}§public ManaforceMace(final ManaforceMace card) {§super(card);§}§@Override§public ManaforceMace copy() {§return new ManaforceMace(this);§}§}§
public class ManiacalRage extends CardImpl {§public ManiacalRage(UUID ownerId) {§super(ownerId, 68, "Maniacal Rage", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{R}");§this.expansionSetCode = "CON";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(2, 2, Duration.WhileOnBattlefield)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new CantBlockAttachedEffect(AttachmentType.AURA)));§}§public ManiacalRage(final ManiacalRage card) {§super(card);§}§@Override§public ManiacalRage copy() {§return new ManiacalRage(this);§}§}§
public class MarkOfAsylum extends CardImpl {§private static final FilterControlledCreatureInPlay filter = new FilterControlledCreatureInPlay("creatures you control");§public MarkOfAsylum(UUID ownerId) {§super(ownerId, 10, "Mark of Asylum", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{1}{W}");§this.expansionSetCode = "CON";§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new PreventAllNonCombatDamageToAllEffect(Duration.WhileOnBattlefield, filter)));§}§public MarkOfAsylum(final MarkOfAsylum card) {§super(card);§}§@Override§public MarkOfAsylum copy() {§return new MarkOfAsylum(this);§}§}§
public class MartialCoup extends CardImpl {§public MartialCoup(UUID ownerId) {§super(ownerId, 11, "Martial Coup", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{X}{W}{W}");§this.expansionSetCode = "CON";§this.getSpellAbility().addEffect(new MartialCoupEffect());§}§public MartialCoup(final MartialCoup card) {§super(card);§}§@Override§public MartialCoup copy() {§return new MartialCoup(this);§}§}§class MartialCoupEffect extends OneShotEffect {§private static SoldierToken token = new SoldierToken();§public MartialCoupEffect() {§super(Outcome.PutCreatureInPlay);§staticText = "Put X 1/1 white Soldier creature tokens onto the battlefield. If X is 5 or more, destroy all other creatures";§}§public MartialCoupEffect(final MartialCoupEffect effect) {§super(effect);§}§@Override§public MartialCoupEffect copy() {§return new MartialCoupEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§int amount = source.getManaCostsToPay().getX();§token.putOntoBattlefield(amount, game, source.getSourceId(), source.getControllerId());§List<UUID> tokens = token.getLastAddedTokenIds();§if (amount > 4) {§for (Permanent permanent : game.getBattlefield().getActivePermanents(new FilterCreaturePermanent(), source.getControllerId(), game)) {§if (!tokens.contains(permanent.getId())) {§permanent.destroy(source.getSourceId(), game, false);§}§}§}§return true;§}§}§
public class MasterTransmuter extends CardImpl {§public MasterTransmuter(UUID ownerId) {§super(ownerId, 31, "Master Transmuter", Rarity.RARE, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{3}{U}");§this.expansionSetCode = "CON";§this.subtype.add("Human");§this.subtype.add("Artificer");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new PutPermanentOnBattlefieldEffect(new FilterArtifactCard("an artifact card")), new ManaCostsImpl("{U}"));§ability.addCost(new TapSourceCost());§ability.addCost(new ReturnToHandChosenControlledPermanentCost(new TargetControlledPermanent(new FilterControlledArtifactPermanent("an artifact"))));§this.addAbility(ability);§}§public MasterTransmuter(final MasterTransmuter card) {§super(card);§}§@Override§public MasterTransmuter copy() {§return new MasterTransmuter(this);§}§}§
public class MatcaRioters extends CardImpl {§public MatcaRioters(UUID ownerId) {§super(ownerId, 84, "Matca Rioters", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{G}");§this.expansionSetCode = "CON";§this.subtype.add("Human");§this.subtype.add("Warrior");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§Effect effect = new SetPowerToughnessSourceEffect(new DomainValue(), Duration.EndOfGame);§effect.setText("Domain - {this}'s power and toughness are each equal to the number of basic land types among lands you control.");§this.addAbility(new SimpleStaticAbility(Zone.ALL, effect));§}§public MatcaRioters(final MatcaRioters card) {§super(card);§}§@Override§public MatcaRioters copy() {§return new MatcaRioters(this);§}§}§
public class MirrorSigilSergeant extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("blue permanent");§static {§filter.add(new ColorPredicate(ObjectColor.BLUE));§}§private static final String rule = "At the beginning of your upkeep, if you control a blue permanent, you may put a token that's a copy of Mirror-Sigil Sergeant onto the battlefield.";§public MirrorSigilSergeant(UUID ownerId) {§super(ownerId, 12, "Mirror-Sigil Sergeant", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{5}{W}");§this.expansionSetCode = "CON";§this.subtype.add("Rhino");§this.subtype.add("Soldier");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(TrampleAbility.getInstance());§Effect effect = new PutTokenOntoBattlefieldCopySourceEffect();§effect.setText("you may put a token that's a copy of {this} onto the battlefield");§TriggeredAbility ability = new BeginningOfUpkeepTriggeredAbility(Zone.BATTLEFIELD, effect, TargetController.YOU, true);§this.addAbility(new ConditionalTriggeredAbility(ability, new PermanentsOnTheBattlefieldCondition(filter), rule));§}§public MirrorSigilSergeant(final MirrorSigilSergeant card) {§super(card);§}§@Override§public MirrorSigilSergeant copy() {§return new MirrorSigilSergeant(this);§}§}§
public class MoltenFrame extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("artifact creature");§static {§filter.add(new CardTypePredicate(CardType.ARTIFACT));§}§public MoltenFrame(UUID ownerId) {§super(ownerId, 69, "Molten Frame", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{R}");§this.expansionSetCode = "CON";§this.getSpellAbility().addEffect(new DestroyTargetEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent(filter));§this.addAbility(new CyclingAbility(new ManaCostsImpl("{2}")));§}§public MoltenFrame (final MoltenFrame card) {§super(card);§}§@Override§public MoltenFrame copy() {§return new MoltenFrame(this);§}§}§
public class NacatlHuntPride extends CardImpl {§public NacatlHuntPride(UUID ownerId) {§super(ownerId, 13, "Nacatl Hunt-Pride", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{5}{W}");§this.expansionSetCode = "CON";§this.subtype.add("Cat");§this.subtype.add("Warrior");§this.power = new MageInt(5);§this.toughness = new MageInt(4);§this.addAbility(VigilanceAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new CantBlockTargetEffect(Duration.EndOfTurn), new ManaCostsImpl("{R}"));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§Ability ability2 = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BlocksIfAbleTargetEffect(Duration.EndOfTurn), new ManaCostsImpl("{G}"));§ability2.addCost(new TapSourceCost());§ability2.addTarget(new TargetCreaturePermanent());§this.addAbility(ability2);§}§public NacatlHuntPride(final NacatlHuntPride card) {§super(card);§}§@Override§public NacatlHuntPride copy() {§return new NacatlHuntPride(this);§}§}§
public class NacatlOutlander extends CardImpl {§private static final FilterCard filter = new FilterCard("blue");§static {§filter.add(new ColorPredicate(ObjectColor.BLUE));§}§public NacatlOutlander(UUID ownerId) {§super(ownerId, 119, "Nacatl Outlander", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{R}{G}");§this.expansionSetCode = "CON";§this.subtype.add("Cat");§this.subtype.add("Scout");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new ProtectionAbility(filter));§}§public NacatlOutlander(final NacatlOutlander card) {§super(card);§}§@Override§public NacatlOutlander copy() {§return new NacatlOutlander(this);§}§}§
public class NacatlSavage extends CardImpl {§public NacatlSavage(UUID ownerId) {§super(ownerId, 86, "Nacatl Savage", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "CON";§this.subtype.add("Cat");§this.subtype.add("Warrior");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new ProtectionAbility(new FilterArtifactCard("artifacts")));§}§public NacatlSavage(final NacatlSavage card) {§super(card);§}§@Override§public NacatlSavage copy() {§return new NacatlSavage(this);§}§}§
public class NicolBolasPlaneswalker extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("noncreature permanent");§static {§filter.add(Predicates.not(new CardTypePredicate(CardType.CREATURE)));§}§public NicolBolasPlaneswalker(UUID ownerId) {§super(ownerId, 120, "Nicol Bolas, Planeswalker", Rarity.MYTHIC, new CardType[]{CardType.PLANESWALKER}, "{4}{U}{B}{B}{R}");§this.expansionSetCode = "CON";§this.subtype.add("Bolas");§this.addAbility(new PlanswalkerEntersWithLoyalityCountersAbility(5));§LoyaltyAbility ability = new LoyaltyAbility(new DestroyTargetEffect(), 3);§ability.addTarget(new TargetPermanent(filter));§this.addAbility(ability);§ability = new LoyaltyAbility(new GainControlTargetEffect(Duration.Custom), -2);§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§ability = new LoyaltyAbility(new DamageTargetEffect(7), -9);§ability.addTarget(new TargetPlayer());§ability.addEffect(new DiscardTargetEffect(7));§ability.addEffect(new SacrificeEffect(new FilterPermanent(), 7, "then"));§this.addAbility(ability);§}§public NicolBolasPlaneswalker(final NicolBolasPlaneswalker card) {§super(card);§}§@Override§public NicolBolasPlaneswalker copy() {§return new NicolBolasPlaneswalker(this);§}§}§
public class NobleHierarch extends CardImpl {§public NobleHierarch(UUID ownerId) {§super(ownerId, 87, "Noble Hierarch", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{G}");§this.expansionSetCode = "CON";§this.subtype.add("Human");§this.subtype.add("Druid");§this.power = new MageInt(0);§this.toughness = new MageInt(1);§this.addAbility(new ExaltedAbility());§this.addAbility(new GreenManaAbility());§this.addAbility(new WhiteManaAbility());§this.addAbility(new BlueManaAbility());§}§public NobleHierarch(final NobleHierarch card) {§super(card);§}§@Override§public NobleHierarch copy() {§return new NobleHierarch(this);§}§}§
public class Nyxathid extends CardImpl {§public Nyxathid(UUID ownerId) {§super(ownerId, 49, "Nyxathid", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{B}{B}");§this.expansionSetCode = "CON";§this.subtype.add("Elemental");§this.power = new MageInt(7);§this.toughness = new MageInt(7);§this.addAbility(new AsEntersBattlefieldAbility(new ChooseOpponentEffect(Outcome.Detriment)));§DynamicValue chosenPlayerHand = new SignInversionDynamicValue(new CardsInChosenPlayerHandCount());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostSourceEffect(chosenPlayerHand, chosenPlayerHand, Duration.WhileOnBattlefield)));§}§public Nyxathid(final Nyxathid card) {§super(card);§}§@Override§public Nyxathid copy() {§return new Nyxathid(this);§}§}§class CardsInChosenPlayerHandCount implements DynamicValue {§@Override§public int calculate(Game game, Ability sourceAbility, Effect effect) {§if (sourceAbility != null) {§UUID playerId = (UUID) game.getState().getValue(sourceAbility.getSourceId() + ChooseOpponentEffect.VALUE_KEY);§Player chosenPlayer = game.getPlayer(playerId);§if (chosenPlayer != null) {§return chosenPlayer.getHand().size();§}§}§return 0;§}§@Override§public DynamicValue copy() {§return new CardsInChosenPlayerHandCount();§}§@Override§public String getMessage() {§return "cards in chosen opponents hand";§}§@Override§public String toString() {§return "1";§}§}§
public class ObeliskOfAlara extends CardImpl {§public ObeliskOfAlara(UUID ownerId) {§super(ownerId, 140, "Obelisk of Alara", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{6}");§this.expansionSetCode = "CON";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainLifeEffect(5), new ManaCostsImpl("{1}{W}"));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DrawDiscardControllerEffect(), new ManaCostsImpl("{1}{U}"));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostTargetEffect(-2, -2, Duration.EndOfTurn), new ManaCostsImpl("{1}{B}"));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(3), new ManaCostsImpl("{1}{R}"));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostTargetEffect(4, 4, Duration.EndOfTurn), new ManaCostsImpl("{1}{G}"));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public ObeliskOfAlara(final ObeliskOfAlara card) {§super(card);§}§@Override§public ObeliskOfAlara copy() {§return new ObeliskOfAlara(this);§}§}§
public class Paleoloth extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("another creature with power 5 or greater");§static {§filter.add(new PowerPredicate(Filter.ComparisonType.GreaterThan, 4));§filter.add(new AnotherPredicate());§}§private static final String rule = "Whenever another creature with power 5 or greater enters the battlefield under your control, you may return target creature card from your graveyard to your hand.";§public Paleoloth(UUID ownerId) {§super(ownerId, 88, "Paleoloth", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{G}{G}");§this.expansionSetCode = "CON";§this.subtype.add("Beast");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§Ability ability = new EntersBattlefieldControlledTriggeredAbility(Zone.BATTLEFIELD, new ReturnFromGraveyardToHandTargetEffect(), filter, true, rule);§ability.addTarget(new TargetCardInYourGraveyard(new FilterCreatureCard()));§this.addAbility(ability);§}§public Paleoloth(final Paleoloth card) {§super(card);§}§@Override§public Paleoloth copy() {§return new Paleoloth(this);§}§}§
public class ParagonOfTheAmesha extends CardImpl {§public ParagonOfTheAmesha(UUID ownerId) {§super(ownerId, 14, "Paragon of the Amesha", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "CON";§this.subtype.add("Human");§this.subtype.add("Knight");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FirstStrikeAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ParagonOfTheAmeshaEffect(), new ManaCostsImpl("{W}{U}{B}{R}{G}"));§Effect effect = new BoostSourceEffect(3, 3, Duration.EndOfTurn);§effect.setText("gets +3/+3,");§ability.addEffect(effect);§effect = new GainAbilitySourceEffect(FlyingAbility.getInstance(), Duration.EndOfTurn);§effect.setText("and gains flying");§ability.addEffect(effect);§effect = new GainAbilitySourceEffect(LifelinkAbility.getInstance(), Duration.EndOfTurn);§effect.setText("and lifelink");§ability.addEffect(effect);§this.addAbility(ability);§}§public ParagonOfTheAmesha(final ParagonOfTheAmesha card) {§super(card);§}§@Override§public ParagonOfTheAmesha copy() {§return new ParagonOfTheAmesha(this);§}§private class ParagonOfTheAmeshaEffect extends ContinuousEffectImpl {§public ParagonOfTheAmeshaEffect() {§super(Duration.EndOfTurn, Outcome.BecomeCreature);§setText();§}§public ParagonOfTheAmeshaEffect(final ParagonOfTheAmeshaEffect effect) {§super(effect);§}§@Override§public ParagonOfTheAmeshaEffect copy() {§return new ParagonOfTheAmeshaEffect(this);§}§@Override§public boolean apply(Layer layer, SubLayer sublayer, Ability source, Game game) {§Permanent permanent = game.getPermanent(source.getSourceId());§if (permanent == null) {§return false;§}§switch (layer) {§case TypeChangingEffects_4:§if (sublayer == SubLayer.NA) {§permanent.getSubtype().clear();§permanent.getSubtype().add("Angel");§}§break;§}§return true;§}§@Override§public boolean apply(Game game, Ability source) {§return false;§}§private void setText() {§staticText = "Until end of turn, {this} becomes an Angel, ";§}§@Override§public boolean hasLayer(Layer layer) {§return layer == Layer.TypeChangingEffects_4;§}§}§}§
public class ParasiticStrix extends CardImpl {§public ParasiticStrix(UUID ownerId) {§super(ownerId, 32, "Parasitic Strix", Rarity.COMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{2}{U}");§this.expansionSetCode = "CON";§this.subtype.add("Bird");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new ParasiticStrixTriggeredAbility());§}§public ParasiticStrix(final ParasiticStrix card) {§super(card);§}§@Override§public ParasiticStrix copy() {§return new ParasiticStrix(this);§}§}§class ParasiticStrixTriggeredAbility extends TriggeredAbilityImpl {§public ParasiticStrixTriggeredAbility() {§super(Zone.BATTLEFIELD, new LoseLifeTargetEffect(2));§this.addEffect(new GainLifeEffect(2));§this.addTarget(new TargetPlayer());§}§public ParasiticStrixTriggeredAbility(final ParasiticStrixTriggeredAbility ability) {§super(ability);§}§@Override§public ParasiticStrixTriggeredAbility copy() {§return new ParasiticStrixTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.ENTERS_THE_BATTLEFIELD;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§return event.getTargetId().equals(this.getSourceId());§}§@Override§public boolean checkInterveningIfClause(Game game) {§FilterPermanent filter = new FilterPermanent();§filter.add(new ColorPredicate(ObjectColor.BLACK));§if (game.getBattlefield().countAll(filter, this.controllerId, game) >= 1) {§return true;§}§return false;§}§@Override§public String getRule() {§return "When Parasitic Strix enters the battlefield, if you control a black permanent, target player loses 2 life and you gain 2 life.";§}§}§
public class PathToExile extends CardImpl {§public PathToExile(UUID ownerId) {§super(ownerId, 15, "Path to Exile", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{W}");§this.expansionSetCode = "CON";§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.getSpellAbility().addEffect(new PathToExileEffect());§}§public PathToExile(final PathToExile card) {§super(card);§}§@Override§public PathToExile copy() {§return new PathToExile(this);§}§}§class PathToExileEffect extends OneShotEffect {§public PathToExileEffect() {§super(Outcome.Exile);§staticText = "Exile target creature. Its controller may search his or her library for a basic land card, put that card onto the battlefield tapped, then shuffle his or her library";§}§public PathToExileEffect(final PathToExileEffect effect) {§super(effect);§}§@Override§public PathToExileEffect copy() {§return new PathToExileEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§Permanent permanent = game.getPermanent(source.getFirstTarget());§if (controller != null && permanent != null) {§Player player = game.getPlayer(permanent.getControllerId());§controller.moveCardToExileWithInfo(permanent, null, "", source.getSourceId(), game, Zone.BATTLEFIELD, true);§if (player.chooseUse(Outcome.PutCardInPlay, "Search your library for a basic land card?", source, game)) {§TargetCardInLibrary target = new TargetCardInLibrary(new FilterBasicLandCard());§if (player.searchLibrary(target, game)) {§Card card = player.getLibrary().getCard(target.getFirstTarget(), game);§if (card != null) {§player.moveCards(card, Zone.BATTLEFIELD, source, game, true, false, false, null);§}§}§player.shuffleLibrary(game);§}§return true;§}§return false;§}§}§
public class PestilentKathari extends CardImpl {§public PestilentKathari(UUID ownerId) {§super(ownerId, 50, "Pestilent Kathari", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{B}");§this.expansionSetCode = "CON";§this.subtype.add("Bird");§this.subtype.add("Warrior");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(DeathtouchAbility.getInstance());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilitySourceEffect(FirstStrikeAbility.getInstance(), Duration.EndOfTurn), new ManaCostsImpl("{2}{R}")));§}§public PestilentKathari(final PestilentKathari card) {§super(card);§}§@Override§public PestilentKathari copy() {§return new PestilentKathari(this);§}§}§
public class Progenitus extends CardImpl {§public Progenitus(UUID ownerId) {§super(ownerId, 121, "Progenitus", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{W}{W}{U}{U}{B}{B}{R}{R}{G}{G}");§this.expansionSetCode = "CON";§this.supertype.add("Legendary");§this.subtype.add("Hydra");§this.subtype.add("Avatar");§this.power = new MageInt(10);§this.toughness = new MageInt(10);§this.addAbility(new ProgenitusProtectionAbility());§this.addAbility(new PutIntoGraveFromAnywhereSourceAbility(new RevealAndShuffleIntoLibrarySourceEffect()));§}§public Progenitus(final Progenitus card) {§super(card);§}§@Override§public Progenitus copy() {§return new Progenitus(this);§}§}§class ProgenitusProtectionAbility extends ProtectionAbility {§public ProgenitusProtectionAbility() {§super(new FilterCard("everything"));§}§public ProgenitusProtectionAbility(final ProgenitusProtectionAbility ability) {§super(ability);§}§@Override§public ProgenitusProtectionAbility copy() {§return new ProgenitusProtectionAbility(this);§}§@Override§public String getRule() {§return "Protection from everything";§}§@Override§public boolean canTarget(MageObject source, Game game) {§return false;§}§}§
public class QuenchableFire extends CardImpl {§public QuenchableFire(UUID ownerId) {§super(ownerId, 70, "Quenchable Fire", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{3}{R}");§this.expansionSetCode = "CON";§this.getSpellAbility().addTarget(new TargetPlayer());§this.getSpellAbility().addEffect(new DamageTargetEffect(3));§this.getSpellAbility().addEffect(new UnlessPaysDelayedEffect(new ManaCostsImpl("{U}"),§new DamageTargetEffect(3, true, "that player"), PhaseStep.UPKEEP, false,§"It deals an additional 3 damage to that player at the beginning of your next upkeep step unless he or she pays {U} before that step."));§}§public QuenchableFire(final QuenchableFire card) {§super(card);§}§@Override§public QuenchableFire copy() {§return new QuenchableFire(this);§}§}§
public class RakkaMar extends CardImpl {§private static ElementalToken token = new ElementalToken();§public RakkaMar(UUID ownerId) {§super(ownerId, 71, "Rakka Mar", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{R}{R}");§this.expansionSetCode = "CON";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Shaman");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(HasteAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new CreateTokenEffect(token), new ManaCostsImpl("{R}"));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§}§public RakkaMar(final RakkaMar card) {§super(card);§}§@Override§public RakkaMar copy() {§return new RakkaMar(this);§}§}§class ElementalToken extends Token {§public ElementalToken() {§super("Elemental", "3/1 red Elemental creature with Haste");§cardType.add(CardType.CREATURE);§color.setRed(true);§subtype.add("Elemental");§power = new MageInt(3);§toughness = new MageInt(1);§addAbility(HasteAbility.getInstance());§}§}§
public class ReliquaryTower extends CardImpl {§public ReliquaryTower(UUID ownerId) {§super(ownerId, 143, "Reliquary Tower", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "CON";§Effect effect = new MaximumHandSizeControllerEffect(Integer.MAX_VALUE, Duration.WhileOnBattlefield, HandSizeModification.SET);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, effect));§this.addAbility(new ColorlessManaAbility());§}§public ReliquaryTower(final ReliquaryTower card) {§super(card);§}§@Override§public ReliquaryTower copy() {§return new ReliquaryTower(this);§}§}§
public class RottingRats extends CardImpl {§public RottingRats (UUID ownerId) {§super(ownerId, 51, "Rotting Rats", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{B}");§this.expansionSetCode = "CON";§this.subtype.add("Zombie");§this.subtype.add("Rat");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new EntersBattlefieldTriggeredAbility(new DiscardEachPlayerEffect()));§this.addAbility(new UnearthAbility(new ManaCostsImpl("{1}{B}")));§}§public RottingRats (final RottingRats card) {§super(card);§}§@Override§public RottingRats copy() {§return new RottingRats(this);§}§}§
public class RuptureSpire extends CardImpl {§public RuptureSpire (UUID ownerId) {§super(ownerId, 144, "Rupture Spire", Rarity.COMMON, new CardType[]{CardType.LAND}, null);§this.expansionSetCode = "CON";§this.addAbility(new EntersBattlefieldTappedAbility());§this.addAbility(new EntersBattlefieldTriggeredAbility(new SacrificeSourceUnlessPaysEffect(new ManaCostsImpl("{1}")), false));§this.addAbility(new AnyColorManaAbility());§}§public RuptureSpire (final RuptureSpire card) {§super(card);§}§@Override§public RuptureSpire copy() {§return new RuptureSpire(this);§}§}§
public class SacellumArchers extends CardImpl {§public SacellumArchers(UUID ownerId) {§super(ownerId, 89, "Sacellum Archers", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{G}");§this.expansionSetCode = "CON";§this.subtype.add("Elf");§this.subtype.add("Archer");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(2), new ManaCostsImpl("{R}{W}"));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetAttackingOrBlockingCreature());§this.addAbility(ability);§}§public SacellumArchers(final SacellumArchers card) {§super(card);§}§@Override§public SacellumArchers copy() {§return new SacellumArchers(this);§}§}§
public class SalvageSlasher extends CardImpl {§public SalvageSlasher(UUID ownerId) {§super(ownerId, 52, "Salvage Slasher", Rarity.COMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{1}{B}");§this.expansionSetCode = "CON";§this.subtype.add("Human");§this.subtype.add("Rogue");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§BoostSourceEffect effect = new BoostSourceEffect(new CardsInControllerGraveyardCount(new FilterArtifactCard()),§new StaticValue(0),§Duration.WhileOnBattlefield);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, effect));§}§public SalvageSlasher(final SalvageSlasher card) {§super(card);§}§@Override§public SalvageSlasher copy() {§return new SalvageSlasher(this);§}§}§
public class ScarlandThrinax extends CardImpl {§public ScarlandThrinax(UUID ownerId) {§super(ownerId, 123, "Scarland Thrinax", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{B}{R}{G}");§this.expansionSetCode = "CON";§this.subtype.add("Lizard");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new AddCountersSourceEffect(CounterType.P1P1.createInstance()), new ManaCostsImpl());§ability.addCost(new SacrificeTargetCost(new TargetControlledCreaturePermanent()));§this.addAbility(ability);§}§public ScarlandThrinax(final ScarlandThrinax card) {§super(card);§}§@Override§public ScarlandThrinax copy() {§return new ScarlandThrinax(this);§}§}§
public class ScattershotArcher extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature with flying");§static {§filter.add(new AbilityPredicate(FlyingAbility.class));§}§public ScattershotArcher(UUID ownerId) {§super(ownerId, 90, "Scattershot Archer", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{G}");§this.expansionSetCode = "CON";§this.subtype.add("Elf");§this.subtype.add("Archer");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageAllEffect(1, filter), new TapSourceCost()));§}§public ScattershotArcher(final ScattershotArcher card) {§super(card);§}§@Override§public ScattershotArcher copy() {§return new ScattershotArcher(this);§}§}§
public class ScepterOfDominance extends CardImpl {§public ScepterOfDominance(UUID ownerId) {§super(ownerId, 17, "Scepter of Dominance", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{1}{W}{W}");§this.expansionSetCode = "CON";§SimpleActivatedAbility ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new TapTargetEffect(), new ManaCostsImpl("{W}"));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetPermanent());§this.addAbility(ability);§}§public ScepterOfDominance(ScepterOfDominance card) {§super(card);§}§@Override§public ScepterOfDominance copy() {§return new ScepterOfDominance(this);§}§}§
public class ScepterOfFugue extends CardImpl {§public ScepterOfFugue(UUID ownerId) {§super(ownerId, 53, "Scepter of Fugue", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{B}{B}");§this.expansionSetCode = "CON";§Ability ability = new ActivateIfConditionActivatedAbility(Zone.BATTLEFIELD, new DiscardTargetEffect(1), new ManaCostsImpl("{1}{B}"), MyTurnCondition.getInstance());§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§}§public ScepterOfFugue(final ScepterOfFugue card) {§super(card);§}§@Override§public ScepterOfFugue copy() {§return new ScepterOfFugue(this);§}§}§
public class ScepterOfInsight extends CardImpl {§public ScepterOfInsight(UUID ownerId) {§super(ownerId, 33, "Scepter of Insight", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{1}{U}{U}");§this.expansionSetCode = "CON";§SimpleActivatedAbility ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DrawCardSourceControllerEffect(1), new ManaCostsImpl("{3}{U}"));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§}§public ScepterOfInsight(final ScepterOfInsight card) {§super(card);§}§@Override§public ScepterOfInsight copy() {§return new ScepterOfInsight(this);§}§}§
public class ScornfulAEtherLich extends CardImpl {§public ScornfulAEtherLich(UUID ownerId) {§super(ownerId, 34, "Scornful AEther-Lich", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{3}{U}");§this.expansionSetCode = "CON";§this.subtype.add("Zombie");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(4);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilitySourceEffect(FearAbility.getInstance(), Duration.EndOfTurn), new ManaCostsImpl("{W}{B}"));§ability.addEffect(new GainAbilitySourceEffect(VigilanceAbility.getInstance(), Duration.EndOfTurn));§this.addAbility(ability);§}§public ScornfulAEtherLich(final ScornfulAEtherLich card) {§super(card);§}§@Override§public ScornfulAEtherLich copy() {§return new ScornfulAEtherLich(this);§}§}§
public class SedraxisAlchemist extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("blue permanent");§static {§filter.add(new ColorPredicate(ObjectColor.BLUE));§}§private static final String rule = "When {this} enters the battlefield, if you control a blue permanent, return target nonland permanent to its owner's hand.";§public SedraxisAlchemist(UUID ownerId) {§super(ownerId, 54, "Sedraxis Alchemist", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{B}");§this.expansionSetCode = "CON";§this.subtype.add("Zombie");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§TriggeredAbility ability = new EntersBattlefieldTriggeredAbility(new ReturnToHandTargetEffect(), false);§ability.addTarget(new TargetNonlandPermanent());§this.addAbility(new ConditionalTriggeredAbility(ability, new PermanentsOnTheBattlefieldCondition(filter), rule));§}§public SedraxisAlchemist(final SedraxisAlchemist card) {§super(card);§}§@Override§public SedraxisAlchemist copy() {§return new SedraxisAlchemist(this);§}§}§
public class ShamblingRemains extends CardImpl {§public ShamblingRemains(UUID ownerId) {§super(ownerId, 124, "Shambling Remains", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{B}{R}");§this.expansionSetCode = "CON";§this.subtype.add("Zombie");§this.subtype.add("Horror");§this.power = new MageInt(4);§this.toughness = new MageInt(3);§this.addAbility(new CantBlockAbility());§this.addAbility(new UnearthAbility(new ManaCostsImpl("{B}{R}")));§}§public ShamblingRemains(final ShamblingRemains card) {§super(card);§}§@Override§public ShamblingRemains copy() {§return new ShamblingRemains(this);§}§}§
public class ShardConvergence extends CardImpl {§public ShardConvergence(UUID ownerId) {§super(ownerId, 91, "Shard Convergence", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{3}{G}");§this.expansionSetCode = "CON";§this.getSpellAbility().addEffect(new ShardConvergenceEffect());§}§public ShardConvergence(final ShardConvergence card) {§super(card);§}§@Override§public ShardConvergence copy() {§return new ShardConvergence(this);§}§}§class ShardConvergenceEffect extends OneShotEffect {§ShardConvergenceEffect() {§super(Outcome.DrawCard);§staticText = "Search your library for a Plains card, an Island card, a Swamp card, and a Mountain card. Reveal those cards and put them into your hand. Then shuffle your library";§}§ShardConvergenceEffect(final ShardConvergenceEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player == null) {§return false;§}§Cards cards = new CardsImpl();§searchLand(player, source, game, cards, "Plains");§searchLand(player, source, game, cards, "Island");§searchLand(player, source, game, cards, "Swamp");§searchLand(player, source, game, cards, "Mountain");§player.revealCards("Shard Convergence", cards, game);§player.shuffleLibrary(game);§return true;§}§private void searchLand(Player player, Ability source, Game game, Cards cards, String subtype) {§FilterLandCard filter = new FilterLandCard(subtype);§filter.add(new SubtypePredicate(subtype));§TargetCardInLibrary target = new TargetCardInLibrary(filter);§if (player.searchLibrary(target, game)) {§Card card = player.getLibrary().remove(target.getFirstTarget(), game);§if (card != null) {§card.moveToZone(Zone.HAND, source.getSourceId(), game, false);§cards.add(card);§}§}§}§@Override§public ShardConvergenceEffect copy() {§return new ShardConvergenceEffect(this);§}§}§
public class SigilOfTheEmptyThrone extends CardImpl {§private static final FilterSpell filter = new FilterSpell("an enchantment spell");§static {§filter.add(new CardTypePredicate(CardType.ENCHANTMENT));§}§public SigilOfTheEmptyThrone(UUID ownerId) {§super(ownerId, 18, "Sigil of the Empty Throne", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{3}{W}{W}");§this.expansionSetCode = "CON";§this.addAbility(new SpellCastControllerTriggeredAbility(new CreateTokenEffect(new AngelToken()), filter, false));§}§public SigilOfTheEmptyThrone(final SigilOfTheEmptyThrone card) {§super(card);§}§@Override§public SigilOfTheEmptyThrone copy() {§return new SigilOfTheEmptyThrone(this);§}§}§
public class SkywardEyeProphets extends CardImpl {§public SkywardEyeProphets(UUID ownerId) {§super(ownerId, 125, "Skyward Eye Prophets", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{G}{W}{U}");§this.expansionSetCode = "CON";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(VigilanceAbility.getInstance());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new SkywardEyeProphetsEffect(), new TapSourceCost()));§}§public SkywardEyeProphets(final SkywardEyeProphets card) {§super(card);§}§@Override§public SkywardEyeProphets copy() {§return new SkywardEyeProphets(this);§}§public static class SkywardEyeProphetsEffect extends OneShotEffect {§public SkywardEyeProphetsEffect() {§super(Outcome.DrawCard);§this.staticText = "Reveal the top card of your library. If it's a land card, put it onto the battlefield. Otherwise, put it into your hand";§}§public SkywardEyeProphetsEffect(final SkywardEyeProphetsEffect effect) {§super(effect);§}§@Override§public SkywardEyeProphetsEffect copy() {§return new SkywardEyeProphetsEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§MageObject sourceObject = game.getObject(source.getSourceId());§if (sourceObject == null || controller == null) {§return false;§}§if (controller.getLibrary().size() > 0) {§CardsImpl cards = new CardsImpl();§Card card = controller.getLibrary().getFromTop(game);§if (card == null) {§return false;§}§cards.add(card);§controller.revealCards(sourceObject.getName(), cards, game);§if (card.getCardType().contains(CardType.LAND)) {§return controller.moveCards(card, Zone.BATTLEFIELD, source, game);§} else {§controller.moveCards(card, Zone.HAND, source, game);§}§}§return true;§}§}§}§
public class SludgeStrider extends CardImpl {§public SludgeStrider(UUID ownerId) {§super(ownerId, 126, "Sludge Strider", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{1}{W}{U}{B}");§this.expansionSetCode = "CON";§this.subtype.add("Insect");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§Ability ability = new SludgeStriderTriggeredAbility();§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§}§public SludgeStrider(final SludgeStrider card) {§super(card);§}§@Override§public SludgeStrider copy() {§return new SludgeStrider(this);§}§}§class SludgeStriderTriggeredAbility extends TriggeredAbilityImpl {§private static final FilterArtifactCard filter = new FilterArtifactCard("another artifact under your control");§static {§filter.add(new ControllerPredicate(TargetController.YOU));§filter.add(new AnotherPredicate());§}§public SludgeStriderTriggeredAbility() {§super(Zone.BATTLEFIELD, new DoIfCostPaid(new SludgeStriderEffect(), new GenericManaCost(1)), false);§}§public SludgeStriderTriggeredAbility(final SludgeStriderTriggeredAbility ability) {§super(ability);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.ENTERS_THE_BATTLEFIELD || event.getType() == EventType.ZONE_CHANGE;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (event.getType() == GameEvent.EventType.ENTERS_THE_BATTLEFIELD) {§Permanent permanent = game.getPermanent(event.getTargetId());§if (permanent != null && filter.match(permanent, getSourceId(), getControllerId(), game)) {§return true;§}§}§if (event.getType() == GameEvent.EventType.ZONE_CHANGE) {§ZoneChangeEvent zEvent = (ZoneChangeEvent) event;§if (zEvent.getFromZone() == Zone.BATTLEFIELD) {§UUID targetId = event.getTargetId();§Permanent permanent = game.getPermanent(targetId);§if (permanent == null) {§permanent = (Permanent) game.getLastKnownInformation(targetId, Zone.BATTLEFIELD);§}§if (permanent != null && filter.match(permanent, getSourceId(), getControllerId(), game)) {§return true;§}§}§}§return false;§}§@Override§public SludgeStriderTriggeredAbility copy() {§return new SludgeStriderTriggeredAbility(this);§}§@Override§public String getRule() {§return "Whenever another artifact enters the battlefield under your control or another artifact you control leaves the battlefield, you may pay {1}. If you do, target player loses 1 life and you gain 1 life.";§}§}§class SludgeStriderEffect extends OneShotEffect {§SludgeStriderEffect() {§super(Outcome.Detriment);§staticText = "target player loses 1 life and you gain 1 life";§}§SludgeStriderEffect(final SludgeStriderEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player targetPlayer = game.getPlayer(source.getFirstTarget());§Player you = game.getPlayer(source.getControllerId());§if (targetPlayer != null) {§targetPlayer.loseLife(1, game);§}§if (you != null) {§you.gainLife(1, game);§}§return true;§}§@Override§public SludgeStriderEffect copy() {§return new SludgeStriderEffect(this);§}§}§
public class SoulsMajesty extends CardImpl {§public SoulsMajesty(UUID ownerId) {§super(ownerId, 92, "Soul's Majesty", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{4}{G}");§this.expansionSetCode = "CON";§this.getSpellAbility().addTarget(new TargetControlledCreaturePermanent());§this.getSpellAbility().addEffect(new SoulsMajestyEffect());§}§public SoulsMajesty(final SoulsMajesty card) {§super(card);§}§@Override§public SoulsMajesty copy() {§return new SoulsMajesty(this);§}§private class SoulsMajestyEffect extends OneShotEffect {§public SoulsMajestyEffect() {§super(Outcome.DrawCard);§staticText = "Draw cards equal to the power of target creature you control";§}§public SoulsMajestyEffect(final SoulsMajestyEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent target = game.getPermanent(source.getFirstTarget());§Player player = game.getPlayer(source.getControllerId());§if (player != null && target != null) {§player.drawCards(target.getPower().getValue(), game);§return true;§}§return false;§}§@Override§public SoulsMajestyEffect copy() {§return new SoulsMajestyEffect(this);§}§}§}§
public class SphinxSummoner extends CardImpl {§private static final FilterCard filter = new FilterCard("artifact creature card");§static {§filter.add(Predicates.and(new CardTypePredicate(CardType.ARTIFACT), new CardTypePredicate(CardType.CREATURE)));§}§public SphinxSummoner(UUID ownerId) {§super(ownerId, 127, "Sphinx Summoner", Rarity.RARE, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{3}{U}{B}");§this.expansionSetCode = "CON";§this.subtype.add("Sphinx");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new EntersBattlefieldTriggeredAbility(new SearchLibraryPutInHandEffect(new TargetCardInLibrary(filter), true, false), true));§}§public SphinxSummoner(final SphinxSummoner card) {§super(card);§}§@Override§public SphinxSummoner copy() {§return new SphinxSummoner(this);§}§}§
public class SylvanBounty extends CardImpl {§public SylvanBounty(UUID ownerId) {§super(ownerId, 94, "Sylvan Bounty", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{5}{G}");§this.expansionSetCode = "CON";§this.getSpellAbility().addEffect(new GainLifeTargetEffect(8));§this.getSpellAbility().addTarget(new TargetPlayer());§this.addAbility(new BasicLandcyclingAbility(new ManaCostsImpl("{1}{G}")));§}§public SylvanBounty(final SylvanBounty card) {§super(card);§}§@Override§public SylvanBounty copy() {§return new SylvanBounty(this);§}§}§
public class TeleminPerformance extends CardImpl {§public TeleminPerformance(UUID ownerId) {§super(ownerId, 35, "Telemin Performance", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{3}{U}{U}");§this.expansionSetCode = "CON";§this.getSpellAbility().addEffect(new TeleminPerformanceEffect());§this.getSpellAbility().addTarget(new TargetOpponent());§}§public TeleminPerformance(final TeleminPerformance card) {§super(card);§}§@Override§public TeleminPerformance copy() {§return new TeleminPerformance(this);§}§}§class TeleminPerformanceEffect extends OneShotEffect {§public TeleminPerformanceEffect() {§super(Outcome.PutCreatureInPlay);§this.staticText = "Target opponent reveals cards from the top of his or her library until he or she reveals a creature card. That player puts all noncreature cards revealed this way into his or her graveyard, then you put the creature card onto the battlefield under your control";§}§public TeleminPerformanceEffect(final TeleminPerformanceEffect effect) {§super(effect);§}§@Override§public TeleminPerformanceEffect copy() {§return new TeleminPerformanceEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Card creature = null;§Player opponent = game.getPlayer(source.getFirstTarget());§CardsImpl cards = new CardsImpl();§boolean creatureFound = false;§while (opponent.getLibrary().size() > 0 && !creatureFound) {§Card card = opponent.getLibrary().removeFromTop(game);§if (card != null) {§if (card.getCardType().contains(CardType.CREATURE)) {§creature = card;§creatureFound = true;§}§if (!creatureFound) {§cards.add(card);§}§}§}§if (!cards.isEmpty()) {§opponent.revealCards("Telemin Performance", cards, game);§opponent.moveCards(cards, Zone.LIBRARY, Zone.GRAVEYARD, source, game);§}§if (creature != null) {§return creature.putOntoBattlefield(game, Zone.LIBRARY, source.getSourceId(), source.getControllerId());§}§return false;§}§}§
public class Thornling extends CardImpl {§public Thornling(UUID ownerId) {§super(ownerId, 95, "Thornling", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{3}{G}{G}");§this.expansionSetCode = "CON";§this.subtype.add("Elemental");§this.subtype.add("Shapeshifter");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilitySourceEffect(HasteAbility.getInstance(), Duration.EndOfTurn), new ManaCostsImpl("{G}")));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilitySourceEffect(TrampleAbility.getInstance(), Duration.EndOfTurn), new ManaCostsImpl("{G}")));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilitySourceEffect(IndestructibleAbility.getInstance(), Duration.EndOfTurn), new ManaCostsImpl("{G}")));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(1, -1, Duration.EndOfTurn), new ManaCostsImpl("{1}")));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(-1, 1, Duration.EndOfTurn), new ManaCostsImpl("{1}")));§}§public Thornling(final Thornling card) {§super(card);§}§@Override§public Thornling copy() {§return new Thornling(this);§}§}§
public class ToxicIguanar extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("green");§static {§filter.add(new ColorPredicate(ObjectColor.GREEN));§}§public ToxicIguanar(UUID ownerId) {§super(ownerId, 72, "Toxic Iguanar", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{R}");§this.expansionSetCode = "CON";§this.subtype.add("Lizard");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD,§new ConditionalContinuousEffect(new GainAbilitySourceEffect(DeathtouchAbility.getInstance(), Duration.WhileOnBattlefield),§new PermanentsOnTheBattlefieldCondition(filter), "{this} has deathtouch as long as you control a green permanent")));§}§public ToxicIguanar(final ToxicIguanar card) {§super(card);§}§@Override§public ToxicIguanar copy() {§return new ToxicIguanar(this);§}§}§
public class TraumaticVisions extends CardImpl {§public TraumaticVisions(UUID ownerId) {§super(ownerId, 36, "Traumatic Visions", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{3}{U}{U}");§this.expansionSetCode = "CON";§this.getSpellAbility().addTarget(new TargetSpell());§this.getSpellAbility().addEffect(new CounterTargetEffect());§this.addAbility(new BasicLandcyclingAbility(new ManaCostsImpl("{1}{U}")));§}§public TraumaticVisions(final TraumaticVisions card) {§super(card);§}§@Override§public TraumaticVisions copy() {§return new TraumaticVisions(this);§}§}§
public class TukatongueThallid extends CardImpl {§public TukatongueThallid(UUID ownerId) {§super(ownerId, 96, "Tukatongue Thallid", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{G}");§this.expansionSetCode = "CON";§this.subtype.add("Fungus");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new DiesTriggeredAbility(new CreateTokenEffect(new SaprolingToken()), false));§}§public TukatongueThallid(final TukatongueThallid card) {§super(card);§}§@Override§public TukatongueThallid copy() {§return new TukatongueThallid(this);§}§}§
public class UnstableFrontier extends CardImpl {§public UnstableFrontier(UUID ownerId) {§super(ownerId, 145, "Unstable Frontier", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "CON";§this.addAbility(new ColorlessManaAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BecomesBasicLandTargetEffect(Duration.EndOfTurn), new TapSourceCost());§Target target = new TargetControlledPermanent(new FilterControlledLandPermanent());§ability.addTarget(target);§this.addAbility(ability);§}§public UnstableFrontier(final UnstableFrontier card) {§super(card);§}§@Override§public UnstableFrontier copy() {§return new UnstableFrontier(this);§}§}§
public class VagrantPlowbeasts extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature with power 5 or greater");§static {§filter.add(new PowerPredicate(ComparisonType.GreaterThan, 4));§}§public VagrantPlowbeasts(UUID ownerId) {§super(ownerId, 129, "Vagrant Plowbeasts", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{5}{G}{W}");§this.expansionSetCode = "CON";§this.subtype.add("Beast");§this.power = new MageInt(6);§this.toughness = new MageInt(6);§SimpleActivatedAbility ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,§new RegenerateTargetEffect(),§new ManaCostsImpl("{1}"));§ability.addTarget(new TargetCreaturePermanent(filter));§this.addAbility(ability);§}§public VagrantPlowbeasts(final VagrantPlowbeasts card) {§super(card);§}§@Override§public VagrantPlowbeasts copy() {§return new VagrantPlowbeasts(this);§}§}§
public class ValeronOutlander extends CardImpl {§private static final FilterCard filter = new FilterCard("black");§static {§filter.add(new ColorPredicate(ObjectColor.BLACK));§}§public ValeronOutlander(UUID ownerId) {§super(ownerId, 130, "Valeron Outlander", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{G}{W}");§this.expansionSetCode = "CON";§this.subtype.add("Human");§this.subtype.add("Scout");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new ProtectionAbility(filter));§}§public ValeronOutlander(final ValeronOutlander card) {§super(card);§}§@Override§public ValeronOutlander copy() {§return new ValeronOutlander(this);§}§}§
public class ValiantGuard extends CardImpl {§public ValiantGuard(UUID ownerId) {§super(ownerId, 19, "Valiant Guard", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{W}");§this.expansionSetCode = "CON";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(0);§this.toughness = new MageInt(3);§}§public ValiantGuard(final ValiantGuard card) {§super(card);§}§@Override§public ValiantGuard copy() {§return new ValiantGuard(this);§}§}§
public class VectisAgents extends CardImpl {§public VectisAgents(UUID ownerId) {§super(ownerId, 131, "Vectis Agents", Rarity.COMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{3}{U}{B}");§this.expansionSetCode = "CON";§this.subtype.add("Human");§this.subtype.add("Rogue");§this.power = new MageInt(4);§this.toughness = new MageInt(3);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,§new BoostSourceEffect(-2, -0, Duration.EndOfTurn),§new ManaCostsImpl("{U}{B}"));§ability.addEffect(new CantBeBlockedSourceEffect(Duration.EndOfTurn));§this.addAbility(ability);§}§public VectisAgents(final VectisAgents card) {§super(card);§}§@Override§public VectisAgents copy() {§return new VectisAgents(this);§}§}§
public class VedalkenOutlander extends CardImpl {§private static final FilterCard filter = new FilterCard("red");§static {§filter.add(new ColorPredicate(ObjectColor.RED));§}§public VedalkenOutlander(UUID ownerId) {§super(ownerId, 132, "Vedalken Outlander", Rarity.COMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{W}{U}");§this.expansionSetCode = "CON";§this.subtype.add("Vedalken");§this.subtype.add("Scout");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new ProtectionAbility(filter));§}§public VedalkenOutlander(final VedalkenOutlander card) {§super(card);§}§@Override§public VedalkenOutlander copy() {§return new VedalkenOutlander(this);§}§}§
public class ViashinoSlaughtermaster extends CardImpl {§public ViashinoSlaughtermaster(UUID ownerId) {§super(ownerId, 73, "Viashino Slaughtermaster", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{R}");§this.expansionSetCode = "CON";§this.subtype.add("Viashino");§this.subtype.add("Warrior");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(DoubleStrikeAbility.getInstance());§this.addAbility(new LimitedTimesPerTurnActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(1, 1, Duration.EndOfTurn), new ManaCostsImpl("{B}{G}")));§}§public ViashinoSlaughtermaster(final ViashinoSlaughtermaster card) {§super(card);§}§@Override§public ViashinoSlaughtermaster copy() {§return new ViashinoSlaughtermaster(this);§}§}§
public class ViewFromAbove extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("white permanent you control");§static {§filter.add(new ColorPredicate(ObjectColor.WHITE));§}§public ViewFromAbove(UUID ownerId) {§super(ownerId, 38, "View from Above", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{1}{U}");§this.expansionSetCode = "CON";§this.getSpellAbility().addEffect(new GainAbilityTargetEffect(FlyingAbility.getInstance(), Duration.EndOfTurn));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.getSpellAbility().addEffect(new ConditionalOneShotEffect(§ReturnToHandSpellEffect.getInstance(),§new PermanentsOnTheBattlefieldCondition(filter),§"If you control a white permanent, return {this} to its owner's hand"));§}§public ViewFromAbove(final ViewFromAbove card) {§super(card);§}§@Override§public ViewFromAbove copy() {§return new ViewFromAbove(this);§}§}§
public class VoicesFromTheVoid extends CardImpl {§public VoicesFromTheVoid(UUID ownerId) {§super(ownerId, 55, "Voices from the Void", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{4}{B}");§this.expansionSetCode = "CON";§this.getSpellAbility().addEffect(new DiscardTargetEffect(new DomainValue()));§this.getSpellAbility().addTarget(new TargetPlayer());§}§public VoicesFromTheVoid(final VoicesFromTheVoid card) {§super(card);§}§@Override§public VoicesFromTheVoid copy() {§return new VoicesFromTheVoid(this);§}§}§
public class VolcanicFallout extends CardImpl {§public VolcanicFallout(UUID ownerId) {§super(ownerId, 74, "Volcanic Fallout", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{1}{R}{R}");§this.expansionSetCode = "CON";§this.addAbility(new CantBeCounteredAbility());§this.getSpellAbility().addEffect(new DamageEverythingEffect(2));§}§public VolcanicFallout(final VolcanicFallout card) {§super(card);§}§@Override§public VolcanicFallout copy() {§return new VolcanicFallout(this);§}§}§
public class VoraciousDragon extends CardImpl {§public VoraciousDragon(UUID ownerId) {§super(ownerId, 75, "Voracious Dragon", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{R}{R}");§this.expansionSetCode = "CON";§this.subtype.add("Dragon");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new DevourAbility(DevourFactor.Devour1));§Ability ability = new EntersBattlefieldTriggeredAbility(new DamageTargetEffect(new TwiceDevouredGoblins()), false);§ability.addTarget(new TargetCreatureOrPlayer());§this.addAbility(ability);§}§public VoraciousDragon(final VoraciousDragon card) {§super(card);§}§@Override§public VoraciousDragon copy() {§return new VoraciousDragon(this);§}§}§class TwiceDevouredGoblins implements DynamicValue {§@Override§public int calculate(Game game, Ability sourceAbility, Effect effect) {§Permanent sourcePermanent = game.getPermanent(sourceAbility.getSourceId());§if (sourcePermanent != null) {§for (Ability ability : sourcePermanent.getAbilities()) {§if (ability instanceof DevourAbility) {§for (Effect abilityEffect: ability.getEffects()) {§if (abilityEffect instanceof DevourEffect) {§DevourEffect devourEffect = (DevourEffect) abilityEffect;§int amountGoblins = 0;§for (ArrayList<String> subtypesItem :devourEffect.getSubtypes(game, sourcePermanent.getId())) {§if (subtypesItem.contains("Goblin")) {§++amountGoblins;§}§}§return amountGoblins *2;§}§}§}§}§}§return 0;§}§@Override§public TwiceDevouredGoblins copy() {§return new TwiceDevouredGoblins();§}§@Override§public String toString() {§return "";§}§@Override§public String getMessage() {§return "twice the number of Goblins it devoured";§}§}§
public class WallOfReverence extends CardImpl {§public WallOfReverence (UUID ownerId) {§super(ownerId, 20, "Wall of Reverence", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{W}");§this.expansionSetCode = "CON";§this.subtype.add("Spirit");§this.subtype.add("Wall");§this.power = new MageInt(1);§this.toughness = new MageInt(6);§this.addAbility(DefenderAbility.getInstance());§this.addAbility(FlyingAbility.getInstance());§Ability ability = new BeginningOfYourEndStepTriggeredAbility(new WallOfReverenceTriggeredEffect(), true);§ability.addTarget(new TargetControlledCreaturePermanent());§this.addAbility(ability);§}§public WallOfReverence (final WallOfReverence card) {§super(card);§}§@Override§public WallOfReverence copy() {§return new WallOfReverence(this);§}§}§class WallOfReverenceTriggeredEffect extends OneShotEffect {§WallOfReverenceTriggeredEffect() {§super(Outcome.GainLife);§staticText = "gain life equal to the power of target creature you control";§}§WallOfReverenceTriggeredEffect(WallOfReverenceTriggeredEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent target = game.getPermanent(source.getFirstTarget());§Player player = game.getPlayer(source.getControllerId());§if (target != null && player != null) {§player.gainLife(target.getPower().getValue(), game);§return true;§}§return false;§}§@Override§public WallOfReverenceTriggeredEffect copy() {§return new WallOfReverenceTriggeredEffect(this);§}§}§
public class WorldlyCounsel extends CardImpl {§public WorldlyCounsel(UUID ownerId) {§super(ownerId, 39, "Worldly Counsel", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{U}");§this.expansionSetCode = "CON";§this.getSpellAbility().addEffect(new WorldlyCounselEffect());§}§public WorldlyCounsel(final WorldlyCounsel card) {§super(card);§}§@Override§public WorldlyCounsel copy() {§return new WorldlyCounsel(this);§}§}§class WorldlyCounselEffect extends OneShotEffect {§public WorldlyCounselEffect() {§super(Outcome.DrawCard);§this.staticText = "<i>Domain</i> - Look at the top X cards of your library, where X is the number of basic land types among lands you control. Put one of those cards into your hand and the rest on the bottom of your library in any order";§}§public WorldlyCounselEffect(final WorldlyCounselEffect effect) {§super(effect);§}§@Override§public WorldlyCounselEffect copy() {§return new WorldlyCounselEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player == null) {§return false;§}§Cards cards = new CardsImpl();§int count = (new DomainValue()).calculate(game, source, this);§count = Math.min(player.getLibrary().size(), count);§for (int i = 0; i < count; i++) {§Card card = player.getLibrary().removeFromTop(game);§if (card != null) {§cards.add(card);§}§}§player.lookAtCards("Worldly Counsel", cards, game);§if (!cards.isEmpty()) {§if (cards.size() == 1) {§Card card = cards.getRandom(game);§cards.remove(card);§card.moveToZone(Zone.HAND, source.getSourceId(), game, false);§return true;§} else {§TargetCard target = new TargetCard(Zone.LIBRARY, new FilterCard("card to put into your hand"));§if (player.choose(Outcome.DrawCard, cards, target, game)) {§Card card = cards.get(target.getFirstTarget(), game);§if (card != null) {§cards.remove(card);§card.moveToZone(Zone.HAND, source.getSourceId(), game, false);§}§}§}§}§player.putCardsOnBottomOfLibrary(cards, game, source, true);§return true;§}§}§
public class WretchedBanquet extends CardImpl {§public WretchedBanquet(UUID ownerId) {§super(ownerId, 56, "Wretched Banquet", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{B}");§this.expansionSetCode = "CON";§this.getSpellAbility().addEffect(new WretchedBanquetEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public WretchedBanquet(final WretchedBanquet card) {§super(card);§}§@Override§public WretchedBanquet copy() {§return new WretchedBanquet(this);§}§}§class WretchedBanquetEffect extends OneShotEffect {§public WretchedBanquetEffect() {§super(Outcome.DestroyPermanent);§this.staticText = "Destroy target creature if it has the least power or is tied for least power among creatures on the battlefield";§}§public WretchedBanquetEffect(final WretchedBanquetEffect effect) {§super(effect);§}§@Override§public WretchedBanquetEffect copy() {§return new WretchedBanquetEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent targetCreature = game.getPermanent(source.getFirstTarget());§List<Permanent> creatures = game.getBattlefield().getActivePermanents(new FilterCreaturePermanent(), source.getControllerId(), source.getSourceId(), game);§int minPower = targetCreature.getPower().getValue() + 1;§for (Permanent creature : creatures) {§if (minPower > creature.getPower().getValue()) {§minPower = creature.getPower().getValue();§}§}§if (targetCreature != null && targetCreature.getPower().getValue() <= minPower) {§targetCreature.destroy(source.getSourceId(), game, false);§return true;§}§return false;§}§}§
public class YokeOfTheDamned extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("a creature");§public YokeOfTheDamned(UUID ownerId) {§super(ownerId, 57, "Yoke of the Damned", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{B}");§this.expansionSetCode = "CON";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.Detriment));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new DiesCreatureTriggeredAbility(new DestroyAttachedEffect("enchanted creature"), false, filter));§}§public YokeOfTheDamned(final YokeOfTheDamned card) {§super(card);§}§@Override§public YokeOfTheDamned copy() {§return new YokeOfTheDamned(this);§}§}§
public class ZombieOutlander extends CardImpl {§private static final FilterCard filter = new FilterCard("green");§static {§filter.add(new ColorPredicate(ObjectColor.GREEN));§}§public ZombieOutlander(UUID ownerId) {§super(ownerId, 133, "Zombie Outlander", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{U}{B}");§this.expansionSetCode = "CON";§this.subtype.add("Zombie");§this.subtype.add("Scout");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new ProtectionAbility(filter));§}§public ZombieOutlander(final ZombieOutlander card) {§super(card);§}§@Override§public ZombieOutlander copy() {§return new ZombieOutlander(this);§}§}§
public class AcademyElite extends CardImpl {§public AcademyElite(UUID ownerId) {§super(ownerId, 20, "Academy Elite", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{U}");§this.expansionSetCode = "CNS";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§this.addAbility(new EntersBattlefieldAbility(new AcademyEliteEffect1(), "with X +1/+1 counters on it, where X is the number of instant and sorcery cards in all graveyards"));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DrawDiscardControllerEffect(1, 1, false), new ManaCostsImpl("{2}{U}"));§ability.addCost(new RemoveCountersSourceCost(CounterType.P1P1.createInstance(1)));§this.addAbility(ability);§}§public AcademyElite(final AcademyElite card) {§super(card);§}§@Override§public AcademyElite copy() {§return new AcademyElite(this);§}§}§class AcademyEliteEffect1 extends OneShotEffect {§public AcademyEliteEffect1() {§super(Outcome.BoostCreature);§staticText = "{this} enters the battlefield with X +1/+1 counters on it, where X is the number of instant and sorcery cards in all graveyards";§}§public AcademyEliteEffect1(final AcademyEliteEffect1 effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getPermanentEntering(source.getSourceId());§if (permanent != null) {§SpellAbility spellAbility = (SpellAbility) getValue(EntersBattlefieldEffect.SOURCE_CAST_SPELL_ABILITY);§if (spellAbility != null§&& spellAbility.getSourceId().equals(source.getSourceId())§&& permanent.getZoneChangeCounter(game) == spellAbility.getSourceObjectZoneChangeCounter()) {§CardsInAllGraveyardsCount instantsAndSorceries = new CardsInAllGraveyardsCount(new FilterInstantOrSorceryCard("instant or sorcery cards"));§int instantsAndSorceriesCount = instantsAndSorceries.calculate(game, source, this);§if (instantsAndSorceriesCount > 0) {§permanent.addCounters(CounterType.P1P1.createInstance(instantsAndSorceriesCount), game);§}§}§}§return true;§}§@Override§public AcademyEliteEffect1 copy() {§return new AcademyEliteEffect1(this);§}§}§
public class BarbedShocker extends CardImpl {§public BarbedShocker(UUID ownerId) {§super(ownerId, 136, "Barbed Shocker", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{R}");§this.expansionSetCode = "CNS";§this.subtype.add("Insect");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(TrampleAbility.getInstance());§this.addAbility(HasteAbility.getInstance());§this.addAbility(new DealsDamageToAPlayerTriggeredAbility(new BarbedShockerEffect(), false, true));§}§public BarbedShocker(final BarbedShocker card) {§super(card);§}§@Override§public BarbedShocker copy() {§return new BarbedShocker(this);§}§}§class BarbedShockerEffect extends OneShotEffect {§public BarbedShockerEffect() {§super(Outcome.Discard);§this.staticText = " that player discards all the cards in his or her hand, then draws that many cards";§}§public BarbedShockerEffect(final BarbedShockerEffect effect) {§super(effect);§}§@Override§public BarbedShockerEffect copy() {§return new BarbedShockerEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player targetPlayer = game.getPlayer(targetPointer.getFirst(game, source));§if (targetPlayer != null) {§int count = targetPlayer.getHand().size();§for (Card card : targetPlayer.getHand().getCards(game)) {§targetPlayer.discard(card, source, game);§}§targetPlayer.drawCards(count, game);§return false;§}§return true;§}§}§
public class BiteOfTheBlackRose extends CardImpl {§public BiteOfTheBlackRose(UUID ownerId) {§super(ownerId, 26, "Bite of the Black Rose", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{3}{B}");§this.expansionSetCode = "CNS";§this.getSpellAbility().addEffect(new BiteOfTheBlackRoseEffect());§}§public BiteOfTheBlackRose(final BiteOfTheBlackRose card) {§super(card);§}§@Override§public BiteOfTheBlackRose copy() {§return new BiteOfTheBlackRose(this);§}§}§class BiteOfTheBlackRoseEffect extends OneShotEffect {§BiteOfTheBlackRoseEffect() {§super(Outcome.Benefit);§this.staticText = "<i>Will of the council</i> - Starting with you, each player votes for sickness or psychosis. If sickness gets more votes, creatures your opponents control get -2/-2 until end of turn. If psychosis gets more votes or the vote is tied, each opponent discards two cards";§}§BiteOfTheBlackRoseEffect(final BiteOfTheBlackRoseEffect effect) {§super(effect);§}§@Override§public BiteOfTheBlackRoseEffect copy() {§return new BiteOfTheBlackRoseEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§int sicknessCount = 0;§int psychosisCount = 0;§for (UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {§Player player = game.getPlayer(playerId);§if (player != null) {§if (player.chooseUse(Outcome.ExtraTurn, "Choose sickness?", source, game)) {§sicknessCount++;§game.informPlayers(player.getLogName() + " has chosen: sickness");§} else {§psychosisCount++;§game.informPlayers(player.getLogName() + " has chosen: psychosis");§}§}§}§if (sicknessCount > psychosisCount) {§ContinuousEffect effect = new BoostOpponentsEffect(-2, -2, Duration.EndOfTurn);§game.addEffect(effect, source);§} else {§new DiscardEachPlayerEffect(new StaticValue(2), false, TargetController.OPPONENT).apply(game, source);§}§return true;§}§return false;§}§}§
public class Breakthrough extends CardImpl {§public Breakthrough(UUID ownerId) {§super(ownerId, 92, "Breakthrough", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{X}{U}");§this.expansionSetCode = "CNS";§this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(4));§this.getSpellAbility().addEffect(new BreakthroughEffect());§}§public Breakthrough(final Breakthrough card) {§super(card);§}§@Override§public Breakthrough copy() {§return new Breakthrough(this);§}§}§class BreakthroughEffect extends OneShotEffect {§BreakthroughEffect() {§super(Outcome.Discard);§this.staticText = ", then choose X cards in your hand and discard the rest.";§}§BreakthroughEffect(final BreakthroughEffect effect) {§super(effect);§}§@Override§public BreakthroughEffect copy() {§return new BreakthroughEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§int amountToKeep = source.getManaCostsToPay().getX();§if (amountToKeep == 0) {§player.discard(player.getHand().size(), source, game);§}§else if (amountToKeep < player.getHand().size()) {§TargetCardInHand target = new TargetCardInHand(amountToKeep, new FilterCard());§target.setTargetName("cards to keep");§target.choose(Outcome.Benefit, player.getId(), source.getSourceId(), game);§for (Card card : player.getHand().getCards(game)) {§if (!target.getTargets().contains(card.getId())) {§player.discard(card, source, game);§}§}§}§return true;§}§return false;§}§}§
public class CoercivePortal extends CardImpl {§public CoercivePortal(UUID ownerId) {§super(ownerId, 56, "Coercive Portal", Rarity.MYTHIC, new CardType[]{CardType.ARTIFACT}, "{4}");§this.expansionSetCode = "CNS";§this.addAbility(new BeginningOfUpkeepTriggeredAbility(new CoercivePortalEffect(), TargetController.YOU, false));§}§public CoercivePortal(final CoercivePortal card) {§super(card);§}§@Override§public CoercivePortal copy() {§return new CoercivePortal(this);§}§}§class CoercivePortalEffect extends OneShotEffect {§CoercivePortalEffect() {§super(Outcome.Benefit);§this.staticText = "<i>Will of the council</i> - At the beginning of your upkeep, starting with you, each player votes for carnage or homage. If carnage gets more votes, sacrifice Coercive Portal and destroy all nonland permanents. If homage gets more votes or the vote is tied, draw a card";§}§CoercivePortalEffect(final CoercivePortalEffect effect) {§super(effect);§}§@Override§public CoercivePortalEffect copy() {§return new CoercivePortalEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§int carnageCount = 0;§int homageCount = 0;§for (UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {§Player player = game.getPlayer(playerId);§if (player != null) {§if (player.chooseUse(Outcome.DestroyPermanent, "Choose carnage?", source, game)) {§carnageCount++;§game.informPlayers(player.getLogName() + " has chosen: carnage");§}§else {§homageCount++;§game.informPlayers(player.getLogName() + " has chosen: homage");§}§}§}§if (carnageCount > homageCount) {§new SacrificeSourceEffect().apply(game, source);§new CoercivePortalDestroyEffect().apply(game, source);§} else {§controller.drawCards(1, game);§}§return true;§}§return false;§}§}§class CoercivePortalDestroyEffect extends OneShotEffect {§private static final FilterPermanent filter = new FilterNonlandPermanent();§public CoercivePortalDestroyEffect() {§super(Outcome.DestroyPermanent);§staticText = "sacrifice Coercive Portal and destroy all nonland permanents";§}§public CoercivePortalDestroyEffect(final CoercivePortalDestroyEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§for (Permanent permanent : game.getBattlefield().getActivePermanents(filter, source.getControllerId(), source.getSourceId(), game)) {§permanent.destroy(source.getSourceId(), game, false);§}§return true;§}§@Override§public CoercivePortalDestroyEffect copy() {§return new CoercivePortalDestroyEffect(this);§}§}§
public class CustodiSoulbinders extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("other creatures");§static {§filter.add(new AnotherPredicate());§}§public CustodiSoulbinders(UUID ownerId) {§super(ownerId, 17, "Custodi Soulbinders", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{W}");§this.expansionSetCode = "CNS";§this.subtype.add("Human");§this.subtype.add("Cleric");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§this.addAbility(new EntersBattlefieldAbility(§new AddCountersSourceEffect(§CounterType.P1P1.createInstance(),§new PermanentsOnBattlefieldCount(filter),§false),§"with X +1/+1 counters on it, where X is the number of other creatures on the battlefield"));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new CreateTokenEffect(new SpiritWhiteToken("CNS")), new ManaCostsImpl<>("{2}{W}"));§ability.addCost(new RemoveCountersSourceCost(CounterType.P1P1.createInstance()));§this.addAbility(ability);§}§public CustodiSoulbinders(final CustodiSoulbinders card) {§super(card);§}§@Override§public CustodiSoulbinders copy() {§return new CustodiSoulbinders(this);§}§}§
public class DackFayden extends CardImpl {§public DackFayden(UUID ownerId) {§super(ownerId, 42, "Dack Fayden", Rarity.MYTHIC, new CardType[]{CardType.PLANESWALKER}, "{1}{U}{R}");§this.expansionSetCode = "CNS";§this.subtype.add("Dack");§this.addAbility(new PlanswalkerEntersWithLoyalityCountersAbility(3));§LoyaltyAbility ability = new LoyaltyAbility(new DrawCardTargetEffect(2), 1);§Effect effect = new DiscardTargetEffect(2);§effect.setText(", then discards two cards");§ability.addEffect(effect);§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§effect = new GainControlTargetEffect(Duration.EndOfGame, true);§effect.setText("Gain control of target artifact");§ability = new LoyaltyAbility(effect, -2);§ability.addTarget(new TargetArtifactPermanent());§this.addAbility(ability);§effect = new GetEmblemEffect(new DackFaydenEmblem());§effect.setText("You get an emblem with \"Whenever you cast a spell that targets one or more permanents, gain control of those permanents.\"");§ability = new LoyaltyAbility(effect, -6);§this.addAbility(ability);§}§public DackFayden(final DackFayden card) {§super(card);§}§@Override§public DackFayden copy() {§return new DackFayden(this);§}§}§class DackFaydenEmblem extends Emblem {§DackFaydenEmblem() {§this.setName("EMBLEM: Dack Fayden");§this.getAbilities().add(new DackFaydenEmblemTriggeredAbility());§}§}§class DackFaydenEmblemTriggeredAbility extends TriggeredAbilityImpl {§DackFaydenEmblemTriggeredAbility() {§super(Zone.COMMAND, new DackFaydenEmblemEffect(), false);§}§DackFaydenEmblemTriggeredAbility(final DackFaydenEmblemTriggeredAbility ability) {§super(ability);§}§@Override§public DackFaydenEmblemTriggeredAbility copy() {§return new DackFaydenEmblemTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.SPELL_CAST;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§boolean returnValue = false;§List<UUID> targettedPermanents = new ArrayList<>(0);§Player player = game.getPlayer(this.getControllerId());§if (player != null) {§if (event.getPlayerId().equals(this.getControllerId())) {§Spell spell = game.getStack().getSpell(event.getTargetId());§if (spell != null) {§SpellAbility spellAbility = spell.getSpellAbility();§for (Target target : spellAbility.getTargets()) {§if (!target.isNotTarget()) {§for (UUID targetId : target.getTargets()) {§if (game.getBattlefield().containsPermanent(targetId)) {§returnValue = true;§targettedPermanents.add(targetId);§}§}§}§}§for (Effect effect : spellAbility.getEffects()) {§for (UUID targetId : effect.getTargetPointer().getTargets(game, spellAbility)) {§if (game.getBattlefield().containsPermanent(targetId)) {§returnValue = true;§targettedPermanents.add(targetId);§}§}§}§}§}§}§for (Effect effect : this.getEffects()) {§if (effect instanceof DackFaydenEmblemEffect) {§DackFaydenEmblemEffect dackEffect = (DackFaydenEmblemEffect) effect;§dackEffect.setPermanents(targettedPermanents);§}§}§return returnValue;§}§@Override§public String getRule() {§return "Whenever you cast a spell that targets one or more permanents, gain control of those permanents.";§}§}§class DackFaydenEmblemEffect extends ContinuousEffectImpl {§protected List<UUID> permanents;§DackFaydenEmblemEffect() {§super(Duration.EndOfGame, Layer.ControlChangingEffects_2, SubLayer.NA, Outcome.GainControl);§this.staticText = "gain control of those permanents";§}§DackFaydenEmblemEffect(final DackFaydenEmblemEffect effect) {§super(effect);§this.permanents = effect.permanents;§}§@Override§public DackFaydenEmblemEffect copy() {§return new DackFaydenEmblemEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§for (UUID permanentId : this.permanents) {§Permanent permanent = game.getPermanent(permanentId);§if (permanent != null) {§permanent.changeControllerId(source.getControllerId(), game);§}§}§return true;§}§public void setPermanents(List<UUID> targettedPermanents) {§this.permanents = new ArrayList<>(targettedPermanents);§}§}§
public class DeathreapRitual extends CardImpl {§public DeathreapRitual(UUID ownerId) {§super(ownerId, 44, "Deathreap Ritual", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{B}{G}");§this.expansionSetCode = "CNS";§this.addAbility(new BeginningOfEndStepTriggeredAbility(Zone.BATTLEFIELD, new DrawCardSourceControllerEffect(1),§TargetController.ANY, MorbidCondition.getInstance(), true));§}§public DeathreapRitual(final DeathreapRitual card) {§super(card);§}§@Override§public DeathreapRitual copy() {§return new DeathreapRitual(this);§}§}§
public class DrakestownForgotten extends CardImpl {§public DrakestownForgotten(UUID ownerId) {§super(ownerId, 27, "Drakestown Forgotten", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{B}");§this.expansionSetCode = "CNS";§this.subtype.add("Zombie");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§this.addAbility(new EntersBattlefieldAbility(§new AddCountersSourceEffect(§CounterType.P1P1.createInstance(),§new CardsInAllGraveyardsCount(new FilterCreatureCard()),§false),§"with X +1/+1 counters on it, where X is the number of other creatures on the battlefield"));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostTargetEffect(-1, -1, Duration.EndOfTurn), new ManaCostsImpl<>("{2}{B}"));§ability.addCost(new RemoveCountersSourceCost(CounterType.P1P1.createInstance()));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public DrakestownForgotten(final DrakestownForgotten card) {§super(card);§}§@Override§public DrakestownForgotten copy() {§return new DrakestownForgotten(this);§}§}§
public class EnragedRevolutionary extends CardImpl {§public EnragedRevolutionary(UUID ownerId) {§super(ownerId, 31, "Enraged Revolutionary", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "CNS";§this.subtype.add("Human");§this.subtype.add("Warrior");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new DethroneAbility());§}§public EnragedRevolutionary(final EnragedRevolutionary card) {§super(card);§}§@Override§public EnragedRevolutionary copy() {§return new EnragedRevolutionary(this);§}§}§
public class ExtractFromDarkness extends CardImpl {§public ExtractFromDarkness(UUID ownerId) {§super(ownerId, 45, "Extract from Darkness", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{3}{U}{B}");§this.expansionSetCode = "CNS";§this.getSpellAbility().addEffect(new ExtractFromDarknessMillEffect());§this.getSpellAbility().addEffect(new ExtractFromDarknessReturnFromGraveyardToBattlefieldEffect());§}§public ExtractFromDarkness(final ExtractFromDarkness card) {§super(card);§}§@Override§public ExtractFromDarkness copy() {§return new ExtractFromDarkness(this);§}§}§class ExtractFromDarknessMillEffect extends OneShotEffect {§ExtractFromDarknessMillEffect() {§super(Outcome.Detriment);§staticText = "Each player puts the top two cards of his or her library into his or her graveyard";§}§ExtractFromDarknessMillEffect(final ExtractFromDarknessMillEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§for (UUID playerId : game.getPlayerList()) {§Player player = game.getPlayer(playerId);§if (player != null) {§player.moveCards(player.getLibrary().getTopCards(game, 2), Zone.LIBRARY, Zone.GRAVEYARD, source, game);§}§}§return true;§}§@Override§public ExtractFromDarknessMillEffect copy() {§return new ExtractFromDarknessMillEffect(this);§}§}§class ExtractFromDarknessReturnFromGraveyardToBattlefieldEffect extends OneShotEffect {§public ExtractFromDarknessReturnFromGraveyardToBattlefieldEffect() {§super(Outcome.PutCreatureInPlay);§staticText = "Put a creature card from a graveyard onto the battlefield under your control";§}§public ExtractFromDarknessReturnFromGraveyardToBattlefieldEffect(final ExtractFromDarknessReturnFromGraveyardToBattlefieldEffect effect) {§super(effect);§}§@Override§public ExtractFromDarknessReturnFromGraveyardToBattlefieldEffect copy() {§return new ExtractFromDarknessReturnFromGraveyardToBattlefieldEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Target target = new TargetCardInGraveyard(new FilterCreatureCard());§target.setNotTarget(true);§if (target.canChoose(source.getSourceId(), source.getControllerId(), game)§&& controller.chooseTarget(outcome, target, source, game)) {§return controller.moveCards(game.getCard(target.getFirstTarget()), Zone.BATTLEFIELD, source, game);§}§return true;§}§return false;§}§}§
public class Flamewright extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("creature with defender");§static {§filter.add(new CardTypePredicate(CardType.CREATURE));§filter.add(new AbilityPredicate(DefenderAbility.class));§}§public Flamewright(UUID ownerId) {§super(ownerId, 46, "Flamewright", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{R}{W}");§this.expansionSetCode = "CNS";§this.subtype.add("Human");§this.subtype.add("Artificer");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new CreateTokenEffect(new ConstructToken()), new ManaCostsImpl("{1}"));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(1), new TapSourceCost());§ability.addCost(new SacrificeTargetCost(new TargetControlledPermanent(filter)));§ability.addTarget(new TargetCreatureOrPlayer());§this.addAbility(ability);§}§public Flamewright(final Flamewright card) {§super(card);§}§@Override§public Flamewright copy() {§return new Flamewright(this);§}§}§class ConstructToken extends Token {§public ConstructToken() {§this("CNS");§}§public ConstructToken(String setCode) {§super("Construct", "1/1 colorless Construct artifact creature token with defender");§this.setOriginalExpansionSetCode(setCode);§cardType.add(CardType.ARTIFACT);§cardType.add(CardType.CREATURE);§subtype.add("Construct");§power = new MageInt(1);§toughness = new MageInt(1);§addAbility(DefenderAbility.getInstance());§}§}§
public class FlowstoneBlade extends CardImpl {§public FlowstoneBlade(UUID ownerId) {§super(ownerId, 143, "Flowstone Blade", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{R}");§this.expansionSetCode = "CNS";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.Copy));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(1, -1, Duration.EndOfTurn), new ManaCostsImpl("R")));§}§public FlowstoneBlade(final FlowstoneBlade card) {§super(card);§}§@Override§public FlowstoneBlade copy() {§return new FlowstoneBlade(this);§}§}§
public class GrenzoDungeonWarden extends CardImpl {§public GrenzoDungeonWarden(UUID ownerId) {§super(ownerId, 47, "Grenzo, Dungeon Warden", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{X}{B}{R}");§this.expansionSetCode = "CNS";§this.supertype.add("Legendary");§this.subtype.add("Goblin");§this.subtype.add("Rogue");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new EntersBattlefieldAbility(new EntersBattlefieldWithXCountersEffect(CounterType.P1P1.createInstance())));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new GrenzoDungeonWardenEffect(), new GenericManaCost(2)));§}§public GrenzoDungeonWarden(final GrenzoDungeonWarden card) {§super(card);§}§@Override§public GrenzoDungeonWarden copy() {§return new GrenzoDungeonWarden(this);§}§}§class GrenzoDungeonWardenEffect extends OneShotEffect {§GrenzoDungeonWardenEffect() {§super(Outcome.Benefit);§this.staticText = "Put the bottom card of your library into your graveyard. If it's a creature card with power less than or equal to {this}'s power, put it onto the battlefield";§}§GrenzoDungeonWardenEffect(final GrenzoDungeonWardenEffect effect) {§super(effect);§}§@Override§public GrenzoDungeonWardenEffect copy() {§return new GrenzoDungeonWardenEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§if (controller.getLibrary().size() > 0) {§Card card = controller.getLibrary().getFromBottom(game);§if (card != null) {§controller.moveCards(card, Zone.GRAVEYARD, source, game);§if (card.getCardType().contains(CardType.CREATURE)) {§Permanent sourcePermanent = game.getPermanentOrLKIBattlefield(source.getSourceId());§if (sourcePermanent != null && card.getPower().getValue() <= sourcePermanent.getPower().getValue()) {§controller.moveCards(card, Zone.BATTLEFIELD, source, game);§}§}§}§}§return true;§}§return false;§}§}§
public class ManaGeyser extends CardImpl {§private static final FilterLandPermanent filter = new FilterLandPermanent("tapped land your opponents control");§static {§filter.add(new TappedPredicate());§filter.add(new ControllerPredicate(TargetController.OPPONENT));§}§public ManaGeyser(UUID ownerId) {§super(ownerId, 147, "Mana Geyser", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{3}{R}{R}");§this.expansionSetCode = "CNS";§this.getSpellAbility().addEffect(new DynamicManaEffect(Mana.RedMana(1), new PermanentsOnBattlefieldCount(filter)));§}§public ManaGeyser(final ManaGeyser card) {§super(card);§}§@Override§public ManaGeyser copy() {§return new ManaGeyser(this);§}§}§
public class MarchesasEmissary extends CardImpl {§public MarchesasEmissary(UUID ownerId) {§super(ownerId, 21, "Marchesa's Emissary", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{U}");§this.expansionSetCode = "CNS";§this.subtype.add("Human");§this.subtype.add("Rogue");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(HexproofAbility.getInstance());§this.addAbility(new DethroneAbility());§}§public MarchesasEmissary(final MarchesasEmissary card) {§super(card);§}§@Override§public MarchesasEmissary copy() {§return new MarchesasEmissary(this);§}§}§
public class MarchesasInfiltrator extends CardImpl {§public MarchesasInfiltrator(UUID ownerId) {§super(ownerId, 22, "Marchesa's Infiltrator", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{U}");§this.expansionSetCode = "CNS";§this.subtype.add("Human");§this.subtype.add("Rogue");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new DethroneAbility());§this.addAbility(new DealsCombatDamageToAPlayerTriggeredAbility(new DrawCardSourceControllerEffect(1), false));§}§public MarchesasInfiltrator(final MarchesasInfiltrator card) {§super(card);§}§@Override§public MarchesasInfiltrator copy() {§return new MarchesasInfiltrator(this);§}§}§
public class MarchesasSmuggler extends CardImpl {§public MarchesasSmuggler(UUID ownerId) {§super(ownerId, 50, "Marchesa's Smuggler", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{U}{R}");§this.expansionSetCode = "CNS";§this.subtype.add("Human");§this.subtype.add("Rogue");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new DethroneAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilityTargetEffect(HasteAbility.getInstance(), Duration.EndOfTurn), new ManaCostsImpl("{1}{U}{R}"));§ability.addTarget(new TargetControlledCreaturePermanent());§Effect effect = new CantBeBlockedTargetEffect(Duration.EndOfTurn);§effect.setText("and can't be blocked this turn");§ability.addEffect(effect);§this.addAbility(ability);§}§public MarchesasSmuggler(final MarchesasSmuggler card) {§super(card);§}§@Override§public MarchesasSmuggler copy() {§return new MarchesasSmuggler(this);§}§}§
public class MuzzioVisionaryArchitect extends CardImpl {§public MuzzioVisionaryArchitect(UUID ownerId) {§super(ownerId, 23, "Muzzio, Visionary Architect", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{1}{U}{U}");§this.expansionSetCode = "CNS";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Artificer");§this.power = new MageInt(1);§this.toughness = new MageInt(3);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new MuzzioVisionaryArchitectEffect(), new ManaCostsImpl("{3}{U}"));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§}§public MuzzioVisionaryArchitect(final MuzzioVisionaryArchitect card) {§super(card);§}§@Override§public MuzzioVisionaryArchitect copy() {§return new MuzzioVisionaryArchitect(this);§}§}§class MuzzioVisionaryArchitectEffect extends OneShotEffect {§public MuzzioVisionaryArchitectEffect() {§super(Outcome.Benefit);§this.staticText = "Look at the top X cards of your library, where X is the highest converted mana cost among artifacts you control. You may reveal an artifact card from among them and put it onto the battlefield. Put the rest on the bottom of your library in any order";§}§public MuzzioVisionaryArchitectEffect(final MuzzioVisionaryArchitectEffect effect) {§super(effect);§}§@Override§public MuzzioVisionaryArchitectEffect copy() {§return new MuzzioVisionaryArchitectEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§Permanent sourcePermanent = game.getPermanentOrLKIBattlefield(source.getSourceId());§if (controller == null || sourcePermanent == null) {§return false;§}§int highCMC = 0;§List<Permanent> controlledArtifacts = game.getBattlefield().getAllActivePermanents(new FilterArtifactPermanent(), controller.getId(), game);§for (Permanent permanent : controlledArtifacts) {§if (permanent.getSpellAbility() != null) {§int cmc = permanent.getSpellAbility().getManaCosts().convertedManaCost();§if (cmc > highCMC) {§highCMC = cmc;§}§}§}§Cards cards = new CardsImpl();§for (int i = 0; i < highCMC; i++) {§Card card = controller.getLibrary().removeFromTop(game);§if (card != null) {§cards.add(card);§}§}§controller.lookAtCards(sourcePermanent.getIdName(), cards, game);§if (!cards.isEmpty()) {§TargetCard target = new TargetCard(Zone.LIBRARY, new FilterArtifactCard("artifact card to put onto the battlefield"));§if (target.canChoose(source.getSourceId(), controller.getId(), game) && controller.choose(Outcome.Benefit, cards, target, game)) {§Card card = cards.get(target.getFirstTarget(), game);§if (card != null) {§controller.revealCards(sourcePermanent.getIdName(), new CardsImpl(card), game);§cards.remove(card);§controller.moveCards(card, Zone.BATTLEFIELD, source, game);§}§}§}§controller.putCardsOnBottomOfLibrary(cards, game, source, true);§return true;§}§}§
public class PowerOfFire extends CardImpl {§public PowerOfFire(UUID ownerId) {§super(ownerId, 150, "Power of Fire", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{R}");§this.expansionSetCode = "CNS";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§Ability gainedAbility = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(1), new TapSourceCost());§gainedAbility.addTarget(new TargetCreatureOrPlayer());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(gainedAbility, AttachmentType.AURA, Duration.WhileOnBattlefield,§"Enchanted creature has \"{T}: This creature deals 1 damage to target creature or player.\"")));§}§public PowerOfFire(final PowerOfFire card) {§super(card);§}§@Override§public PowerOfFire copy() {§return new PowerOfFire(this);§}§}§
public class PredatorsHowl extends CardImpl {§public PredatorsHowl(UUID ownerId) {§super(ownerId, 37, "Predator's Howl", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{3}{G}");§this.expansionSetCode = "CNS";§Effect effect = new ConditionalOneShotEffect(§new CreateTokenEffect(new WolfToken(), 3),§new CreateTokenEffect(new WolfToken(), 1),§new MorbidCondition(),§"Put a 2/2 green Wolf creature token onto the battlefield. <br/><br/><i>Morbid</i> - Put three 2/2 green Wolf creature tokens onto the battlefield instead if a creature died this turn.");§this.getSpellAbility().addEffect(effect);§}§public PredatorsHowl(final PredatorsHowl card) {§super(card);§}§@Override§public PredatorsHowl copy() {§return new PredatorsHowl(this);§}§}§
public class RealmSeekers extends CardImpl {§public RealmSeekers(UUID ownerId) {§super(ownerId, 38, "Realm Seekers", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{G}{G}");§this.expansionSetCode = "CNS";§this.subtype.add("Elf");§this.subtype.add("Scout");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§this.addAbility(new EntersBattlefieldAbility(§new AddCountersSourceEffect(§CounterType.P1P1.createInstance(),§new CardsInAllHandsCount(),§false),§"with X +1/+1 counters on it, where X is the total number of cards in all players' hands"));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new SearchLibraryPutInHandEffect(new TargetCardInLibrary(new FilterLandCard()), true), new ManaCostsImpl<>("{2}{G}"));§ability.addCost(new RemoveCountersSourceCost(CounterType.P1P1.createInstance()));§this.addAbility(ability);§}§public RealmSeekers(final RealmSeekers card) {§super(card);§}§@Override§public RealmSeekers copy() {§return new RealmSeekers(this);§}§}§
public class RousingOfSouls extends CardImpl {§public RousingOfSouls(UUID ownerId) {§super(ownerId, 19, "Rousing of Souls", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{2}{W}");§this.expansionSetCode = "CNS";§this.getSpellAbility().addEffect(new RousingOfSoulsEffect());§Effect effect = new DrawCardAllEffect(1);§effect.setText("Then each player draws a card");§this.getSpellAbility().addEffect(effect);§}§public RousingOfSouls(final RousingOfSouls card) {§super(card);§}§@Override§public RousingOfSouls copy() {§return new RousingOfSouls(this);§}§}§class RousingOfSoulsEffect extends OneShotEffect {§public RousingOfSoulsEffect() {§super(Outcome.Benefit);§this.staticText = "<i>Parley &mdash; </i> Each player reveals the top card of his or her library. For each nonland card revealed this way, you put a 1/1 white Spirit creature token with flying onto the battlefield";§}§public RousingOfSoulsEffect(final RousingOfSoulsEffect effect) {§super(effect);§}§@Override§public RousingOfSoulsEffect copy() {§return new RousingOfSoulsEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§int parley = ParleyCount.getInstance().calculate(game, source, this);§if (parley > 0) {§new CreateTokenEffect(new SpiritWhiteToken(), parley).apply(game, source);§}§return true;§}§return false;§}§}§
public class Rout extends CardImpl {§public Rout(UUID ownerId) {§super(ownerId, 80, "Rout", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{3}{W}{W}");§this.expansionSetCode = "CNS";§Effect effect = new DestroyAllEffect(new FilterCreaturePermanent("creatures"), true);§Ability ability = new PayMoreToCastAsThoughtItHadFlashAbility(this, new ManaCostsImpl("{2}"));§ability.addEffect(effect);§this.addAbility(ability);§this.getSpellAbility().addEffect(effect);§}§public Rout(final Rout card) {§super(card);§}§@Override§public Rout copy() {§return new Rout(this);§}§}§
public class ScreamingSeahawk extends CardImpl {§private static final FilterCard filter = new FilterCard("card named Screaming Seahawk");§static {§filter.add(new NamePredicate("Screaming Seahawk"));§}§public ScreamingSeahawk(UUID ownerId) {§super(ownerId, 105, "Screaming Seahawk", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{U}");§this.expansionSetCode = "CNS";§this.subtype.add("Bird");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§TargetCardInLibrary target = new TargetCardInLibrary(0, 1, filter);§this.addAbility(new EntersBattlefieldTriggeredAbility(new SearchLibraryPutInHandEffect(target, true, true), true));§}§public ScreamingSeahawk(final ScreamingSeahawk card) {§super(card);§}§@Override§public ScreamingSeahawk copy() {§return new ScreamingSeahawk(this);§}§}§
public class SelvalasCharge extends CardImpl {§public SelvalasCharge(UUID ownerId) {§super(ownerId, 39, "Selvala's Charge", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{4}{G}");§this.expansionSetCode = "CNS";§this.getSpellAbility().addEffect(new SelvalasChargeEffect());§Effect effect = new DrawCardAllEffect(1);§effect.setText("Then each player draws a card");§this.getSpellAbility().addEffect(effect);§}§public SelvalasCharge(final SelvalasCharge card) {§super(card);§}§@Override§public SelvalasCharge copy() {§return new SelvalasCharge(this);§}§}§class SelvalasChargeEffect extends OneShotEffect {§public SelvalasChargeEffect() {§super(Outcome.Benefit);§this.staticText = "<i>Parley &mdash; </i> Each player reveals the top card of his or her library. For each nonland card revealed this way, you put a 3/3 green Elephant creature token onto the battlefield";§}§public SelvalasChargeEffect(final SelvalasChargeEffect effect) {§super(effect);§}§@Override§public SelvalasChargeEffect copy() {§return new SelvalasChargeEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§int parley = ParleyCount.getInstance().calculate(game, source, this);§if (parley > 0) {§new CreateTokenEffect(new ElephantToken(), parley).apply(game, source);§}§return true;§}§return false;§}§}§
public class SelvalasEnforcer extends CardImpl {§public SelvalasEnforcer(UUID ownerId) {§super(ownerId, 40, "Selvala's Enforcer", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{G}");§this.expansionSetCode = "CNS";§this.subtype.add("Elf");§this.subtype.add("Warrior");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new EntersBattlefieldTriggeredAbility(new SelvalasEnforcerEffect(), false, "<i>Parley &mdash; </i>");§Effect effect = new DrawCardAllEffect(1);§effect.setText("Then each player draws a card");§ability.addEffect(effect);§this.addAbility(ability);§}§public SelvalasEnforcer(final SelvalasEnforcer card) {§super(card);§}§@Override§public SelvalasEnforcer copy() {§return new SelvalasEnforcer(this);§}§}§class SelvalasEnforcerEffect extends OneShotEffect {§public SelvalasEnforcerEffect() {§super(Outcome.Benefit);§this.staticText = "each player reveals the top card of his or her library. For each nonland card revealed this way, put a +1/+1 counter on {this}";§}§public SelvalasEnforcerEffect(final SelvalasEnforcerEffect effect) {§super(effect);§}§@Override§public SelvalasEnforcerEffect copy() {§return new SelvalasEnforcerEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§int parley = ParleyCount.getInstance().calculate(game, source, this);§if (parley > 0) {§Permanent sourcePermanent = game.getPermanent(source.getSourceId());§if (sourcePermanent != null) {§sourcePermanent.addCounters(CounterType.P1P1.createInstance(parley), game);§}§}§return true;§}§return false;§}§}§
public class SplitDecision extends CardImpl {§private static final FilterSpell filter = new FilterSpell("instant or sorcery spell");§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.INSTANT),§new CardTypePredicate(CardType.SORCERY)));§}§public SplitDecision(UUID ownerId) {§super(ownerId, 25, "Split Decision", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{1}{U}");§this.expansionSetCode = "CNS";§this.getSpellAbility().addEffect(new SplitDecisionEffect());§this.getSpellAbility().addTarget(new TargetSpell(filter));§}§public SplitDecision(final SplitDecision card) {§super(card);§}§@Override§public SplitDecision copy() {§return new SplitDecision(this);§}§}§class SplitDecisionEffect extends OneShotEffect {§SplitDecisionEffect() {§super(Outcome.Benefit);§this.staticText = "<i>Will of the council</i> - Choose target instant or sorcery spell. Starting with you, each player votes for denial or duplication. If denial gets more votes, counter the spell. If duplication gets more votes or the vote is tied, copy the spell. You may choose new targets for the copy";§}§SplitDecisionEffect(final SplitDecisionEffect effect) {§super(effect);§}§@Override§public SplitDecisionEffect copy() {§return new SplitDecisionEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§int denialCount = 0;§int duplicationCount = 0;§for (UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {§Player player = game.getPlayer(playerId);§if (player != null) {§if (player.chooseUse(Outcome.ExtraTurn, "Choose denial?", source, game)) {§denialCount++;§game.informPlayers(player.getLogName() + " has chosen: denial");§} else {§duplicationCount++;§game.informPlayers(player.getLogName() + " has chosen: duplication");§}§}§}§if (denialCount > duplicationCount) {§return game.getStack().counter(getTargetPointer().getFirst(game, source), source.getSourceId(), game);§} else {§return new CopyTargetSpellEffect().apply(game, source);§}§}§return false;§}§}§
public class SquirrelNest extends CardImpl {§public SquirrelNest(UUID ownerId) {§super(ownerId, 180, "Squirrel Nest", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{G}{G}");§this.expansionSetCode = "CNS";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetLandPermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§Ability gainedAbility = new SimpleActivatedAbility(Zone.BATTLEFIELD, new CreateTokenEffect(new SquirrelToken()), new TapSourceCost());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD,§new GainAbilityAttachedEffect(gainedAbility, AttachmentType.AURA, Duration.WhileOnBattlefield, "Enchanted land has \"{T}: Put a 1/1 green Squirrel creature token onto the battlefield.\"")));§}§public SquirrelNest(final SquirrelNest card) {§super(card);§}§@Override§public SquirrelNest copy() {§return new SquirrelNest(this);§}§}§
public class StrongholdDiscipline extends CardImpl {§public StrongholdDiscipline(UUID ownerId) {§super(ownerId, 126, "Stronghold Discipline", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{2}{B}{B}");§this.expansionSetCode = "CNS";§this.getSpellAbility().addEffect(new StrongholdDisciplineEffect());§}§public StrongholdDiscipline(final StrongholdDiscipline card) {§super(card);§}§@Override§public StrongholdDiscipline copy() {§return new StrongholdDiscipline(this);§}§}§class StrongholdDisciplineEffect extends OneShotEffect {§StrongholdDisciplineEffect() {§super(Outcome.Sacrifice);§this.staticText = "Each player loses 1 life for each creature he or she controls";§}§StrongholdDisciplineEffect(final StrongholdDisciplineEffect effect) {§super(effect);§}§@Override§public StrongholdDisciplineEffect copy() {§return new StrongholdDisciplineEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§for (UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {§final int count = game.getBattlefield().getAllActivePermanents(new FilterCreaturePermanent(), playerId, game).size();§if (count > 0) {§Player player = game.getPlayer(playerId);§if (player != null) {§player.loseLife(count, game);§}§}§}§return true;§}§return false;§}§}§
public class TravelersCloak extends CardImpl {§public TravelersCloak(UUID ownerId) {§super(ownerId, 109, "Traveler's Cloak", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{U}");§this.expansionSetCode = "CNS";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new AsEntersBattlefieldAbility(new ChooseLandTypeEffect(Outcome.AddAbility)));§this.addAbility(new EntersBattlefieldTriggeredAbility(new DrawCardSourceControllerEffect(1), false));§FilterLandPermanent filter = new FilterLandPermanent("Landwalk of the chosen type");§filter.add(new ChosenSubtypePredicate(this.getId()));§Ability landwalkAbility = new LandwalkAbility(filter);§Effect effect = new GainAbilityAttachedEffect(landwalkAbility, AttachmentType.AURA);§effect.setText("Enchanted creature has landwalk of the chosen type");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, effect));§}§public TravelersCloak(final TravelersCloak card) {§super(card);§}§@Override§public TravelersCloak copy() {§return new TravelersCloak(this);§}§}§
public class TreasonousOgre extends CardImpl {§public TreasonousOgre(UUID ownerId) {§super(ownerId, 36, "Treasonous Ogre", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{R}");§this.expansionSetCode = "CNS";§this.subtype.add("Ogre");§this.subtype.add("Shaman");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(new DethroneAbility());§this.addAbility(new SimpleManaAbility(Zone.BATTLEFIELD, new Mana(ColoredManaSymbol.R), new PayLifeCost(3)));§}§public TreasonousOgre(final TreasonousOgre card) {§super(card);§}§@Override§public TreasonousOgre copy() {§return new TreasonousOgre(this);§}§}§
public class Victimize extends CardImpl {§public Victimize(UUID ownerId) {§super(ownerId, 133, "Victimize", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{2}{B}");§this.expansionSetCode = "CNS";§this.getSpellAbility().addEffect(new VictimizeEffect());§this.getSpellAbility().addTarget(new TargetCardInYourGraveyard(2, new FilterCreatureCard("creature cards in your graveyard")));§}§public Victimize(final Victimize card) {§super(card);§}§@Override§public Victimize copy() {§return new Victimize(this);§}§}§class VictimizeEffect extends OneShotEffect {§VictimizeEffect() {§super(Outcome.PutCreatureInPlay);§this.staticText = "Choose two target creature cards in your graveyard. Sacrifice a creature. If you do, return the chosen cards to the battlefield tapped";§}§VictimizeEffect(final VictimizeEffect effect) {§super(effect);§}§@Override§public VictimizeEffect copy() {§return new VictimizeEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§SacrificeTargetCost cost = new SacrificeTargetCost(new TargetControlledCreaturePermanent(new FilterControlledCreaturePermanent("a creature")));§if (cost.pay(source, game, source.getSourceId(), source.getControllerId(), false, null)) {§controller.moveCards(new CardsImpl(getTargetPointer().getTargets(game, source)).getCards(game),§Zone.BATTLEFIELD, source, game, true, false, false, null);§}§return true;§}§return false;§}§}§
public class WakestoneGargoyle extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("Creatures you control with defender");§static {§filter.add(new AbilityPredicate(DefenderAbility.class));§}§public WakestoneGargoyle(UUID ownerId) {§super(ownerId, 88, "Wakestone Gargoyle", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{W}");§this.expansionSetCode = "CNS";§this.subtype.add("Gargoyle");§this.power = new MageInt(3);§this.toughness = new MageInt(4);§this.addAbility(DefenderAbility.getInstance());§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new CanAttackAsThoughItDidntHaveDefenderAllEffect(Duration.EndOfTurn, filter), new ManaCostsImpl("{1}{W}") ));§}§public WakestoneGargoyle(final WakestoneGargoyle card) {§super(card);§}§@Override§public WakestoneGargoyle copy() {§return new WakestoneGargoyle(this);§}§}§
public class WoodvineElemental extends CardImpl {§final private String rule = "<i>Parley &mdash; </i> Whenever {this} attacks, each player reveals the top card of his or her library. "§+ "For each nonland card revealed this way, attacking creatures you control get +1/+1 until end of turn. Then each player draws a card.";§public WoodvineElemental(UUID ownerId) {§super(ownerId, 52, "Woodvine Elemental", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{G}{W}");§this.expansionSetCode = "CNS";§this.subtype.add("Elemental");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(TrampleAbility.getInstance());§Ability ability = new AttacksTriggeredAbility(new WoodvineElementalEffect(), false, rule);§Effect effect = new DrawCardAllEffect(1);§ability.addEffect(effect);§this.addAbility(ability);§}§public WoodvineElemental(final WoodvineElemental card) {§super(card);§}§@Override§public WoodvineElemental copy() {§return new WoodvineElemental(this);§}§}§class WoodvineElementalEffect extends OneShotEffect {§public WoodvineElementalEffect() {§super(Outcome.Benefit);§}§public WoodvineElementalEffect(final WoodvineElementalEffect effect) {§super(effect);§}§@Override§public WoodvineElementalEffect copy() {§return new WoodvineElementalEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§int parley = ParleyCount.getInstance().calculate(game, source, this);§if (parley > 0) {§game.addEffect(new BoostControlledEffect(parley, parley, Duration.EndOfTurn, new FilterAttackingCreature("Attacking creatures"), false), source);§}§return true;§}§return false;§}§}§
public class WrapInVigor extends CardImpl {§public WrapInVigor(UUID ownerId) {§super(ownerId, 183, "Wrap in Vigor", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{G}");§this.expansionSetCode = "CNS";§this.getSpellAbility().addEffect(new RegenerateAllEffect(new FilterControlledCreaturePermanent()));§}§public WrapInVigor(final WrapInVigor card) {§super(card);§}§@Override§public WrapInVigor copy() {§return new WrapInVigor(this);§}§}§
public class AfflictedDeserter extends CardImpl {§public AfflictedDeserter(UUID ownerId) {§super(ownerId, 81, "Afflicted Deserter", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{R}");§this.expansionSetCode = "DKA";§this.subtype.add("Human");§this.subtype.add("Werewolf");§this.canTransform = true;§this.secondSideCard = new WerewolfRansacker(ownerId);§this.power = new MageInt(3);§this.toughness = new MageInt(2);§Ability ability1 = new WerewolfRansackerAbility();§ability1.setRuleVisible(false); §
public class AlphaBrawl extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature an opponent controls");§static {§filter.add(new ControllerPredicate(TargetController.OPPONENT));§}§public AlphaBrawl(UUID ownerId) {§super(ownerId, 82, "Alpha Brawl", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{6}{R}{R}");§this.expansionSetCode = "DKA";§this.getSpellAbility().addEffect(new AlphaBrawlEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent(filter));§}§public AlphaBrawl(final AlphaBrawl card) {§super(card);§}§@Override§public AlphaBrawl copy() {§return new AlphaBrawl(this);§}§}§class AlphaBrawlEffect extends OneShotEffect {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent();§public AlphaBrawlEffect() {§super(Outcome.Damage);§staticText = "Target creature an opponent controls deals damage equal to its power to each other creature that player controls, then each of those creatures deals damage equal to its power to that creature";§}§public AlphaBrawlEffect(final AlphaBrawlEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent creature = game.getPermanent(source.getFirstTarget());§if (creature != null) {§Player player = game.getPlayer(creature.getControllerId());§if (player != null) {§int power = creature.getPower().getValue();§for (Permanent perm: game.getBattlefield().getAllActivePermanents(filter, player.getId(), game)) {§perm.damage(power, creature.getId(), game, false, true);§}§for (Permanent perm: game.getBattlefield().getAllActivePermanents(filter, player.getId(), game)) {§creature.damage(perm.getPower().getValue(), perm.getId(), game, false, true);§}§return true;§}§}§return false;§}§@Override§public AlphaBrawlEffect copy() {§return new AlphaBrawlEffect(this);§}§}§
public class AltarOfTheLost extends CardImpl {§public AltarOfTheLost(UUID ownerId) {§super(ownerId, 144, "Altar of the Lost", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "DKA";§this.addAbility(new EntersBattlefieldTappedAbility());§this.addAbility(new ConditionalAnyColorManaAbility(2, new AltarOfTheLostManaBuilder()));§}§public AltarOfTheLost(final AltarOfTheLost card) {§super(card);§}§@Override§public AltarOfTheLost copy() {§return new AltarOfTheLost(this);§}§}§class AltarOfTheLostManaBuilder extends ConditionalManaBuilder {§@Override§public ConditionalMana build(Object. options) {§return new AltarOfTheLostConditionalMana(this.mana);§}§@Override§public String getRule() {§return "Spend this mana only to cast spells with flashback from a graveyard";§}§}§class AltarOfTheLostConditionalMana extends ConditionalMana {§public AltarOfTheLostConditionalMana(Mana mana) {§super(mana);§staticText = "Spend this mana only to cast spells with flashback from a graveyard";§addCondition(new AltarOfTheLostManaCondition());§}§}§class AltarOfTheLostManaCondition implements Condition {§@Override§public boolean apply(Game game, Ability source) {§MageObject object = game.getObject(source.getSourceId());§if (object != null && game.getState().getZone(object.getId()) == Zone.GRAVEYARD) {§for (Ability ability: object.getAbilities()) {§if (ability instanceof FlashbackAbility) {§return true;§}§}§}§return false;§}§}§
public class ArchangelsLight extends CardImpl {§public ArchangelsLight(UUID ownerId) {§super(ownerId, 1, "Archangel's Light", Rarity.MYTHIC, new CardType[]{CardType.SORCERY}, "{7}{W}");§this.expansionSetCode = "DKA";§this.getSpellAbility().addEffect(new ArchangelsLightEffect());§}§public ArchangelsLight(final ArchangelsLight card) {§super(card);§}§@Override§public ArchangelsLight copy() {§return new ArchangelsLight(this);§}§}§class ArchangelsLightEffect extends OneShotEffect {§public ArchangelsLightEffect() {§super(Outcome.GainLife);§staticText = "You gain 2 life for each card in your graveyard, then shuffle your graveyard into your library";§}§public ArchangelsLightEffect(final ArchangelsLightEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§DynamicValue value = new CardsInControllerGraveyardCount();§if (controller != null) {§controller.gainLife(value.calculate(game, source, this) * 2, game);§for (Card card: controller.getGraveyard().getCards(game)) {§controller.moveCardToLibraryWithInfo(card, source.getSourceId(), game, Zone.GRAVEYARD, true, true);§}§controller.shuffleLibrary(game);§return true;§}§return false;§}§@Override§public ArchangelsLightEffect copy() {§return new ArchangelsLightEffect(this);§}§}§
public class ArchdemonOfGreed extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("Human");§static {§filter.add(new SubtypePredicate("Human"));§filter.add(new ControllerPredicate(TargetController.YOU));§}§public ArchdemonOfGreed(UUID ownerId) {§super(ownerId, 71, "Archdemon of Greed", Rarity.RARE, new CardType[]{CardType.CREATURE}, "");§this.expansionSetCode = "DKA";§this.subtype.add("Demon");§this.color.setBlack(true);§this.nightCard = true;§this.canTransform = true;§this.power = new MageInt(9);§this.toughness = new MageInt(9);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(TrampleAbility.getInstance());§this.addAbility(new OnEventTriggeredAbility(GameEvent.EventType.UPKEEP_STEP_PRE, "beginning of your upkeep", new ArchdemonOfGreedEffect(), false));§}§public ArchdemonOfGreed(final ArchdemonOfGreed card) {§super(card);§}§@Override§public ArchdemonOfGreed copy() {§return new ArchdemonOfGreed(this);§}§class ArchdemonOfGreedEffect extends OneShotEffect {§public ArchdemonOfGreedEffect() {§super(Outcome.Damage);§this.staticText = "Sacrifice a Human. If you can't, tap {this} and it deals 9 damage to you.";§}§public ArchdemonOfGreedEffect(final ArchdemonOfGreedEffect effect) {§super(effect);§}§@Override§public ArchdemonOfGreedEffect copy() {§return new ArchdemonOfGreedEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getPermanent(source.getSourceId());§if (permanent != null) {§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§TargetControlledPermanent target = new TargetControlledPermanent(1, 1, filter, false);§if (target.canChoose(player.getId(), game)) {§player.choose(Outcome.Sacrifice, target, source.getSourceId(), game);§Permanent humanSacrifice = game.getPermanent(target.getFirstTarget());§if (humanSacrifice != null) {§return humanSacrifice.sacrifice(source.getSourceId(), game);§}§}§else {§permanent.tap(game);§player.damage(9, source.getSourceId(), game, false, true);§}§}§return true;§}§return false;§}§}§}§
public class ArtfulDodge extends CardImpl {§public ArtfulDodge(UUID ownerId) {§super(ownerId, 27, "Artful Dodge", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{U}");§this.expansionSetCode = "DKA";§this.getSpellAbility().addEffect(new CantBeBlockedTargetEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.addAbility(new FlashbackAbility(new ManaCostsImpl("{U}"), TimingRule.SORCERY));§}§public ArtfulDodge(final ArtfulDodge card) {§super(card);§}§@Override§public ArtfulDodge copy() {§return new ArtfulDodge(this);§}§}§
public class AvacynsCollar extends CardImpl {§public AvacynsCollar(UUID ownerId) {§super(ownerId, 145, "Avacyn's Collar", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{1}");§this.expansionSetCode = "DKA";§this.subtype.add("Equipment");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEquippedEffect(1, 0)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(VigilanceAbility.getInstance(), AttachmentType.EQUIPMENT)));§this.addAbility(new AvacynsCollarTriggeredAbility());§this.addAbility(new EquipAbility(Outcome.BoostCreature, new GenericManaCost(2)));§}§public AvacynsCollar(final AvacynsCollar card) {§super(card);§}§@Override§public AvacynsCollar copy() {§return new AvacynsCollar(this);§}§}§class AvacynsCollarTriggeredAbility extends TriggeredAbilityImpl {§public AvacynsCollarTriggeredAbility() {§super(Zone.BATTLEFIELD, new CreateTokenEffect(new SpiritWhiteToken()));§}§public AvacynsCollarTriggeredAbility(final AvacynsCollarTriggeredAbility ability) {§super(ability);§}§@Override§public AvacynsCollarTriggeredAbility copy() {§return new AvacynsCollarTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.ZONE_CHANGE;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (((ZoneChangeEvent) event).isDiesEvent()) {§Permanent permanent = (Permanent) game.getLastKnownInformation(event.getTargetId(), Zone.BATTLEFIELD);§if (permanent.getAttachments().contains(this.getSourceId()) && permanent.hasSubtype("Human")) {§return true;§}§}§return false;§}§@Override§public String getRule() {§return "Whenever equipped creature dies, if it was a Human, put a 1/1 white Spirit creature token with flying onto the battlefield.";§}§}§
public class BarTheDoor extends CardImpl {§public BarTheDoor(UUID ownerId) {§super(ownerId, 2, "Bar the Door", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{W}");§this.expansionSetCode = "DKA";§this.getSpellAbility().addEffect(new BoostControlledEffect(0, 4, Duration.EndOfTurn));§}§public BarTheDoor(final BarTheDoor card) {§super(card);§}§@Override§public BarTheDoor copy() {§return new BarTheDoor(this);§}§}§
public class BeguilerOfWills extends CardImpl {§public BeguilerOfWills(UUID ownerId) {§super(ownerId, 28, "Beguiler of Wills", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{3}{U}{U}");§this.expansionSetCode = "DKA";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§SimpleActivatedAbility ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,§new GainControlTargetEffect(Duration.Custom),§new TapSourceCost());§ability.addTarget(new BeguilerOfWillsTarget());§this.addAbility(ability);§}§public BeguilerOfWills(final BeguilerOfWills card) {§super(card);§}§@Override§public BeguilerOfWills copy() {§return new BeguilerOfWills(this);§}§}§class BeguilerOfWillsTarget extends TargetPermanent {§public BeguilerOfWillsTarget() {§super(new FilterCreaturePermanent("creature with power less than or equal to the number of creatures you control"));§}§public BeguilerOfWillsTarget(final BeguilerOfWillsTarget target) {§super(target);§}§@Override§public BeguilerOfWillsTarget copy() {§return new BeguilerOfWillsTarget(this);§}§@Override§public boolean canTarget(UUID controllerId, UUID id, Ability source, Game game) {§Permanent permanent = game.getPermanent(id);§int count = game.getBattlefield().countAll(this.filter, source.getControllerId(), game);§if (permanent != null && permanent.getPower().getValue() <= count) {§return super.canTarget(controllerId, id, source, game);§}§return false;§}§}§
public class BlackCat extends CardImpl {§public BlackCat(UUID ownerId) {§super(ownerId, 54, "Black Cat", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{B}");§this.expansionSetCode = "DKA";§this.subtype.add("Zombie");§this.subtype.add("Cat");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new DiesTriggeredAbility(new DiscardTargetEffect(1, true),false);§ability.addTarget(new TargetOpponent());§this.addAbility(ability);§}§public BlackCat(final BlackCat card) {§super(card);§}§@Override§public BlackCat copy() {§return new BlackCat(this);§}§}§
public class BloodFeud extends CardImpl {§public BloodFeud(UUID ownerId) {§super(ownerId, 83, "Blood Feud", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{4}{R}{R}");§this.expansionSetCode = "DKA";§this.getSpellAbility().addEffect(new FightTargetsEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.getSpellAbility().addTarget(new TargetOtherCreaturePermanent());§}§public BloodFeud(final BloodFeud card) {§super(card);§}§@Override§public BloodFeud copy() {§return new BloodFeud(this);§}§}§class TargetOtherCreaturePermanent extends TargetCreaturePermanent {§public TargetOtherCreaturePermanent() {§super();§}§public TargetOtherCreaturePermanent(final TargetOtherCreaturePermanent target) {§super(target);§}§@Override§public boolean canTarget(UUID controllerId, UUID id, Ability source, Game game) {§if (source.getTargets().get(0).getTargets().contains(id)) {§return false;§}§return super.canTarget(controllerId, id, source, game);§}§@Override§public TargetOtherCreaturePermanent copy() {§return new TargetOtherCreaturePermanent(this);§}§}§
public class BoneToAsh extends CardImpl {§private static final FilterSpell filter = new FilterSpell("creature spell");§static {§filter.add(new CardTypePredicate(CardType.CREATURE));§}§public BoneToAsh(UUID ownerId) {§super(ownerId, 29, "Bone to Ash", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{U}{U}");§this.expansionSetCode = "DKA";§this.getSpellAbility().addTarget(new TargetSpell(filter));§this.getSpellAbility().addEffect(new CounterTargetEffect());§this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(1));§}§public BoneToAsh(final BoneToAsh card) {§super(card);§}§@Override§public BoneToAsh copy() {§return new BoneToAsh(this);§}§}§
public class BreakOfDay extends CardImpl {§public BreakOfDay(UUID ownerId) {§super(ownerId, 3, "Break of Day", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{W}");§this.expansionSetCode = "DKA";§this.getSpellAbility().addEffect(new BoostControlledEffect(1, 1, Duration.EndOfTurn));§this.getSpellAbility().addEffect(new ConditionalContinuousEffect(§new GainAbilityAllEffect(IndestructibleAbility.getInstance(), Duration.EndOfTurn, new FilterControlledCreaturePermanent("creatures you control"), false),§new LockedInCondition(FatefulHourCondition.getInstance()),§"If you have 5 or less life, those creatures also are indestructible this turn"));§}§public BreakOfDay(final BreakOfDay card) {§super(card);§}§@Override§public BreakOfDay copy() {§return new BreakOfDay(this);§}§}§
public class BriarpackAlpha extends CardImpl {§public BriarpackAlpha(UUID ownerId) {§super(ownerId, 108, "Briarpack Alpha", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{G}");§this.expansionSetCode = "DKA";§this.subtype.add("Wolf");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(FlashAbility.getInstance());§Ability ability = new EntersBattlefieldTriggeredAbility(new BoostTargetEffect(2, 2, Duration.EndOfTurn));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public BriarpackAlpha(final BriarpackAlpha card) {§super(card);§}§@Override§public BriarpackAlpha copy() {§return new BriarpackAlpha(this);§}§}§
public class CallToTheKindred extends CardImpl {§public CallToTheKindred(UUID ownerId) {§super(ownerId, 30, "Call to the Kindred", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{3}{U}");§this.expansionSetCode = "DKA";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));§this.addAbility(new EnchantAbility(auraTarget.getTargetName()));§this.addAbility(new OnEventTriggeredAbility(GameEvent.EventType.UPKEEP_STEP_PRE, "beginning of your upkeep", new CallToTheKindredEffect(), true));§}§public CallToTheKindred(final CallToTheKindred card) {§super(card);§}§@Override§public CallToTheKindred copy() {§return new CallToTheKindred(this);§}§}§class CallToTheKindredEffect extends OneShotEffect {§public CallToTheKindredEffect() {§super(Outcome.PutCreatureInPlay);§this.staticText = "look at the top five cards of your library. If you do, you may put a creature card that shares a creature type with enchanted creature from among them onto the battlefield, then you put the rest of those cards on the bottom of your library in any order";§}§public CallToTheKindredEffect(final CallToTheKindredEffect effect) {§super(effect);§}§@Override§public CallToTheKindredEffect copy() {§return new CallToTheKindredEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§Permanent enchantment = game.getPermanent(source.getSourceId());§if (enchantment == null || controller == null || enchantment.getAttachedTo() == null) {§return false;§}§Permanent creature = game.getPermanent(enchantment.getAttachedTo());§if (creature == null) {§return false;§}§Cards cards = new CardsImpl();§cards.addAll(controller.getLibrary().getTopCards(game, 5));§controller.lookAtCards(enchantment.getIdName(), cards, game);§FilterCreatureCard filter = new FilterCreatureCard();§if (!creature.getAbilities().contains(ChangelingAbility.getInstance())) {§StringBuilder sb = new StringBuilder("creature card with at least one subtype from: ");§ArrayList<Predicate<MageObject>> subtypes = new ArrayList<>();§for (String subtype : creature.getSubtype()) {§subtypes.add(new SubtypePredicate(subtype));§sb.append(subtype).append(", ");§}§filter.add(Predicates.or(subtypes));§sb.delete(sb.length() - 2, sb.length());§filter.setMessage(sb.toString());§} else {§filter.setMessage("creature card that shares a creature type with enchanted creature");§}§if (cards.count(filter, game) > 0 && controller.chooseUse(Outcome.DrawCard, "Do you wish to put a creature card onto the battlefield?", source, game)) {§TargetCard target = new TargetCard(Zone.LIBRARY, filter);§if (controller.choose(Outcome.PutCreatureInPlay, cards, target, game)) {§Card card = cards.get(target.getFirstTarget(), game);§if (card != null) {§cards.remove(card);§controller.moveCards(card, Zone.BATTLEFIELD, source, game);§}§}§}§controller.putCardsOnBottomOfLibrary(cards, game, source, true);§return true;§}§}§
public class ChaliceOfDeath extends CardImpl {§public ChaliceOfDeath(UUID ownerId) {§super(ownerId, 146, "Chalice of Death", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "");§this.expansionSetCode = "DKA";§this.nightCard = true;§this.canTransform = true;§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new LoseLifeTargetEffect(5), new TapSourceCost());§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§}§public ChaliceOfDeath(final ChaliceOfDeath card) {§super(card);§}§@Override§public ChaliceOfDeath copy() {§return new ChaliceOfDeath(this);§}§}§
public class ChaliceOfLife extends CardImpl {§public ChaliceOfLife(UUID ownerId) {§super(ownerId, 146, "Chalice of Life", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "DKA";§this.canTransform = true;§this.secondSideCard = new ChaliceOfDeath(ownerId);§this.addAbility(new TransformAbility());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new ChaliceOfLifeEffect(), new TapSourceCost()));§}§public ChaliceOfLife(final ChaliceOfLife card) {§super(card);§}§@Override§public ChaliceOfLife copy() {§return new ChaliceOfLife(this);§}§}§class ChaliceOfLifeEffect extends OneShotEffect {§public ChaliceOfLifeEffect() {§super(Outcome.GainLife);§staticText = "You gain 1 life. Then if you have at least 10 life more than your starting life total, transform Chalice of Life";§}§public ChaliceOfLifeEffect(final ChaliceOfLifeEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getPermanent(source.getSourceId());§if (permanent != null) {§Player player = game.getPlayer(source.getControllerId());§player.gainLife(1, game);§if (player.getLife() >= game.getLife() + 10) {§permanent.transform(game);§game.informPlayers(new StringBuilder(permanent.getName()).append(" transforms into ").append(permanent.getSecondCardFace().getName()).toString());§}§}§return false;§}§@Override§public ChaliceOfLifeEffect copy() {§return new ChaliceOfLifeEffect(this);§}§}§
public class ChantOfTheSkifsang extends CardImpl {§public ChantOfTheSkifsang(UUID ownerId) {§super(ownerId, 31, "Chant of the Skifsang", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{U}");§this.expansionSetCode = "DKA";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.Detriment));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(-13, 0, Duration.WhileOnBattlefield)));§}§public ChantOfTheSkifsang(final ChantOfTheSkifsang card) {§super(card);§}§@Override§public ChantOfTheSkifsang copy() {§return new ChantOfTheSkifsang(this);§}§}§
public class ChillOfForeboding extends CardImpl {§public ChillOfForeboding(UUID ownerId) {§super(ownerId, 32, "Chill of Foreboding", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{2}{U}");§this.expansionSetCode = "DKA";§this.getSpellAbility().addEffect(new ChillOfForebodingEffect());§this.addAbility(new FlashbackAbility(new ManaCostsImpl("{7}{U}"), TimingRule.SORCERY));§}§public ChillOfForeboding(final ChillOfForeboding card) {§super(card);§}§@Override§public ChillOfForeboding copy() {§return new ChillOfForeboding(this);§}§}§class ChillOfForebodingEffect extends OneShotEffect {§public ChillOfForebodingEffect() {§super(Outcome.Detriment);§this.staticText = "Each player puts the top five cards of his or her library into his or her graveyard";§}§public ChillOfForebodingEffect(final ChillOfForebodingEffect effect) {§super(effect);§}§@Override§public ChillOfForebodingEffect copy() {§return new ChillOfForebodingEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player sourcePlayer = game.getPlayer(source.getControllerId());§for (UUID playerId : game.getState().getPlayersInRange(sourcePlayer.getId(), game)) {§Player player = game.getPlayer(playerId);§if (player != null) {§player.moveCards(player.getLibrary().getTopCards(game, 5), Zone.LIBRARY, Zone.GRAVEYARD, source, game);§}§}§return true;§}§}§
public class ChosenOfMarkov extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("untapped Vampire you control");§static {§filter.add(Predicates.not(new TappedPredicate()));§filter.add(new SubtypePredicate("Vampire"));§}§public ChosenOfMarkov(UUID ownerId) {§super(ownerId, 55, "Chosen of Markov", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{B}");§this.expansionSetCode = "DKA";§this.subtype.add("Human");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.canTransform = true;§this.secondSideCard = new MarkovsServant(ownerId);§this.addAbility(new TransformAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new TransformSourceEffect(true), new TapSourceCost());§ability.addCost(new TapTargetCost(new TargetControlledPermanent(filter)));§this.addAbility(ability);§}§public ChosenOfMarkov(final ChosenOfMarkov card) {§super(card);§}§@Override§public ChosenOfMarkov copy() {§return new ChosenOfMarkov(this);§}§}§
public class ClingingMists extends CardImpl {§public ClingingMists(UUID ownerId) {§super(ownerId, 109, "Clinging Mists", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{G}");§this.expansionSetCode = "DKA";§this.getSpellAbility().addEffect(new PreventAllDamageByAllEffect(null, Duration.EndOfTurn, true));§this.getSpellAbility().addEffect(new ConditionalOneShotEffect(new ClingingMistsEffect(),§FatefulHourCondition.getInstance(), "If you have 5 or less life, tap all attacking creatures. Those creatures don't untap during their controller's next untap step."));§}§public ClingingMists(final ClingingMists card) {§super(card);§}§@Override§public ClingingMists copy() {§return new ClingingMists(this);§}§}§class ClingingMistsEffect extends OneShotEffect {§private static final FilterAttackingCreature filter = new FilterAttackingCreature("attacking creatures");§public ClingingMistsEffect() {§super(Outcome.Tap);§staticText = "tap all attacking creatures. Those creatures don't untap during their controller's next untap step";§}§public ClingingMistsEffect(final ClingingMistsEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§for (Permanent creature: game.getBattlefield().getActivePermanents(filter, source.getControllerId(), source.getSourceId(), game)) {§creature.tap(game);§ContinuousEffect effect = new DontUntapInControllersNextUntapStepTargetEffect();§effect.setTargetPointer(new FixedTarget(creature.getId()));§game.addEffect(effect, source);§}§return true;§}§@Override§public ClingingMistsEffect copy() {§return new ClingingMistsEffect(this);§}§}§
public class Counterlash extends CardImpl {§public Counterlash(UUID ownerId) {§super(ownerId, 33, "Counterlash", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{4}{U}{U}");§this.expansionSetCode = "DKA";§this.getSpellAbility().addTarget(new TargetSpell());§this.getSpellAbility().addEffect(new CounterlashEffect());§}§public Counterlash(final Counterlash card) {§super(card);§}§@Override§public Counterlash copy() {§return new Counterlash(this);§}§}§class CounterlashEffect extends OneShotEffect {§public CounterlashEffect() {§super(Outcome.Detriment);§this.staticText = "Counter target spell. You may cast a nonland card in your hand that shares a card type with that spell without paying its mana cost";§}§public CounterlashEffect(final CounterlashEffect effect) {§super(effect);§}§@Override§public CounterlashEffect copy() {§return new CounterlashEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§StackObject stackObject = game.getStack().getStackObject(source.getFirstTarget());§Player player = game.getPlayer(source.getControllerId());§if (stackObject != null && player != null) {§game.getStack().counter(source.getFirstTarget(), source.getSourceId(), game);§if (player.chooseUse(Outcome.PutCardInPlay, "Cast a nonland card in your hand that shares a card type with that spell without paying its mana cost?", source, game)) {§FilterCard filter = new FilterCard();§ArrayList<Predicate<MageObject>> types = new ArrayList<Predicate<MageObject>>();§for (CardType type: stackObject.getCardType()) {§if (type != CardType.LAND) {§types.add(new CardTypePredicate(type));§}§}§filter.add(Predicates.or(types));§TargetCardInHand target = new TargetCardInHand(filter);§if (player.choose(Outcome.PutCardInPlay, target, source.getSourceId(), game)) {§Card card = player.getHand().get(target.getFirstTarget(), game);§if (card != null) {§player.cast(card.getSpellAbility(), game, true);§}§}§}§return true;§}§return false;§}§}§
public class CrushingVines extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature with flying");§static {§filter.add(new AbilityPredicate(FlyingAbility.class));§}§public CrushingVines(UUID ownerId) {§super(ownerId, 110, "Crushing Vines", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{G}");§this.expansionSetCode = "DKA";§this.getSpellAbility().addTarget(new TargetCreaturePermanent(filter));§this.getSpellAbility().addEffect(new DestroyTargetEffect());§Mode mode = new Mode();§mode.getTargets().add(new TargetArtifactPermanent());§mode.getEffects().add(new DestroyTargetEffect());§this.getSpellAbility().addMode(mode);§}§public CrushingVines(final CrushingVines card) {§super(card);§}§@Override§public CrushingVines copy() {§return new CrushingVines(this);§}§}§
public class CurseOfBloodletting extends CardImpl {§public CurseOfBloodletting(UUID ownerId) {§super(ownerId, 85, "Curse of Bloodletting", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{3}{R}{R}");§this.expansionSetCode = "DKA";§this.subtype.add("Aura");§this.subtype.add("Curse");§TargetPlayer auraTarget = new TargetPlayer();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.Damage));§this.addAbility(new EnchantAbility(auraTarget.getTargetName()));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new CurseOfBloodlettingEffect()));§}§public CurseOfBloodletting(final CurseOfBloodletting card) {§super(card);§}§@Override§public CurseOfBloodletting copy() {§return new CurseOfBloodletting(this);§}§}§class CurseOfBloodlettingEffect extends ReplacementEffectImpl {§public CurseOfBloodlettingEffect() {§super(Duration.WhileOnBattlefield, Outcome.Damage);§staticText = "If a source would deal damage to enchanted player, it deals double that damage to that player instead";§}§public CurseOfBloodlettingEffect(final CurseOfBloodlettingEffect effect) {§super(effect);§}§@Override§public CurseOfBloodlettingEffect copy() {§return new CurseOfBloodlettingEffect(this);§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType().equals(GameEvent.EventType.DAMAGE_PLAYER);§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§Permanent enchantment = game.getPermanent(source.getSourceId());§if (enchantment != null &&§enchantment.getAttachedTo() != null &&§event.getTargetId().equals(enchantment.getAttachedTo())) {§return true;§}§return false;§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§event.setAmount(event.getAmount() * 2);§return false;§}§}§
public class CurseOfEchoes extends CardImpl {§public CurseOfEchoes(UUID ownerId) {§super(ownerId, 34, "Curse of Echoes", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{4}{U}");§this.expansionSetCode = "DKA";§this.subtype.add("Aura");§this.subtype.add("Curse");§TargetPlayer auraTarget = new TargetPlayer();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.Damage));§this.addAbility(new EnchantAbility(auraTarget.getTargetName()));§this.addAbility(new CurseOfEchoesCopyTriggeredAbility());§}§public CurseOfEchoes(final CurseOfEchoes card) {§super(card);§}§@Override§public CurseOfEchoes copy() {§return new CurseOfEchoes(this);§}§}§class CurseOfEchoesCopyTriggeredAbility extends TriggeredAbilityImpl {§private static final FilterSpell filter = new FilterSpell();§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.INSTANT),§new CardTypePredicate(CardType.SORCERY)));§}§public CurseOfEchoesCopyTriggeredAbility() {§super(Zone.BATTLEFIELD, new CurseOfEchoesEffect(), false);§}§public CurseOfEchoesCopyTriggeredAbility(final CurseOfEchoesCopyTriggeredAbility ability) {§super(ability);§}§@Override§public CurseOfEchoesCopyTriggeredAbility copy() {§return new CurseOfEchoesCopyTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.SPELL_CAST;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§Spell spell = game.getStack().getSpell(event.getTargetId());§if (spell != null && (spell.getCardType().contains(CardType.INSTANT) || spell.getCardType().contains(CardType.SORCERY))) {§Permanent enchantment = game.getPermanent(sourceId);§if (enchantment != null && enchantment.getAttachedTo() != null) {§Player player = game.getPlayer(enchantment.getAttachedTo());§if (player != null && spell.getControllerId().equals(player.getId())) {§this.getEffects().get(0).setTargetPointer(new FixedTarget(spell.getId()));§return true;§}§}§}§return false;§}§@Override§public String getRule() {§return "Whenever enchanted player casts an instant or sorcery spell, each other player may copy that spell and may choose new targets for the copy he or she controls.";§}§}§class CurseOfEchoesEffect extends OneShotEffect {§public CurseOfEchoesEffect() {§super(Outcome.Copy);§}§public CurseOfEchoesEffect(final CurseOfEchoesEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Spell spell = game.getStack().getSpell(targetPointer.getFirst(game, source));§if (spell != null) {§String chooseMessage = "Copy target spell? You may choose new targets for the copy.";§for (UUID playerId: game.getPlayerList()) {§if (!playerId.equals(spell.getControllerId())) {§Player player = game.getPlayer(playerId);§if (player.chooseUse(Outcome.Copy, chooseMessage, source, game)) {§Spell copy = spell.copySpell();§copy.setControllerId(playerId);§copy.setCopiedSpell(true);§game.getStack().push(copy);§copy.chooseNewTargets(game, playerId);§}§}§}§return true;§}§return false;§}§@Override§public CurseOfEchoesEffect copy() {§return new CurseOfEchoesEffect(this);§}§@Override§public String getText(Mode mode) {§StringBuilder sb = new StringBuilder();§sb.append("Copy target ").append(mode.getTargets().get(0).getTargetName()).append(". You may choose new targets for the copy");§return sb.toString();§}§}§
public class CurseOfExhaustion extends CardImpl {§public CurseOfExhaustion(UUID ownerId) {§super(ownerId, 5, "Curse of Exhaustion", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{W}{W}");§this.expansionSetCode = "DKA";§this.subtype.add("Aura");§this.subtype.add("Curse");§TargetPlayer auraTarget = new TargetPlayer();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.Detriment));§this.addAbility(new EnchantAbility(auraTarget.getTargetName()));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new CurseOfExhaustionEffect()));§}§public CurseOfExhaustion(final CurseOfExhaustion card) {§super(card);§}§@Override§public CurseOfExhaustion copy() {§return new CurseOfExhaustion(this);§}§}§class CurseOfExhaustionEffect extends ContinuousRuleModifyingEffectImpl {§public CurseOfExhaustionEffect() {§super(Duration.WhileOnBattlefield, Outcome.Benefit);§staticText = "Enchanted player can't cast more than one spell each turn";§}§public CurseOfExhaustionEffect(final CurseOfExhaustionEffect effect) {§super(effect);§}§@Override§public CurseOfExhaustionEffect copy() {§return new CurseOfExhaustionEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§if (event.getType() == GameEvent.EventType.CAST_SPELL) {§Permanent enchantment = game.getPermanent(source.getSourceId());§if (enchantment != null && enchantment.getAttachedTo() != null) {§Player player = game.getPlayer(enchantment.getAttachedTo());§if (player != null && event.getPlayerId().equals(player.getId())) {§CastSpellLastTurnWatcher watcher = (CastSpellLastTurnWatcher) game.getState().getWatchers().get("CastSpellLastTurnWatcher");§if (watcher != null && watcher.getAmountOfSpellsPlayerCastOnCurrentTurn(event.getPlayerId()) > 0) {§return true;§}§}§}§}§return false;§}§}§
public class CurseOfMisfortunes extends CardImpl {§public CurseOfMisfortunes(UUID ownerId) {§super(ownerId, 56, "Curse of Misfortunes", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{4}{B}");§this.expansionSetCode = "DKA";§this.subtype.add("Aura");§this.subtype.add("Curse");§TargetPlayer auraTarget = new TargetPlayer();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.Detriment));§this.addAbility(new EnchantAbility(auraTarget.getTargetName()));§this.addAbility(new OnEventTriggeredAbility(GameEvent.EventType.UPKEEP_STEP_PRE, "beginning of your upkeep", new CurseOfMisfortunesEffect(), true));§}§public CurseOfMisfortunes(final CurseOfMisfortunes card) {§super(card);§}§@Override§public CurseOfMisfortunes copy() {§return new CurseOfMisfortunes(this);§}§}§class CurseOfMisfortunesEffect extends OneShotEffect {§public CurseOfMisfortunesEffect() {§super(Outcome.Detriment);§staticText = "you may search your library for a Curse card that doesn't have the same name as a Curse attached to enchanted player, put it onto the battlefield attached to that player, then shuffle your library";§}§public CurseOfMisfortunesEffect(final CurseOfMisfortunesEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§FilterCard filter = new FilterCard("Curse card that doesn't have the same name as a Curse attached to enchanted player");§filter.add(new SubtypePredicate("Curse"));§Permanent enchantment = game.getPermanent(source.getSourceId());§if (enchantment != null && enchantment.getAttachedTo() != null) {§Player targetPlayer = game.getPlayer(enchantment.getAttachedTo());§Player player = game.getPlayer(source.getControllerId());§if (player != null && targetPlayer != null) {§for (UUID attachmentId: targetPlayer.getAttachments()) {§Permanent attachment = game.getPermanent(attachmentId);§if (attachment != null && attachment.getSubtype().contains("Curse")) {§filter.add(Predicates.not(new NamePredicate(attachment.getName())));§}§}§TargetCardInLibrary targetCard = new TargetCardInLibrary(filter);§if (player.searchLibrary(targetCard, game)) {§Card card = game.getCard(targetCard.getFirstTarget());§if (card != null) {§this.setTargetPointer(new FixedTarget(targetPlayer.getId()));§game.getState().setValue("attachTo:" + card.getId(), targetPlayer.getId());§player.shuffleLibrary(game);§return card.putOntoBattlefield(game, Zone.LIBRARY, source.getSourceId(), source.getControllerId());§}§}§player.shuffleLibrary(game);§}§}§return false;§}§@Override§public CurseOfMisfortunesEffect copy() {§return new CurseOfMisfortunesEffect(this);§}§}§
public class CurseOfThirst extends CardImpl {§public CurseOfThirst(UUID ownerId) {§super(ownerId, 57, "Curse of Thirst", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{4}{B}");§this.expansionSetCode = "DKA";§this.subtype.add("Aura");§this.subtype.add("Curse");§TargetPlayer auraTarget = new TargetPlayer();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.Detriment));§this.addAbility(new EnchantAbility(auraTarget.getTargetName()));§this.addAbility(new CurseOfThirstAbility());§}§public CurseOfThirst(final CurseOfThirst card) {§super(card);§}§@Override§public CurseOfThirst copy() {§return new CurseOfThirst(this);§}§}§class CurseOfThirstAbility extends TriggeredAbilityImpl {§public CurseOfThirstAbility() {§super(Zone.BATTLEFIELD, new DamageTargetEffect(new CursesAttachedCount()));§}§public CurseOfThirstAbility(final CurseOfThirstAbility ability) {§super(ability);§}§@Override§public CurseOfThirstAbility copy() {§return new CurseOfThirstAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.UPKEEP_STEP_PRE;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§Permanent enchantment = game.getPermanent(this.sourceId);§if (enchantment != null && enchantment.getAttachedTo() != null) {§Player player = game.getPlayer(enchantment.getAttachedTo());§if (player != null && game.getActivePlayerId().equals(player.getId())) {§this.getEffects().get(0).setTargetPointer(new FixedTarget(player.getId()));§return true;§}§}§return false;§}§@Override§public String getRule() {§return "At the beginning of enchanted player's upkeep, Curse of Thirst deals damage to that player equal to the number of Curses attached to him or her.";§}§}§class CursesAttachedCount implements DynamicValue {§public CursesAttachedCount() {§}§@Override§public int calculate(Game game, Ability sourceAbility, Effect effect) {§int count = 0;§Permanent enchantment = game.getPermanent(sourceAbility.getSourceId());§if (enchantment != null && enchantment.getAttachedTo() != null) {§Player player = game.getPlayer(enchantment.getAttachedTo());§if (player != null) {§for (UUID attachmentId: player.getAttachments()) {§Permanent attachment = game.getPermanent(attachmentId);§if (attachment != null && attachment.getSubtype().contains("Curse"))§count++;§}§}§}§return count;§}§@Override§public DynamicValue copy() {§return new CursesAttachedCount();§}§@Override§public String toString() {§return "";§}§@Override§public String getMessage() {§return "number of Curses attached to him or her";§}§}§
public class DawntreaderElk extends CardImpl {§public DawntreaderElk(UUID ownerId) {§super(ownerId, 111, "Dawntreader Elk", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "DKA";§this.subtype.add("Elk");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§SimpleActivatedAbility ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,§new SearchLibraryPutInPlayEffect(new TargetCardInLibrary(new FilterBasicLandCard()), true),§new ColoredManaCost(ColoredManaSymbol.G));§ability.addCost(new SacrificeSourceCost());§this.addAbility(ability);§}§public DawntreaderElk(final DawntreaderElk card) {§super(card);§}§@Override§public DawntreaderElk copy() {§return new DawntreaderElk(this);§}§}§
public class DeadlyAllure extends CardImpl {§public DeadlyAllure(UUID ownerId) {§super(ownerId, 58, "Deadly Allure", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{B}");§this.expansionSetCode = "DKA";§this.getSpellAbility().addEffect(new GainAbilityTargetEffect(DeathtouchAbility.getInstance(), Duration.EndOfTurn));§this.getSpellAbility().addEffect(new MustBeBlockedByAtLeastOneTargetEffect(Duration.EndOfTurn));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.addAbility(new FlashbackAbility(new ManaCostsImpl("{G}"), TimingRule.SORCERY));§}§public DeadlyAllure(final DeadlyAllure card) {§super(card);§}§@Override§public DeadlyAllure copy() {§return new DeadlyAllure(this);§}§}§
public class DeathsCaress extends CardImpl {§public DeathsCaress(UUID ownerId) {§super(ownerId, 59, "Death's Caress", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{3}{B}{B}");§this.expansionSetCode = "DKA";§this.getSpellAbility().addEffect(new DestroyTargetEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.getSpellAbility().addEffect(new DeathsCaressEffect());§}§public DeathsCaress(final DeathsCaress card) {§super(card);§}§@Override§public DeathsCaress copy() {§return new DeathsCaress(this);§}§}§class DeathsCaressEffect extends OneShotEffect {§public DeathsCaressEffect() {§super(Outcome.GainLife);§this.staticText = "If that creature was a Human, you gain life equal to its toughness";§}§public DeathsCaressEffect(final DeathsCaressEffect effect) {§super(effect);§}§@Override§public DeathsCaressEffect copy() {§return new DeathsCaressEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§Permanent creature = (Permanent) game.getLastKnownInformation(source.getFirstTarget(), Zone.BATTLEFIELD);§if (player != null && creature != null && creature.hasSubtype("Human")) {§player.gainLife(creature.getToughness().getValue(), game);§return true;§}§return false;§}§}§
public class DerangedOutcast extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("a Human");§static {§filter.add(new SubtypePredicate("Human"));§}§public DerangedOutcast(UUID ownerId) {§super(ownerId, 112, "Deranged Outcast", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "DKA";§this.subtype.add("Human");§this.subtype.add("Rogue");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new AddCountersTargetEffect(CounterType.P1P1.createInstance(2)), new ManaCostsImpl("{1}{G}"));§ability.addCost(new SacrificeTargetCost(new TargetControlledPermanent(filter)));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public DerangedOutcast(final DerangedOutcast card) {§super(card);§}§@Override§public DerangedOutcast copy() {§return new DerangedOutcast(this);§}§}§
public class DrogskolReaver extends CardImpl {§public DrogskolReaver(UUID ownerId) {§super(ownerId, 137, "Drogskol Reaver", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{5}{W}{U}");§this.expansionSetCode = "DKA";§this.subtype.add("Spirit");§this.power = new MageInt(3);§this.toughness = new MageInt(5);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(DoubleStrikeAbility.getInstance());§this.addAbility(LifelinkAbility.getInstance());§this.addAbility(new DrogskolReaverAbility());§}§public DrogskolReaver(final DrogskolReaver card) {§super(card);§}§@Override§public DrogskolReaver copy() {§return new DrogskolReaver(this);§}§}§class DrogskolReaverAbility extends TriggeredAbilityImpl {§public DrogskolReaverAbility() {§super(Zone.BATTLEFIELD, new DrawCardSourceControllerEffect(1), false);§}§public DrogskolReaverAbility(final DrogskolReaverAbility ability) {§super(ability);§}§@Override§public DrogskolReaverAbility copy() {§return new DrogskolReaverAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.GAINED_LIFE;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§return event.getPlayerId().equals(controllerId);§}§@Override§public String getRule() {§return "Whenever you gain life, draw a card.";§}§}§
public class DungeonGeists extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature an opponent controls");§static {§filter.add(new ControllerPredicate(TargetController.OPPONENT));§}§public DungeonGeists(UUID ownerId) {§super(ownerId, 36, "Dungeon Geists", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{U}{U}");§this.expansionSetCode = "DKA";§this.subtype.add("Spirit");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new EntersBattlefieldTriggeredAbility(new TapTargetEffect(), false);§ability.addEffect(new DungeonGeistsEffect());§Target target = new TargetCreaturePermanent(filter);§ability.addTarget(target);§this.addAbility(ability, new DungeonGeistsWatcher());§}§public DungeonGeists(final DungeonGeists card) {§super(card);§}§@Override§public DungeonGeists copy() {§return new DungeonGeists(this);§}§}§class DungeonGeistsEffect extends ContinuousRuleModifyingEffectImpl {§public DungeonGeistsEffect() {§super(Duration.Custom, Outcome.Detriment, false, false);§this.staticText = "That creature doesn't untap during its controller's untap step for as long as you control {this}";§}§public DungeonGeistsEffect(final DungeonGeistsEffect effect) {§super(effect);§}§@Override§public DungeonGeistsEffect copy() {§return new DungeonGeistsEffect(this);§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.UNTAP || event.getType() == GameEvent.EventType.ZONE_CHANGE || event.getType() == GameEvent.EventType.LOST_CONTROL;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§Permanent sourcePermanent = (Permanent) source.getSourceObjectIfItStillExists(game);§if (sourcePermanent == null || !sourcePermanent.getControllerId().equals(source.getControllerId())) {§discard();§return false;§}§switch(event.getType()) {§case ZONE_CHANGE:§if (event.getTargetId().equals(source.getSourceId())) {§ZoneChangeEvent zEvent = (ZoneChangeEvent)event;§if (zEvent.getFromZone() == Zone.BATTLEFIELD) {§discard();§return false;§}§}§break;§case UNTAP:§if (game.getTurn().getStepType() == PhaseStep.UNTAP && event.getTargetId().equals(targetPointer.getFirst(game, source))) {§Permanent targetCreature = game.getPermanent(targetPointer.getFirst(game, source));§if (targetCreature != null) {§return targetCreature.getControllerId().equals(game.getActivePlayerId());§} else {§discard();§return false;§}§}§break;§case LOST_CONTROL:§if (event.getTargetId().equals(source.getSourceId())) {§discard();§return false;§}§break;§}§return false;§}§}§class DungeonGeistsWatcher extends Watcher {§DungeonGeistsWatcher () {§super("ControlLost", WatcherScope.CARD);§}§DungeonGeistsWatcher(DungeonGeistsWatcher watcher) {§super(watcher);§}§@Override§public void watch(GameEvent event, Game game) {§if (event.getType() == GameEvent.EventType.LOST_CONTROL && event.getPlayerId().equals(controllerId) && event.getTargetId().equals(sourceId)) {§condition = true;§game.replaceEvent(event);§return;§}§if (event.getType() == GameEvent.EventType.ZONE_CHANGE && event.getTargetId().equals(sourceId)) {§ZoneChangeEvent zEvent = (ZoneChangeEvent)event;§if (zEvent.getFromZone() == Zone.BATTLEFIELD) {§condition = true;§game.replaceEvent(event);§}§}§}§@Override§public void reset() {§}§@Override§public DungeonGeistsWatcher copy() {§return new DungeonGeistsWatcher(this);§}§}§
public class ElbrusTheBindingBlade extends CardImpl {§public ElbrusTheBindingBlade(UUID ownerId) {§super(ownerId, 147, "Elbrus, the Binding Blade", Rarity.MYTHIC, new CardType[]{CardType.ARTIFACT}, "{7}");§this.expansionSetCode = "DKA";§this.supertype.add("Legendary");§this.subtype.add("Equipment");§this.canTransform = true;§this.secondSideCard = new WithengarUnbound(ownerId);§this.addAbility(new TransformAbility());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEquippedEffect(1, 0)));§this.addAbility(new DealsDamageToAPlayerAttachedTriggeredAbility(new ElbrusTheBindingBladeEffect(), "equipped", true));§this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(1)));§}§public ElbrusTheBindingBlade(final ElbrusTheBindingBlade card) {§super(card);§}§@Override§public ElbrusTheBindingBlade copy() {§return new ElbrusTheBindingBlade(this);§}§}§class ElbrusTheBindingBladeEffect extends OneShotEffect {§public ElbrusTheBindingBladeEffect() {§super(Outcome.BecomeCreature);§staticText = "unattach {this}, then transform it";§}§public ElbrusTheBindingBladeEffect(final ElbrusTheBindingBladeEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent equipment = game.getPermanent(source.getSourceId());§if (equipment != null && equipment.getAttachedTo() != null) {§Permanent attachedTo = game.getPermanent(equipment.getAttachedTo());§if (attachedTo != null) {§attachedTo.removeAttachment(equipment.getId(), game);§equipment.transform(game);§game.informPlayers(new StringBuilder(equipment.getName()).append(" transforms into ").append(equipment.getSecondCardFace().getName()).toString());§}§}§return false;§}§@Override§public ElbrusTheBindingBladeEffect copy() {§return new ElbrusTheBindingBladeEffect(this);§}§}§
public class ElgaudInquisitor extends CardImpl {§public ElgaudInquisitor(UUID ownerId) {§super(ownerId, 6, "Elgaud Inquisitor", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{W}");§this.expansionSetCode = "DKA";§this.subtype.add("Human");§this.subtype.add("Cleric");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(LifelinkAbility.getInstance());§this.addAbility(new DiesTriggeredAbility(new CreateTokenEffect(new SpiritWhiteToken())));§}§public ElgaudInquisitor(final ElgaudInquisitor card) {§super(card);§}§@Override§public ElgaudInquisitor copy() {§return new ElgaudInquisitor(this);§}§}§
public class ErdwalRipper extends CardImpl {§public ErdwalRipper(UUID ownerId) {§super(ownerId, 86, "Erdwal Ripper", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{R}{R}");§this.expansionSetCode = "DKA";§this.subtype.add("Vampire");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(HasteAbility.getInstance());§this.addAbility(new DealsCombatDamageToAPlayerTriggeredAbility(new AddCountersSourceEffect(CounterType.P1P1.createInstance()), false));§}§public ErdwalRipper(final ErdwalRipper card) {§super(card);§}§@Override§public ErdwalRipper copy() {§return new ErdwalRipper(this);§}§}§
public class ExecutionersHood extends CardImpl {§public ExecutionersHood(UUID ownerId) {§super(ownerId, 148, "Executioner's Hood", Rarity.COMMON, new CardType[]{CardType.ARTIFACT}, "{2}");§this.expansionSetCode = "DKA";§this.subtype.add("Equipment");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(IntimidateAbility.getInstance(), AttachmentType.EQUIPMENT)));§this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(2)));§}§public ExecutionersHood(final ExecutionersHood card) {§super(card);§}§@Override§public ExecutionersHood copy() {§return new ExecutionersHood(this);§}§}§
public class FaithlessLooting extends CardImpl {§public FaithlessLooting(UUID ownerId) {§super(ownerId, 87, "Faithless Looting", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{R}");§this.expansionSetCode = "DKA";§this.getSpellAbility().addEffect(new DrawDiscardControllerEffect(2,2));§this.addAbility(new FlashbackAbility(new ManaCostsImpl("{2}{R}"), TimingRule.SORCERY));§}§public FaithlessLooting(final FaithlessLooting card) {§super(card);§}§@Override§public FaithlessLooting copy() {§return new FaithlessLooting(this);§}§}§
public class FaithsShield extends CardImpl {§public FaithsShield(UUID ownerId) {§super(ownerId, 7, "Faith's Shield", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{W}");§this.expansionSetCode = "DKA";§this.getSpellAbility().addEffect(new FaithsShieldEffect());§this.getSpellAbility().addTarget(new TargetControlledPermanent());§}§public FaithsShield(final FaithsShield card) {§super(card);§}§@Override§public FaithsShield copy() {§return new FaithsShield(this);§}§}§class FaithsShieldEffect extends OneShotEffect {§public FaithsShieldEffect() {§super(Outcome.Protect);§staticText = "Target permanent you control gains protection from the color of your choice until end of turn."§+ "<br/><br/><i>Fateful hour</i> - If you have 5 or less life, instead you and each permanent you control gain protection from the color of your choice until end of turn";§}§public FaithsShieldEffect(final FaithsShieldEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§if (FatefulHourCondition.getInstance().apply(game, source)) {§ChoiceColor choice = new ChoiceColor();§while (!choice.isChosen()) {§controller.choose(Outcome.Protect, choice, game);§if (!controller.canRespond()) {§return false;§}§}§FilterCard filter = new FilterCard();§filter.add(new ColorPredicate(choice.getColor()));§filter.setMessage(choice.getChoice());§Ability ability = new ProtectionAbility(filter) ;§game.addEffect(new GainAbilityControlledEffect(ability, Duration.EndOfTurn), source);§game.addEffect(new GainAbilityControllerEffect(ability, Duration.EndOfTurn), source);§}§else {§game.addEffect(new GainProtectionFromColorTargetEffect(Duration.EndOfTurn), source);§}§return true;§}§return false;§}§@Override§public FaithsShieldEffect copy() {§return new FaithsShieldEffect(this);§}§}§
public class FalkenrathAristocrat extends CardImpl {§public FalkenrathAristocrat(UUID ownerId) {§super(ownerId, 138, "Falkenrath Aristocrat", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{2}{B}{R}");§this.expansionSetCode = "DKA";§this.subtype.add("Vampire");§this.power = new MageInt(4);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(HasteAbility.getInstance());§SimpleActivatedAbility ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,§new GainAbilitySourceEffect(IndestructibleAbility.getInstance(), Duration.EndOfTurn),§new SacrificeTargetCost(new TargetControlledCreaturePermanent()));§ability.addEffect(new FalkenrathAristocratEffect());§this.addAbility(ability);§}§public FalkenrathAristocrat(final FalkenrathAristocrat card) {§super(card);§}§@Override§public FalkenrathAristocrat copy() {§return new FalkenrathAristocrat(this);§}§}§class FalkenrathAristocratEffect extends OneShotEffect {§public FalkenrathAristocratEffect() {§super(Outcome.BoostCreature);§this.staticText = "If the sacrificed creature was a Human, put a +1/+1 counter on {this}";§}§public FalkenrathAristocratEffect(final FalkenrathAristocratEffect effect) {§super(effect);§}§@Override§public FalkenrathAristocratEffect copy() {§return new FalkenrathAristocratEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§for (Cost cost : source.getCosts()) {§if (cost instanceof SacrificeTargetCost) {§Permanent sacrificedCreature = ((SacrificeTargetCost) cost).getPermanents().get(0);§Permanent sourceCreature = game.getPermanent(source.getSourceId());§if (sacrificedCreature.hasSubtype("Human") && sourceCreature != null) {§sourceCreature.addCounters(CounterType.P1P1.createInstance(), game);§return true;§}§}§}§return true;§}§}§
public class FalkenrathTorturer extends CardImpl {§public FalkenrathTorturer(UUID ownerId) {§super(ownerId, 60, "Falkenrath Torturer", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{B}");§this.expansionSetCode = "DKA";§this.subtype.add("Vampire");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§SimpleActivatedAbility ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,§new GainAbilitySourceEffect(FlyingAbility.getInstance(), Duration.EndOfTurn),§new SacrificeTargetCost(new TargetControlledCreaturePermanent()));§ability.addEffect(new FalkenrathAristocratEffect());§this.addAbility(ability);§}§public FalkenrathTorturer(final FalkenrathTorturer card) {§super(card);§}§@Override§public FalkenrathTorturer copy() {§return new FalkenrathTorturer(this);§}§}§class FalkenrathTorturerEffect extends OneShotEffect {§public FalkenrathTorturerEffect() {§super(Outcome.DrawCard);§this.staticText = "If the sacrificed creature was a Human, put a +1/+1 counter on {this}";§}§public FalkenrathTorturerEffect(final FalkenrathTorturerEffect effect) {§super(effect);§}§@Override§public FalkenrathTorturerEffect copy() {§return new FalkenrathTorturerEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§for (Cost cost : source.getCosts()) {§if (cost instanceof SacrificeTargetCost) {§Permanent sacrificedCreature = ((SacrificeTargetCost) cost).getPermanents().get(0);§Permanent sourceCreature = game.getPermanent(source.getSourceId());§if (sacrificedCreature.hasSubtype("Human") && sourceCreature != null) {§sourceCreature.addCounters(CounterType.P1P1.createInstance(), game);§return true;§}§}§}§return false;§}§}§
public class FarbogBoneflinger extends CardImpl {§public FarbogBoneflinger(UUID ownerId) {§super(ownerId, 61, "Farbog Boneflinger", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{B}");§this.expansionSetCode = "DKA";§this.subtype.add("Zombie");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new EntersBattlefieldTriggeredAbility(new BoostTargetEffect(-2, -2, Duration.EndOfTurn));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public FarbogBoneflinger(final FarbogBoneflinger card) {§super(card);§}§@Override§public FarbogBoneflinger copy() {§return new FarbogBoneflinger(this);§}§}§
public class FavorOfTheWoods extends CardImpl {§public FavorOfTheWoods(UUID ownerId) {§super(ownerId, 113, "Favor of the Woods", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{G}");§this.expansionSetCode = "DKA";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.Neutral));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new BlocksAttachedTriggeredAbility(new GainLifeEffect(3), "enchanted", false));§}§public FavorOfTheWoods(final FavorOfTheWoods card) {§super(card);§}§@Override§public FavorOfTheWoods copy() {§return new FavorOfTheWoods(this);§}§}§
public class FeedThePack extends CardImpl {§public FeedThePack(UUID ownerId) {§super(ownerId, 114, "Feed the Pack", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{5}{G}");§this.expansionSetCode = "DKA";§this.addAbility(new BeginningOfYourEndStepTriggeredAbility(new FeedThePackEffect(), true));§}§public FeedThePack(final FeedThePack card) {§super(card);§}§@Override§public FeedThePack copy() {§return new FeedThePack(this);§}§}§class FeedThePackEffect extends OneShotEffect {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("nontoken creature");§static {§filter.add(Predicates.not(new TokenPredicate()));§}§public FeedThePackEffect() {§super(Outcome.PutCreatureInPlay);§this.staticText = "sacrifice a nontoken creature. If you do, put X 2/2 green Wolf creature tokens onto the battlefield, where X is the sacrificed creature's toughness";§}§public FeedThePackEffect(final FeedThePackEffect effect) {§super(effect);§}§@Override§public FeedThePackEffect copy() {§return new FeedThePackEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Target target = new TargetPermanent(filter);§Player player = game.getPlayer(source.getControllerId());§if (player.choose(Outcome.PutCreatureInPlay, target, source.getSourceId(), game)) {§Permanent permanent = game.getPermanent(target.getFirstTarget());§if (permanent != null && permanent.sacrifice(source.getSourceId(), game)) {§int toughness = permanent.getToughness().getValue();§WolfToken token = new WolfToken();§token.putOntoBattlefield(toughness, game, source.getSourceId(), source.getControllerId());§return true;§}§}§return false;§}§}§
public class FiendOfTheShadows extends CardImpl {§private UUID exileId = UUID.randomUUID();§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("a human");§static {§filter.add(new SubtypePredicate("Human"));§}§public FiendOfTheShadows(UUID ownerId) {§super(ownerId, 62, "Fiend of the Shadows", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{B}{B}");§this.expansionSetCode = "DKA";§this.subtype.add("Vampire");§this.subtype.add("Wizard");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new DealsCombatDamageToAPlayerTriggeredAbility(new ExileFromZoneTargetEffect(Zone.HAND, exileId, "Fiend of the Shadows", new FilterCard()), false, true));§this.addAbility(new SimpleStaticAbility(Zone.ALL, new FiendOfTheShadowsEffect(exileId)));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new RegenerateSourceEffect(), new SacrificeTargetCost(new TargetControlledCreaturePermanent(1, 1, filter, false))));§}§public FiendOfTheShadows(final FiendOfTheShadows card) {§super(card);§}§@Override§public FiendOfTheShadows copy() {§return new FiendOfTheShadows(this);§}§}§class FiendOfTheShadowsEffect extends AsThoughEffectImpl {§private final UUID exileId;§public FiendOfTheShadowsEffect(UUID exileId) {§super(AsThoughEffectType.PLAY_FROM_NOT_OWN_HAND_ZONE, Duration.EndOfGame, Outcome.Benefit);§this.exileId = exileId;§staticText = "You may play that card for as long as it remains exiled";§}§public FiendOfTheShadowsEffect(final FiendOfTheShadowsEffect effect) {§super(effect);§this.exileId = effect.exileId;§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public FiendOfTheShadowsEffect copy() {§return new FiendOfTheShadowsEffect(this);§}§@Override§public boolean applies(UUID objectId, Ability source, UUID affectedControllerId, Game game) {§if (affectedControllerId.equals(source.getControllerId())) {§ExileZone zone = game.getExile().getExileZone(exileId);§if (zone != null && zone.contains(objectId)) {§return true;§}§}§return false;§}§}§
public class FiresOfUndeath extends CardImpl {§public FiresOfUndeath(UUID ownerId) {§super(ownerId, 88, "Fires of Undeath", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{R}");§this.expansionSetCode = "DKA";§this.getSpellAbility().addTarget(new TargetCreatureOrPlayer());§this.getSpellAbility().addEffect(new DamageTargetEffect(2));§this.addAbility(new FlashbackAbility(new ManaCostsImpl("{5}{B}"), TimingRule.INSTANT));§}§public FiresOfUndeath(final FiresOfUndeath card) {§super(card);§}§@Override§public FiresOfUndeath copy() {§return new FiresOfUndeath(this);§}§}§
public class FlayerOfTheHatebound extends CardImpl {§public FlayerOfTheHatebound(UUID ownerId) {§super(ownerId, 89, "Flayer of the Hatebound", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}{R}");§this.expansionSetCode = "DKA";§this.subtype.add("Devil");§this.power = new MageInt(4);§this.toughness = new MageInt(2);§this.addAbility(new UndyingAbility());§Ability ability = new FlayerTriggeredAbility();§ability.addTarget(new TargetCreatureOrPlayer());§this.addAbility(ability);§}§public FlayerOfTheHatebound(final FlayerOfTheHatebound card) {§super(card);§}§@Override§public FlayerOfTheHatebound copy() {§return new FlayerOfTheHatebound(this);§}§}§class FlayerTriggeredAbility extends TriggeredAbilityImpl {§public FlayerTriggeredAbility() {§super(Zone.BATTLEFIELD, new FlayerEffect(), false);§}§public FlayerTriggeredAbility(FlayerTriggeredAbility ability) {§super(ability);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.ENTERS_THE_BATTLEFIELD;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§Permanent permanent = game.getPermanent(event.getTargetId());§if (((EntersTheBattlefieldEvent) event).getFromZone() == Zone.GRAVEYARD§&& permanent.getOwnerId().equals(controllerId)§&& permanent.getCardType().contains(CardType.CREATURE)) {§Effect effect = this.getEffects().get(0);§effect.setValue("damageSource", event.getTargetId());§return true;§}§return false;§}§@Override§public String getRule() {§return "Whenever Flayer of the Hatebound or another creature enters the battlefield from your graveyard, that creature deals damage equal to its power to target creature or player.";§}§@Override§public FlayerTriggeredAbility copy() {§return new FlayerTriggeredAbility(this);§}§}§class FlayerEffect extends OneShotEffect {§public FlayerEffect() {§super(Outcome.Damage);§staticText = "that creature deals damage equal to its power to target creature or player";§}§public FlayerEffect(final FlayerEffect effect) {§super(effect);§}§@Override§public FlayerEffect copy() {§return new FlayerEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§UUID creatureId = (UUID) getValue("damageSource");§Permanent creature = game.getPermanent(creatureId);§if (creature == null) {§creature = (Permanent) game.getLastKnownInformation(creatureId, Zone.BATTLEFIELD);§}§if (creature != null) {§int amount = creature.getPower().getValue();§UUID target = source.getTargets().getFirstTarget();§Permanent targetCreature = game.getPermanent(target);§if (targetCreature != null) {§targetCreature.damage(amount, creature.getId(), game, false, true);§return true;§}§Player player = game.getPlayer(target);§if (player != null) {§player.damage(amount, creature.getId(), game, false, true);§return true;§}§}§return false;§}§}§
public class ForgeDevil extends CardImpl {§public ForgeDevil(UUID ownerId) {§super(ownerId, 91, "Forge Devil", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{R}");§this.expansionSetCode = "DKA";§this.subtype.add("Devil");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Effect effect = new DamageTargetEffect(1);§effect.setText("it deals 1 damage to target creature");§Ability ability = new EntersBattlefieldTriggeredAbility(effect);§ability.addTarget(new TargetCreaturePermanent());§effect = new DamageControllerEffect(1);§effect.setText("and 1 damage to you");§ability.addEffect(effect);§this.addAbility(ability);§}§public ForgeDevil(final ForgeDevil card) {§super(card);§}§@Override§public ForgeDevil copy() {§return new ForgeDevil(this);§}§}§
public class GatherTheTownsfolk extends CardImpl {§public GatherTheTownsfolk(UUID ownerId) {§super(ownerId, 8, "Gather the Townsfolk", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{1}{W}");§this.expansionSetCode = "DKA";§this.getSpellAbility().addEffect(new ConditionalOneShotEffect(new CreateTokenEffect(new HumanToken(), 5), new CreateTokenEffect(new HumanToken(), 2),§FatefulHourCondition.getInstance(), "Put two 1/1 white Human creature tokens onto the battlefield. If you have 5 or less life, put five of those tokens onto the battlefield instead"));§}§public GatherTheTownsfolk(final GatherTheTownsfolk card) {§super(card);§}§@Override§public GatherTheTownsfolk copy() {§return new GatherTheTownsfolk(this);§}§}§
public class GeralfsMindcrusher extends CardImpl {§public GeralfsMindcrusher(UUID ownerId) {§super(ownerId, 37, "Geralf's Mindcrusher", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{U}{U}");§this.expansionSetCode = "DKA";§this.subtype.add("Zombie");§this.subtype.add("Horror");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§Ability ability = new EntersBattlefieldTriggeredAbility(new PutLibraryIntoGraveTargetEffect(5));§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§this.addAbility(new UndyingAbility());§}§public GeralfsMindcrusher(final GeralfsMindcrusher card) {§super(card);§}§@Override§public GeralfsMindcrusher copy() {§return new GeralfsMindcrusher(this);§}§}§
public class GhastlyHaunting extends CardImpl {§public GhastlyHaunting(UUID ownerId) {§super(ownerId, 50, "Ghastly Haunting", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "");§this.expansionSetCode = "DKA";§this.subtype.add("Aura");§this.color.setBlue(true);§this.nightCard = true;§this.canTransform = true;§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new ControlEnchantedEffect()));§}§public GhastlyHaunting(final GhastlyHaunting card) {§super(card);§}§@Override§public GhastlyHaunting copy() {§return new GhastlyHaunting(this);§}§}§
public class Ghoultree extends CardImpl {§public Ghoultree(UUID ownerId) {§super(ownerId, 115, "Ghoultree", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{7}{G}");§this.expansionSetCode = "DKA";§this.subtype.add("Zombie");§this.subtype.add("Treefolk");§this.power = new MageInt(10);§this.toughness = new MageInt(10);§Ability ability = new SimpleStaticAbility(Zone.ALL, new GhoultreeCostReductionEffect());§ability.setRuleAtTheTop(true);§this.addAbility(ability);§}§public Ghoultree(final Ghoultree card) {§super(card);§}§@Override§public Ghoultree copy() {§return new Ghoultree(this);§}§}§class GhoultreeCostReductionEffect extends CostModificationEffectImpl {§GhoultreeCostReductionEffect() {§super(Duration.WhileOnStack, Outcome.Benefit, CostModificationType.REDUCE_COST);§staticText = "{this} costs {1} less to cast for each creature card in your graveyard";§}§GhoultreeCostReductionEffect(GhoultreeCostReductionEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source, Ability abilityToModify) {§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§int reductionAmount = player.getGraveyard().count(new FilterCreatureCard(), game);§CardUtil.reduceCost(abilityToModify, reductionAmount);§return true;§}§return false;§}§@Override§public boolean applies(Ability abilityToModify, Ability source, Game game) {§if ((abilityToModify instanceof SpellAbility) && abilityToModify.getSourceId().equals(source.getSourceId())) {§return game.getCard(abilityToModify.getSourceId()) != null;§}§return false;§}§@Override§public GhoultreeCostReductionEffect copy() {§return new GhoultreeCostReductionEffect(this);§}§}§
public class GrafdiggersCage extends CardImpl {§public GrafdiggersCage(UUID ownerId) {§super(ownerId, 149, "Grafdigger's Cage", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{1}");§this.expansionSetCode = "DKA";§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GrafdiggersCageEffect()));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GrafdiggersCageEffect2()));§}§public GrafdiggersCage(final GrafdiggersCage card) {§super(card);§}§@Override§public GrafdiggersCage copy() {§return new GrafdiggersCage(this);§}§}§class GrafdiggersCageEffect extends ContinuousRuleModifyingEffectImpl {§public GrafdiggersCageEffect() {§super(Duration.WhileOnBattlefield, Outcome.Benefit);§staticText = "Creature cards can't enter the battlefield from graveyards or libraries";§}§public GrafdiggersCageEffect(final GrafdiggersCageEffect effect) {§super(effect);§}§@Override§public GrafdiggersCageEffect copy() {§return new GrafdiggersCageEffect(this);§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return EventType.ZONE_CHANGE.equals(event.getType());§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§ZoneChangeEvent zEvent = (ZoneChangeEvent) event;§if (zEvent.getToZone() == Zone.BATTLEFIELD && (zEvent.getFromZone() == Zone.GRAVEYARD || zEvent.getFromZone() == Zone.LIBRARY)) {§Card card = game.getCard(zEvent.getTargetId());§if (card != null && card.getCardType().contains(CardType.CREATURE)) {§return true;§}§}§return false;§}§}§class GrafdiggersCageEffect2 extends ContinuousRuleModifyingEffectImpl {§public GrafdiggersCageEffect2() {§super(Duration.WhileOnBattlefield, Outcome.Benefit);§staticText = "Players can't cast cards in graveyards or libraries";§}§public GrafdiggersCageEffect2(final GrafdiggersCageEffect2 effect) {§super(effect);§}§@Override§public GrafdiggersCageEffect2 copy() {§return new GrafdiggersCageEffect2(this);§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.CAST_SPELL;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§Card card = game.getCard(event.getSourceId());§if (card != null) {§Zone zone = game.getState().getZone(card.getId());§if (zone != null && (zone == Zone.GRAVEYARD || zone == Zone.LIBRARY)) {§return true;§}§}§return false;§}§}§
public class Gravecrawler extends CardImpl {§public Gravecrawler(UUID ownerId) {§super(ownerId, 64, "Gravecrawler", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{B}");§this.expansionSetCode = "DKA";§this.subtype.add("Zombie");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new CantBlockAbility());§this.addAbility(new SimpleStaticAbility(Zone.ALL, new GravecrawlerPlayEffect()));§}§public Gravecrawler(final Gravecrawler card) {§super(card);§}§@Override§public Gravecrawler copy() {§return new Gravecrawler(this);§}§}§class GravecrawlerPlayEffect extends AsThoughEffectImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("zombie");§static {§filter.add(new SubtypePredicate("Zombie"));§}§public GravecrawlerPlayEffect() {§super(AsThoughEffectType.PLAY_FROM_NOT_OWN_HAND_ZONE, Duration.EndOfGame, Outcome.Benefit);§staticText = "You may cast {this} from your graveyard as long as you control a Zombie";§}§public GravecrawlerPlayEffect(final GravecrawlerPlayEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public GravecrawlerPlayEffect copy() {§return new GravecrawlerPlayEffect(this);§}§@Override§public boolean applies(UUID sourceId, Ability source, UUID affectedControllerId, Game game) {§if (sourceId.equals(source.getSourceId()) && source.getControllerId().equals(affectedControllerId)) {§Card card = game.getCard(source.getSourceId());§if (card != null && game.getState().getZone(source.getSourceId()) == Zone.GRAVEYARD) {§if (game.getBattlefield().countAll(filter, source.getControllerId(), game) > 0) {§return true;§}§}§}§return false;§}§}§
public class Gravepurge extends CardImpl {§public Gravepurge(UUID ownerId) {§super(ownerId, 65, "Gravepurge", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{B}");§this.expansionSetCode = "DKA";§this.getSpellAbility().addEffect(new PutOnLibraryTargetEffect(true));§this.getSpellAbility().addTarget(new TargetCardInYourGraveyard(0, Integer.MAX_VALUE, new FilterCreatureCard("creature cards from your graveyard")));§this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(1));§}§public Gravepurge(final Gravepurge card) {§super(card);§}§@Override§public Gravepurge copy() {§return new Gravepurge(this);§}§}§
public class GravetillerWurm extends CardImpl {§public GravetillerWurm(UUID ownerId) {§super(ownerId, 116, "Gravetiller Wurm", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{5}{G}");§this.expansionSetCode = "DKA";§this.subtype.add("Wurm");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(TrampleAbility.getInstance());§this.addAbility(new EntersBattlefieldAbility(new ConditionalOneShotEffect(new AddCountersSourceEffect(CounterType.P1P1.createInstance(4)),§MorbidCondition.getInstance(), ""), "with four +1/+1 counters on it if a creature died this turn"));§}§public GravetillerWurm(final GravetillerWurm card) {§super(card);§}§@Override§public GravetillerWurm copy() {§return new GravetillerWurm(this);§}§}§
public class GrimBackwoods extends CardImpl {§public GrimBackwoods(UUID ownerId) {§super(ownerId, 156, "Grim Backwoods", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "DKA";§this.addAbility(new ColorlessManaAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DrawCardSourceControllerEffect(1), new ManaCostsImpl("{2}{B}{G}"));§ability.addCost(new TapSourceCost());§ability.addCost(new SacrificeTargetCost(new TargetControlledCreaturePermanent()));§this.addAbility(ability);§}§public GrimBackwoods(final GrimBackwoods card) {§super(card);§}§@Override§public GrimBackwoods copy() {§return new GrimBackwoods(this);§}§}§
public class GrimFlowering extends CardImpl {§public GrimFlowering(UUID ownerId) {§super(ownerId, 117, "Grim Flowering", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{5}{G}");§this.expansionSetCode = "DKA";§this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(new CardsInControllerGraveyardCount(new FilterCreatureCard())));§}§public GrimFlowering(final GrimFlowering card) {§super(card);§}§@Override§public GrimFlowering copy() {§return new GrimFlowering(this);§}§}§
public class Griptide extends CardImpl {§public Griptide(UUID ownerId) {§super(ownerId, 38, "Griptide", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{3}{U}");§this.expansionSetCode = "DKA";§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.getSpellAbility().addEffect(new PutOnLibraryTargetEffect(true));§}§public Griptide(final Griptide card) {§super(card);§}§@Override§public Griptide copy() {§return new Griptide(this);§}§}§
public class GruesomeDiscovery extends CardImpl {§public GruesomeDiscovery(UUID ownerId) {§super(ownerId, 66, "Gruesome Discovery", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{2}{B}{B}");§this.expansionSetCode = "DKA";§this.getSpellAbility().addEffect(new ConditionalOneShotEffect(§new GruesomeDiscoveryEffect(),§new DiscardTargetEffect(2),§MorbidCondition.getInstance(),§"Target player discards two cards. Morbid - If a creature died this turn, instead that player reveals his or her hand, you choose two cards from it, then that player discards those cards"));§this.getSpellAbility().addTarget(new TargetPlayer());§}§public GruesomeDiscovery(final GruesomeDiscovery card) {§super(card);§}§@Override§public GruesomeDiscovery copy() {§return new GruesomeDiscovery(this);§}§}§class GruesomeDiscoveryEffect extends OneShotEffect {§public GruesomeDiscoveryEffect() {§super(Outcome.Discard);§this.staticText = "target player reveals his or her hand, you choose two cards from it, then that player discards those cards";§}§public GruesomeDiscoveryEffect(final GruesomeDiscoveryEffect effect) {§super(effect);§}§@Override§public GruesomeDiscoveryEffect copy() {§return new GruesomeDiscoveryEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§Player targetPlayer = game.getPlayer(source.getFirstTarget());§if (player != null && targetPlayer != null) {§targetPlayer.revealCards("Gruesome Discovery", targetPlayer.getHand(), game);§if (targetPlayer.getHand().size() <= 2) {§targetPlayer.discard(2, source, game);§}§TargetCard target = new TargetCard(2, Zone.HAND, new FilterCard());§if (player.choose(Outcome.Benefit, targetPlayer.getHand(), target, game)) {§List<UUID> targets = target.getTargets();§for (UUID targetId : targets) {§Card card = targetPlayer.getHand().get(targetId, game);§if (card != null) {§targetPlayer.discard(card, source, game);§}§}§}§return true;§}§return false;§}§}§
public class HarrowingJourney extends CardImpl {§public HarrowingJourney(UUID ownerId) {§super(ownerId, 67, "Harrowing Journey", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{4}{B}");§this.expansionSetCode = "DKA";§this.getSpellAbility().addEffect(new DrawCardTargetEffect(3));§this.getSpellAbility().addEffect(new LoseLifeTargetEffect(3));§this.getSpellAbility().addTarget(new TargetPlayer());§}§public HarrowingJourney(final HarrowingJourney card) {§super(card);§}§@Override§public HarrowingJourney copy() {§return new HarrowingJourney(this);§}§}§
public class HauntedFengraf extends CardImpl {§public HauntedFengraf(UUID ownerId) {§super(ownerId, 157, "Haunted Fengraf", Rarity.COMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "DKA";§this.addAbility(new ColorlessManaAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new HauntedFengrafEffect(), new GenericManaCost(3));§ability.addCost(new TapSourceCost());§ability.addCost(new SacrificeSourceCost());§this.addAbility(ability);§}§public HauntedFengraf(final HauntedFengraf card) {§super(card);§}§@Override§public HauntedFengraf copy() {§return new HauntedFengraf(this);§}§}§class HauntedFengrafEffect extends OneShotEffect {§public HauntedFengrafEffect() {§super(Outcome.ReturnToHand);§this.staticText = "Return a creature card at random from your graveyard to your hand";§}§public HauntedFengrafEffect(final HauntedFengrafEffect effect) {§super(effect);§}§@Override§public HauntedFengrafEffect copy() {§return new HauntedFengrafEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§Card[] cards = player.getGraveyard().getCards(new FilterCreatureCard(), game).toArray(new Card[0]);§if (cards.length > 0) {§Random rnd = new Random();§Card card = cards[rnd.nextInt(cards.length)];§card.moveToZone(Zone.HAND, source.getSourceId(), game, true);§game.informPlayers(card.getName() + " returned to the hand of " + player.getLogName());§return true;§}§}§return false;§}§}§
public class HavengulLich extends CardImpl {§private static final FilterCard filter = new FilterCreatureCard("creature card in a graveyard");§public HavengulLich(UUID ownerId) {§super(ownerId, 139, "Havengul Lich", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{3}{U}{B}");§this.expansionSetCode = "DKA";§this.subtype.add("Zombie");§this.subtype.add("Wizard");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new HavengulLichPlayEffect(), new ManaCostsImpl("{1}"));§ability.addEffect(new HavengulLichPlayedEffect());§ability.addTarget(new TargetCardInGraveyard(filter));§this.addAbility(ability);§}§public HavengulLich(final HavengulLich card) {§super(card);§}§@Override§public HavengulLich copy() {§return new HavengulLich(this);§}§}§class HavengulLichPlayEffect extends AsThoughEffectImpl {§public HavengulLichPlayEffect() {§super(AsThoughEffectType.PLAY_FROM_NOT_OWN_HAND_ZONE, Duration.EndOfTurn, Outcome.Benefit);§staticText = "You may cast target creature card in a graveyard this turn";§}§public HavengulLichPlayEffect(final HavengulLichPlayEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public HavengulLichPlayEffect copy() {§return new HavengulLichPlayEffect(this);§}§@Override§public boolean applies(UUID objectId, Ability source, UUID affectedControllerId, Game game) {§UUID targetId = getTargetPointer().getFirst(game, source);§if (targetId != null) {§return targetId.equals(objectId)§&& source.getControllerId().equals(affectedControllerId)§&& Zone.GRAVEYARD.equals(game.getState().getZone(objectId));§} else {§discard();§return false;§}§}§}§class HavengulLichPlayedEffect extends OneShotEffect {§public HavengulLichPlayedEffect() {§super(Outcome.PutCreatureInPlay);§}§public HavengulLichPlayedEffect(final HavengulLichPlayedEffect effect) {§super(effect);§staticText = "When you cast that card this turn, {this} gains all activated abilities of that card until end of turn";§}§@Override§public boolean apply(Game game, Ability source) {§DelayedTriggeredAbility ability = new HavengulLichDelayedTriggeredAbility(getTargetPointer().getFirst(game, source));§game.addDelayedTriggeredAbility(ability, source);§return true;§}§@Override§public HavengulLichPlayedEffect copy() {§return new HavengulLichPlayedEffect(this);§}§}§class HavengulLichDelayedTriggeredAbility extends DelayedTriggeredAbility {§private UUID cardId;§public HavengulLichDelayedTriggeredAbility(UUID cardId) {§super(new HavengulLichEffect(cardId), Duration.EndOfTurn);§this.cardId = cardId;§}§public HavengulLichDelayedTriggeredAbility(HavengulLichDelayedTriggeredAbility ability) {§super(ability);§this.cardId = ability.cardId;§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.SPELL_CAST;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§return event.getSourceId().equals(cardId);§}§@Override§public HavengulLichDelayedTriggeredAbility copy() {§return new HavengulLichDelayedTriggeredAbility(this);§}§@Override§public String getRule() {§return "When you cast that card this turn, {this} gains all activated abilities of that card until end of turn.";§}§}§class HavengulLichEffect extends ContinuousEffectImpl {§private final UUID cardId;§public HavengulLichEffect(UUID cardId) {§super(Duration.EndOfTurn, Layer.AbilityAddingRemovingEffects_6, SubLayer.NA, Outcome.AddAbility);§this.cardId = cardId;§}§public HavengulLichEffect(final HavengulLichEffect effect) {§super(effect);§this.cardId = effect.cardId;§}§@Override§public HavengulLichEffect copy() {§return new HavengulLichEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getPermanent(source.getSourceId());§Card card = game.getCard(cardId);§if (permanent != null && card != null) {§for (ActivatedAbility ability : card.getAbilities().getActivatedAbilities(Zone.BATTLEFIELD)) {§permanent.addAbility(ability, source.getSourceId(), game);§}§}§return false;§}§}§
public class HavengulRunebinder extends CardImpl {§private static final FilterCreatureCard filter = new FilterCreatureCard("a creature card from your graveyard");§private static final FilterControlledCreaturePermanent filterPermanent = new FilterControlledCreaturePermanent("Zombie creature you control");§static {§filterPermanent.add(new SubtypePredicate("Zombie"));§}§public HavengulRunebinder(UUID ownerId) {§super(ownerId, 39, "Havengul Runebinder", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{U}{U}");§this.expansionSetCode = "DKA";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§SimpleActivatedAbility ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,§new CreateTokenEffect(new ZombieToken()),§new ManaCostsImpl("{2}{U}"));§ability.addCost(new TapSourceCost());§ability.addCost(new ExileFromGraveCost(new TargetCardInYourGraveyard(filter)));§ability.addEffect(new AddCountersAllEffect(CounterType.P1P1.createInstance(), filterPermanent));§this.addAbility(ability);§}§public HavengulRunebinder(final HavengulRunebinder card) {§super(card);§}§@Override§public HavengulRunebinder copy() {§return new HavengulRunebinder(this);§}§}§
public class HeadlessSkaab extends CardImpl {§public HeadlessSkaab(UUID ownerId) {§super(ownerId, 40, "Headless Skaab", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{U}");§this.expansionSetCode = "DKA";§this.subtype.add("Zombie");§this.subtype.add("Warrior");§this.power = new MageInt(3);§this.toughness = new MageInt(6);§this.getSpellAbility().addCost(new ExileFromGraveCost(new TargetCardInYourGraveyard(new FilterCreatureCard("creature card from your graveyard"))));§this.addAbility(new EntersBattlefieldTappedAbility());§}§public HeadlessSkaab(final HeadlessSkaab card) {§super(card);§}§@Override§public HeadlessSkaab copy() {§return new HeadlessSkaab(this);§}§}§
public class HeavyMattock extends CardImpl {§private static final String staticText = "As long as equipped creature is a Human, it gets an additional +1/+1";§public HeavyMattock(UUID ownerId) {§super(ownerId, 150, "Heavy Mattock", Rarity.COMMON, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "DKA";§this.subtype.add("Equipment");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEquippedEffect(1, 1)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new ConditionalContinuousEffect(new BoostEquippedEffect(1, 1), new EquippedHasSubtypeCondition("Human"), staticText)));§this.addAbility(new EquipAbility(Outcome.BoostCreature, new GenericManaCost(2)));§}§public HeavyMattock(final HeavyMattock card) {§super(card);§}§@Override§public HeavyMattock copy() {§return new HeavyMattock(this);§}§}§
public class HecklingFiends extends CardImpl {§public HecklingFiends(UUID ownerId) {§super(ownerId, 92, "Heckling Fiends", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "DKA";§this.subtype.add("Devil");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§SimpleActivatedAbility ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,§new AttacksIfAbleTargetEffect(Duration.EndOfTurn),§new ManaCostsImpl("{2}{R}"));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public HecklingFiends(final HecklingFiends card) {§super(card);§}§@Override§public HecklingFiends copy() {§return new HecklingFiends(this);§}§}§
public class HighbornGhoul extends CardImpl {§public HighbornGhoul(UUID ownerId) {§super(ownerId, 68, "Highborn Ghoul", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{B}{B}");§this.expansionSetCode = "DKA";§this.subtype.add("Zombie");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(IntimidateAbility.getInstance());§}§public HighbornGhoul(final HighbornGhoul card) {§super(card);§}§@Override§public HighbornGhoul copy() {§return new HighbornGhoul(this);§}§}§
public class HinterlandHermit extends CardImpl {§public HinterlandHermit(UUID ownerId) {§super(ownerId, 94, "Hinterland Hermit", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{R}");§this.expansionSetCode = "DKA";§this.subtype.add("Human");§this.subtype.add("Werewolf");§this.canTransform = true;§this.secondSideCard = new HinterlandScourge(ownerId);§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new TransformAbility());§TriggeredAbility ability = new BeginningOfUpkeepTriggeredAbility(new TransformSourceEffect(true), TargetController.ANY, false);§this.addAbility(new ConditionalTriggeredAbility(ability, NoSpellsWereCastLastTurnCondition.getInstance(), TransformAbility.NO_SPELLS_TRANSFORM_RULE));§}§public HinterlandHermit(final HinterlandHermit card) {§super(card);§}§@Override§public HinterlandHermit copy() {§return new HinterlandHermit(this);§}§}§
public class HinterlandScourge extends CardImpl {§public HinterlandScourge(UUID ownerId) {§super(ownerId, 94, "Hinterland Scourge", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "");§this.expansionSetCode = "DKA";§this.subtype.add("Werewolf");§this.color.setRed(true);§this.nightCard = true;§this.canTransform = true;§this.power = new MageInt(3);§this.toughness = new MageInt(2);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new MustBeBlockedByAtLeastOneSourceEffect()));§TriggeredAbility ability = new BeginningOfUpkeepTriggeredAbility(new TransformSourceEffect(false), TargetController.ANY, false);§this.addAbility(new ConditionalTriggeredAbility(ability, TwoOrMoreSpellsWereCastLastTurnCondition.getInstance(), TransformAbility.TWO_OR_MORE_SPELLS_TRANSFORM_RULE));§}§public HinterlandScourge(final HinterlandScourge card) {§super(card);§}§@Override§public HinterlandScourge copy() {§return new HinterlandScourge(this);§}§}§
public class HollowhengeBeast extends CardImpl {§public HollowhengeBeast(UUID ownerId) {§super(ownerId, 118, "Hollowhenge Beast", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{G}{G}");§this.expansionSetCode = "DKA";§this.subtype.add("Beast");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§}§public HollowhengeBeast(final HollowhengeBeast card) {§super(card);§}§@Override§public HollowhengeBeast copy() {§return new HollowhengeBeast(this);§}§}§
public class HollowhengeSpirit extends CardImpl {§public HollowhengeSpirit(UUID ownerId) {§super(ownerId, 10, "Hollowhenge Spirit", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{W}");§this.expansionSetCode = "DKA";§this.subtype.add("Spirit");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlashAbility.getInstance());§this.addAbility(FlyingAbility.getInstance());§Ability ability = new EntersBattlefieldTriggeredAbility(new RemoveFromCombatTargetEffect());§Target target = new TargetAttackingOrBlockingCreature();§ability.addTarget(target);§this.addAbility(ability);§}§public HollowhengeSpirit(final HollowhengeSpirit card) {§super(card);§}§@Override§public HollowhengeSpirit copy() {§return new HollowhengeSpirit(this);§}§}§
public class HungerOfTheHowlpack extends CardImpl {§public HungerOfTheHowlpack(UUID ownerId) {§super(ownerId, 119, "Hunger of the Howlpack", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{G}");§this.expansionSetCode = "DKA";§this.getSpellAbility().addEffect(§new ConditionalOneShotEffect(§new AddCountersTargetEffect(CounterType.P1P1.createInstance(3)),§new AddCountersTargetEffect(CounterType.P1P1.createInstance()),§MorbidCondition.getInstance(),§"Put a +1/+1 counter on target creature. Morbid - Put three +1/+1 counters on that creature instead if a creature died this turn"));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public HungerOfTheHowlpack(final HungerOfTheHowlpack card) {§super(card);§}§@Override§public HungerOfTheHowlpack copy() {§return new HungerOfTheHowlpack(this);§}§}§
public class HuntmasterOfTheFells extends CardImpl {§public HuntmasterOfTheFells(UUID ownerId) {§super(ownerId, 140, "Huntmaster of the Fells", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{2}{R}{G}");§this.expansionSetCode = "DKA";§this.subtype.add("Human");§this.subtype.add("Werewolf");§this.canTransform = true;§this.secondSideCard = new RavagerOfTheFells(ownerId);§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new HuntmasterOfTheFellsAbility());§this.addAbility(new RavagerOfTheFellsAbility());§this.addAbility(new TransformAbility());§TriggeredAbility ability = new BeginningOfUpkeepTriggeredAbility(new TransformSourceEffect(true), TargetController.ANY, false);§this.addAbility(new ConditionalTriggeredAbility(ability, NoSpellsWereCastLastTurnCondition.getInstance(), TransformAbility.NO_SPELLS_TRANSFORM_RULE));§}§public HuntmasterOfTheFells(final HuntmasterOfTheFells card) {§super(card);§}§@Override§public HuntmasterOfTheFells copy() {§return new HuntmasterOfTheFells(this);§}§}§class HuntmasterOfTheFellsAbility extends TriggeredAbilityImpl {§public HuntmasterOfTheFellsAbility() {§super(Zone.BATTLEFIELD, new CreateTokenEffect(new WolfToken()), false);§this.addEffect(new GainLifeEffect(2));§}§public HuntmasterOfTheFellsAbility(final HuntmasterOfTheFellsAbility ability) {§super(ability);§}§@Override§public HuntmasterOfTheFellsAbility copy() {§return new HuntmasterOfTheFellsAbility(this);§}§@Override§public boolean isInUseableZone(Game game, MageObject source, GameEvent event) {§if (event.getType() == GameEvent.EventType.TRANSFORMED) {§Permanent currentSourceObject = (Permanent) getSourceObjectIfItStillExists(game);§if (currentSourceObject != null && !currentSourceObject.isNightCard()) {§return true;§}§}§return super.isInUseableZone(game, source, event);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.TRANSFORMED || event.getType() == GameEvent.EventType.ENTERS_THE_BATTLEFIELD;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (event.getType() == GameEvent.EventType.TRANSFORMED && event.getTargetId().equals(this.getSourceId())) {§Permanent permanent = game.getPermanent(sourceId);§if (permanent != null && !permanent.isTransformed()) {§return true;§}§}§if (event.getType() == GameEvent.EventType.ENTERS_THE_BATTLEFIELD && event.getTargetId().equals(this.getSourceId())) {§return true;§}§return false;§}§@Override§public String getRule() {§return "Whenever this creature enters the battlefield or transforms into {this}, put a 2/2 green Wolf creature token onto the battlefield and you gain 2 life.";§}§}§class RavagerOfTheFellsAbility extends TriggeredAbilityImpl {§public RavagerOfTheFellsAbility() {§super(Zone.BATTLEFIELD, new RavagerOfTheFellsEffect(), false);§Target target1 = new TargetOpponent();§this.addTarget(target1);§this.addTarget(new RavagerOfTheFellsTarget());§this.setRuleVisible(false);§}§public RavagerOfTheFellsAbility(final RavagerOfTheFellsAbility ability) {§super(ability);§}§@Override§public RavagerOfTheFellsAbility copy() {§return new RavagerOfTheFellsAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.TRANSFORMED;§}§@Override§public boolean isInUseableZone(Game game, MageObject source, GameEvent event) {§Permanent currentSourceObject = (Permanent) getSourceObjectIfItStillExists(game);§if (currentSourceObject != null && currentSourceObject.isNightCard()) {§return true;§}§return super.isInUseableZone(game, source, event);§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (event.getTargetId().equals(sourceId)) {§Permanent permanent = game.getPermanent(sourceId);§if (permanent != null && permanent.isTransformed()) {§return true;§}§}§return false;§}§@Override§public String getRule() {§return "Whenever this creature transforms into Ravager of the Fells, it deals 2 damage to target opponent and 2 damage to up to one target creature that player controls.";§}§}§class RavagerOfTheFellsEffect extends OneShotEffect {§public RavagerOfTheFellsEffect() {§super(Outcome.Damage);§}§public RavagerOfTheFellsEffect(final RavagerOfTheFellsEffect effect) {§super(effect);§}§@Override§public RavagerOfTheFellsEffect copy() {§return new RavagerOfTheFellsEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getTargets().get(0).getFirstTarget());§if (player != null) {§player.damage(2, source.getSourceId(), game, false, true);§}§Permanent creature = game.getPermanent(source.getTargets().get(1).getFirstTarget());§if (creature != null) {§creature.damage(2, source.getSourceId(), game, false, true);§}§return true;§}§}§class RavagerOfTheFellsTarget extends TargetPermanent {§public RavagerOfTheFellsTarget() {§super(0, 1, new FilterCreaturePermanent(), false);§}§public RavagerOfTheFellsTarget(final RavagerOfTheFellsTarget target) {§super(target);§}§@Override§public boolean canTarget(UUID id, Ability source, Game game) {§UUID firstTarget = source.getFirstTarget();§Permanent permanent = game.getPermanent(id);§if (firstTarget != null && permanent != null && permanent.getControllerId().equals(firstTarget)) {§return super.canTarget(id, source, game);§}§return false;§}§@Override§public Set<UUID> possibleTargets(UUID sourceId, UUID sourceControllerId, Game game) {§Set<UUID> availablePossibleTargets = super.possibleTargets(sourceId, sourceControllerId, game);§Set<UUID> possibleTargets = new HashSet<>();§MageObject object = game.getObject(sourceId);§for (StackObject item: game.getState().getStack()) {§if (item.getId().equals(sourceId)) {§object = item;§}§if (item.getSourceId().equals(sourceId)) {§object = item;§}§}§if (object instanceof StackObject) {§UUID playerId = ((StackObject)object).getStackAbility().getFirstTarget();§for (UUID targetId : availablePossibleTargets) {§Permanent permanent = game.getPermanent(targetId);§if(permanent != null && permanent.getControllerId().equals(playerId)){§possibleTargets.add(targetId);§}§}§}§return possibleTargets;§}§@Override§public RavagerOfTheFellsTarget copy() {§return new RavagerOfTheFellsTarget(this);§}§}§
public class Immerwolf extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Wolf and Werewolf creatures");§static {§filter.add(Predicates.or(new SubtypePredicate("Wolf"), new SubtypePredicate("Werewolf")));§}§public Immerwolf(UUID ownerId) {§super(ownerId, 141, "Immerwolf", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{R}{G}");§this.expansionSetCode = "DKA";§this.subtype.add("Wolf");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(IntimidateAbility.getInstance());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostControlledEffect(1, 1, Duration.WhileOnBattlefield, filter, true)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new ImmerwolfEffect()));§}§public Immerwolf(final Immerwolf card) {§super(card);§}§@Override§public Immerwolf copy() {§return new Immerwolf(this);§}§}§class ImmerwolfEffect extends ContinuousRuleModifyingEffectImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent();§static {§filter.add(new SubtypePredicate("Werewolf"));§filter.add(Predicates.not(new SubtypePredicate("Human")));§}§public ImmerwolfEffect() {§super(Duration.WhileOnBattlefield, Outcome.Detriment);§staticText = "Non-Human Werewolves you control can't transform";§}§public ImmerwolfEffect(final ImmerwolfEffect effect) {§super(effect);§}§@Override§public ImmerwolfEffect copy() {§return new ImmerwolfEffect(this);§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == EventType.TRANSFORM;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§Permanent permanent = game.getPermanent(event.getTargetId());§return permanent != null &&§permanent.getControllerId().equals(source.getControllerId()) &&§filter.match(permanent, game) ;§}§}§
public class IncreasingAmbition extends CardImpl {§public IncreasingAmbition(UUID ownerId) {§super(ownerId, 69, "Increasing Ambition", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{4}{B}");§this.expansionSetCode = "DKA";§this.getSpellAbility().addEffect(new IncreasingAmbitionEffect());§this.addAbility(new FlashbackAbility(new ManaCostsImpl("{7}{B}"), TimingRule.SORCERY));§}§public IncreasingAmbition(final IncreasingAmbition card) {§super(card);§}§@Override§public IncreasingAmbition copy() {§return new IncreasingAmbition(this);§}§}§class IncreasingAmbitionEffect extends SearchEffect {§public IncreasingAmbitionEffect() {§super(new TargetCardInLibrary(), Outcome.DrawCard);§staticText = "Search your library for a card and put that card into your hand. If {this} was cast from a graveyard, instead search your library for two cards and put those cards into your hand. Then shuffle your library";§}§public IncreasingAmbitionEffect(final IncreasingAmbitionEffect effect) {§super(effect);§}§@Override§public IncreasingAmbitionEffect copy() {§return new IncreasingAmbitionEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§Spell spell = (Spell) game.getStack().getStackObject(source.getSourceId());§if (spell != null) {§if (spell.getFromZone() == Zone.GRAVEYARD) {§target = new TargetCardInLibrary(2, new FilterCard());§}§else {§target = new TargetCardInLibrary();§}§if (player.searchLibrary(target, game)) {§if (target.getTargets().size() > 0) {§for (UUID cardId: (List<UUID>)target.getTargets()) {§Card card = player.getLibrary().remove(cardId, game);§if (card != null) {§card.moveToZone(Zone.HAND, source.getSourceId(), game, false);§}§}§}§}§player.shuffleLibrary(game);§return true;§}§}§return false;§}§}§
public class IncreasingConfusion extends CardImpl {§public IncreasingConfusion(UUID ownerId) {§super(ownerId, 41, "Increasing Confusion", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{X}{U}");§this.expansionSetCode = "DKA";§this.getSpellAbility().addEffect(new IncreasingConfusionEffect());§this.getSpellAbility().addTarget(new TargetPlayer());§this.addAbility(new FlashbackAbility(new ManaCostsImpl("{X}{U}"), TimingRule.SORCERY));§}§public IncreasingConfusion(final IncreasingConfusion card) {§super(card);§}§@Override§public IncreasingConfusion copy() {§return new IncreasingConfusion(this);§}§}§class IncreasingConfusionEffect extends OneShotEffect {§public IncreasingConfusionEffect() {§super(Outcome.Detriment);§staticText = "Target player puts the top X cards of his or her library into his or her graveyard. If {this} was cast from a graveyard, that player puts twice that many cards into his or her graveyard instead";§}§public IncreasingConfusionEffect(final IncreasingConfusionEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getFirstTarget());§if (player != null) {§int amount = source.getManaCostsToPay().getX();§Spell spell = (Spell) game.getStack().getStackObject(source.getSourceId());§if (spell != null) {§if (spell.getFromZone() == Zone.GRAVEYARD) {§amount *= 2;§}§player.moveCards(player.getLibrary().getTopCards(game, amount), Zone.LIBRARY, Zone.GRAVEYARD, source, game);§return true;§}§}§return false;§}§@Override§public IncreasingConfusionEffect copy() {§return new IncreasingConfusionEffect(this);§}§}§
public class IncreasingDevotion extends CardImpl {§public IncreasingDevotion(UUID ownerId) {§super(ownerId, 11, "Increasing Devotion", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{3}{W}{W}");§this.expansionSetCode = "DKA";§this.getSpellAbility().addEffect(new IncreasingDevotionEffect());§this.addAbility(new FlashbackAbility(new ManaCostsImpl("{7}{W}{W}"), TimingRule.SORCERY));§}§public IncreasingDevotion(final IncreasingDevotion card) {§super(card);§}§@Override§public IncreasingDevotion copy() {§return new IncreasingDevotion(this);§}§}§class IncreasingDevotionEffect extends OneShotEffect {§private static HumanToken token = new HumanToken();§public IncreasingDevotionEffect() {§super(Outcome.PutCreatureInPlay);§staticText = "Put five 1/1 white Human creature tokens onto the battlefield. If Increasing Devotion was cast from a graveyard, put ten of those tokens onto the battlefield instead";§}§public IncreasingDevotionEffect(final IncreasingDevotionEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§int amount = 5;§Spell spell = (Spell) game.getStack().getStackObject(source.getSourceId());§if (spell != null) {§if (spell.getFromZone() == Zone.GRAVEYARD) {§amount = 10;§}§token.putOntoBattlefield(amount, game, source.getSourceId(), source.getControllerId());§return true;§}§return false;§}§@Override§public IncreasingDevotionEffect copy() {§return new IncreasingDevotionEffect(this);§}§}§
public class IncreasingSavagery extends CardImpl {§public IncreasingSavagery(UUID ownerId) {§super(ownerId, 120, "Increasing Savagery", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{2}{G}{G}");§this.expansionSetCode = "DKA";§this.getSpellAbility().addEffect(new IncreasingSavageryEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.addAbility(new FlashbackAbility(new ManaCostsImpl("{5}{G}{G}"), TimingRule.SORCERY));§}§public IncreasingSavagery(final IncreasingSavagery card) {§super(card);§}§@Override§public IncreasingSavagery copy() {§return new IncreasingSavagery(this);§}§}§class IncreasingSavageryEffect extends OneShotEffect {§public IncreasingSavageryEffect() {§super(Outcome.BoostCreature);§staticText = "Put five +1/+1 counters on target creature. If Increasing Savagery was cast from a graveyard, put ten +1/+1 counters on that creature instead";§}§public IncreasingSavageryEffect(final IncreasingSavageryEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§int amount = 5;§Spell spell = (Spell) game.getStack().getStackObject(source.getSourceId());§if (spell != null) {§if (spell.getFromZone() == Zone.GRAVEYARD) {§amount = 10;§}§Permanent permanent = game.getPermanent(targetPointer.getFirst(game, source));§if (permanent != null) {§permanent.addCounters(CounterType.P1P1.createInstance(amount), game);§}§return true;§}§return false;§}§@Override§public IncreasingSavageryEffect copy() {§return new IncreasingSavageryEffect(this);§}§}§
public class IncreasingVengeance extends CardImpl {§private static final FilterSpell filter = new FilterSpell("instant or sorcery spell");§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.INSTANT),§new CardTypePredicate(CardType.SORCERY)));§filter.add(new ControllerPredicate(TargetController.YOU));§}§public IncreasingVengeance(UUID ownerId) {§super(ownerId, 95, "Increasing Vengeance", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{R}{R}");§this.expansionSetCode = "DKA";§this.getSpellAbility().addEffect(new IncreasingVengeanceEffect());§Target target = new TargetSpell(filter);§this.getSpellAbility().addTarget(target);§this.addAbility(new FlashbackAbility(new ManaCostsImpl("{3}{R}{R}"), TimingRule.INSTANT));§}§public IncreasingVengeance(final IncreasingVengeance card) {§super(card);§}§@Override§public IncreasingVengeance copy() {§return new IncreasingVengeance(this);§}§}§class IncreasingVengeanceEffect extends OneShotEffect {§public IncreasingVengeanceEffect() {§super(Outcome.BoostCreature);§staticText = "Copy target instant or sorcery spell you control. If Increasing Vengeance was cast from a graveyard, copy that spell twice instead. You may choose new targets for the copies";§}§public IncreasingVengeanceEffect(final IncreasingVengeanceEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Spell spell = game.getStack().getSpell(targetPointer.getFirst(game, source));§if (spell != null) {§Spell copy = spell.copySpell();§copy.setControllerId(source.getControllerId());§copy.setCopiedSpell(true);§game.getStack().push(copy);§copy.chooseNewTargets(game, source.getControllerId());§game.informPlayers(new StringBuilder(controller.getLogName()).append(copy.getActivatedMessage(game)).toString());§Spell sourceSpell = (Spell) game.getStack().getStackObject(source.getSourceId());§if (sourceSpell != null) {§if (sourceSpell.getFromZone() == Zone.GRAVEYARD) {§copy = spell.copySpell();§copy.setControllerId(source.getControllerId());§copy.setCopiedSpell(true);§game.getStack().push(copy);§copy.chooseNewTargets(game, source.getControllerId());§game.informPlayers(new StringBuilder(controller.getLogName()).append(copy.getActivatedMessage(game)).toString());§}§}§return true;§}§}§return false;§}§@Override§public IncreasingVengeanceEffect copy() {§return new IncreasingVengeanceEffect(this);§}§}§
public class JarOfEyeballs extends CardImpl {§public JarOfEyeballs(UUID ownerId) {§super(ownerId, 152, "Jar of Eyeballs", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "DKA";§this.addAbility(new JarOfEyeballsTriggeredAbility());§SimpleActivatedAbility ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new JarOfEyeballsEffect(), new GenericManaCost(3));§ability.addCost(new TapSourceCost());§ability.addCost(new JarOfEyeballsCost());§this.addAbility(ability);§}§public JarOfEyeballs(final JarOfEyeballs card) {§super(card);§}§@Override§public JarOfEyeballs copy() {§return new JarOfEyeballs(this);§}§}§class JarOfEyeballsTriggeredAbility extends TriggeredAbilityImpl {§public JarOfEyeballsTriggeredAbility() {§super(Zone.BATTLEFIELD, new AddCountersSourceEffect(CounterType.EYEBALL.createInstance(2)));§}§public JarOfEyeballsTriggeredAbility(final JarOfEyeballsTriggeredAbility ability) {§super(ability);§}§@Override§public JarOfEyeballsTriggeredAbility copy() {§return new JarOfEyeballsTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.ZONE_CHANGE;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (((ZoneChangeEvent) event).getToZone() == Zone.GRAVEYARD§&& ((ZoneChangeEvent) event).getFromZone() == Zone.BATTLEFIELD) {§Permanent permanent = (Permanent) game.getLastKnownInformation(event.getTargetId(), Zone.BATTLEFIELD);§if (permanent.getControllerId().equals(this.getControllerId()) && permanent.getCardType().contains(CardType.CREATURE)) {§return true;§}§}§return false;§}§@Override§public String getRule() {§return "Whenever a creature you control dies, " + super.getRule();§}§}§class JarOfEyeballsCost extends CostImpl {§private int removedCounters;§public JarOfEyeballsCost() {§super();§this.removedCounters = 0;§this.text = "Remove all eyeball counters from {this}";§}§public JarOfEyeballsCost(JarOfEyeballsCost cost) {§super(cost);§this.removedCounters = cost.removedCounters;§}§@Override§public boolean canPay(Ability ability, UUID sourceId, UUID controllerId, Game game) {§return true;§}§@Override§public boolean pay(Ability ability, Game game, UUID sourceId, UUID controllerId, boolean noMana, Cost costToPay) {§Permanent permanent = game.getPermanent(ability.getSourceId());§if (permanent != null) {§this.removedCounters = permanent.getCounters().getCount(CounterType.EYEBALL);§if (this.removedCounters > 0) {§permanent.removeCounters(CounterType.EYEBALL.createInstance(this.removedCounters), game);§}§}§this.paid = true;§return true;§}§@Override§public JarOfEyeballsCost copy() {§return new JarOfEyeballsCost(this);§}§public int getRemovedCounters() {§return this.removedCounters;§}§}§class JarOfEyeballsEffect extends OneShotEffect {§public JarOfEyeballsEffect() {§super(Outcome.DrawCard);§this.staticText = "Look at the top X cards of your library, where X is the number of eyeball counters removed this way. Put one of them into your hand and the rest on the bottom of your library in any order";§}§public JarOfEyeballsEffect(final JarOfEyeballsEffect effect) {§super(effect);§}§@Override§public JarOfEyeballsEffect copy() {§return new JarOfEyeballsEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§int countersRemoved = 0;§for (Cost cost : source.getCosts()) {§if (cost instanceof JarOfEyeballsCost) {§countersRemoved = ((JarOfEyeballsCost) cost).getRemovedCounters();§}§}§Player player = game.getPlayer(source.getControllerId());§if (player == null) {§return false;§}§Cards cards = new CardsImpl();§int count = Math.min(player.getLibrary().size(), countersRemoved);§for (int i = 0; i < count; i++) {§Card card = player.getLibrary().removeFromTop(game);§if (card != null) {§cards.add(card);§}§}§player.lookAtCards("Jar of Eyeballs", cards, game);§TargetCard target = new TargetCard(Zone.LIBRARY, new FilterCard("card to put into your hand"));§if (player.choose(Outcome.DrawCard, cards, target, game)) {§Card card = cards.get(target.getFirstTarget(), game);§if (card != null) {§cards.remove(card);§card.moveToZone(Zone.HAND, source.getSourceId(), game, false);§}§}§player.putCardsOnBottomOfLibrary(cards, game, source, true);§return true;§}§}§
public class KessigRecluse extends CardImpl {§public KessigRecluse(UUID ownerId) {§super(ownerId, 121, "Kessig Recluse", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{G}{G}");§this.expansionSetCode = "DKA";§this.subtype.add("Spider");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(ReachAbility.getInstance());§this.addAbility(DeathtouchAbility.getInstance());§}§public KessigRecluse(final KessigRecluse card) {§super(card);§}§@Override§public KessigRecluse copy() {§return new KessigRecluse(this);§}§}§
public class KrallenhordeKiller extends CardImpl {§public KrallenhordeKiller(UUID ownerId) {§super(ownerId, 133, "Krallenhorde Killer", Rarity.RARE, new CardType[]{CardType.CREATURE}, "");§this.expansionSetCode = "DKA";§this.subtype.add("Werewolf");§this.color.setGreen(true);§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.nightCard = true;§this.canTransform = true;§this.addAbility(new LimitedTimesPerTurnActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(4, 4, Duration.EndOfTurn), new ManaCostsImpl("{3}{G}")));§TriggeredAbility ability = new BeginningOfUpkeepTriggeredAbility(new TransformSourceEffect(false), TargetController.ANY, false);§this.addAbility(new ConditionalTriggeredAbility(ability, TwoOrMoreSpellsWereCastLastTurnCondition.getInstance(), TransformAbility.TWO_OR_MORE_SPELLS_TRANSFORM_RULE));§}§public KrallenhordeKiller(final KrallenhordeKiller card) {§super(card);§}§@Override§public KrallenhordeKiller copy() {§return new KrallenhordeKiller(this);§}§}§
public class LambholtElder extends CardImpl {§public LambholtElder(UUID ownerId) {§super(ownerId, 122, "Lambholt Elder", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{G}");§this.expansionSetCode = "DKA";§this.subtype.add("Human");§this.subtype.add("Werewolf");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§this.canTransform = true;§this.secondSideCard = new SilverpeltWerewolf(ownerId);§this.addAbility(new TransformAbility());§TriggeredAbility ability = new BeginningOfUpkeepTriggeredAbility(new TransformSourceEffect(true), TargetController.ANY, false);§this.addAbility(new ConditionalTriggeredAbility(ability, NoSpellsWereCastLastTurnCondition.getInstance(), TransformAbility.NO_SPELLS_TRANSFORM_RULE));§}§public LambholtElder(final LambholtElder card) {§super(card);§}§@Override§public LambholtElder copy() {§return new LambholtElder(this);§}§}§
public class LingeringSouls extends CardImpl {§public LingeringSouls(UUID ownerId) {§super(ownerId, 12, "Lingering Souls", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{2}{W}");§this.expansionSetCode = "DKA";§this.getSpellAbility().addEffect(new CreateTokenEffect(new SpiritWhiteToken("ISD"), 2));§this.addAbility(new FlashbackAbility(new ManaCostsImpl("{1}{B}"), TimingRule.SORCERY));§}§public LingeringSouls(final LingeringSouls card) {§super(card);§}§@Override§public LingeringSouls copy() {§return new LingeringSouls(this);§}§}§
public class MarkovBlademaster extends CardImpl {§public MarkovBlademaster(UUID ownerId) {§super(ownerId, 96, "Markov Blademaster", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{R}{R}");§this.expansionSetCode = "DKA";§this.subtype.add("Vampire");§this.subtype.add("Warrior");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(DoubleStrikeAbility.getInstance());§this.addAbility(new DealsCombatDamageToAPlayerTriggeredAbility(new AddCountersSourceEffect(CounterType.P1P1.createInstance()), false));§}§public MarkovBlademaster(final MarkovBlademaster card) {§super(card);§}§@Override§public MarkovBlademaster copy() {§return new MarkovBlademaster(this);§}§}§
public class MarkovsServant extends CardImpl {§public MarkovsServant(UUID ownerId) {§super(ownerId, 55, "Markov's Servant", Rarity.COMMON, new CardType[]{CardType.CREATURE}, null);§this.expansionSetCode = "DKA";§this.subtype.add("Vampire");§this.color.setBlack(true);§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.canTransform = true;§this.nightCard = true;§}§public MarkovsServant(final MarkovsServant card) {§super(card);§}§@Override§public MarkovsServant copy() {§return new MarkovsServant(this);§}§}§
public class MarkovWarlord extends CardImpl {§public MarkovWarlord(UUID ownerId) {§super(ownerId, 97, "Markov Warlord", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{5}{R}");§this.expansionSetCode = "DKA";§this.subtype.add("Vampire");§this.subtype.add("Warrior");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(HasteAbility.getInstance());§EntersBattlefieldTriggeredAbility ability = new EntersBattlefieldTriggeredAbility(new CantBlockTargetEffect(Duration.EndOfTurn));§TargetCreaturePermanent target = new TargetCreaturePermanent(0, 2);§ability.addTarget(target);§this.addAbility(ability);§}§public MarkovWarlord(final MarkovWarlord card) {§super(card);§}§@Override§public MarkovWarlord copy() {§return new MarkovWarlord(this);§}§}§
public class MidnightGuard extends CardImpl {§private static final FilterPermanent filter = new FilterCreaturePermanent("another creature");§static {§filter.add(new AnotherPredicate());§}§public MidnightGuard(UUID ownerId) {§super(ownerId, 14, "Midnight Guard", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "DKA";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(new EntersBattlefieldAllTriggeredAbility(new UntapSourceEffect(), filter));§}§public MidnightGuard(final MidnightGuard card) {§super(card);§}§@Override§public MidnightGuard copy() {§return new MidnightGuard(this);§}§}§
public class MikaeusTheUnhallowed extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("non-Human creatures");§static {§filter.add(Predicates.not(new SubtypePredicate("Human")));§}§public MikaeusTheUnhallowed(UUID ownerId) {§super(ownerId, 70, "Mikaeus, the Unhallowed", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{3}{B}{B}{B}");§this.expansionSetCode = "DKA";§this.supertype.add("Legendary");§this.subtype.add("Zombie");§this.subtype.add("Cleric");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(IntimidateAbility.getInstance());§this.addAbility(new MikaeusTheUnhallowedAbility());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostControlledEffect(1, 1, Duration.WhileOnBattlefield, filter, true)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityControlledEffect(new UndyingAbility(), Duration.WhileOnBattlefield, filter, true)));§}§public MikaeusTheUnhallowed(final MikaeusTheUnhallowed card) {§super(card);§}§@Override§public MikaeusTheUnhallowed copy() {§return new MikaeusTheUnhallowed(this);§}§}§class MikaeusTheUnhallowedAbility extends TriggeredAbilityImpl {§public MikaeusTheUnhallowedAbility() {§super(Zone.BATTLEFIELD, new DestroyTargetEffect());§}§public MikaeusTheUnhallowedAbility(final MikaeusTheUnhallowedAbility ability) {§super(ability);§}§@Override§public MikaeusTheUnhallowedAbility copy() {§return new MikaeusTheUnhallowedAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.DAMAGED_PLAYER;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (event.getTargetId().equals(this.controllerId)) {§Permanent permanent = game.getPermanent(event.getSourceId());§if (permanent != null && permanent.hasSubtype("Human")) {§this.getEffects().get(0).setTargetPointer(new FixedTarget(permanent.getId()));§return true;§}§}§return false;§}§@Override§public String getRule() {§return "Whenever a Human deals damage to you, destroy it.";§}§}§
public class MondronenShaman extends CardImpl {§public MondronenShaman(UUID ownerId) {§super(ownerId, 98, "Mondronen Shaman", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{R}");§this.expansionSetCode = "DKA";§this.subtype.add("Human");§this.subtype.add("Werewolf");§this.subtype.add("Shaman");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§this.canTransform = true;§this.secondSideCard = new TovolarsMagehunter(ownerId);§this.addAbility(new TransformAbility());§TriggeredAbility ability = new BeginningOfUpkeepTriggeredAbility(new TransformSourceEffect(true), TargetController.ANY, false);§this.addAbility(new ConditionalTriggeredAbility(ability,§NoSpellsWereCastLastTurnCondition.getInstance(),§TransformAbility.NO_SPELLS_TRANSFORM_RULE));§}§public MondronenShaman(final MondronenShaman card) {§super(card);§}§@Override§public MondronenShaman copy() {§return new MondronenShaman(this);§}§}§
public class MoonscarredWerewolf extends CardImpl {§public MoonscarredWerewolf(UUID ownerId) {§super(ownerId, 125, "Moonscarred Werewolf", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "");§this.expansionSetCode = "DKA";§this.subtype.add("Werewolf");§this.color.setGreen(true);§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.nightCard = true;§this.canTransform = true;§this.addAbility(VigilanceAbility.getInstance());§this.addAbility(new SimpleManaAbility(Zone.BATTLEFIELD, new BasicManaEffect(Mana.GreenMana(2)), new TapSourceCost()));§TriggeredAbility ability = new BeginningOfUpkeepTriggeredAbility(new TransformSourceEffect(false), TargetController.ANY, false);§this.addAbility(new ConditionalTriggeredAbility(ability,§TwoOrMoreSpellsWereCastLastTurnCondition.getInstance(),§TransformAbility.TWO_OR_MORE_SPELLS_TRANSFORM_RULE));§}§public MoonscarredWerewolf(final MoonscarredWerewolf card) {§super(card);§}§@Override§public MoonscarredWerewolf copy() {§return new MoonscarredWerewolf(this);§}§}§
public class MoonveilDragon extends CardImpl {§public MoonveilDragon(UUID ownerId) {§super(ownerId, 99, "Moonveil Dragon", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{3}{R}{R}{R}");§this.expansionSetCode = "DKA";§this.subtype.add("Dragon");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostControlledEffect(1, 0, Duration.EndOfTurn), new ColoredManaCost(ColoredManaSymbol.R)));§}§public MoonveilDragon(final MoonveilDragon card) {§super(card);§}§@Override§public MoonveilDragon copy() {§return new MoonveilDragon(this);§}§}§
public class MysticRetrieval extends CardImpl {§private static final FilterCard filter = new FilterCard("instant or sorcery card from your graveyard");§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.INSTANT),§new CardTypePredicate(CardType.SORCERY)));§}§public MysticRetrieval(UUID ownerId) {§super(ownerId, 42, "Mystic Retrieval", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{3}{U}");§this.expansionSetCode = "DKA";§this.getSpellAbility().addEffect(new ReturnToHandTargetEffect());§this.getSpellAbility().addTarget(new TargetCardInYourGraveyard(filter));§this.addAbility(new FlashbackAbility(new ManaCostsImpl("{2}{R}"), TimingRule.SORCERY));§}§public MysticRetrieval(final MysticRetrieval card) {§super(card);§}§@Override§public MysticRetrieval copy() {§return new MysticRetrieval(this);§}§}§
public class NearheathStalker extends CardImpl {§public NearheathStalker(UUID ownerId) {§super(ownerId, 100, "Nearheath Stalker", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{R}");§this.expansionSetCode = "DKA";§this.subtype.add("Vampire");§this.subtype.add("Rogue");§this.power = new MageInt(4);§this.toughness = new MageInt(1);§this.addAbility(new UndyingAbility());§}§public NearheathStalker(final NearheathStalker card) {§super(card);§}§@Override§public NearheathStalker copy() {§return new NearheathStalker(this);§}§}§
public class NephaliaSeakite extends CardImpl {§public NephaliaSeakite(UUID ownerId) {§super(ownerId, 43, "Nephalia Seakite", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{U}");§this.expansionSetCode = "DKA";§this.subtype.add("Bird");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(FlashAbility.getInstance());§this.addAbility(FlyingAbility.getInstance());§}§public NephaliaSeakite(final NephaliaSeakite card) {§super(card);§}§@Override§public NephaliaSeakite copy() {§return new NephaliaSeakite(this);§}§}§
public class NiblisOfTheBreath extends CardImpl {§public NiblisOfTheBreath(UUID ownerId) {§super(ownerId, 44, "Niblis of the Breath", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{U}");§this.expansionSetCode = "DKA";§this.subtype.add("Spirit");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new MayTapOrUntapTargetEffect(), new ColoredManaCost(ColoredManaSymbol.U));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public NiblisOfTheBreath(final NiblisOfTheBreath card) {§super(card);§}§@Override§public NiblisOfTheBreath copy() {§return new NiblisOfTheBreath(this);§}§}§
public class NiblisOfTheMist extends CardImpl {§public NiblisOfTheMist(UUID ownerId) {§super(ownerId, 15, "Niblis of the Mist", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "DKA";§this.subtype.add("Spirit");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new EntersBattlefieldTriggeredAbility(new TapTargetEffect(), true);§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public NiblisOfTheMist(final NiblisOfTheMist card) {§super(card);§}§@Override§public NiblisOfTheMist copy() {§return new NiblisOfTheMist(this);§}§}§
public class NiblisOfTheUrn extends CardImpl {§public NiblisOfTheUrn(UUID ownerId) {§super(ownerId, 16, "Niblis of the Urn", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "DKA";§this.subtype.add("Spirit");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new AttacksTriggeredAbility(new TapTargetEffect(), true);§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public NiblisOfTheUrn(final NiblisOfTheUrn card) {§super(card);§}§@Override§public NiblisOfTheUrn copy() {§return new NiblisOfTheUrn(this);§}§}§
public class PredatorOoze extends CardImpl {§public PredatorOoze(UUID ownerId) {§super(ownerId, 124, "Predator Ooze", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{G}{G}{G}");§this.expansionSetCode = "DKA";§this.subtype.add("Ooze");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(IndestructibleAbility.getInstance());§this.addAbility(new AttacksTriggeredAbility(new AddCountersSourceEffect(CounterType.P1P1.createInstance()), false));§this.addAbility(new DiesAndDealtDamageThisTurnTriggeredAbility(new AddCountersSourceEffect(CounterType.P1P1.createInstance())));§}§public PredatorOoze(final PredatorOoze card) {§super(card);§}§@Override§public PredatorOoze copy() {§return new PredatorOoze(this);§}§}§
public class PyreheartWolf extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creatures you control");§static {§filter.add(new ControllerPredicate(TargetController.YOU));§}§public PyreheartWolf(UUID ownerId) {§super(ownerId, 101, "Pyreheart Wolf", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "DKA";§this.subtype.add("Wolf");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new AttacksTriggeredAbility(new GainAbilityAllEffect(new MenaceAbility(), Duration.EndOfTurn, filter), false));§this.addAbility(new UndyingAbility());§}§public PyreheartWolf(final PyreheartWolf card) {§super(card);§}§@Override§public PyreheartWolf copy() {§return new PyreheartWolf(this);§}§}§
public class RavagerOfTheFells extends CardImpl {§private static final String rule = "Whenever this creature transforms into Ravager of the Fells, it deals 2 damage to target opponent and 2 damage to up to one target creature that player controls";§public RavagerOfTheFells(UUID ownerId) {§super(ownerId, 140, "Ravager of the Fells", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "");§this.expansionSetCode = "DKA";§this.subtype.add("Werewolf");§this.color.setRed(true);§this.color.setGreen(true);§this.nightCard = true;§this.canTransform = true;§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(TrampleAbility.getInstance());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new InfoEffect(rule)));§TriggeredAbility ability = new BeginningOfUpkeepTriggeredAbility(new TransformSourceEffect(false), TargetController.ANY, false);§this.addAbility(new ConditionalTriggeredAbility(ability, TwoOrMoreSpellsWereCastLastTurnCondition.getInstance(), TransformAbility.TWO_OR_MORE_SPELLS_TRANSFORM_RULE));§}§public RavagerOfTheFells(final RavagerOfTheFells card) {§super(card);§}§@Override§public RavagerOfTheFells copy() {§return new RavagerOfTheFells(this);§}§}§
public class RavenousDemon extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("Human");§static {§filter.add(new SubtypePredicate("Human"));§}§public RavenousDemon(UUID ownerId) {§super(ownerId, 71, "Ravenous Demon", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{B}{B}");§this.expansionSetCode = "DKA";§this.subtype.add("Demon");§this.canTransform = true;§this.secondSideCard = new ArchdemonOfGreed(ownerId);§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(new TransformAbility());§this.addAbility(new ActivateAsSorceryActivatedAbility(Zone.BATTLEFIELD, new TransformSourceEffect(true), new SacrificeTargetCost(new TargetControlledPermanent(filter))));§}§public RavenousDemon(final RavenousDemon card) {§super(card);§}§@Override§public RavenousDemon copy() {§return new RavenousDemon(this);§}§}§
public class RelentlessSkaabs extends CardImpl {§public RelentlessSkaabs(UUID ownerId) {§super(ownerId, 45, "Relentless Skaabs", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{U}{U}");§this.expansionSetCode = "DKA";§this.subtype.add("Zombie");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.getSpellAbility().addCost(new ExileFromGraveCost(new TargetCardInYourGraveyard(new FilterCreatureCard("creature card from your graveyard"))));§this.addAbility(new UndyingAbility());§}§public RelentlessSkaabs(final RelentlessSkaabs card) {§super(card);§}§@Override§public RelentlessSkaabs copy() {§return new RelentlessSkaabs(this);§}§}§
public class RequiemAngel extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("another non-Spirit creature you control");§static {§filter.add(Predicates.not(new SubtypePredicate("Spirit")));§filter.add(new AnotherPredicate());§filter.add(new ControllerPredicate(TargetController.YOU));§}§public RequiemAngel(UUID ownerId) {§super(ownerId, 18, "Requiem Angel", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}{W}");§this.expansionSetCode = "DKA";§this.subtype.add("Angel");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new DiesCreatureTriggeredAbility(new CreateTokenEffect(new SpiritWhiteToken("ISD"), 1), false, filter));§}§public RequiemAngel(final RequiemAngel card) {§super(card);§}§@Override§public RequiemAngel copy() {§return new RequiemAngel(this);§}§}§
public class RussetWolves extends CardImpl {§public RussetWolves(UUID ownerId) {§super(ownerId, 102, "Russet Wolves", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{R}");§this.expansionSetCode = "DKA";§this.subtype.add("Wolf");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§}§public RussetWolves(final RussetWolves card) {§super(card);§}§@Override§public RussetWolves copy() {§return new RussetWolves(this);§}§}§
public class SanctuaryCat extends CardImpl {§public SanctuaryCat(UUID ownerId) {§super(ownerId, 19, "Sanctuary Cat", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{W}");§this.expansionSetCode = "DKA";§this.subtype.add("Cat");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§}§public SanctuaryCat(final SanctuaryCat card) {§super(card);§}§@Override§public SanctuaryCat copy() {§return new SanctuaryCat(this);§}§}§
public class SavingGrasp extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature you own");§static {§filter.add(new OwnerPredicate(TargetController.YOU));§}§public SavingGrasp(UUID ownerId) {§super(ownerId, 46, "Saving Grasp", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{U}");§this.expansionSetCode = "DKA";§this.getSpellAbility().addTarget(new TargetCreaturePermanent(filter));§this.getSpellAbility().addEffect(new ReturnToHandTargetEffect());§this.addAbility(new FlashbackAbility(new ManaCostsImpl("{W}"), TimingRule.INSTANT));§}§public SavingGrasp(final SavingGrasp card) {§super(card);§}§@Override§public SavingGrasp copy() {§return new SavingGrasp(this);§}§}§
public class ScorchTheFields extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Human creature");§static {§filter.add(new SubtypePredicate("Human"));§}§public ScorchTheFields(UUID ownerId) {§super(ownerId, 103, "Scorch the Fields", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{4}{R}");§this.expansionSetCode = "DKA";§this.getSpellAbility().addEffect(new DestroyTargetEffect());§this.getSpellAbility().addTarget(new TargetLandPermanent());§this.getSpellAbility().addEffect(new DamageAllEffect(1, filter));§}§public ScorchTheFields(final ScorchTheFields card) {§super(card);§}§@Override§public ScorchTheFields copy() {§return new ScorchTheFields(this);§}§}§
public class ScornedVillager extends CardImpl {§public ScornedVillager(UUID ownerId) {§super(ownerId, 125, "Scorned Villager", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "DKA";§this.subtype.add("Human");§this.subtype.add("Werewolf");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.canTransform = true;§this.secondSideCard = new MoonscarredWerewolf(ownerId);§this.addAbility(new GreenManaAbility());§this.addAbility(new TransformAbility());§TriggeredAbility ability = new BeginningOfUpkeepTriggeredAbility(new TransformSourceEffect(true), TargetController.ANY, false);§this.addAbility(new ConditionalTriggeredAbility(ability,§NoSpellsWereCastLastTurnCondition.getInstance(),§TransformAbility.NO_SPELLS_TRANSFORM_RULE));§}§public ScornedVillager(final ScornedVillager card) {§super(card);§}§@Override§public ScornedVillager copy() {§return new ScornedVillager(this);§}§}§
public class ScreechingSkaab extends CardImpl {§public ScreechingSkaab(UUID ownerId) {§super(ownerId, 47, "Screeching Skaab", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{U}");§this.expansionSetCode = "DKA";§this.subtype.add("Zombie");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new EntersBattlefieldTriggeredAbility(new PutTopCardOfLibraryIntoGraveControllerEffect(2)));§}§public ScreechingSkaab(final ScreechingSkaab card) {§super(card);§}§@Override§public ScreechingSkaab copy() {§return new ScreechingSkaab(this);§}§}§
public class Seance extends CardImpl {§public Seance(UUID ownerId) {§super(ownerId, 20, "Seance", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{2}{W}{W}");§this.expansionSetCode = "DKA";§Ability ability = new BeginningOfUpkeepTriggeredAbility(new SeanceEffect(), TargetController.ANY, true);§ability.addTarget(new TargetCardInYourGraveyard(new FilterCreatureCard()));§this.addAbility(ability);§}§public Seance(final Seance card) {§super(card);§}§@Override§public Seance copy() {§return new Seance(this);§}§}§class SeanceEffect extends OneShotEffect {§public SeanceEffect() {§super(Outcome.PutCreatureInPlay);§this.staticText = "you may exile target creature card from your graveyard. If you do, put a token onto the battlefield that's a copy of that card except it's a Spirit in addition to its other types. Exile it at the beginning of the next end step";§}§public SeanceEffect(final SeanceEffect effect) {§super(effect);§}§@Override§public SeanceEffect copy() {§return new SeanceEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Card card = game.getCard(source.getFirstTarget());§Player controller = game.getPlayer(source.getControllerId());§if (controller != null && card != null) {§if (controller.moveCards(card, Zone.EXILED, source, game)) {§PutTokenOntoBattlefieldCopyTargetEffect effect = new PutTokenOntoBattlefieldCopyTargetEffect(source.getControllerId(), null, false);§effect.setTargetPointer(new FixedTarget(card.getId(), card.getZoneChangeCounter(game)));§effect.setAdditionalSubType("Spirit");§effect.apply(game, source);§ExileTargetEffect exileEffect = new ExileTargetEffect();§exileEffect.setTargetPointer(new FixedTargets(effect.getAddedPermanent(), game));§DelayedTriggeredAbility delayedAbility = new AtTheBeginOfNextEndStepDelayedTriggeredAbility(exileEffect);§game.addDelayedTriggeredAbility(delayedAbility, source);§}§return true;§}§return false;§}§}§
public class SecretsOfTheDead extends CardImpl {§private static final FilterSpell filter = new FilterSpell("a spell from your graveyard");§static {§filter.add(new SpellZonePredicate(Zone.GRAVEYARD));§}§public SecretsOfTheDead(UUID ownerId) {§super(ownerId, 48, "Secrets of the Dead", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{U}");§this.expansionSetCode = "DKA";§this.addAbility(new SpellCastControllerTriggeredAbility(new DrawCardSourceControllerEffect(1), filter, false));§}§public SecretsOfTheDead(final SecretsOfTheDead card) {§super(card);§}§@Override§public SecretsOfTheDead copy() {§return new SecretsOfTheDead(this);§}§}§class SpellZonePredicate implements Predicate<Spell> {§private final Zone zone;§public SpellZonePredicate(Zone zone) {§this.zone = zone;§}§@Override§public boolean apply(Spell input, Game game) {§return input.getFromZone().match(zone);§}§@Override§public String toString() {§return "SpellZone(" + zone + ')';§}§}§
public class ShatteredPerception extends CardImpl {§public ShatteredPerception(UUID ownerId) {§super(ownerId, 104, "Shattered Perception", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{2}{R}");§this.expansionSetCode = "DKA";§this.getSpellAbility().addEffect(new ShatteredPerceptionEffect());§this.addAbility(new FlashbackAbility(new ManaCostsImpl("{5}{R}"), TimingRule.SORCERY));§}§public ShatteredPerception(final ShatteredPerception card) {§super(card);§}§@Override§public ShatteredPerception copy() {§return new ShatteredPerception(this);§}§}§class ShatteredPerceptionEffect extends OneShotEffect {§public ShatteredPerceptionEffect() {§super(Outcome.DrawCard);§this.staticText = "Discard all the cards in your hand, then draw that many cards";§}§public ShatteredPerceptionEffect(final ShatteredPerceptionEffect effect) {§super(effect);§}§@Override§public ShatteredPerceptionEffect copy() {§return new ShatteredPerceptionEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§Set<Card> cardsInHand = player.getHand().getCards(game);§int amount = cardsInHand.size();§for (Card card : cardsInHand) {§player.discard(card, source, game);§}§player.drawCards(amount, game);§return true;§}§return false;§}§}§
public class Shriekgeist extends CardImpl {§public Shriekgeist(UUID ownerId) {§super(ownerId, 49, "Shriekgeist", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{U}");§this.expansionSetCode = "DKA";§this.subtype.add("Spirit");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new ShriekgeistTriggeredAbility());§}§public Shriekgeist(final Shriekgeist card) {§super(card);§}§@Override§public Shriekgeist copy() {§return new Shriekgeist(this);§}§}§class ShriekgeistTriggeredAbility extends TriggeredAbilityImpl {§public ShriekgeistTriggeredAbility() {§super(Zone.BATTLEFIELD, new PutLibraryIntoGraveTargetEffect(2));§}§public ShriekgeistTriggeredAbility(final ShriekgeistTriggeredAbility ability) {§super(ability);§}§@Override§public ShriekgeistTriggeredAbility copy() {§return new ShriekgeistTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.DAMAGED_PLAYER;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§DamagedPlayerEvent damageEvent = (DamagedPlayerEvent) event;§if (damageEvent.isCombatDamage() && event.getSourceId().equals(this.getSourceId())) {§for (Effect effect : this.getEffects()) {§effect.setTargetPointer(new FixedTarget(event.getPlayerId()));§}§return true;§}§return false;§}§@Override§public String getRule() {§return "Whenever {this} deals combat damage to a player, that player puts the top two cards of his or her library into his or her graveyard.";§}§}§
public class SightlessGhoul extends CardImpl {§public SightlessGhoul(UUID ownerId) {§super(ownerId, 73, "Sightless Ghoul", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{B}");§this.expansionSetCode = "DKA";§this.subtype.add("Zombie");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new CantBlockAbility());§this.addAbility(new UndyingAbility());§}§public SightlessGhoul(final SightlessGhoul card) {§super(card);§}§@Override§public SightlessGhoul copy() {§return new SightlessGhoul(this);§}§}§
public class SilverclawGriffin extends CardImpl {§public SilverclawGriffin(UUID ownerId) {§super(ownerId, 21, "Silverclaw Griffin", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{W}{W}");§this.expansionSetCode = "DKA";§this.subtype.add("Griffin");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(FirstStrikeAbility.getInstance());§}§public SilverclawGriffin(final SilverclawGriffin card) {§super(card);§}§@Override§public SilverclawGriffin copy() {§return new SilverclawGriffin(this);§}§}§
public class SilverpeltWerewolf extends CardImpl {§public SilverpeltWerewolf(UUID ownerId) {§super(ownerId, 122, "Silverpelt Werewolf", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, null);§this.expansionSetCode = "DKA";§this.subtype.add("Werewolf");§this.color.setGreen(true);§this.power = new MageInt(4);§this.toughness = new MageInt(5);§this.canTransform = true;§this.nightCard = true;§this.addAbility(new DealsCombatDamageToAPlayerTriggeredAbility(new DrawCardSourceControllerEffect(1), false));§TriggeredAbility ability = new BeginningOfUpkeepTriggeredAbility(new TransformSourceEffect(false), TargetController.ANY, false);§this.addAbility(new ConditionalTriggeredAbility(ability, TwoOrMoreSpellsWereCastLastTurnCondition.getInstance(), TransformAbility.TWO_OR_MORE_SPELLS_TRANSFORM_RULE));§}§public SilverpeltWerewolf(final SilverpeltWerewolf card) {§super(card);§}§@Override§public SilverpeltWerewolf copy() {§return new SilverpeltWerewolf(this);§}§}§
public class SkillfulLunge extends CardImpl {§public SkillfulLunge(UUID ownerId) {§super(ownerId, 22, "Skillful Lunge", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{W}");§this.expansionSetCode = "DKA";§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.getSpellAbility().addEffect(new BoostTargetEffect(2, 0, Duration.EndOfTurn));§this.getSpellAbility().addEffect(new GainAbilityTargetEffect(FirstStrikeAbility.getInstance(), Duration.EndOfTurn));§}§public SkillfulLunge(final SkillfulLunge card) {§super(card);§}§@Override§public SkillfulLunge copy() {§return new SkillfulLunge(this);§}§}§
public class SkirsdagFlayer extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("Human");§static {§filter.add(new SubtypePredicate("Human"));§}§public SkirsdagFlayer(UUID ownerId) {§super(ownerId, 74, "Skirsdag Flayer", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{B}");§this.expansionSetCode = "DKA";§this.subtype.add("Human");§this.subtype.add("Cleric");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DestroyTargetEffect(), new ManaCostsImpl("{3}{B}"));§ability.addCost(new TapSourceCost());§ability.addCost(new SacrificeTargetCost(new TargetControlledPermanent(filter)));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public SkirsdagFlayer(final SkirsdagFlayer card) {§super(card);§}§@Override§public SkirsdagFlayer copy() {§return new SkirsdagFlayer(this);§}§}§
public class SomberwaldDryad extends CardImpl {§public SomberwaldDryad(UUID ownerId) {§super(ownerId, 126, "Somberwald Dryad", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "DKA";§this.subtype.add("Dryad");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new ForestwalkAbility());§}§public SomberwaldDryad(final SomberwaldDryad card) {§super(card);§}§@Override§public SomberwaldDryad copy() {§return new SomberwaldDryad(this);§}§}§
public class SpitefulShadows extends CardImpl {§public SpitefulShadows(UUID ownerId) {§super(ownerId, 75, "Spiteful Shadows", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{B}");§this.expansionSetCode = "DKA";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.UnboostCreature));§this.addAbility(new EnchantAbility(auraTarget.getTargetName()));§this.addAbility(new DamageDealtToAttachedTriggeredAbility(Zone.BATTLEFIELD, new SpitefulShadowsEffect(),§false, SetTargetPointer.PERMANENT));§}§public SpitefulShadows(final SpitefulShadows card) {§super(card);§}§@Override§public SpitefulShadows copy() {§return new SpitefulShadows(this);§}§}§class SpitefulShadowsEffect extends OneShotEffect {§public SpitefulShadowsEffect() {§super(Outcome.Damage);§this.staticText = "it deals that much damage to its controller";§}§public SpitefulShadowsEffect(final SpitefulShadowsEffect effect) {§super(effect);§}§@Override§public SpitefulShadowsEffect copy() {§return new SpitefulShadowsEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Integer damageAmount = (Integer) this.getValue("damage");§if (damageAmount != null) {§Permanent permanent = game.getPermanent(getTargetPointer().getFirst(game, source));§if (permanent == null) {§FixedTarget fixedTarget = (FixedTarget) getTargetPointer();§permanent = (Permanent) game.getLastKnownInformation(fixedTarget.getTarget(), Zone.BATTLEFIELD, fixedTarget.getZoneChangeCounter());§}§if (permanent != null) {§Player player = game.getPlayer(permanent.getControllerId());§if (player != null) {§player.damage(damageAmount, permanent.getId(), game, false, true);§return true;§}§}§}§return false;§}§}§
public class StormboundGeist extends CardImpl {§public StormboundGeist(UUID ownerId) {§super(ownerId, 51, "Stormbound Geist", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{U}{U}");§this.expansionSetCode = "DKA";§this.subtype.add("Spirit");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new CanBlockOnlyFlyingAbility());§this.addAbility(new UndyingAbility());§}§public StormboundGeist(final StormboundGeist card) {§super(card);§}§@Override§public StormboundGeist copy() {§return new StormboundGeist(this);§}§}§
public class StranglerootGeist extends CardImpl {§public StranglerootGeist(UUID ownerId) {§super(ownerId, 127, "Strangleroot Geist", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{G}{G}");§this.expansionSetCode = "DKA";§this.subtype.add("Spirit");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(HasteAbility.getInstance());§this.addAbility(new UndyingAbility());§}§public StranglerootGeist(final StranglerootGeist card) {§super(card);§}§@Override§public StranglerootGeist copy() {§return new StranglerootGeist(this);§}§}§
public class StromkirkCaptain extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Vampire creatures");§static {§filter.add(new SubtypePredicate("Vampire"));§}§public StromkirkCaptain(UUID ownerId) {§super(ownerId, 143, "Stromkirk Captain", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{B}{R}");§this.expansionSetCode = "DKA";§this.subtype.add("Vampire");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FirstStrikeAbility.getInstance());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostControlledEffect(1, 1, Duration.WhileOnBattlefield, filter, true)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityControlledEffect(FirstStrikeAbility.getInstance(), Duration.WhileOnBattlefield, filter, true)));§}§public StromkirkCaptain(final StromkirkCaptain card) {§super(card);§}§@Override§public StromkirkCaptain copy() {§return new StromkirkCaptain(this);§}§}§
public class SuddenDisappearance extends CardImpl {§public SuddenDisappearance(UUID ownerId) {§super(ownerId, 23, "Sudden Disappearance", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{5}{W}");§this.expansionSetCode = "DKA";§this.getSpellAbility().addEffect(new SuddenDisappearanceEffect());§this.getSpellAbility().addTarget(new TargetPlayer());§}§public SuddenDisappearance(final SuddenDisappearance card) {§super(card);§}§@Override§public SuddenDisappearance copy() {§return new SuddenDisappearance(this);§}§}§class SuddenDisappearanceEffect extends OneShotEffect {§private static FilterNonlandPermanent filter = new FilterNonlandPermanent();§public SuddenDisappearanceEffect() {§super(Outcome.Exile);§staticText = "Exile all nonland permanents target player controls. Return the exiled cards to the battlefield under their owner's control at the beginning of the next end step";§}§public SuddenDisappearanceEffect(final SuddenDisappearanceEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§MageObject sourceObject = source.getSourceObject(game);§if (controller != null && sourceObject != null) {§List<Permanent> perms = game.getBattlefield().getAllActivePermanents(filter, source.getFirstTarget(), game);§if (perms.size() > 0) {§for (Permanent permanent : game.getBattlefield().getAllActivePermanents(filter, source.getFirstTarget(), game)) {§controller.moveCardToExileWithInfo(permanent, source.getSourceId(), sourceObject.getIdName(), source.getSourceId(), game, Zone.BATTLEFIELD, true);§}§AtTheBeginOfNextEndStepDelayedTriggeredAbility delayedAbility = new AtTheBeginOfNextEndStepDelayedTriggeredAbility(new ReturnFromExileEffect(source.getSourceId(), Zone.BATTLEFIELD));§game.addDelayedTriggeredAbility(delayedAbility, source);§}§return true;§}§return false;§}§@Override§public SuddenDisappearanceEffect copy() {§return new SuddenDisappearanceEffect(this);§}§}§
public class TalonsOfFalkenrath extends CardImpl {§public TalonsOfFalkenrath(UUID ownerId) {§super(ownerId, 105, "Talons of Falkenrath", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{R}");§this.expansionSetCode = "DKA";§this.subtype.add("Aura");§this.addAbility(FlashAbility.getInstance());§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));§this.addAbility(new EnchantAbility(auraTarget.getTargetName()));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD,§new GainAbilityAttachedEffect(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(2, 0, Duration.EndOfTurn), new ManaCostsImpl("{1}{R}")),§AttachmentType.AURA)));§}§public TalonsOfFalkenrath(final TalonsOfFalkenrath card) {§super(card);§}§@Override§public TalonsOfFalkenrath copy() {§return new TalonsOfFalkenrath(this);§}§}§
public class ThaliaGuardianOfThraben extends CardImpl {§public ThaliaGuardianOfThraben(UUID ownerId) {§super(ownerId, 24, "Thalia, Guardian of Thraben", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "DKA";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(FirstStrikeAbility.getInstance());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new ThaliaGuardianOfThrabenCostReductionEffect()));§}§public ThaliaGuardianOfThraben(final ThaliaGuardianOfThraben card) {§super(card);§}§@Override§public ThaliaGuardianOfThraben copy() {§return new ThaliaGuardianOfThraben(this);§}§}§class ThaliaGuardianOfThrabenCostReductionEffect extends CostModificationEffectImpl {§ThaliaGuardianOfThrabenCostReductionEffect ( ) {§super(Duration.WhileOnBattlefield, Outcome.Benefit, CostModificationType.INCREASE_COST);§staticText = "Noncreature spells cost {1} more to cast";§}§ThaliaGuardianOfThrabenCostReductionEffect(ThaliaGuardianOfThrabenCostReductionEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source, Ability abilityToModify) {§CardUtil.increaseCost(abilityToModify, 1);§return true;§}§@Override§public boolean applies(Ability abilityToModify, Ability source, Game game) {§if (abilityToModify instanceof SpellAbility || abilityToModify instanceof FlashbackAbility) {§Card card = game.getCard(abilityToModify.getSourceId());§if (card != null && !card.getCardType().contains(CardType.CREATURE)) {§return true;§}§}§return false;§}§@Override§public ThaliaGuardianOfThrabenCostReductionEffect copy() {§return new ThaliaGuardianOfThrabenCostReductionEffect(this);§}§}§
public class ThoughtScour extends CardImpl {§public ThoughtScour(UUID ownerId) {§super(ownerId, 52, "Thought Scour", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{U}");§this.expansionSetCode = "DKA";§this.getSpellAbility().addTarget(new TargetPlayer());§this.getSpellAbility().addEffect(new PutLibraryIntoGraveTargetEffect(2));§this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(1));§}§public ThoughtScour(final ThoughtScour card) {§super(card);§}§@Override§public ThoughtScour copy() {§return new ThoughtScour(this);§}§}§
public class ThrabenDoomsayer extends CardImpl {§public ThrabenDoomsayer(UUID ownerId) {§super(ownerId, 25, "Thraben Doomsayer", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{W}{W}");§this.expansionSetCode = "DKA";§this.subtype.add("Human");§this.subtype.add("Cleric");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new CreateTokenEffect(new HumanToken()), new TapSourceCost()));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new ConditionalContinuousEffect(new BoostControlledEffect(2, 2, Duration.WhileOnBattlefield, true),§FatefulHourCondition.getInstance(), "As long as you have 5 or less life, other creatures you control get +2/+2")));§}§public ThrabenDoomsayer(final ThrabenDoomsayer card) {§super(card);§}§@Override§public ThrabenDoomsayer copy() {§return new ThrabenDoomsayer(this);§}§}§
public class ThrabenHeretic extends CardImpl {§public ThrabenHeretic(UUID ownerId) {§super(ownerId, 26, "Thraben Heretic", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "DKA";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ExileTargetEffect(), new TapSourceCost());§ability.addTarget(new TargetCardInGraveyard(new FilterCreatureCard("creature card from a graveyard")));§this.addAbility(ability);§}§public ThrabenHeretic(final ThrabenHeretic card) {§super(card);§}§@Override§public ThrabenHeretic copy() {§return new ThrabenHeretic(this);§}§}§
public class TorchFiend extends CardImpl {§public TorchFiend(UUID ownerId) {§super(ownerId, 106, "Torch Fiend", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{R}");§this.expansionSetCode = "DKA";§this.subtype.add("Devil");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DestroyTargetEffect(), new ColoredManaCost(ColoredManaSymbol.R));§ability.addCost(new SacrificeSourceCost());§ability.addTarget(new TargetArtifactPermanent());§this.addAbility(ability);§}§public TorchFiend(final TorchFiend card) {§super(card);§}§@Override§public TorchFiend copy() {§return new TorchFiend(this);§}§}§
public class TovolarsMagehunter extends CardImpl {§public TovolarsMagehunter(UUID ownerId) {§super(ownerId, 98, "Tovolar's Magehunter", Rarity.RARE, new CardType[]{CardType.CREATURE}, "");§this.expansionSetCode = "DKA";§this.subtype.add("Werewolf");§this.color.setRed(true);§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.nightCard = true;§this.canTransform = true;§this.addAbility(new TovolarsMagehunterTriggeredAbility());§TriggeredAbility ability = new BeginningOfUpkeepTriggeredAbility(new TransformSourceEffect(false), TargetController.ANY, false);§this.addAbility(new ConditionalTriggeredAbility(ability,§TwoOrMoreSpellsWereCastLastTurnCondition.getInstance(),§TransformAbility.TWO_OR_MORE_SPELLS_TRANSFORM_RULE));§}§public TovolarsMagehunter(final TovolarsMagehunter card) {§super(card);§}§@Override§public TovolarsMagehunter copy() {§return new TovolarsMagehunter(this);§}§}§class TovolarsMagehunterTriggeredAbility extends TriggeredAbilityImpl {§public TovolarsMagehunterTriggeredAbility() {§super(Zone.BATTLEFIELD, new DamageTargetEffect(2), false);§}§public TovolarsMagehunterTriggeredAbility(final TovolarsMagehunterTriggeredAbility ability) {§super(ability);§}§@Override§public TovolarsMagehunterTriggeredAbility copy() {§return new TovolarsMagehunterTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.SPELL_CAST;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (game.getOpponents(controllerId).contains(event.getPlayerId())) {§this.getEffects().get(0).setTargetPointer(new FixedTarget(event.getPlayerId()));§return true;§}§return false;§}§@Override§public String getRule() {§return "Whenever an opponent casts a spell, {this} deals 2 damage to that player.";§}§}§
public class TowerGeist extends CardImpl {§public TowerGeist(UUID ownerId) {§super(ownerId, 53, "Tower Geist", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{U}");§this.expansionSetCode = "DKA";§this.subtype.add("Spirit");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new EntersBattlefieldTriggeredAbility(§new LookLibraryAndPickControllerEffect(new StaticValue(2), false, new StaticValue(1), new FilterCard(), Zone.GRAVEYARD, false, false)));§}§public TowerGeist(final TowerGeist card) {§super(card);§}§@Override§public TowerGeist copy() {§return new TowerGeist(this);§}§}§
public class TrackersInstincts extends CardImpl {§public TrackersInstincts(UUID ownerId) {§super(ownerId, 128, "Tracker's Instincts", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{1}{G}");§this.expansionSetCode = "DKA";§this.getSpellAbility().addEffect(new TrackersInstinctsEffect());§this.addAbility(new FlashbackAbility(new ManaCostsImpl("{2}{U}"), TimingRule.SORCERY));§}§public TrackersInstincts(final TrackersInstincts card) {§super(card);§}§@Override§public TrackersInstincts copy() {§return new TrackersInstincts(this);§}§}§class TrackersInstinctsEffect extends OneShotEffect {§public TrackersInstinctsEffect() {§super(Outcome.DrawCard);§this.staticText = "Reveal the top four cards of your library. Put a creature card from among them into your hand and the rest into your graveyard";§}§public TrackersInstinctsEffect(final TrackersInstinctsEffect effect) {§super(effect);§}§@Override§public TrackersInstinctsEffect copy() {§return new TrackersInstinctsEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Cards cards = new CardsImpl();§boolean creaturesFound = false;§int count = Math.min(controller.getLibrary().size(), 4);§for (int i = 0; i < count; i++) {§Card card = controller.getLibrary().removeFromTop(game);§if (card != null) {§cards.add(card);§if (card.getCardType().contains(CardType.CREATURE)) {§creaturesFound = true;§}§}§}§if (!cards.isEmpty()) {§controller.revealCards("Tracker's Instincts", cards, game);§TargetCard target = new TargetCard(Zone.LIBRARY, new FilterCreatureCard("creature card to put in hand"));§if (creaturesFound && controller.choose(Outcome.DrawCard, cards, target, game)) {§Card card = game.getCard(target.getFirstTarget());§if (card != null) {§cards.remove(card);§card.moveToZone(Zone.HAND, source.getSourceId(), game, false);§}§}§controller.moveCards(cards, Zone.LIBRARY, Zone.GRAVEYARD, source, game);§}§return true;§}§return false;§}§}§
public class TragicSlip extends CardImpl {§public TragicSlip(UUID ownerId) {§super(ownerId, 76, "Tragic Slip", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{B}");§this.expansionSetCode = "DKA";§this.getSpellAbility().addEffect(new ConditionalContinuousEffect(§new BoostTargetEffect(-13, -13, Duration.EndOfTurn),§new BoostTargetEffect(-1, -1, Duration.EndOfTurn),§new LockedInCondition(MorbidCondition.getInstance()),§"Target creature gets -1/-1 until end of turn. Morbid - That creature gets -13/-13 until end of turn instead if a creature died this turn"));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public TragicSlip(final TragicSlip card) {§super(card);§}§@Override§public TragicSlip copy() {§return new TragicSlip(this);§}§}§
public class UlvenwaldBear extends CardImpl {§public UlvenwaldBear(UUID ownerId) {§super(ownerId, 129, "Ulvenwald Bear", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{G}");§this.expansionSetCode = "DKA";§this.subtype.add("Bear");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new ConditionalTriggeredAbility(new EntersBattlefieldTriggeredAbility(new AddCountersTargetEffect(CounterType.P1P1.createInstance(2), Outcome.BoostCreature)),§MorbidCondition.getInstance(), "When {this} enters the battlefield, if a creature died this turn, put two +1/+1 counters on target creature.");§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public UlvenwaldBear(final UlvenwaldBear card) {§super(card);§}§@Override§public UlvenwaldBear copy() {§return new UlvenwaldBear(this);§}§}§
public class UndyingEvil extends CardImpl {§public UndyingEvil(UUID ownerId) {§super(ownerId, 77, "Undying Evil", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{B}");§this.expansionSetCode = "DKA";§this.getSpellAbility().addEffect(new GainAbilityTargetEffect(new UndyingAbility(), Duration.EndOfTurn));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public UndyingEvil(final UndyingEvil card) {§super(card);§}§@Override§public UndyingEvil copy() {§return new UndyingEvil(this);§}§}§
public class UnhallowedCathar extends CardImpl {§public UnhallowedCathar(UUID ownerId) {§super(ownerId, 13, "Unhallowed Cathar", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "");§this.expansionSetCode = "DKA";§this.subtype.add("Zombie");§this.subtype.add("Soldier");§this.color.setBlack(true);§this.nightCard = true;§this.canTransform = true;§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new CantBlockAbility());§}§public UnhallowedCathar(final UnhallowedCathar card) {§super(card);§}§@Override§public UnhallowedCathar copy() {§return new UnhallowedCathar(this);§}§}§
public class VillageSurvivors extends CardImpl {§public VillageSurvivors(UUID ownerId) {§super(ownerId, 130, "Village Survivors", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{G}");§this.expansionSetCode = "DKA";§this.subtype.add("Human");§this.power = new MageInt(4);§this.toughness = new MageInt(5);§this.addAbility(VigilanceAbility.getInstance());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new ConditionalContinuousEffect(§new GainAbilityControlledEffect(VigilanceAbility.getInstance(), Duration.WhileOnBattlefield, new FilterCreaturePermanent(), true),§FatefulHourCondition.getInstance(),§"Fateful hour - As long as you have 5 or less life, other creatures you control have vigilance")));§}§public VillageSurvivors(final VillageSurvivors card) {§super(card);§}§@Override§public VillageSurvivors copy() {§return new VillageSurvivors(this);§}§}§
public class Vorapede extends CardImpl {§public Vorapede(UUID ownerId) {§super(ownerId, 131, "Vorapede", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{2}{G}{G}{G}");§this.expansionSetCode = "DKA";§this.subtype.add("Insect");§this.power = new MageInt(5);§this.toughness = new MageInt(4);§this.addAbility(VigilanceAbility.getInstance());§this.addAbility(TrampleAbility.getInstance());§this.addAbility(new UndyingAbility());§}§public Vorapede(final Vorapede card) {§super(card);§}§@Override§public Vorapede copy() {§return new Vorapede(this);§}§}§
public class Wakedancer extends CardImpl {§private static final String staticText = "Morbid - When {this} enters the battlefield, if a creature died this turn, put a 2/2 black Zombie creature token onto the battlefield.";§public Wakedancer(UUID ownerId) {§super(ownerId, 79, "Wakedancer", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{B}");§this.expansionSetCode = "DKA";§this.subtype.add("Human");§this.subtype.add("Shaman");§this.color.setBlack(true);§this.power = new MageInt(2);§this.toughness = new MageInt(2);§TriggeredAbility ability = new EntersBattlefieldTriggeredAbility(new CreateTokenEffect(new ZombieToken()));§this.addAbility(new ConditionalTriggeredAbility(ability, MorbidCondition.getInstance(), staticText));§}§public Wakedancer(final Wakedancer card) {§super(card);§}§@Override§public Wakedancer copy() {§return new Wakedancer(this);§}§}§
public class WardenOfTheWall extends CardImpl {§public WardenOfTheWall(UUID ownerId) {§super(ownerId, 153, "Warden of the Wall", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "DKA";§this.addAbility(new EntersBattlefieldTappedAbility());§this.addAbility(new ColorlessManaAbility());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new ConditionalContinuousEffect(new BecomesCreatureSourceEffect(new GargoyleToken(), "", Duration.WhileOnBattlefield), NotMyTurnCondition.getInstance(), "As long as it's not your turn, Warden of the Wall is a 2/3 Gargoyle artifact creature with flying")));§}§public WardenOfTheWall(final WardenOfTheWall card) {§super(card);§}§@Override§public WardenOfTheWall copy() {§return new WardenOfTheWall(this);§}§}§class GargoyleToken extends Token {§public GargoyleToken() {§super("", "2/3 Gargoyle artifact creature with flying");§cardType.add(CardType.CREATURE);§cardType.add(CardType.ARTIFACT);§subtype.add("Gargoyle");§power = new MageInt(2);§toughness = new MageInt(3);§addAbility(FlyingAbility.getInstance());§}§}§
public class WerewolfRansacker extends CardImpl {§public WerewolfRansacker(UUID ownerId) {§super(ownerId, 81, "Werewolf Ransacker", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "");§this.expansionSetCode = "DKA";§this.subtype.add("Werewolf");§this.color.setRed(true);§this.nightCard = true;§this.canTransform = true;§this.power = new MageInt(5);§this.toughness = new MageInt(4);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new InfoEffect(WerewolfRansackerAbility.RULE_TEXT)));§TriggeredAbility ability = new BeginningOfUpkeepTriggeredAbility(new TransformSourceEffect(false), TargetController.ANY, false);§this.addAbility(new ConditionalTriggeredAbility(ability, TwoOrMoreSpellsWereCastLastTurnCondition.getInstance(), TransformAbility.TWO_OR_MORE_SPELLS_TRANSFORM_RULE));§}§public WerewolfRansacker(final WerewolfRansacker card) {§super(card);§}§@Override§public WerewolfRansacker copy() {§return new WerewolfRansacker(this);§}§}§class WerewolfRansackerAbility extends TriggeredAbilityImpl {§public static final String RULE_TEXT = "Whenever this creature transforms into Werewolf Ransacker, you may destroy target artifact. If that artifact is put into a graveyard this way, Werewolf Ransacker deals 3 damage to that artifact's controller";§public WerewolfRansackerAbility() {§super(Zone.BATTLEFIELD, new WerewolfRansackerEffect(), true);§Target target = new TargetPermanent(new FilterArtifactPermanent());§this.addTarget(target);§}§public WerewolfRansackerAbility(final WerewolfRansackerAbility ability) {§super(ability);§}§@Override§public WerewolfRansackerAbility copy() {§return new WerewolfRansackerAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.TRANSFORMED;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (event.getTargetId().equals(sourceId)) {§Permanent permanent = game.getPermanent(sourceId);§if (permanent != null && permanent.isTransformed()) {§return true;§}§}§return false;§}§@Override§public String getRule() {§return RULE_TEXT + '.';§}§}§class WerewolfRansackerEffect extends OneShotEffect {§public WerewolfRansackerEffect() {§super(Outcome.DestroyPermanent);§}§public WerewolfRansackerEffect(final WerewolfRansackerEffect effect) {§super(effect);§}§@Override§public WerewolfRansackerEffect copy() {§return new WerewolfRansackerEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§int affectedTargets = 0;§if (targetPointer.getTargets(game, source).size() > 0) {§for (UUID permanentId : targetPointer.getTargets(game, source)) {§Permanent permanent = game.getPermanent(permanentId);§if (permanent != null) {§if (permanent.destroy(source.getSourceId(), game, false)) {§affectedTargets++;§if (game.getState().getZone(permanent.getId()) == Zone.GRAVEYARD) {§Player player = game.getPlayer(permanent.getControllerId());§if (player != null)§player.damage(3, source.getSourceId(), game, false, true);§}§}§}§}§}§return affectedTargets > 0;§}§}§
public class WildHunger extends CardImpl {§public WildHunger(UUID ownerId) {§super(ownerId, 132, "Wild Hunger", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{G}");§this.expansionSetCode = "DKA";§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.getSpellAbility().addEffect(new BoostTargetEffect(3, 1, Duration.EndOfTurn));§this.getSpellAbility().addEffect(new GainAbilityTargetEffect(TrampleAbility.getInstance(), Duration.EndOfTurn));§this.addAbility(new FlashbackAbility(new ManaCostsImpl("{3}{R}"), TimingRule.INSTANT));§}§public WildHunger(final WildHunger card) {§super(card);§}§@Override§public WildHunger copy() {§return new WildHunger(this);§}§}§
public class WithengarUnbound extends CardImpl {§public WithengarUnbound(UUID ownerId) {§super(ownerId, 147, "Withengar Unbound", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "");§this.expansionSetCode = "DKA";§this.supertype.add("Legendary");§this.subtype.add("Demon");§this.color.setBlack(true);§this.nightCard = true;§this.canTransform = true;§this.power = new MageInt(13);§this.toughness = new MageInt(13);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(IntimidateAbility.getInstance());§this.addAbility(TrampleAbility.getInstance());§this.addAbility(new WithengarUnboundTriggeredAbility());§}§public WithengarUnbound(final WithengarUnbound card) {§super(card);§}§@Override§public WithengarUnbound copy() {§return new WithengarUnbound(this);§}§}§class WithengarUnboundTriggeredAbility extends TriggeredAbilityImpl {§public WithengarUnboundTriggeredAbility() {§super(Zone.BATTLEFIELD, new AddCountersSourceEffect(CounterType.P1P1.createInstance(13)), false);§}§public WithengarUnboundTriggeredAbility(final WithengarUnboundTriggeredAbility ability) {§super(ability);§}§@Override§public WithengarUnboundTriggeredAbility copy() {§return new WithengarUnboundTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.LOST;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§return true;§}§@Override§public String getRule() {§return "Whenever a player loses the game, put thirteen +1/+1 counters on Withengar Unbound.";§}§}§
public class WolfbittenCaptive extends CardImpl {§public WolfbittenCaptive(UUID ownerId) {§super(ownerId, 133, "Wolfbitten Captive", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{G}");§this.expansionSetCode = "DKA";§this.subtype.add("Human");§this.subtype.add("Werewolf");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.canTransform = true;§this.secondSideCard = new KrallenhordeKiller(ownerId);§this.addAbility(new LimitedTimesPerTurnActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(2, 2, Duration.EndOfTurn), new ManaCostsImpl("{1}{G}")));§this.addAbility(new TransformAbility());§TriggeredAbility ability = new BeginningOfUpkeepTriggeredAbility(new TransformSourceEffect(true), TargetController.ANY, false);§this.addAbility(new ConditionalTriggeredAbility(ability, NoSpellsWereCastLastTurnCondition.getInstance(), TransformAbility.NO_SPELLS_TRANSFORM_RULE));§}§public WolfbittenCaptive(final WolfbittenCaptive card) {§super(card);§}§@Override§public WolfbittenCaptive copy() {§return new WolfbittenCaptive(this);§}§}§
public class WolfhuntersQuiver extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Werewolf creature");§static {§filter.add(new SubtypePredicate("Werewolf"));§}§public WolfhuntersQuiver(UUID ownerId) {§super(ownerId, 154, "Wolfhunter's Quiver", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{1}");§this.expansionSetCode = "DKA";§this.subtype.add("Equipment");§Ability abilityToGain = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(1), new TapSourceCost());§abilityToGain.addTarget(new TargetCreatureOrPlayer());§Effect effect = new GainAbilityAttachedEffect(abilityToGain, AttachmentType.EQUIPMENT);§effect.setText("Equipped creature has \"{T}: This creature deals 1 damage to target creature or player\"");§SimpleStaticAbility ability = new SimpleStaticAbility(Zone.BATTLEFIELD, effect);§abilityToGain = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(3), new TapSourceCost());§abilityToGain.addTarget(new TargetCreaturePermanent(filter));§effect = new GainAbilityAttachedEffect(abilityToGain, AttachmentType.EQUIPMENT);§effect.setText("and \"{T}: This creature deals 3 damage to target Werewolf creature");§ability.addEffect(effect);§this.addAbility(ability);§this.addAbility(new EquipAbility(Outcome.BoostCreature, new GenericManaCost(5)));§}§public WolfhuntersQuiver(final WolfhuntersQuiver card) {§super(card);§}§@Override§public WolfhuntersQuiver copy() {§return new WolfhuntersQuiver(this);§}§}§
public class WrackWithMadness extends CardImpl {§public WrackWithMadness(UUID ownerId) {§super(ownerId, 107, "Wrack with Madness", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{3}{R}");§this.expansionSetCode = "DKA";§this.getSpellAbility().addEffect(new WrackWithMadnessEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public WrackWithMadness(final WrackWithMadness card) {§super(card);§}§@Override§public WrackWithMadness copy() {§return new WrackWithMadness(this);§}§}§class WrackWithMadnessEffect extends OneShotEffect {§public WrackWithMadnessEffect() {§super(Outcome.Damage);§this.staticText = "Target creature deals damage to itself equal to its power";§}§public WrackWithMadnessEffect(final WrackWithMadnessEffect effect) {§super(effect);§}§@Override§public WrackWithMadnessEffect copy() {§return new WrackWithMadnessEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getPermanent(targetPointer.getFirst(game, source));§if (permanent != null) {§permanent.damage(permanent.getPower().getValue(), permanent.getId(), game, false, true);§return true;§}§return false;§}§}§
public class YoungWolf extends CardImpl {§public YoungWolf(UUID ownerId) {§super(ownerId, 134, "Young Wolf", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{G}");§this.expansionSetCode = "DKA";§this.subtype.add("Wolf");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new UndyingAbility());§}§public YoungWolf(final YoungWolf card) {§super(card);§}§@Override§public YoungWolf copy() {§return new YoungWolf(this);§}§}§
public class ZombieApocalypse extends CardImpl {§public ZombieApocalypse(UUID ownerId) {§super(ownerId, 80, "Zombie Apocalypse", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{3}{B}{B}{B}");§this.expansionSetCode = "DKA";§this.getSpellAbility().addEffect(new ZombieApocalypseEffect());§}§public ZombieApocalypse(final ZombieApocalypse card) {§super(card);§}§@Override§public ZombieApocalypse copy() {§return new ZombieApocalypse(this);§}§}§class ZombieApocalypseEffect extends OneShotEffect {§private static final FilterCreatureCard filterZombie = new FilterCreatureCard();§private static final FilterCreaturePermanent filterHuman = new FilterCreaturePermanent();§static {§filterZombie.add(new SubtypePredicate("Zombie"));§filterHuman.add(new SubtypePredicate("Human"));§}§public ZombieApocalypseEffect() {§super(Outcome.PutCreatureInPlay);§this.staticText = "Return all Zombie creature cards from your graveyard to the battlefield tapped, then destroy all Humans.";§}§public ZombieApocalypseEffect(final ZombieApocalypseEffect effect) {§super(effect);§}§@Override§public ZombieApocalypseEffect copy() {§return new ZombieApocalypseEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§for (Card card : player.getGraveyard().getCards(filterZombie, game)) {§card.putOntoBattlefield(game, Zone.GRAVEYARD, source.getSourceId(), source.getControllerId());§Permanent permanent = game.getPermanent(card.getId());§if (permanent != null) {§permanent.setTapped(true);§}§}§for (Permanent permanent: game.getBattlefield().getActivePermanents(filterHuman, source.getControllerId(), game)) {§permanent.destroy(source.getSourceId(), game, false);§}§return true;§}§}§
public class AEtherVial extends CardImpl {§public AEtherVial(UUID ownerId) {§super(ownerId, 91, "AEther Vial", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{1}");§this.expansionSetCode = "DST";§this.addAbility(new BeginningOfUpkeepTriggeredAbility(new AddCountersSourceEffect(CounterType.CHARGE.createInstance(), true), TargetController.YOU, true));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new AEtherVialEffect(), new TapSourceCost()));§}§public AEtherVial(final AEtherVial card) {§super(card);§}§@Override§public AEtherVial copy() {§return new AEtherVial(this);§}§}§class AEtherVialEffect extends OneShotEffect {§public AEtherVialEffect() {§super(Outcome.PutCreatureInPlay);§this.staticText = "You may put a creature card with converted mana cost equal to the number of charge counters on {this} from your hand onto the battlefield";§}§public AEtherVialEffect(final AEtherVialEffect effect) {§super(effect);§}§@Override§public AEtherVialEffect copy() {§return new AEtherVialEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getBattlefield().getPermanent(source.getSourceId());§if (permanent == null) {§permanent = (Permanent) game.getLastKnownInformation(source.getSourceId(), Zone.BATTLEFIELD);§if (permanent == null) {§return false;§}§}§int count = permanent.getCounters().getCount(CounterType.CHARGE);§FilterCreatureCard filter = new FilterCreatureCard("creature card with converted mana cost equal to " + count);§filter.add(new ConvertedManaCostPredicate(Filter.ComparisonType.Equal, count));§String choiceText = "Put a " + filter.getMessage() + " from your hand onto the battlefield?";§Player controller = game.getPlayer(source.getControllerId());§if (controller == null) {§return false;§}§if (controller.getHand().count(filter, game) == 0§|| !controller.chooseUse(this.outcome, choiceText, source, game)) {§return true;§}§TargetCardInHand target = new TargetCardInHand(filter);§if (controller.choose(this.outcome, target, source.getSourceId(), game)) {§Card card = game.getCard(target.getFirstTarget());§if (card != null) {§return controller.moveCards(card, Zone.BATTLEFIELD, source, game);§}§}§return false;§}§}§
public class ArcaneSpyglass extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledLandPermanent("a land");§public ArcaneSpyglass (UUID ownerId) {§super(ownerId, 93, "Arcane Spyglass", Rarity.COMMON, new CardType[]{CardType.ARTIFACT}, "{4}");§this.expansionSetCode = "DST";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DrawCardSourceControllerEffect(1), new GenericManaCost(2));§ability.addCost(new TapSourceCost());§ability.addCost(new SacrificeTargetCost(new TargetControlledPermanent(filter)));§ability.addEffect(new AddCountersSourceEffect(CounterType.CHARGE.createInstance()));§this.addAbility(ability);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new DrawCardSourceControllerEffect(1), new RemoveCountersSourceCost(CounterType.CHARGE.createInstance(3))));§}§public ArcaneSpyglass (final ArcaneSpyglass card) {§super(card);§}§@Override§public ArcaneSpyglass copy() {§return new ArcaneSpyglass(this);§}§}§
public class ArcboundBruiser extends CardImpl {§public ArcboundBruiser(UUID ownerId) {§super(ownerId, 94, "Arcbound Bruiser", Rarity.COMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{5}");§this.expansionSetCode = "DST";§this.subtype.add("Golem");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§this.addAbility(new ModularAbility(this, 3));§}§public ArcboundBruiser(final ArcboundBruiser card) {§super(card);§}§@Override§public ArcboundBruiser copy() {§return new ArcboundBruiser(this);§}§}§
public class ArcboundHybrid extends CardImpl {§public ArcboundHybrid(UUID ownerId) {§super(ownerId, 97, "Arcbound Hybrid", Rarity.COMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{4}");§this.expansionSetCode = "DST";§this.subtype.add("Beast");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§this.addAbility(HasteAbility.getInstance());§this.addAbility(new ModularAbility(this, 2));§}§public ArcboundHybrid(final ArcboundHybrid card) {§super(card);§}§@Override§public ArcboundHybrid copy() {§return new ArcboundHybrid(this);§}§}§
public class ArcboundLancer extends CardImpl {§public ArcboundLancer(UUID ownerId) {§super(ownerId, 98, "Arcbound Lancer", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{7}");§this.expansionSetCode = "DST";§this.subtype.add("Beast");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§this.addAbility(FirstStrikeAbility.getInstance());§this.addAbility(new ModularAbility(this, 4));§}§public ArcboundLancer(final ArcboundLancer card) {§super(card);§}§@Override§public ArcboundLancer copy() {§return new ArcboundLancer(this);§}§}§
public class ArcboundOverseer extends CardImpl {§private static final FilterControlledCreaturePermanent filter;§static {§filter = new FilterControlledCreaturePermanent("creature with modular you control");§filter.add(new AbilityPredicate(ModularAbility.class));§}§public ArcboundOverseer(UUID ownerId) {§super(ownerId, 99, "Arcbound Overseer", Rarity.RARE, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{8}");§this.expansionSetCode = "DST";§this.subtype.add("Golem");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§this.addAbility(new OnEventTriggeredAbility(§GameEvent.EventType.UPKEEP_STEP_PRE,§"beginning of your upkeep",§new AddCountersAllEffect(CounterType.P1P1.createInstance(), filter)));§this.addAbility(new ModularAbility(this, 6));§}§public ArcboundOverseer(final ArcboundOverseer card) {§super(card);§}§@Override§public ArcboundOverseer copy() {§return new ArcboundOverseer(this);§}§}§
public class ArcboundStinger extends CardImpl {§public ArcboundStinger(UUID ownerId) {§super(ownerId, 103, "Arcbound Stinger", Rarity.COMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{2}");§this.expansionSetCode = "DST";§this.subtype.add("Insect");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new ModularAbility(this, 1));§}§public ArcboundStinger(final ArcboundStinger card) {§super(card);§}§@Override§public ArcboundStinger copy() {§return new ArcboundStinger(this);§}§}§
public class ArcboundWorker extends CardImpl {§public ArcboundWorker(UUID ownerId) {§super(ownerId, 104, "Arcbound Worker", Rarity.COMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{1}");§this.expansionSetCode = "DST";§this.subtype.add("Construct");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§this.addAbility(new ModularAbility(this, 1));§}§public ArcboundWorker(final ArcboundWorker card) {§super(card);§}§@Override§public ArcboundWorker copy() {§return new ArcboundWorker(this);§}§}§
